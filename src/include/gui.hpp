// dear gui, v1.90.1 WIP
// (headers)

// Help:
// - See links below.
// - Call and read Gui::ShowDemoWindow() in gui_demo.cpp. All applications in
// examples/ are doing that.
// - Read top of gui.cpp for more details, links and comments.

// Resources:
// - FAQ                   https://dearimgui.com/faq
// - Getting Started       https://dearimgui.com/getting-started
// - Homepage              https://github.com/ocornut/imgui
// - Releases & changelog  https://github.com/ocornut/imgui/releases
// - Gallery               https://github.com/ocornut/imgui/issues/6897 (please
// post your screenshots/video there!)
// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good
// stuff there)
// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary
// - Issues & support      https://github.com/ocornut/imgui/issues
// - Tests & Automation    https://github.com/ocornut/gui_test_engine

// For first-time users having issues compiling/linking/running/loading fonts:
// please post in https://github.com/ocornut/imgui/discussions if you cannot
// find a solution in resources above. Everything else should be asked in
// 'Issues'! We are building a database of cross-linked knowledge there.

// Library Version
// (Integer encoded as XYYZZ for use in #if preprocessor conditionals, e.g. '#if
// GUI_VERSION_NUM >= 12345')
#define GUI_VERSION "1.90.1 WIP"
#define GUI_VERSION_NUM 19002
#define GUI_HAS_TABLE

/*

Index of this file:
// [SECTION] Header mess
// [SECTION] Forward declarations and basic types
// [SECTION] Dear Gui end-user API functions
// [SECTION] Flags & Enumerations
// [SECTION] Tables API flags and structures (TableFlags,
TableColumnFlags, TableRowFlags, TableBgTarget,
TableSortSpecs, TableColumnSortSpecs)
// [SECTION] Helpers: Memory allocations macros, Vector<>
// [SECTION] Style
// [SECTION] IO
// [SECTION] Misc data structures (InputTextCallbackData,
SizeCallbackData, Payload)
// [SECTION] Helpers (OnceUponAFrame, TextFilter, TextBuffer,
Storage, ListClipper, Math Operators, Color)
// [SECTION] Drawing API (DrawCallback, DrawCmd, DrawIdx, DrawVert,
DrawChannel, DrawListSplitter, DrawFlags, DrawListFlags, DrawList,
DrawData)
// [SECTION] Font API (FontConfig, FontGlyph, FontGlyphRangesBuilder,
FontAtlasFlags, FontAtlas, Font)
// [SECTION] Viewports (ViewportFlags, Viewport)
// [SECTION] Platform Dependent Interfaces (PlatformImeData)
// [SECTION] Obsolete functions and types

*/

#pragma once

// Configuration file with compile-time options
// (edit config.hpp or '#define GUI_USER_CONFIG "myfilename.h" from your build
// system)
#ifdef GUI_USER_CONFIG
#include GUI_USER_CONFIG
#endif

#ifndef GUI_DISABLE

//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

// Includes
#include "textedit.hpp"
#include <float.h>  // FLT_MIN, FLT_MAX
#include <limits.h> // INT_MIN, INT_MAX
#include <math.h>   // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf
#include <stdarg.h> // va_list, va_start, va_end
#include <stddef.h> // ptrdiff_t, NULL
#include <stdint.h> // intptr_t
#include <stdio.h>  // vsnprintf, sscanf, printf
#include <stdlib.h> // NULL, malloc, free, qsort, atoi, atof
#include <string.h> // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp
#include <string>
// Define attributes of all API symbols declarations (e.g. for DLL under
// Windows) GUI_API is used for core gui functions, GUI_IMPL_API is used
// for the default backends files (gui_impl_xxx.h) Using dear gui via a
// shared library is not recommended: we don't guarantee backward nor forward
// ABI compatibility + this is a call-heavy library and function call overhead
// adds up.
#ifndef GUI_API
#define GUI_API
#endif
#ifndef GUI_IMPL_API
#define GUI_IMPL_API GUI_API
#endif

// Helper Macros
#ifndef GUI_ASSERT
#include <assert.h>
#define GUI_ASSERT(_EXPR)                                                      \
  assert(_EXPR) // You can override the default assert handler by editing
                // config.hpp
#endif
#define GUI_ARRAYSIZE(_ARR)                                                    \
  ((int)(sizeof(_ARR) / sizeof(*(_ARR)))) // Size of a static C-style array.
                                          // Don't use on pointers!
#define GUI_UNUSED(_VAR)                                                       \
  ((void)(_VAR)) // Used to silence "unused variable warnings". Often useful as
                 // asserts may be stripped out from final builds.
#define GUI_CHECKVERSION()                                                     \
  Gui::DebugCheckVersionAndDataLayout(GUI_VERSION, sizeof(IO), sizeof(Style),  \
                                      sizeof(Vec2), sizeof(Vec4),              \
                                      sizeof(DrawVert), sizeof(DrawIdx))

// Helper Macros - GUI_FMTARGS, GUI_FMTLIST: Apply printf-style warnings to our
// formatting functions.
#if !defined(GUI_USE_STB_SPRINTF) && defined(__MINGW32__) && !defined(__clang__)
#define GUI_FMTARGS(FMT) __attribute__((format(gnu_printf, FMT, FMT + 1)))
#define GUI_FMTLIST(FMT) __attribute__((format(gnu_printf, FMT, 0)))
#elif !defined(GUI_USE_STB_SPRINTF) && (defined(__clang__) || defined(__GNUC__))
#define GUI_FMTARGS(FMT) __attribute__((format(printf, FMT, FMT + 1)))
#define GUI_FMTLIST(FMT) __attribute__((format(printf, FMT, 0)))
#else
#define GUI_FMTARGS(FMT)
#define GUI_FMTLIST(FMT)
#endif

// Disable some of MSVC most aggressive Debug runtime checks in function
// header/footer (used in some simple/low-level functions)
#if defined(_MSC_VER) && !defined(__clang__) && !defined(__INTEL_COMPILER) &&  \
    !defined(GUI_DEBUG_PARANOID)
#define GUI_MSVC_RUNTIME_CHECKS_OFF                                            \
  __pragma(runtime_checks("", off)) __pragma(check_stack(off))                 \
      __pragma(strict_gs_check(push, off))
#define GUI_MSVC_RUNTIME_CHECKS_RESTORE                                        \
  __pragma(runtime_checks("", restore)) __pragma(check_stack())                \
      __pragma(strict_gs_check(pop))
#else
#define GUI_MSVC_RUNTIME_CHECKS_OFF
#define GUI_MSVC_RUNTIME_CHECKS_RESTORE
#endif

// Warnings
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(                                                               \
    disable : 26495) // [Static Analyzer] Variable 'XXX' is uninitialized.
                     // Always initialize a member variable (type.6).
#endif
#if defined(__clang__)
#pragma clang diagnostic push
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored                                               \
    "-Wunknown-warning-option" // warning: unknown warning group 'xxx'
#endif
#pragma clang diagnostic ignored                                               \
    "-Wunknown-pragmas" // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wold-style-cast"
#pragma clang diagnostic ignored                                               \
    "-Wfloat-equal" // warning: comparing floating point with == or !=
                    // is unsafe
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#pragma clang diagnostic ignored                                               \
    "-Wreserved-identifier" // warning: identifier '_Xxx' is reserved because it
                            // starts with '_' followed by a capital letter
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored                                                 \
    "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored                                                 \
    "-Wclass-memaccess" // [__GNUC__ >= 8] warning: 'memset/memcpy'
                        // clearing/writing an object of type 'xxxx' with no
                        // trivial copy-assignment; use assignment or
                        // value-initialization instead
#endif

//-----------------------------------------------------------------------------
// [SECTION] Forward declarations and basic types
//-----------------------------------------------------------------------------

// Forward declarations
struct DrawChannel; // Temporary storage to output draw commands out of order,
                    // used by DrawListSplitter and
                    // DrawList::ChannelsSplit()
struct DrawCmd;     // A single draw command within a parent DrawList (generally
                    // maps to 1 GPU draw call, unless it is a callback)
struct DrawData;    // All draw command lists required to render the frame +
                    // pos/size coordinates to use for the projection matrix.
struct DrawList;    // A single draw command list (generally one per window,
                 // conceptually you may see this as a dynamic "mesh" builder)
struct DrawListSharedData; // Data shared among multiple draw lists (typically
                           // owned by parent Gui context, but you may
                           // create one yourself)
struct DrawListSplitter;   // Helper to split a draw list into different layers
                           // which can be drawn into out of order, then
                           // flattened back.
struct DrawVert;  // A single vertex (pos + uv + col = 20 bytes by default.
                  // Override layout with
                  // GUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)
struct Font;      // Runtime data for a single font within a parent FontAtlas
struct FontAtlas; // Runtime data for multiple fonts, bake multiple fonts into
                  // a single texture, TTF/OTF font loader
struct FontBuilderIO; // Opaque interface to a font builder (stb_truetype or
                      // FreeType).
struct FontConfig;    // Configuration data when adding a font or merging fonts
struct FontGlyph;     // A single font glyph (code point + coordinates within in
                      // FontAtlas + offset)
struct FontGlyphRangesBuilder; // Helper to build glyph ranges from
                               // text/string data
struct Color;   // Helper functions to create a color that can be converted to
                // either u32 or float4 (*OBSOLETE* please avoid using)
struct Context; // Dear Gui context (opaque structure, unless including
                // gui_internal.hpp)
struct IO;      // Main configuration and I/O between your application and Gui
struct InputTextCallbackData; // Shared state of InputText() when using
                              // custom InputTextCallback
                              // (rare/advanced use)
struct KeyData;          // Storage for IO and IsKeyDown(), IsKeyPressed() etc
                         // functions.
struct ListClipper;      // Helper to manually clip large list of items
struct OnceUponAFrame;   // Helper for running a block of code not more than
                         // once a frame
struct Payload;          // User data payload for drag and drop operations
struct PlatformImeData;  // Platform IME data for io.SetPlatformImeDataFn()
                         // function.
struct SizeCallbackData; // Callback data when using
                         // SetNextWindowSizeConstraints() (rare/advanced
                         // use)
struct Storage;          // Helper for key->value storage
struct Style;            // Runtime data for styling/colors
struct TableSortSpecs;   // Sorting specifications for a table (often
                         // handling sort specs for a single column,
                         // occasionally more)
struct TableColumnSortSpecs; // Sorting specification for one column of a
                             // table
struct TextBuffer; // Helper to hold and append into a text buffer (~string
                   // builder)
struct TextFilter; // Helper to parse and apply text filters (e.g.
                   // "aaaaa[,bbbbb][,ccccc]")
struct Viewport;   // A Platform Window (always only one in 'master' branch),
                   // in the future may represent Platform Monitor

// Enumerations
// - We don't use strongly typed enums much because they add constraints (can't
// extend in private code, can't store typed in bit fields, extra casting on
// iteration)
// - Tip: Use your programming IDE navigation facilities on the names in the
// _central column_ below to find the actual flags/enum lists!
//   In Visual Studio IDE: CTRL+comma ("Edit.GoToAll") can follow symbols in
//   comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot. With Visual
//   Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow
//   symbols in comments.
enum Key : int;         // -> enum Key              // Enum: A key identifier
                        // (Key_XXX or Mod_XXX value)
enum MouseSource : int; // -> enum MouseSource      // Enum; A mouse
                        // input source identifier (Mouse, TouchScreen,
                        // Pen)
typedef int Col;        // -> enum Col_             // Enum: A color
                        // identifier for styling
typedef int Cond;       // -> enum Cond_            // Enum: A condition for
                        // many Set*() functions
typedef int DataType;   // -> enum DataType_        // Enum: A primary data type
typedef int Dir; // -> enum Dir_             // Enum: A cardinal direction
typedef int MouseButton;   // -> enum MouseButton_     // Enum: A mouse
                           // button identifier (0=left, 1=right, 2=middle)
typedef int MouseCursor;   // -> enum MouseCursor_     // Enum: A mouse
                           // cursor shape
typedef int SortDirection; // -> enum SortDirection_   // Enum: A
                           // sorting direction (ascending or descending)
typedef int StyleVar;      // -> enum StyleVar_        // Enum: A variable
                           // identifier for styling
typedef int TableBgTarget; // -> enum TableBgTarget_   // Enum: A
                           // color target for TableSetBgColor()

// Flags (declared as int to allow using as flags without overhead, and to not
// pollute the top of this file)
// - Tip: Use your programming IDE navigation facilities on the names in the
// _central column_ below to find the actual flags/enum lists!
//   In Visual Studio IDE: CTRL+comma ("Edit.GoToAll") can follow symbols in
//   comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot. With Visual
//   Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow
//   symbols in comments.
typedef int DrawFlags;      // -> enum DrawFlags_          // Flags: for
                            // DrawList functions
typedef int DrawListFlags;  // -> enum DrawListFlags_      // Flags: for
                            // DrawList instance
typedef int FontAtlasFlags; // -> enum FontAtlasFlags_     // Flags: for
                            // FontAtlas build
typedef int BackendFlags;   // -> enum BackendFlags_    // Flags: for
                            // io.BackendFlags
typedef int ButtonFlags;    // -> enum ButtonFlags_     // Flags: for
                            // InvisibleButton()
typedef int ChildFlags; // -> enum ChildFlags_      // Flags: for BeginChild()
typedef int ColorEditFlags; // -> enum ColorEditFlags_  // Flags: for
                            // ColorEdit4(), ColorPicker4() etc.
typedef int ConfigFlags;    // -> enum ConfigFlags_     // Flags: for
                            // io.ConfigFlags
typedef int ComboFlags; // -> enum ComboFlags_      // Flags: for BeginCombo()
typedef int DragDropFlags;  // -> enum DragDropFlags_   // Flags: for
                            // BeginDragDropSource(), AcceptDragDropPayload()
typedef int FocusedFlags;   // -> enum FocusedFlags_    // Flags: for
                            // IsWindowFocused()
typedef int HoveredFlags;   // -> enum HoveredFlags_    // Flags: for
                            // IsItemHovered(), IsWindowHovered() etc.
typedef int InputTextFlags; // -> enum InputTextFlags_  // Flags: for
                            // InputText(), InputTextMultiline()
typedef int KeyChord;       // -> Key | Mod_XXX    // Flags: for
                            // IsKeyChordPressed(), Shortcut() etc. an Key
// optionally OR-ed with one or more Mod_XXX values.
typedef int PopupFlags; // -> enum PopupFlags_      // Flags: for
                        // OpenPopup*(), BeginPopupContext*(), IsPopupOpen()
typedef int SelectableFlags; // -> enum SelectableFlags_ // Flags: for
                             // Selectable()
typedef int
    SliderFlags; // -> enum SliderFlags_     // Flags: for
                 // DragFloat(), DragInt(), SliderFloat(), SliderInt() etc.
typedef int TabBarFlags;  // -> enum TabBarFlags_     // Flags: for
                          // BeginTabBar()
typedef int TabItemFlags; // -> enum TabItemFlags_    // Flags: for
                          // BeginTabItem()
typedef int TableFlags;   // -> enum TableFlags_      // Flags: For BeginTable()
typedef int TableColumnFlags; // -> enum TableColumnFlags_// Flags:
                              // For TableSetupColumn()
typedef int TableRowFlags;    // -> enum TableRowFlags_   // Flags: For
                              // TableNextRow()
typedef int TreeNodeFlags;    // -> enum TreeNodeFlags_   // Flags: for
                              // TreeNode(), TreeNodeEx(), CollapsingHeader()
typedef int ViewportFlags;    // -> enum ViewportFlags_   // Flags: for
                              // Viewport
typedef int WindowFlags;      // -> enum WindowFlags_     // Flags: for
                              // Begin(), BeginChild()

// Texture: user data for renderer backend to identify a texture [Compile-time
// configurable type]
// - To use something else than an opaque void* pointer: override with e.g.
// '#define TextureID TextureType*' in your config.hpp file.
// - This can be whatever to you want it to be! read the FAQ about TextureID
// for details.
#ifndef TextureID
typedef void *TextureID; // Default: store a pointer or an integer fitting in a
                         // pointer (most renderer backends are ok with that)
#endif

// DrawIdx: vertex index. [Compile-time configurable type]
// - To use 16-bit indices + allow large meshes: backend need to set
// 'io.BackendFlags |= BackendFlags_RendererHasVtxOffset' and handle
// DrawCmd::VtxOffset (recommended).
// - To use 32-bit indices: override with '#define DrawIdx unsigned int' in
// your config.hpp file.
#ifndef DrawIdx
typedef unsigned short DrawIdx; // Default: 16-bit (for maximum compatibility
                                // with renderer backends)
#endif

// Scalar data types
typedef unsigned int ID;    // A unique ID used by widgets (typically the
                            // result of hashing a stack of string)
typedef signed char S8;     // 8-bit signed integer
typedef unsigned char U8;   // 8-bit unsigned integer
typedef signed short S16;   // 16-bit signed integer
typedef unsigned short U16; // 16-bit unsigned integer
typedef signed int S32;     // 32-bit signed integer == int
typedef unsigned int
    U32; // 32-bit unsigned integer (often used to store packed colors)
typedef signed long long S64;   // 64-bit signed integer
typedef unsigned long long U64; // 64-bit unsigned integer

// Character types
// (we generally use UTF-8 encoded string in the API. This is storage
// specifically for a decoded character used for keyboard input and display)
typedef unsigned int
    Wchar32; // A single decoded U32 character/code point. We encode them as
             // multi bytes UTF-8 when used in strings.
typedef unsigned short
    Wchar16; // A single decoded U16 character/code point. We encode them as
             // multi bytes UTF-8 when used in strings.
#define GUI_USE_WCHAR32
#ifdef GUI_USE_WCHAR32 //  Wchar [configurable type: override in config.hpp
                       //  with '#define GUI_USE_WCHAR32' to support Unicode
                       //  planes 1-16]
typedef Wchar32 Wchar;
#else
typedef Wchar16 Wchar;
#endif

// Callback and functions types
typedef int (*InputTextCallback)(
    InputTextCallbackData *data); // Callback function for Gui::InputText()
typedef void (*SizeCallback)(
    SizeCallbackData
        *data); // Callback function for Gui::SetNextWindowSizeConstraints()
typedef void *(*MemAllocFunc)(
    size_t sz,
    void *user_data); // Function signature for Gui::SetAllocatorFunctions()
typedef void (*MemFreeFunc)(
    void *ptr,
    void *user_data); // Function signature for Gui::SetAllocatorFunctions()

// Vec2: 2D vector used to store positions, sizes etc. [Compile-time
// configurable type] This is a frequently used type in the API. Consider using
// GUI_VEC2_CLASS_EXTRA to create implicit cast from/to our preferred type.
GUI_MSVC_RUNTIME_CHECKS_OFF
struct Vec2 {
  float x, y;
  constexpr Vec2() : x(0.0f), y(0.0f) {}
  constexpr Vec2(float _x, float _y) : x(_x), y(_y) {}
  float &operator[](size_t idx) {
    GUI_ASSERT(idx == 0 || idx == 1);
    return ((float *)(void *)(char *)this)[idx];
  } // We very rarely use this [] operator, so the assert overhead is fine.
  float operator[](size_t idx) const {
    GUI_ASSERT(idx == 0 || idx == 1);
    return ((const float *)(const void *)(const char *)this)[idx];
  }
#ifdef GUI_VEC2_CLASS_EXTRA
  GUI_VEC2_CLASS_EXTRA // Define additional constructors and implicit cast
                       // operators in config.hpp to convert back and forth
                       // between your math types and Vec2.
#endif
};

// Vec4: 4D vector used to store clipping rectangles, colors etc.
// [Compile-time configurable type]
struct Vec4 {
  float x, y, z, w;
  constexpr Vec4() : x(0.0f), y(0.0f), z(0.0f), w(0.0f) {}
  constexpr Vec4(float _x, float _y, float _z, float _w)
      : x(_x), y(_y), z(_z), w(_w) {}
#ifdef GUI_VEC4_CLASS_EXTRA
  GUI_VEC4_CLASS_EXTRA // Define additional constructors and implicit cast
                       // operators in config.hpp to convert back and forth
                       // between your math types and Vec4.
#endif
};
GUI_MSVC_RUNTIME_CHECKS_RESTORE

//-----------------------------------------------------------------------------
// [SECTION] Dear Gui end-user API functions
// (Note that Gui:: being a namespace, you can add extra Gui:: functions in your
// own separate file. Please don't modify gui source files!)
//-----------------------------------------------------------------------------

namespace Gui {
// Context creation and access
// - Each context create its own FontAtlas by default. You may instance one
// yourself and pass it to CreateContext() to share a font atlas between
// contexts.
// - DLL users: heaps and globals are not shared across DLL boundaries! You will
// need to call SetCurrentContext() + SetAllocatorFunctions()
//   for each static/DLL boundary you are calling from. Read "Context and Memory
//   Allocators" section of gui.cpp for details.
GUI_API Context *CreateContext(FontAtlas *shared_font_atlas = NULL);
GUI_API void
DestroyContext(Context *ctx = NULL); // NULL = destroy current context
GUI_API Context *GetCurrentContext();
GUI_API void SetCurrentContext(Context *ctx);

// Main
GUI_API IO &GetIO(); // access the IO structure (mouse/keyboard/gamepad
                     // inputs, time, various configuration options/flags)
GUI_API Style &
GetStyle(); // access the Style structure (colors, sizes). Always use
            // PushStyleColor(), PushStyleVar() to modify style mid-frame!
GUI_API void NewFrame(); // start a new Dear Gui frame, you can submit any
                         // command from this point until Render()/EndFrame().
GUI_API void
EndFrame(); // ends the Dear Gui frame. automatically called by Render(). If
            // you don't need to render data (skipping rendering) you may call
            // EndFrame() without Render()... but you'll have wasted CPU
            // already! If you don't need to render, better to not create any
            // windows and not call NewFrame() at all!
GUI_API void Render(); // ends the Dear Gui frame, finalize the draw data.
                       // You can then get call GetDrawData().
GUI_API DrawData *
GetDrawData(); // valid after Render() and until the next call to NewFrame().
               // this is what you have to render.

// Demo, Debug, Information
GUI_API void ShowDemoWindow(
    bool *p_open = NULL); // create Demo window. demonstrate most Gui
                          // features. call this to learn about the library! try
                          // to make it always available in your application!
GUI_API void ShowMetricsWindow(
    bool *p_open =
        NULL); // create Metrics/Debugger window. display Dear Gui internals:
               // windows, draw commands, various internal state, etc.
GUI_API void ShowDebugLogWindow(
    bool *p_open = NULL); // create Debug Log window. display a simplified log
                          // of important dear gui events.
GUI_API void ShowIDStackToolWindow(
    bool *p_open =
        NULL); // create Stack Tool window. hover items with mouse to query
               // information about the source of their unique ID.
GUI_API void ShowAboutWindow(
    bool *p_open = NULL); // create About window. display Dear Gui version,
                          // credits and build/system information.
GUI_API void ShowStyleEditor(
    Style *ref = NULL); // add style editor block (not a window). you can pass
                        // in a reference Style structure to compare to, revert
                        // to and save to (else it uses the default style)
GUI_API bool ShowStyleSelector(
    const char *label); // add style selector block (not a window), essentially
                        // a combo listing the default styles.
GUI_API void ShowFontSelector(
    const char *label); // add font selector block (not a window), essentially a
                        // combo listing the loaded fonts.
GUI_API void
ShowUserGuide(); // add basic help/info block (not a window): how to manipulate
                 // Gui as an end-user (mouse/keyboard controls).
GUI_API inline const char *GetVersion() { return GUI_VERSION; }
// get the compiled version string e.g. "1.80
// WIP" (essentially the value for GUI_VERSION
// from the compiled version of gui.cpp)

// Styles
GUI_API void
StyleColorsDark(Style *dst = NULL); // new, recommended style (default)
GUI_API void StyleColorsLight(
    Style *dst = NULL); // best used with borders and a custom, thicker font
GUI_API void StyleColorsClassic(Style *dst = NULL); // classic gui style

// Windows
// - Begin() = push window to the stack and start appending to it. End() = pop
// window from the stack.
// - Passing 'bool* p_open != NULL' shows a window-closing widget in the
// upper-right corner of the window,
//   which clicking will set the boolean to false when clicked.
// - You may append multiple times to the same window during the same frame by
// calling Begin()/End() pairs multiple times.
//   Some information such as 'flags' or 'p_open' will only be considered by the
//   first call to Begin().
// - Begin() return false to indicate the window is collapsed or fully clipped,
// so you may early out and omit submitting
//   anything to the window. Always call a matching End() for each Begin() call,
//   regardless of its return value! [Important: due to legacy reason, Begin/End
//   and BeginChild/EndChild are inconsistent with all other functions
//    such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call
//    should only be called if the corresponding BeginXXX function returned
//    true. Begin and BeginChild are the only odd ones out. Will be fixed in a
//    future update.]
// - Note that the bottom of window stack always contains a window called
// "Debug".
GUI_API bool Begin(const char *name, bool *p_open = NULL,
                   WindowFlags flags = 0);
GUI_API void End();

// Child Windows
// - Use child windows to begin into a self-contained independent
// scrolling/clipping regions within a host window. Child windows can embed
// their own child.
// - Before 1.90 (November 2023), the "ChildFlags child_flags = 0"
// parameter was "bool border = false".
//   This API is backward compatible with old code, as we guarantee that
//   ChildFlags_Border == true. Consider updating your old call sites:
//      BeginChild("Name", size, false)   -> Begin("Name", size, 0); or
//      Begin("Name", size, ChildFlags_None); BeginChild("Name", size,
//      true)    -> Begin("Name", size, ChildFlags_Border);
// - Manual sizing (each axis can use a different setting e.g. Vec2(0.0f,
// 400.0f)):
//     == 0.0f: use remaining parent window size for this axis.
//      > 0.0f: use specified size for this axis.
//      < 0.0f: right/bottom-align to specified distance from available content
//      boundaries.
// - Specifying ChildFlags_AutoResizeX or ChildFlags_AutoResizeY makes
// the sizing automatic based on child contents.
//   Combining both ChildFlags_AutoResizeX _and_
//   ChildFlags_AutoResizeY defeats purpose of a scrolling region and is
//   NOT recommended.
// - BeginChild() returns false to indicate the window is collapsed or fully
// clipped, so you may early out and omit submitting
//   anything to the window. Always call a matching EndChild() for each
//   BeginChild() call, regardless of its return value. [Important: due to
//   legacy reason, Begin/End and BeginChild/EndChild are inconsistent with all
//   other functions
//    such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call
//    should only be called if the corresponding BeginXXX function returned
//    true. Begin and BeginChild are the only odd ones out. Will be fixed in a
//    future update.]
GUI_API bool BeginChild(const char *str_id, const Vec2 &size = Vec2(0, 0),
                        ChildFlags child_flags = 0,
                        WindowFlags window_flags = 0);
GUI_API bool BeginChild(ID id, const Vec2 &size = Vec2(0, 0),
                        ChildFlags child_flags = 0,
                        WindowFlags window_flags = 0);
GUI_API void EndChild();

// Windows Utilities
// - 'current window' = the window we are appending into while inside a
// Begin()/End() block. 'next window' = next window we will Begin() into.
GUI_API bool IsWindowAppearing();
GUI_API bool IsWindowCollapsed();
GUI_API bool IsWindowFocused(
    FocusedFlags flags = 0); // is current window focused? or its root/child,
                             // depending on flags. see flags for options.
GUI_API bool IsWindowHovered(
    HoveredFlags flags =
        0); // is current window hovered and hoverable (e.g. not blocked by a
            // popup/modal)? See HoveredFlags_ for options. IMPORTANT: If
            // you are trying to check whether your mouse should be dispatched
            // to Dear Gui or to your underlying app, you should not use this
            // function! Use the 'io.WantCaptureMouse' boolean for that! Refer
            // to FAQ entry "How can I tell whether to dispatch mouse/keyboard
            // to Dear Gui or my application?" for details.
GUI_API DrawList *
GetWindowDrawList(); // get draw list associated to the current window, to
                     // append your own drawing primitives
GUI_API Vec2
GetWindowPos(); // get current window position in screen space (note: it is
                // unlikely you need to use this. Consider using current layout
                // pos instead, GetCursorScreenPos())
GUI_API Vec2
GetWindowSize(); // get current window size (note: it is unlikely you need to
                 // use this. Consider using GetCursorScreenPos() and e.g.
                 // GetContentRegionAvail() instead)
GUI_API float
GetWindowWidth(); // get current window width (shortcut for GetWindowSize().x)
GUI_API float
GetWindowHeight(); // get current window height (shortcut for GetWindowSize().y)

// Window manipulation
// - Prefer using SetNextXXX functions (before Begin) rather that SetXXX
// functions (after Begin).
GUI_API void SetNextWindowPos(
    const Vec2 &pos, Cond cond = 0,
    const Vec2 &pivot =
        Vec2(0, 0)); // set next window position. call before Begin(). use
                     // pivot=(0.5f,0.5f) to center on given point, etc.
GUI_API void SetNextWindowSize(
    const Vec2 &size,
    Cond cond = 0); // set next window size. set axis to 0.0f to force an
                    // auto-fit on this axis. call before Begin()
GUI_API void SetNextWindowSizeConstraints(
    const Vec2 &size_min, const Vec2 &size_max,
    SizeCallback custom_callback = NULL,
    void *custom_callback_data =
        NULL); // set next window size limits. use 0.0f or FLT_MAX if you don't
               // want limits. Use -1 for both min and max of same axis to
               // preserve current size (which itself is a constraint). Use
               // callback to apply non-trivial programmatic constraints.
GUI_API void SetNextWindowContentSize(
    const Vec2 &
        size); // set next window content size (~ scrollable client area, which
               // enforce the range of scrollbars). Not including window
               // decorations (title bar, menu bar, etc.) nor WindowPadding. set
               // an axis to 0.0f to leave it automatic. call before Begin()
GUI_API void SetNextWindowCollapsed(
    bool collapsed,
    Cond cond = 0); // set next window collapsed state. call before Begin()
GUI_API void SetNextWindowFocus(); // set next window to be focused /
                                   // top-most. call before Begin()
GUI_API void
SetNextWindowScroll(const Vec2 &scroll); // set next window scrolling value (use
                                         // < 0.0f to not affect a given axis).
GUI_API void
SetNextWindowBgAlpha(float alpha); // set next window background color alpha.
                                   // helper to easily override the Alpha
                                   // component of Col_WindowBg/ChildBg/PopupBg.
                                   // you may also use WindowFlags_NoBackground.
GUI_API void SetWindowPos(
    const Vec2 &pos,
    Cond cond = 0); // (not recommended) set current window position - call
                    // within Begin()/End(). prefer using SetNextWindowPos(),
                    // as this may incur tearing and side-effects.
GUI_API void SetWindowSize(
    const Vec2 &size,
    Cond cond = 0); // (not recommended) set current window size - call
                    // within Begin()/End(). set to Vec2(0, 0) to force
                    // an auto-fit. prefer using SetNextWindowSize(), as
                    // this may incur tearing and minor side-effects.
GUI_API void SetWindowCollapsed(
    bool collapsed,
    Cond cond = 0); // (not recommended) set current window collapsed
                    // state. prefer using SetNextWindowCollapsed().
GUI_API void
SetWindowFocus(); // (not recommended) set current window to be focused /
                  // top-most. prefer using SetNextWindowFocus().
GUI_API void SetWindowFontScale(
    float scale); // [OBSOLETE] set font scale. Adjust IO.FontGlobalScale if you
                  // want to scale all windows. This is an old API! For correct
                  // scaling, prefer to reload font + rebuild FontAtlas + call
                  // style.ScaleAllSizes().
GUI_API void SetWindowPos(const char *name, const Vec2 &pos,
                          Cond cond = 0); // set named window position.
GUI_API void
SetWindowSize(const char *name, const Vec2 &size,
              Cond cond = 0); // set named window size. set axis to 0.0f to
                              // force an auto-fit on this axis.
GUI_API void
SetWindowCollapsed(const char *name, bool collapsed,
                   Cond cond = 0); // set named window collapsed state
GUI_API void
SetWindowFocus(const char *name); // set named window to be focused / top-most.
                                  // use NULL to remove focus.

// Content region
// - Retrieve available space from a given point. GetContentRegionAvail() is
// frequently useful.
// - Those functions are bound to be redesigned (they are confusing, incomplete
// and the Min/Max return values are in local window coordinates which increases
// confusion)
GUI_API Vec2
GetContentRegionAvail(); // == GetContentRegionMax() - GetCursorPos()
GUI_API Vec2
GetContentRegionMax(); // current content boundaries (typically window
                       // boundaries including scrolling, or current column
                       // boundaries), in windows coordinates
GUI_API Vec2
GetWindowContentRegionMin(); // content boundaries min for the full window
                             // (roughly (0,0)-Scroll), in window coordinates
GUI_API Vec2
GetWindowContentRegionMax(); // content boundaries max for the full window
                             // (roughly (0,0)+Size-Scroll) where Size can be
                             // overridden with SetNextWindowContentSize(), in
                             // window coordinates

// Windows Scrolling
// - Any change of Scroll will be applied at the beginning of next frame in the
// first call to Begin().
// - You may instead use SetNextWindowScroll() prior to calling Begin() to avoid
// this delay, as an alternative to using SetScrollX()/SetScrollY().
GUI_API float GetScrollX(); // get scrolling amount [0 .. GetScrollMaxX()]
GUI_API float GetScrollY(); // get scrolling amount [0 .. GetScrollMaxY()]
GUI_API void
SetScrollX(float scroll_x); // set scrolling amount [0 .. GetScrollMaxX()]
GUI_API void
SetScrollY(float scroll_y); // set scrolling amount [0 .. GetScrollMaxY()]
GUI_API float
GetScrollMaxX(); // get maximum scrolling amount ~~ ContentSize.x - WindowSize.x
                 // - DecorationsSize.x
GUI_API float
GetScrollMaxY(); // get maximum scrolling amount ~~ ContentSize.y - WindowSize.y
                 // - DecorationsSize.y
GUI_API void SetScrollHereX(
    float center_x_ratio =
        0.5f); // adjust scrolling amount to make current cursor position
               // visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right.
               // When using to make a "default/current item" visible, consider
               // using SetItemDefaultFocus() instead.
GUI_API void SetScrollHereY(
    float center_y_ratio =
        0.5f); // adjust scrolling amount to make current cursor position
               // visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom.
               // When using to make a "default/current item" visible, consider
               // using SetItemDefaultFocus() instead.
GUI_API void
SetScrollFromPosX(float local_x,
                  float center_x_ratio =
                      0.5f); // adjust scrolling amount to make given position
                             // visible. Generally GetCursorStartPos() + offset
                             // to compute a valid position.
GUI_API void
SetScrollFromPosY(float local_y,
                  float center_y_ratio =
                      0.5f); // adjust scrolling amount to make given position
                             // visible. Generally GetCursorStartPos() + offset
                             // to compute a valid position.

// Parameters stacks (shared)
GUI_API void
PushFont(Font *font); // use NULL as a shortcut to push default font
GUI_API void PopFont();
GUI_API void
PushStyleColor(Col idx,
               U32 col); // modify a style color. always use this if you
                         // modify the style after NewFrame().
GUI_API void PushStyleColor(Col idx, const Vec4 &col);
GUI_API void PopStyleColor(int count = 1);
GUI_API void
PushStyleVar(StyleVar idx,
             float val); // modify a style float variable. always use this if
                         // you modify the style after NewFrame().
GUI_API void
PushStyleVar(StyleVar idx,
             const Vec2 &val); // modify a style Vec2 variable. always use this
                               // if you modify the style after NewFrame().
GUI_API void PopStyleVar(int count = 1);
GUI_API void
PushTabStop(bool tab_stop); // == tab stop enable. Allow focusing using
                            // TAB/Shift-TAB, enabled by default but you can
                            // disable it for certain widgets
GUI_API void PopTabStop();
GUI_API void PushButtonRepeat(
    bool repeat); // in 'repeat' mode, Button*() functions return repeated true
                  // in a typematic manner (using
                  // io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you
                  // can call IsItemActive() after any Button() to tell if the
                  // button is held in the current frame.
GUI_API void PopButtonRepeat();

// Parameters stacks (current window)
GUI_API void PushItemWidth(
    float item_width); // push width of items for common large "item+label"
                       // widgets. >0.0f: width in pixels, <0.0f align xx pixels
                       // to the right of window (so -FLT_MIN always align width
                       // to the right side).
GUI_API void PopItemWidth();
GUI_API void SetNextItemWidth(
    float item_width); // set width of the _next_ common large "item+label"
                       // widget. >0.0f: width in pixels, <0.0f align xx pixels
                       // to the right of window (so -FLT_MIN always align width
                       // to the right side)
GUI_API float
CalcItemWidth(); // width of item given pushed settings and current cursor
                 // position. NOT necessarily the width of last item unlike most
                 // 'Item' functions.
GUI_API void PushTextWrapPos(
    float wrap_local_pos_x =
        0.0f); // push word-wrapping position for Text*() commands. < 0.0f: no
               // wrapping; 0.0f: wrap to end of window (or column); > 0.0f:
               // wrap at 'wrap_pos_x' position in window local space
GUI_API void PopTextWrapPos();

// Style read access
// - Use the ShowStyleEditor() function to interactively see/edit the colors.
GUI_API Font *GetFont();     // get current font
GUI_API float GetFontSize(); // get current font size (= height in pixels) of
                             // current font with current scale applied
GUI_API Vec2
GetFontTexUvWhitePixel(); // get UV coordinate for a while pixel, useful to draw
                          // custom shapes via the DrawList API
GUI_API U32 GetColorU32(
    Col idx,
    float alpha_mul = 1.0f); // retrieve given style color with style alpha
                             // applied and optional extra alpha multiplier,
                             // packed as a 32-bit value suitable for DrawList
GUI_API U32
GetColorU32(const Vec4 &col); // retrieve given color with style alpha applied,
                              // packed as a 32-bit value suitable for DrawList
GUI_API U32
GetColorU32(U32 col); // retrieve given color with style alpha applied, packed
                      // as a 32-bit value suitable for DrawList
GUI_API const Vec4 &GetStyleColorVec4(
    Col idx); // retrieve style color as stored in Style structure. use to
              // feed back into PushStyleColor(), otherwise use GetColorU32()
              // to get style color with style alpha baked in.

// Layout cursor positioning
// - By "cursor" we mean the current output position.
// - The typical widget behavior is to output themselves at the current cursor
// position, then move the cursor one line down.
// - You can call SameLine() between widgets to undo the last carriage return
// and output at the right of the preceding widget.
// - Attention! We currently have inconsistencies between window-local and
// absolute positions we will aim to fix with future API:
//    - Absolute coordinate:        GetCursorScreenPos(), SetCursorScreenPos(),
//    all DrawList:: functions. -> this is the preferred way forward.
//    - Window-local coordinates:   SameLine(), GetCursorPos(), SetCursorPos(),
//    GetCursorStartPos(), GetContentRegionMax(), GetWindowContentRegion*(),
//    PushTextWrapPos()
// - GetCursorScreenPos() = GetCursorPos() + GetWindowPos(). GetWindowPos() is
// almost only ever useful to convert from window-local to absolute coordinates.
GUI_API Vec2
GetCursorScreenPos(); // cursor position in absolute coordinates (prefer using
                      // this, also more useful to work with DrawList API).
GUI_API void
SetCursorScreenPos(const Vec2 &pos); // cursor position in absolute coordinates
GUI_API Vec2 GetCursorPos();         // [window-local] cursor position in window
                             // coordinates (relative to window position)
GUI_API float GetCursorPosX();                    // [window-local] "
GUI_API float GetCursorPosY();                    // [window-local] "
GUI_API void SetCursorPos(const Vec2 &local_pos); // [window-local] "
GUI_API void SetCursorPosX(float local_x);        // [window-local] "
GUI_API void SetCursorPosY(float local_y);        // [window-local] "
GUI_API Vec2 GetCursorStartPos(); // [window-local] initial cursor position,
                                  // in window coordinates

// Other layout functions
GUI_API void
Separator(); // separator, generally horizontal. inside a menu bar or in
             // horizontal layout mode, this becomes a vertical separator.
GUI_API void
SameLine(float offset_from_start_x = 0.0f,
         float spacing =
             -1.0f);    // call between widgets or groups to layout them
                        // horizontally. X position given in window coordinates.
GUI_API void NewLine(); // undo a SameLine() or force a new line when in a
                        // horizontal-layout context.
GUI_API void Spacing(); // add vertical spacing.
GUI_API void Dummy(const Vec2 &size); // add a dummy item of given size. unlike
                                      // InvisibleButton(), Dummy() won't take
                                      // the mouse click or be navigable into.
GUI_API void Indent(
    float indent_w = 0.0f); // move content position toward the right, by
                            // indent_w, or style.IndentSpacing if indent_w <= 0
GUI_API void Unindent(
    float indent_w = 0.0f); // move content position back to the left, by
                            // indent_w, or style.IndentSpacing if indent_w <= 0
GUI_API void BeginGroup();  // lock horizontal starting position
GUI_API void
EndGroup(); // unlock horizontal starting position + capture the whole group
            // bounding box into one "item" (so you can use IsItemHovered() or
            // layout primitives such as SameLine() on whole group, etc.)
GUI_API void
AlignTextToFramePadding(); // vertically align upcoming text baseline to
                           // FramePadding.y so that it will align properly to
                           // regularly framed items (call if you have text on a
                           // line before a framed item)
GUI_API float GetTextLineHeight(); // ~ FontSize
GUI_API float
GetTextLineHeightWithSpacing(); // ~ FontSize + style.ItemSpacing.y (distance in
                                // pixels between 2 consecutive lines of text)
GUI_API float GetFrameHeight(); // ~ FontSize + style.FramePadding.y * 2
GUI_API float
GetFrameHeightWithSpacing(); // ~ FontSize + style.FramePadding.y * 2 +
                             // style.ItemSpacing.y (distance in pixels between
                             // 2 consecutive lines of framed widgets)

// ID stack/scopes
// Read the FAQ (docs/FAQ.md or http://dearimgui.com/faq) for more details about
// how ID are handled in dear gui.
// - Those questions are answered and impacted by understanding of the ID stack
// system:
//   - "Q: Why is my widget not reacting when I click on it?"
//   - "Q: How can I have widgets with an empty label?"
//   - "Q: How can I have multiple widgets with the same label?"
// - Short version: ID are hashes of the entire ID stack. If you are creating
// widgets in a loop you most likely
//   want to push a unique identifier (e.g. object pointer, loop index) to
//   uniquely differentiate them.
// - You can also use the "Label##foobar" syntax within widget label to
// distinguish them from each others.
// - In this header file we use the "label"/"name" terminology to denote a
// string that will be displayed + used as an ID,
//   whereas "str_id" denote a string that is only used as an ID and not
//   normally displayed.
GUI_API void
PushID(const char *str_id); // push string into the ID stack (will hash string).
GUI_API void PushID(const char *str_id_begin,
                    const char *str_id_end); // push string into the ID stack
                                             // (will hash string).
GUI_API void PushID(
    const void *ptr_id); // push pointer into the ID stack (will hash pointer).
GUI_API void
PushID(int int_id);   // push integer into the ID stack (will hash integer).
GUI_API void PopID(); // pop from the ID stack.
GUI_API ID GetID(const char *str_id); // calculate unique ID (hash of whole ID
                                      // stack + given parameter). e.g. if you
                                      // want to query into Storage yourself
GUI_API ID GetID(const char *str_id_begin, const char *str_id_end);
GUI_API ID GetID(const void *ptr_id);

// Widgets: Text
GUI_API void
TextUnformatted(const char *text,
                const char *text_end =
                    NULL); // raw text without formatting. Roughly equivalent to
                           // Text("%s", text) but: A) doesn't require null
                           // terminated string if 'text_end' is specified, B)
                           // it's faster, no memory copy is done, no buffer
                           // size limits, recommended for long chunks of text.
GUI_API void Text(const char *fmt, ...) GUI_FMTARGS(1); // formatted text
GUI_API void TextV(const char *fmt, va_list args) GUI_FMTLIST(1);
GUI_API void TextColored(const Vec4 &col, const char *fmt, ...)
    GUI_FMTARGS(2); // shortcut for PushStyleColor(Col_Text, col); Text(fmt,
                    // ...); PopStyleColor();
GUI_API void TextColoredV(const Vec4 &col, const char *fmt, va_list args)
    GUI_FMTLIST(2);
GUI_API void TextDisabled(const char *fmt, ...)
    GUI_FMTARGS(1); // shortcut for PushStyleColor(Col_Text,
                    // style.Colors[Col_TextDisabled]); Text(fmt, ...);
                    // PopStyleColor();
GUI_API void TextDisabledV(const char *fmt, va_list args) GUI_FMTLIST(1);
GUI_API void TextWrapped(const char *fmt, ...) GUI_FMTARGS(
    1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...);
        // PopTextWrapPos();. Note that this won't work on an auto-resizing
        // window if there's no other widgets to extend the window width, yoy
        // may need to set a size using SetNextWindowSize().
GUI_API void TextWrappedV(const char *fmt, va_list args) GUI_FMTLIST(1);
GUI_API void LabelText(const char *label, const char *fmt, ...) GUI_FMTARGS(
    2); // display text+label aligned the same way as value+label widgets
GUI_API void LabelTextV(const char *label, const char *fmt, va_list args)
    GUI_FMTLIST(2);
GUI_API void BulletText(const char *fmt, ...)
    GUI_FMTARGS(1); // shortcut for Bullet()+Text()
GUI_API void BulletTextV(const char *fmt, va_list args) GUI_FMTLIST(1);
GUI_API void SeparatorText(
    const char *label); // currently: formatted text with an horizontal line

// Widgets: Main
// - Most widgets return true when the value has been changed or when
// pressed/selected
// - You may also use one of the many IsItemXXX functions (e.g. IsItemActive,
// IsItemHovered, etc.) to query widget state.
GUI_API bool Button(const char *label, const Vec2 &size = Vec2(0, 0)); // button
GUI_API bool SmallButton(const char *label); // button with (FramePadding.y ==
                                             // 0) to easily embed within text
GUI_API bool InvisibleButton(
    const char *str_id, const Vec2 &size,
    ButtonFlags flags =
        0); // flexible button behavior without the visuals, frequently useful
            // to build custom behaviors using the public api (along with
            // IsItemActive, IsItemHovered, etc.)
GUI_API bool ArrowButton(const char *str_id,
                         Dir dir); // square button with an arrow shape
GUI_API bool Checkbox(const char *label, bool *v);
GUI_API bool CheckboxFlags(const char *label, int *flags, int flags_value);
GUI_API bool CheckboxFlags(const char *label, unsigned int *flags,
                           unsigned int flags_value);
GUI_API bool RadioButton(const char *label,
                         bool active); // use with e.g. if (RadioButton("one",
                                       // my_value==1)) { my_value = 1; }
GUI_API inline bool RadioButton(const char *label, int *v, int v_button) {
  const bool pressed = RadioButton(label, *v == v_button);
  if (pressed)
    *v = v_button;
  return pressed;
}
// shortcut to handle the above
// pattern when value is an integer
GUI_API void ProgressBar(float fraction,
                         const Vec2 &size_arg = Vec2(-FLT_MIN, 0),
                         const char *overlay = NULL);
GUI_API void
Bullet(); // draw a small circle + keep the cursor on the same line. advance
          // cursor x position by GetTreeNodeToLabelSpacing(), same distance
          // that TreeNode() uses

// Widgets: Images
// - Read about TextureID here:
// https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples
// - Note that Image() may add +2.0f to provided size if a border is visible,
// ImageButton() adds style.FramePadding*2.0f to provided size.
GUI_API void Image(TextureID user_texture_id, const Vec2 &image_size,
                   const Vec2 &uv0 = Vec2(0, 0), const Vec2 &uv1 = Vec2(1, 1),
                   const Vec4 &tint_col = Vec4(1, 1, 1, 1),
                   const Vec4 &border_col = Vec4(0, 0, 0, 0));
GUI_API bool ImageButton(const char *str_id, TextureID user_texture_id,
                         const Vec2 &image_size, const Vec2 &uv0 = Vec2(0, 0),
                         const Vec2 &uv1 = Vec2(1, 1),
                         const Vec4 &bg_col = Vec4(0, 0, 0, 0),
                         const Vec4 &tint_col = Vec4(1, 1, 1, 1));

// Widgets: Combo Box (Dropdown)
// - The BeginCombo()/EndCombo() api allows you to manage your contents and
// selection state however you want it, by creating e.g. Selectable() items.
// - The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept
// available for convenience purpose. This is analogous to how ListBox are
// created.
GUI_API bool BeginCombo(const char *label, const char *preview_value,
                        ComboFlags flags = 0);
GUI_API void EndCombo(); // only call EndCombo() if BeginCombo() returns true!
GUI_API bool Combo(const char *label, int *current_item,
                   const char *const items[], int items_count,
                   int popup_max_height_in_items = -1);
GUI_API bool Combo(const char *label, int *current_item,
                   const char *items_separated_by_zeros,
                   int popup_max_height_in_items =
                       -1); // Separate items with \0 within a string, end
                            // item-list with \0\0. e.g. "One\0Two\0Three\0"
GUI_API bool Combo(const char *label, int *current_item,
                   const char *(*getter)(void *user_data, int idx),
                   void *user_data, int items_count,
                   int popup_max_height_in_items = -1);

// Widgets: Drag Sliders
// - CTRL+Click on any drag box to turn them into an input box. Manually input
// values aren't clamped by default and can go off-bounds. Use
// SliderFlags_AlwaysClamp to always clamp.
// - For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every function,
// note that a 'float v[X]' function argument is the same as 'float* v',
//   the array syntax is just a way to document the number of elements that are
//   expected to be accessible. You can pass address of your first element out
//   of a contiguous set, e.g. &myvector.x
// - Adjust format string to decorate the value with a prefix, a suffix, or
// adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" ->
// 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
// - Format string may also be set to NULL or use the default format ("%f" or
// "%d").
// - Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by
// 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum
// speed is Max(v_speed, minimum_step_at_given_precision).
// - Use v_min < v_max to clamp edits to given limits. Note that CTRL+Click
// manual input can override those limits if SliderFlags_AlwaysClamp is not
// used.
// - Use v_max = FLT_MAX / INT_MAX etc to avoid clamping to a maximum, same with
// v_min = -FLT_MAX / INT_MIN to avoid clamping to a minimum.
// - We use the same sets of flags for DragXXX() and SliderXXX() functions as
// the features are the same and it makes it easier to swap them.
// - Legacy: Pre-1.78 there are DragXXX() function signatures that take a final
// `float power=1.0f' argument instead of the `SliderFlags flags=0'
// argument.
//   If you get a warning converting a float to SliderFlags, read
//   https://github.com/ocornut/imgui/issues/3361
GUI_API bool
DragFloat(const char *label, float *v, float v_speed = 1.0f, float v_min = 0.0f,
          float v_max = 0.0f, const char *format = "%.3f",
          SliderFlags flags = 0); // If v_min >= v_max we have no bound
GUI_API bool DragFloat2(const char *label, float v[2], float v_speed = 1.0f,
                        float v_min = 0.0f, float v_max = 0.0f,
                        const char *format = "%.3f", SliderFlags flags = 0);
GUI_API bool DragFloat3(const char *label, float v[3], float v_speed = 1.0f,
                        float v_min = 0.0f, float v_max = 0.0f,
                        const char *format = "%.3f", SliderFlags flags = 0);
GUI_API bool DragFloat4(const char *label, float v[4], float v_speed = 1.0f,
                        float v_min = 0.0f, float v_max = 0.0f,
                        const char *format = "%.3f", SliderFlags flags = 0);
GUI_API bool DragFloatRange2(const char *label, float *v_current_min,
                             float *v_current_max, float v_speed = 1.0f,
                             float v_min = 0.0f, float v_max = 0.0f,
                             const char *format = "%.3f",
                             const char *format_max = NULL,
                             SliderFlags flags = 0);
GUI_API bool
DragInt(const char *label, int *v, float v_speed = 1.0f, int v_min = 0,
        int v_max = 0, const char *format = "%d",
        SliderFlags flags = 0); // If v_min >= v_max we have no bound
GUI_API bool DragInt2(const char *label, int v[2], float v_speed = 1.0f,
                      int v_min = 0, int v_max = 0, const char *format = "%d",
                      SliderFlags flags = 0);
GUI_API bool DragInt3(const char *label, int v[3], float v_speed = 1.0f,
                      int v_min = 0, int v_max = 0, const char *format = "%d",
                      SliderFlags flags = 0);
GUI_API bool DragInt4(const char *label, int v[4], float v_speed = 1.0f,
                      int v_min = 0, int v_max = 0, const char *format = "%d",
                      SliderFlags flags = 0);
GUI_API bool DragIntRange2(const char *label, int *v_current_min,
                           int *v_current_max, float v_speed = 1.0f,
                           int v_min = 0, int v_max = 0,
                           const char *format = "%d",
                           const char *format_max = NULL,
                           SliderFlags flags = 0);
GUI_API bool DragScalar(const char *label, DataType data_type, void *p_data,
                        float v_speed = 1.0f, const void *p_min = NULL,
                        const void *p_max = NULL, const char *format = NULL,
                        SliderFlags flags = 0);
GUI_API bool DragScalarN(const char *label, DataType data_type, void *p_data,
                         int components, float v_speed = 1.0f,
                         const void *p_min = NULL, const void *p_max = NULL,
                         const char *format = NULL, SliderFlags flags = 0);

// Widgets: Regular Sliders
// - CTRL+Click on any slider to turn them into an input box. Manually input
// values aren't clamped by default and can go off-bounds. Use
// SliderFlags_AlwaysClamp to always clamp.
// - Adjust format string to decorate the value with a prefix, a suffix, or
// adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" ->
// 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
// - Format string may also be set to NULL or use the default format ("%f" or
// "%d").
// - Legacy: Pre-1.78 there are SliderXXX() function signatures that take a
// final `float power=1.0f' argument instead of the `SliderFlags flags=0'
// argument.
//   If you get a warning converting a float to SliderFlags, read
//   https://github.com/ocornut/imgui/issues/3361
GUI_API bool SliderFloat(
    const char *label, float *v, float v_min, float v_max,
    const char *format = "%.3f",
    SliderFlags flags = 0); // adjust format to decorate the value with a prefix
                            // or a suffix for in-slider labels or unit display.
GUI_API bool SliderFloat2(const char *label, float v[2], float v_min,
                          float v_max, const char *format = "%.3f",
                          SliderFlags flags = 0);
GUI_API bool SliderFloat3(const char *label, float v[3], float v_min,
                          float v_max, const char *format = "%.3f",
                          SliderFlags flags = 0);
GUI_API bool SliderFloat4(const char *label, float v[4], float v_min,
                          float v_max, const char *format = "%.3f",
                          SliderFlags flags = 0);
GUI_API bool SliderAngle(const char *label, float *v_rad,
                         float v_degrees_min = -360.0f,
                         float v_degrees_max = +360.0f,
                         const char *format = "%.0f deg",
                         SliderFlags flags = 0);
GUI_API bool SliderInt(const char *label, int *v, int v_min, int v_max,
                       const char *format = "%d", SliderFlags flags = 0);
GUI_API bool SliderInt2(const char *label, int v[2], int v_min, int v_max,
                        const char *format = "%d", SliderFlags flags = 0);
GUI_API bool SliderInt3(const char *label, int v[3], int v_min, int v_max,
                        const char *format = "%d", SliderFlags flags = 0);
GUI_API bool SliderInt4(const char *label, int v[4], int v_min, int v_max,
                        const char *format = "%d", SliderFlags flags = 0);
GUI_API bool SliderScalar(const char *label, DataType data_type, void *p_data,
                          const void *p_min, const void *p_max,
                          const char *format = NULL, SliderFlags flags = 0);
GUI_API bool SliderScalarN(const char *label, DataType data_type, void *p_data,
                           int components, const void *p_min, const void *p_max,
                           const char *format = NULL, SliderFlags flags = 0);
GUI_API bool VSliderFloat(const char *label, const Vec2 &size, float *v,
                          float v_min, float v_max, const char *format = "%.3f",
                          SliderFlags flags = 0);
GUI_API bool VSliderInt(const char *label, const Vec2 &size, int *v, int v_min,
                        int v_max, const char *format = "%d",
                        SliderFlags flags = 0);
GUI_API bool VSliderScalar(const char *label, const Vec2 &size,
                           DataType data_type, void *p_data, const void *p_min,
                           const void *p_max, const char *format = NULL,
                           SliderFlags flags = 0);

// Widgets: Input with Keyboard
// - If you want to use InputText() with std::string or any custom dynamic
// string type, see misc/cpp/gui_stdlib.hpp and comments in gui_demo.cpp.
// - Most of the InputTextFlags flags are only useful for InputText() and
// not for InputFloatX, InputIntX, InputDouble etc.
GUI_API static int InputTextCallback(InputTextCallbackData *data);
GUI_API bool InputText(const char *label, char *buf, size_t buf_size,
                       InputTextFlags flags = 0,
                       ::InputTextCallback callback = NULL,
                       void *user_data = NULL);
GUI_API bool InputTextMultiline(const char *label, char *buf, size_t buf_size,
                                const Vec2 &size = Vec2(0, 0),
                                InputTextFlags flags = 0,
                                ::InputTextCallback callback = NULL,
                                void *user_data = NULL);
GUI_API bool InputTextWithHint(const char *label, const char *hint, char *buf,
                               size_t buf_size, InputTextFlags flags = 0,
                               ::InputTextCallback callback = NULL,
                               void *user_data = NULL);
GUI_API bool InputFloat(const char *label, float *v, float step = 0.0f,
                        float step_fast = 0.0f, const char *format = "%.3f",
                        InputTextFlags flags = 0);
GUI_API bool InputFloat2(const char *label, float v[2],
                         const char *format = "%.3f", InputTextFlags flags = 0);
GUI_API bool InputFloat3(const char *label, float v[3],
                         const char *format = "%.3f", InputTextFlags flags = 0);
GUI_API bool InputFloat4(const char *label, float v[4],
                         const char *format = "%.3f", InputTextFlags flags = 0);
GUI_API bool InputInt(const char *label, int *v, int step = 1,
                      int step_fast = 100, InputTextFlags flags = 0);
GUI_API bool InputInt2(const char *label, int v[2], InputTextFlags flags = 0);
GUI_API bool InputInt3(const char *label, int v[3], InputTextFlags flags = 0);
GUI_API bool InputInt4(const char *label, int v[4], InputTextFlags flags = 0);
GUI_API bool InputDouble(const char *label, double *v, double step = 0.0,
                         double step_fast = 0.0, const char *format = "%.6f",
                         InputTextFlags flags = 0);
GUI_API bool InputScalar(const char *label, DataType data_type, void *p_data,
                         const void *p_step = NULL,
                         const void *p_step_fast = NULL,
                         const char *format = NULL, InputTextFlags flags = 0);
GUI_API bool InputScalarN(const char *label, DataType data_type, void *p_data,
                          int components, const void *p_step = NULL,
                          const void *p_step_fast = NULL,
                          const char *format = NULL, InputTextFlags flags = 0);

// Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little
// color square that can be left-clicked to open a picker, and right-clicked to
// open an option menu.)
// - Note that in C++ a 'float v[X]' function argument is the _same_ as 'float*
// v', the array syntax is just a way to document the number of elements that
// are expected to be accessible.
// - You can pass the address of a first float element out of a contiguous
// structure, e.g. &myvector.x
GUI_API bool ColorEdit3(const char *label, float col[3],
                        ColorEditFlags flags = 0);
GUI_API bool ColorEdit4(const char *label, float col[4],
                        ColorEditFlags flags = 0);
GUI_API bool ColorPicker3(const char *label, float col[3],
                          ColorEditFlags flags = 0);
GUI_API bool ColorPicker4(const char *label, float col[4],
                          ColorEditFlags flags = 0,
                          const float *ref_col = NULL);
GUI_API bool ColorButton(
    const char *desc_id, const Vec4 &col, ColorEditFlags flags = 0,
    const Vec2 &size = Vec2(0, 0)); // display a color square/button, hover
                                    // for details, return true when pressed.
GUI_API void SetColorEditOptions(
    ColorEditFlags
        flags); // initialize current options (generally on application startup)
                // if you want to select a default format, picker type, etc.
                // User will be able to change many settings, unless you pass
                // the _NoOptions flag to your calls.

// Widgets: Trees
// - TreeNode functions return true when the node is open, in which case you
// need to also call TreePop() when you are finished displaying the tree node
// contents.
GUI_API bool TreeNode(const char *label);
GUI_API bool TreeNode(const char *str_id, const char *fmt, ...) GUI_FMTARGS(
    2); // helper variation to easily decorelate the id from the displayed
        // string. Read the FAQ about why and how to use ID. to align arbitrary
        // text at the same level as a TreeNode() you can use Bullet().
GUI_API bool TreeNode(const void *ptr_id, const char *fmt, ...)
    GUI_FMTARGS(2); // "
GUI_API bool TreeNodeV(const char *str_id, const char *fmt, va_list args)
    GUI_FMTLIST(2);
GUI_API bool TreeNodeV(const void *ptr_id, const char *fmt, va_list args)
    GUI_FMTLIST(2);
GUI_API bool TreeNodeEx(const char *label, TreeNodeFlags flags = 0);
GUI_API bool TreeNodeEx(const char *str_id, TreeNodeFlags flags,
                        const char *fmt, ...) GUI_FMTARGS(3);
GUI_API bool TreeNodeEx(const void *ptr_id, TreeNodeFlags flags,
                        const char *fmt, ...) GUI_FMTARGS(3);
GUI_API bool TreeNodeExV(const char *str_id, TreeNodeFlags flags,
                         const char *fmt, va_list args) GUI_FMTLIST(3);
GUI_API bool TreeNodeExV(const void *ptr_id, TreeNodeFlags flags,
                         const char *fmt, va_list args) GUI_FMTLIST(3);
GUI_API void
TreePush(const char *str_id); // ~ Indent()+PushID(). Already called by
                              // TreeNode() when returning true, but you can
                              // call TreePush/TreePop yourself if desired.
GUI_API void TreePush(const void *ptr_id); // "
GUI_API void TreePop();                    // ~ Unindent()+PopID()
GUI_API float
GetTreeNodeToLabelSpacing(); // horizontal distance preceding label when using
                             // TreeNode*() or Bullet() == (g.FontSize +
                             // style.FramePadding.x*2) for a regular unframed
                             // TreeNode
GUI_API bool CollapsingHeader(
    const char *label,
    TreeNodeFlags flags =
        0); // if returning 'true' the header is open. doesn't indent nor push
            // on ID stack. user doesn't have to call TreePop().
GUI_API bool CollapsingHeader(
    const char *label, bool *p_visible,
    TreeNodeFlags flags =
        0); // when 'p_visible != NULL': if '*p_visible==true' display an
            // additional small close button on upper right of the header which
            // will set the bool to false when clicked, if '*p_visible==false'
            // don't display the header.
GUI_API void SetNextItemOpen(
    bool is_open,
    Cond cond = 0); // set next TreeNode/CollapsingHeader open state.

// Widgets: Selectables
// - A selectable highlights when hovered, and can display another color when
// selected.
// - Neighbors selectable extend their highlight bounds in order to leave no gap
// between them. This is so a series of selected Selectable appear contiguous.
GUI_API bool Selectable(
    const char *label, bool selected = false, SelectableFlags flags = 0,
    const Vec2 &size =
        Vec2(0, 0)); // "bool selected" carry the selection state (read-only).
                     // Selectable() is clicked is returns true so you can
                     // modify your selection state. size.x==0.0: use remaining
                     // width, size.x>0.0: specify width. size.y==0.0: use label
                     // height, size.y>0.0: specify height
GUI_API inline bool Selectable(const char *label, bool *p_selected,
                               SelectableFlags flags = 0,
                               const Vec2 &size_arg = Vec2(0, 0)) {
  if (Selectable(label, *p_selected, flags, size_arg)) {
    *p_selected = !*p_selected;
    return true;
  }
  return false;
}
// "bool* p_selected" point to the selection
// state (read-write), as a convenient helper.

// Widgets: List Boxes
// - This is essentially a thin wrapper to using BeginChild/EndChild with the
// ChildFlags_FrameStyle flag for stylistic changes + displaying a label.
// - You can submit contents and manage your selection state however you want
// it, by creating e.g. Selectable() or any other items.
// - The simplified/old ListBox() api are helpers over
// BeginListBox()/EndListBox() which are kept available for convenience purpose.
// This is analoguous to how Combos are created.
// - Choose frame width:   size.x > 0.0f: custom  /  size.x < 0.0f or -FLT_MIN:
// right-align   /  size.x = 0.0f (default): use current ItemWidth
// - Choose frame height:  size.y > 0.0f: custom  /  size.y < 0.0f or -FLT_MIN:
// bottom-align  /  size.y = 0.0f (default): arbitrary default height which can
// fit ~7 items
GUI_API bool
BeginListBox(const char *label,
             const Vec2 &size = Vec2(0, 0)); // open a framed scrolling region
GUI_API void
EndListBox(); // only call EndListBox() if BeginListBox() returned true!
GUI_API bool ListBox(const char *label, int *current_item,
                     const char *const items[], int items_count,
                     int height_in_items = -1);
GUI_API bool ListBox(const char *label, int *current_item,
                     const char *(*getter)(void *user_data, int idx),
                     void *user_data, int items_count,
                     int height_in_items = -1);

// Widgets: Data Plotting
// - Consider using Plot (https://github.com/epezent/implot) which is much
// better!
GUI_API void PlotLines(const char *label, const float *values, int values_count,
                       int values_offset = 0, const char *overlay_text = NULL,
                       float scale_min = FLT_MAX, float scale_max = FLT_MAX,
                       Vec2 graph_size = Vec2(0, 0),
                       int stride = sizeof(float));
GUI_API void PlotLines(const char *label,
                       float (*values_getter)(void *data, int idx), void *data,
                       int values_count, int values_offset = 0,
                       const char *overlay_text = NULL,
                       float scale_min = FLT_MAX, float scale_max = FLT_MAX,
                       Vec2 graph_size = Vec2(0, 0));
GUI_API void PlotHistogram(const char *label, const float *values,
                           int values_count, int values_offset = 0,
                           const char *overlay_text = NULL,
                           float scale_min = FLT_MAX, float scale_max = FLT_MAX,
                           Vec2 graph_size = Vec2(0, 0),
                           int stride = sizeof(float));
GUI_API void PlotHistogram(const char *label,
                           float (*values_getter)(void *data, int idx),
                           void *data, int values_count, int values_offset = 0,
                           const char *overlay_text = NULL,
                           float scale_min = FLT_MAX, float scale_max = FLT_MAX,
                           Vec2 graph_size = Vec2(0, 0));

// Widgets: Value() Helpers.
// - Those are merely shortcut to calling Text() with a format string. Output
// single value in "name: value" format (tip: freely declare more in your code
// to handle your types. you can add functions to the Gui namespace)
GUI_API inline void Value(const char *prefix, bool b) {
  Text("%s: %s", prefix, (b ? "true" : "false"));
}

GUI_API inline void Value(const char *prefix, int v) {
  Text("%s: %d", prefix, v);
}

GUI_API inline void Value(const char *prefix, unsigned int v) {
  Text("%s: %d", prefix, v);
}

GUI_API void Value(const char *prefix, float v,
                   const char *float_format = NULL);

// Widgets: Menus
// - Use BeginMenuBar() on a window WindowFlags_MenuBar to append to its
// menu bar.
// - Use BeginMainMenuBar() to create a menu bar at the top of the screen and
// append to it.
// - Use BeginMenu() to create a menu. You can call BeginMenu() multiple time
// with the same identifier to append more items to it.
// - Not that MenuItem() keyboardshortcuts are displayed as a convenience but
// _not processed_ by Dear Gui at the moment.
GUI_API bool BeginMenuBar(); // append to menu-bar of current window (requires
                             // WindowFlags_MenuBar flag set on parent window).
GUI_API void
EndMenuBar(); // only call EndMenuBar() if BeginMenuBar() returns true!
GUI_API bool BeginMainMenuBar(); // create and append to a full screen menu-bar.
GUI_API void EndMainMenuBar();   // only call EndMainMenuBar() if
                                 // BeginMainMenuBar() returns true!
GUI_API bool
BeginMenu(const char *label,
          bool enabled = true); // create a sub-menu entry. only call EndMenu()
                                // if this returns true!
GUI_API void EndMenu(); // only call EndMenu() if BeginMenu() returns true!
GUI_API bool MenuItem(const char *label, const char *shortcut = NULL,
                      bool selected = false,
                      bool enabled = true); // return true when activated.
GUI_API bool
MenuItem(const char *label, const char *shortcut, bool *p_selected,
         bool enabled = true); // return true when activated + toggle
                               // (*p_selected) if p_selected != NULL

// Tooltips
// - Tooltips are windows following the mouse. They do not take focus away.
// - A tooltip window can contain items of any types. SetTooltip() is a shortcut
// for the 'if (BeginTooltip()) { Text(...); EndTooltip(); }' idiom.
GUI_API bool BeginTooltip(); // begin/append a tooltip window.
GUI_API void EndTooltip();   // only call EndTooltip() if
                             // BeginTooltip()/BeginItemTooltip() returns true!
GUI_API void SetTooltip(const char *fmt, ...) GUI_FMTARGS(
    1); // set a text-only tooltip. Often used after a Gui::IsItemHovered()
        // check. Override any previous call to SetTooltip().
GUI_API void SetTooltipV(const char *fmt, va_list args) GUI_FMTLIST(1);

// Tooltips: helpers for showing a tooltip when hovering an item
// - BeginItemTooltip() is a shortcut for the 'if
// (IsItemHovered(HoveredFlags_ForTooltip) && BeginTooltip())' idiom.
// - SetItemTooltip() is a shortcut for the 'if
// (IsItemHovered(HoveredFlags_ForTooltip)) { SetTooltip(...); }' idiom.
// - Where 'HoveredFlags_ForTooltip' itself is a shortcut to use
// 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav'
// depending on active input type. For mouse it defaults to
// 'HoveredFlags_Stationary | HoveredFlags_DelayShort'.
GUI_API bool BeginItemTooltip(); // begin/append a tooltip window if preceding
                                 // item was hovered.
GUI_API void SetItemTooltip(const char *fmt, ...)
    GUI_FMTARGS(1); // set a text-only tooltip if preceeding item was hovered.
                    // override any previous call to SetTooltip().
GUI_API void SetItemTooltipV(const char *fmt, va_list args) GUI_FMTLIST(1);

// Popups, Modals
//  - They block normal mouse hovering detection (and therefore most mouse
//  interactions) behind them.
//  - If not modal: they can be closed by clicking anywhere outside them, or by
//  pressing ESCAPE.
//  - Their visibility state (~bool) is held internally instead of being held by
//  the programmer as we are used to with regular Begin*() calls.
//  - The 3 properties above are related: we need to retain popup visibility
//  state in the library because popups may be closed as any time.
//  - You can bypass the hovering restriction by using
//  HoveredFlags_AllowWhenBlockedByPopup when calling IsItemHovered() or
//  IsWindowHovered().
//  - IMPORTANT: Popup identifiers are relative to the current ID stack, so
//  OpenPopup and BeginPopup generally needs to be at the same level of the
//  stack.
//    This is sometimes leading to confusing mistakes. May rework this in the
//    future.
//  - BeginPopup(): query popup state, if open start appending into the window.
//  Call EndPopup() afterwards if returned true. WindowFlags are forwarded
//  to the window.
//  - BeginPopupModal(): block every interaction behind the window, cannot be
//  closed by user, add a dimming background, has a title bar.
GUI_API bool
BeginPopup(const char *str_id,
           WindowFlags flags = 0); // return true if the popup is open, and
                                   // you can start outputting to it.
GUI_API bool
BeginPopupModal(const char *name, bool *p_open = NULL,
                WindowFlags flags = 0); // return true if the modal is open, and
                                        // you can start outputting to it.
GUI_API void
EndPopup(); // only call EndPopup() if BeginPopupXXX() returns true!

// Popups: open/close functions
//  - OpenPopup(): set popup state to open. PopupFlags are available for
//  opening options.
//  - If not modal: they can be closed by clicking anywhere outside them, or by
//  pressing ESCAPE.
//  - CloseCurrentPopup(): use inside the BeginPopup()/EndPopup() scope to close
//  manually.
//  - CloseCurrentPopup() is called by default by Selectable()/MenuItem() when
//  activated (FIXME: need some options).
//  - Use PopupFlags_NoOpenOverExistingPopup to avoid opening a popup if
//  there's already one at the same level. This is equivalent to e.g. testing
//  for !IsAnyPopupOpen() prior to OpenPopup().
//  - Use IsWindowAppearing() after BeginPopup() to tell if a window just
//  opened.
//  - IMPORTANT: Notice that for OpenPopupOnItemClick() we exceptionally default
//  flags to 1 (== PopupFlags_MouseButtonRight) for backward compatibility
//  with older API taking 'int mouse_button = 1' parameter
GUI_API void
OpenPopup(const char *str_id,
          PopupFlags popup_flags =
              0); // call to mark popup as open (don't call every frame!).
GUI_API void
OpenPopup(ID id,
          PopupFlags popup_flags =
              0); // id overload to facilitate calling from nested stacks
GUI_API void
OpenPopupOnItemClick(const char *str_id = NULL,
                     PopupFlags popup_flags =
                         1); // helper to open popup when clicked on last item.
                             // Default to PopupFlags_MouseButtonRight == 1.
                             // (note: actually triggers on the mouse _released_
                             // event to be consistent with popup behaviors)
GUI_API void
CloseCurrentPopup(); // manually close the popup we have begin-ed into.

// Popups: open+begin combined functions helpers
//  - Helpers to do OpenPopup+BeginPopup where the Open action is triggered by
//  e.g. hovering an item and right-clicking.
//  - They are convenient to easily create context menus, hence the name.
//  - IMPORTANT: Notice that BeginPopupContextXXX takes PopupFlags just
//  like OpenPopup() and unlike BeginPopup(). For full consistency, we may add
//  WindowFlags to the BeginPopupContextXXX functions in the future.
//  - IMPORTANT: Notice that we exceptionally default their flags to 1 (==
//  PopupFlags_MouseButtonRight) for backward compatibility with older API
//  taking 'int mouse_button = 1' parameter, so if you add other flags remember
//  to re-add the PopupFlags_MouseButtonRight.
GUI_API bool BeginPopupContextItem(
    const char *str_id = NULL,
    PopupFlags popup_flags =
        1); // open+begin popup when clicked on last item. Use str_id==NULL to
            // associate the popup to previous item. If you want to use that on
            // a non-interactive item such as Text() you need to pass in an
            // explicit ID here. read comments in .cpp!
GUI_API bool BeginPopupContextWindow(
    const char *str_id = NULL,
    PopupFlags popup_flags =
        1); // open+begin popup when clicked on current window.
GUI_API bool BeginPopupContextVoid(
    const char *str_id = NULL,
    PopupFlags popup_flags = 1); // open+begin popup when clicked in void
                                 // (where there are no windows).

// Popups: query functions
//  - IsPopupOpen(): return true if the popup is open at the current
//  BeginPopup() level of the popup stack.
//  - IsPopupOpen() with PopupFlags_AnyPopupId: return true if any popup is
//  open at the current BeginPopup() level of the popup stack.
//  - IsPopupOpen() with PopupFlags_AnyPopupId +
//  PopupFlags_AnyPopupLevel: return true if any popup is open.
GUI_API bool
IsPopupOpen(const char *str_id,
            PopupFlags flags = 0); // return true if the popup is open.

// Tables
// - Full-featured replacement for old Columns API.
// - See Demo->Tables for demo code. See top of gui_tables.hpp for general
// commentary.
// - See TableFlags_ and TableColumnFlags_ enums for a description of
// available flags. The typical call flow is:
// - 1. Call BeginTable(), early out if returning false.
// - 2. Optionally call TableSetupColumn() to submit column name/flags/defaults.
// - 3. Optionally call TableSetupScrollFreeze() to request scroll freezing of
// columns/rows.
// - 4. Optionally call TableHeadersRow() to submit a header row. Names are
// pulled from TableSetupColumn() data.
// - 5. Populate contents:
//    - In most situations you can use TableNextRow() + TableSetColumnIndex(N)
//    to start appending into a column.
//    - If you are using tables as a sort of grid, where every column is holding
//    the same type of contents,
//      you may prefer using TableNextColumn() instead of TableNextRow() +
//      TableSetColumnIndex(). TableNextColumn() will automatically wrap-around
//      into the next row if needed.
//    - IMPORTANT: Comparatively to the old Columns() API, we need to call
//    TableNextColumn() for the first column!
//    - Summary of possible call flow:
//        - TableNextRow() -> TableSetColumnIndex(0) -> Text("Hello 0") ->
//        TableSetColumnIndex(1) -> Text("Hello 1")  // OK
//        - TableNextRow() -> TableNextColumn()      -> Text("Hello 0") ->
//        TableNextColumn()      -> Text("Hello 1")  // OK
//        -                   TableNextColumn()      -> Text("Hello 0") ->
//        TableNextColumn()      -> Text("Hello 1")  // OK: TableNextColumn()
//        automatically gets to next row!
//        - TableNextRow()                           -> Text("Hello 0") // Not
//        OK! Missing TableSetColumnIndex() or TableNextColumn()! Text will not
//        appear!
// - 5. Call EndTable()
GUI_API bool BeginTable(const char *str_id, int column, TableFlags flags = 0,
                        const Vec2 &outer_size = Vec2(0.0f, 0.0f),
                        float inner_width = 0.0f);
GUI_API void EndTable(); // only call EndTable() if BeginTable() returns true!
GUI_API void TableNextRow(
    TableRowFlags row_flags = 0,
    float min_row_height = 0.0f); // append into the first cell of a new row.
GUI_API bool TableNextColumn(); // append into the next column (or first column
                                // of next row if currently in last column).
                                // Return true when column is visible.
GUI_API bool
TableSetColumnIndex(int column_n); // append into the specified column. Return
                                   // true when column is visible.

// Tables: Headers & Columns declaration
// - Use TableSetupColumn() to specify label, resizing policy, default
// width/weight, id, various other flags etc.
// - Use TableHeadersRow() to create a header row and automatically submit a
// TableHeader() for each column.
//   Headers are required to perform: reordering, sorting, and opening the
//   context menu. The context menu can also be made available in columns body
//   using TableFlags_ContextMenuInBody.
// - You may manually submit headers using TableNextRow() + TableHeader() calls,
// but this is only useful in
//   some advanced use cases (e.g. adding custom widgets in header row).
// - Use TableSetupScrollFreeze() to lock columns/rows so they stay visible when
// scrolled.
GUI_API void TableSetupColumn(const char *label, TableColumnFlags flags = 0,
                              float init_width_or_weight = 0.0f,
                              ID user_id = 0);
GUI_API void TableSetupScrollFreeze(
    int cols,
    int rows); // lock columns/rows so they stay visible when scrolled.
GUI_API void
TableHeader(const char *label); // submit one header cell manually (rarely used)
GUI_API void
TableHeadersRow(); // submit a row with headers cells based on data provided to
                   // TableSetupColumn() + submit context menu
GUI_API void
TableAngledHeadersRow(); // submit a row with angled headers for every column
                         // with the TableColumnFlags_AngledHeader flag.
                         // MUST BE FIRST ROW.

// Tables: Sorting & Miscellaneous functions
// - Sorting: call TableGetSortSpecs() to retrieve latest sort specs for the
// table. NULL when not sorting.
//   When 'sort_specs->SpecsDirty == true' you should sort your data. It will be
//   true when sorting specs have changed since last call, or the first time.
//   Make sure to set 'SpecsDirty = false' after sorting, else you may
//   wastefully sort your data every frame!
// - Functions args 'int column_n' treat the default value of -1 as the same as
// passing the current column index.
GUI_API TableSortSpecs *
TableGetSortSpecs(); // get latest sort specs for the table (NULL if not
                     // sorting).  Lifetime: don't hold on this pointer over
                     // multiple frames or past any subsequent call to
                     // BeginTable().
GUI_API int
TableGetColumnCount(); // return number of columns (value passed to BeginTable)
GUI_API int TableGetColumnIndex(); // return current column index.
GUI_API int TableGetRowIndex();    // return current row index.
GUI_API const char *TableGetColumnName(
    int column_n = -1); // return "" if column didn't have a name declared by
                        // TableSetupColumn(). Pass -1 to use current column.
GUI_API TableColumnFlags TableGetColumnFlags(
    int column_n = -1); // return column flags so you can query their
                        // Enabled/Visible/Sorted/Hovered status flags. Pass -1
                        // to use current column.
GUI_API void TableSetColumnEnabled(
    int column_n,
    bool v); // change user accessible enabled/disabled state of a column. Set
             // to false to hide the column. User can use the context menu to
             // change this themselves (right-click in headers, or right-click
             // in columns body with TableFlags_ContextMenuInBody)
GUI_API void TableSetBgColor(
    TableBgTarget target, U32 color,
    int column_n = -1); // change the color of a cell, row, or column. See
                        // TableBgTarget_ flags for details.

// Legacy Columns API (prefer using Tables!)
// - You can also use SameLine(pos_x) to mimic simplified columns.
GUI_API void Columns(int count = 1, const char *id = NULL, bool border = true);
GUI_API void NextColumn(); // next column, defaults to current row or next row
                           // if the current row is finished
GUI_API int GetColumnIndex(); // get current column index
GUI_API float GetColumnWidth(
    int column_index =
        -1); // get column width (in pixels). pass -1 to use current column
GUI_API void SetColumnWidth(
    int column_index,
    float width); // set column width (in pixels). pass -1 to use current column
GUI_API float GetColumnOffset(
    int column_index =
        -1); // get position of column line (in pixels, from the left side of
             // the contents region). pass -1 to use current column, otherwise
             // 0..GetColumnsCount() inclusive. column 0 is typically 0.0f
GUI_API void
SetColumnOffset(int column_index,
                float offset_x); // set position of column line (in pixels, from
                                 // the left side of the contents region). pass
                                 // -1 to use current column
GUI_API int GetColumnsCount();

// Tab Bars, Tabs
// - Note: Tabs are automatically created by the docking system (when in
// 'docking' branch). Use this to create tab bars/tabs yourself.
GUI_API bool
BeginTabBar(const char *str_id,
            TabBarFlags flags = 0); // create and append into a TabBar
GUI_API void
EndTabBar(); // only call EndTabBar() if BeginTabBar() returns true!
GUI_API bool
BeginTabItem(const char *label, bool *p_open = NULL,
             TabItemFlags flags =
                 0); // create a Tab. Returns true if the Tab is selected.
GUI_API void
EndTabItem(); // only call EndTabItem() if BeginTabItem() returns true!
GUI_API bool TabItemButton(
    const char *label,
    TabItemFlags flags = 0); // create a Tab behaving like a button. return true
                             // when clicked. cannot be selected in the tab bar.
GUI_API void SetTabItemClosed(
    const char
        *tab_or_docked_window_label); // notify TabBar or Docking system of a
                                      // closed tab/window ahead (useful to
                                      // reduce visual flicker on reorderable
                                      // tab bars). For tab-bar: call after
                                      // BeginTabBar() and before Tab
                                      // submissions. Otherwise call with a
                                      // window name.

// Logging/Capture
// - All text output from the interface can be captured into tty/file/clipboard.
// By default, tree nodes are automatically opened during logging.
GUI_API void
LogToTTY(int auto_open_depth = -1); // start logging to tty (stdout)
GUI_API void LogToFile(int auto_open_depth = -1,
                       const char *filename = NULL); // start logging to file
GUI_API void
LogToClipboard(int auto_open_depth = -1); // start logging to OS clipboard
GUI_API void LogFinish();                 // stop logging (close file, etc.)
GUI_API void
LogButtons(); // helper to display buttons for logging to tty/file/clipboard
GUI_API void LogText(const char *fmt, ...)
    GUI_FMTARGS(1); // pass text data straight to log (without being displayed)
GUI_API void LogTextV(const char *fmt, va_list args) GUI_FMTLIST(1);

// Drag and Drop
// - On source items, call BeginDragDropSource(), if it returns true also call
// SetDragDropPayload() + EndDragDropSource().
// - On target candidates, call BeginDragDropTarget(), if it returns true also
// call AcceptDragDropPayload() + EndDragDropTarget().
// - If you stop calling BeginDragDropSource() the payload is preserved however
// it won't have a preview tooltip (we currently display a fallback "..."
// tooltip, see #1725)
// - An item can be both drag source and drop target.
GUI_API bool BeginDragDropSource(
    DragDropFlags flags = 0); // call after submitting an item which may be
                              // dragged. when this return true, you can call
                              // SetDragDropPayload() + EndDragDropSource()
GUI_API bool SetDragDropPayload(
    const char *type, const void *data, size_t sz,
    Cond cond = 0); // type is a user defined string of maximum 32
                    // characters. Strings starting with '_' are reserved for
                    // dear gui internal types. Data is copied and held by
                    // gui. Return true when payload has been accepted.
GUI_API void EndDragDropSource(); // only call EndDragDropSource() if
                                  // BeginDragDropSource() returns true!
GUI_API bool
BeginDragDropTarget(); // call after submitting an item that may receive a
                       // payload. If this returns true, you can call
                       // AcceptDragDropPayload() + EndDragDropTarget()
GUI_API const Payload *AcceptDragDropPayload(
    const char *type,
    DragDropFlags flags =
        0); // accept contents of a given type. If
            // DragDropFlags_AcceptBeforeDelivery is set you can peek into
            // the payload before the mouse button is released.
GUI_API void EndDragDropTarget(); // only call EndDragDropTarget() if
                                  // BeginDragDropTarget() returns true!
GUI_API const Payload *
GetDragDropPayload(); // peek directly into the current payload from anywhere.
                      // returns NULL when drag and drop is finished or
                      // inactive. use Payload::IsDataType() to test for
                      // the payload type.

// Disabling [BETA API]
// - Disable all user interactions and dim items visuals (applying
// style.DisabledAlpha over current colors)
// - Those can be nested but it cannot be used to enable an already disabled
// section (a single BeginDisabled(true) in the stack is enough to keep
// everything disabled)
// - BeginDisabled(false) essentially does nothing useful but is provided to
// facilitate use of boolean expressions. If you can avoid calling
// BeginDisabled(False)/EndDisabled() best to avoid it.
GUI_API void BeginDisabled(bool disabled = true);
GUI_API void EndDisabled();

// Clipping
// - Mouse hovering is affected by Gui::PushClipRect() calls, unlike direct
// calls to DrawList::PushClipRect() which are render only.
GUI_API void PushClipRect(const Vec2 &clip_rect_min, const Vec2 &clip_rect_max,
                          bool intersect_with_current_clip_rect);
GUI_API void PopClipRect();

// Focus, Activation
// - Prefer using "SetItemDefaultFocus()" over "if (IsWindowAppearing())
// SetScrollHereY()" when applicable to signify "this is the default item"
GUI_API void
SetItemDefaultFocus(); // make last item the default focused item of a window.
GUI_API void SetKeyboardFocusHere(
    int offset = 0); // focus keyboard on the next widget. Use positive 'offset'
                     // to access sub components of a multiple component widget.
                     // Use -1 to access previous widget.

// Overlapping mode
GUI_API void
SetNextItemAllowOverlap(); // allow next item to be overlapped by a subsequent
                           // item. Useful with invisible buttons, selectable,
                           // treenode covering an area where subsequent items
                           // may need to be added. Note that both Selectable()
                           // and TreeNode() have dedicated flags doing this.

// Item/Widgets Utilities and Query Functions
// - Most of the functions are referring to the previous Item that has been
// submitted.
// - See Demo Window under "Widgets->Querying Status" for an interactive
// visualization of most of those functions.
GUI_API bool
IsItemHovered(HoveredFlags flags =
                  0); // is the last item hovered? (and usable, aka not blocked
                      // by a popup, etc.). See HoveredFlags for more options.
GUI_API bool
IsItemActive(); // is the last item active? (e.g. button being held, text field
                // being edited. This will continuously return true while
                // holding mouse button on an item. Items that don't interact
                // will always return false)
GUI_API bool
IsItemFocused(); // is the last item focused for keyboard/gamepad navigation?
GUI_API bool IsItemClicked(
    MouseButton mouse_button =
        0); // is the last item hovered and mouse clicked on? (**)  ==
            // IsMouseClicked(mouse_button) && IsItemHovered()Important. (**)
            // this is NOT equivalent to the behavior of e.g. Button(). Read
            // comments in function definition.
GUI_API bool IsItemVisible(); // is the last item visible? (items may be out
                              // of sight because of clipping/scrolling)
GUI_API bool
IsItemEdited(); // did the last item modify its underlying value this frame? or
                // was pressed? This is generally the same as the "bool" return
                // value of many widgets.
GUI_API bool IsItemActivated(); // was the last item just made active (item
                                // was previously inactive).
GUI_API bool
IsItemDeactivated(); // was the last item just made inactive (item was
                     // previously active). Useful for Undo/Redo patterns with
                     // widgets that require continuous editing.
GUI_API bool
IsItemDeactivatedAfterEdit(); // was the last item just made inactive and made a
                              // value change when it was active? (e.g.
                              // Slider/Drag moved). Useful for Undo/Redo
                              // patterns with widgets that require continuous
                              // editing. Note that you may get false positives
                              // (some widgets such as
                              // Combo()/ListBox()/Selectable() will return true
                              // even when clicking an already selected item).
GUI_API bool
IsItemToggledOpen(); // was the last item open state toggled? set by TreeNode().
GUI_API bool IsAnyItemHovered(); // is any item hovered?
GUI_API bool IsAnyItemActive();  // is any item active?
GUI_API bool IsAnyItemFocused(); // is any item focused?
GUI_API ID
GetItemID(); // get ID of last item (~~ often same Gui::GetID(label) beforehand)
GUI_API Vec2 GetItemRectMin();  // get upper-left bounding rectangle of the
                                // last item (screen space)
GUI_API Vec2 GetItemRectMax();  // get lower-right bounding rectangle of the
                                // last item (screen space)
GUI_API Vec2 GetItemRectSize(); // get size of last item

// Viewports
// - Currently represents the Platform Window created by the application which
// is hosting our Dear Gui windows.
// - In 'docking' branch with multi-viewport enabled, we extend this concept to
// have multiple active viewports.
// - In the future we will extend this concept further to also represent
// Platform Monitor and support a "no main platform window" operation mode.
GUI_API Viewport *
GetMainViewport(); // return primary/default viewport. This can never be NULL.

// Background/Foreground Draw Lists
GUI_API DrawList *
GetBackgroundDrawList(); // this draw list will be the first rendered one.
                         // Useful to quickly draw shapes/text behind dear gui
                         // contents.
GUI_API DrawList *
GetForegroundDrawList(); // this draw list will be the last rendered one. Useful
                         // to quickly draw shapes/text over dear gui
                         // contents.

// Miscellaneous Utilities
GUI_API bool IsRectVisible(
    const Vec2 &size); // test if rectangle (of given size, starting from
                       // cursor position) is visible / not clipped.
GUI_API bool IsRectVisible(
    const Vec2 &rect_min,
    const Vec2
        &rect_max); // test if rectangle (in screen space) is visible / not
                    // clipped. to perform coarse clipping on user's side.
GUI_API double
GetTime(); // get global gui time. incremented by io.DeltaTime every frame.
GUI_API int
GetFrameCount(); // get global gui frame count. incremented by 1 every frame.
GUI_API DrawListSharedData *
GetDrawListSharedData(); // you may use this when creating your own DrawList
                         // instances.
GUI_API const char *
GetStyleColorName(Col idx); // get a string corresponding to the enum value
                            // (for display, saving, etc.).
GUI_API void SetStateStorage(
    Storage *
        storage); // replace current window storage with our own (if you want to
                  // manipulate it yourself, typically clear subsection of it)
GUI_API Storage *GetStateStorage();

// Text Utilities
GUI_API Vec2 CalcTextSize(const char *text, const char *text_end = NULL,
                          bool hide_text_after_double_hash = false,
                          float wrap_width = -1.0f);

// Color Utilities
GUI_API Vec4 ColorConvertU32ToFloat4(U32 in);
GUI_API U32 ColorConvertFloat4ToU32(const Vec4 &in);
GUI_API void ColorConvertRGBtoHSV(float r, float g, float b, float &out_h,
                                  float &out_s, float &out_v);
GUI_API void ColorConvertHSVtoRGB(float h, float s, float v, float &out_r,
                                  float &out_g, float &out_b);

// Inputs Utilities: Keyboard/Mouse/Gamepad
// - the Key enum contains all possible keyboard, mouse and gamepad inputs
// (e.g. Key_A, Key_MouseLeft, Key_GamepadDpadUp...).
// - before v1.87, we used Key to carry native/user indices as defined by
// each backends. About use of those legacy Key values:
//  - without GUI_DISABLE_OBSOLETE_KEYIO (legacy support): you can still use
//  your legacy native/user indices (< 512) according to how your backend/engine
//  stored them in io.KeysDown[], but need to cast them to Key.
//  - with    GUI_DISABLE_OBSOLETE_KEYIO (this is the way forward): any use of
//  Key will assert with key < 512. GetKeyIndex() is pass-through and
//  therefore deprecated (gone if GUI_DISABLE_OBSOLETE_KEYIO is defined).
GUI_API bool IsKeyDown(Key key); // is key being held.
GUI_API bool IsKeyPressed(
    Key key,
    bool repeat = true); // was key pressed (went from !Down to Down)? if
                         // repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
GUI_API bool
IsKeyReleased(Key key); // was key released (went from Down to !Down)?
GUI_API bool IsKeyChordPressed(
    KeyChord key_chord); // was key chord (mods + key) pressed, e.g. you can
                         // pass 'Mod_Ctrl | Key_S' as a key-chord. This
                         // doesn't do any routing or focus check, please
                         // consider using Shortcut() function instead.
GUI_API int GetKeyPressedAmount(
    Key key, float repeat_delay,
    float rate); // uses provided repeat rate/delay. return a count, most often
                 // 0 or 1 but might be >1 if RepeatRate is small enough that
                 // DeltaTime > RepeatRate
GUI_API const char *
GetKeyName(Key key); // [DEBUG] returns English name of the key. Those
                     // names a provided for debugging purpose and are not
                     // meant to be saved persistently not compared.
GUI_API void SetNextFrameWantCaptureKeyboard(
    bool want_capture_keyboard); // Override io.WantCaptureKeyboard flag next
                                 // frame (said flag is left for your
                                 // application to handle, typically when true
                                 // it instructs your app to ignore inputs).
                                 // e.g. force capture keyboard when your widget
                                 // is being hovered. This is equivalent to
                                 // setting "io.WantCaptureKeyboard =
                                 // want_capture_keyboard"; after the next
                                 // NewFrame() call.

// Inputs Utilities: Mouse specific
// - To refer to a mouse button, you may use named enums in your code e.g.
// MouseButton_Left, MouseButton_Right.
// - You can also use regular integer: it is forever guaranteed that 0=Left,
// 1=Right, 2=Middle.
// - Dragging operations are only reported after mouse has moved a certain
// distance away from the initial clicking position (see 'lock_threshold' and
// 'io.MouseDraggingThreshold')
GUI_API bool IsMouseDown(MouseButton button); // is mouse button held?
GUI_API bool IsMouseClicked(
    MouseButton button,
    bool repeat = false); // did mouse button clicked? (went from !Down to
                          // Down). Same as GetMouseClickedCount() == 1.
GUI_API bool IsMouseReleased(MouseButton button); // did mouse button released?
                                                  // (went from Down to !Down)
GUI_API bool IsMouseDoubleClicked(
    MouseButton
        button); // did mouse button double-clicked? Same as
                 // GetMouseClickedCount() == 2. (note that a double-click will
                 // also report IsMouseClicked() == true)
GUI_API int GetMouseClickedCount(
    MouseButton button); // return the number of successive mouse-clicks at
                         // the time where a click happen (otherwise 0).
GUI_API bool IsMouseHoveringRect(
    const Vec2 &r_min, const Vec2 &r_max,
    bool clip =
        true); // is mouse hovering given bounding rect (in screen space).
               // clipped by current clipping settings, but disregarding of
               // other consideration of focus/window ordering/popup-block.
GUI_API bool IsMousePosValid(
    const Vec2 *mouse_pos = NULL); // by convention we use (-FLT_MAX,-FLT_MAX)
                                   // to denote that there is no mouse available
GUI_API bool
IsAnyMouseDown(); // [WILL OBSOLETE] is any mouse button held? This was designed
                  // for backends, but prefer having backend maintain a mask of
                  // held mouse buttons, because upcoming input queue system
                  // will make this invalid.
GUI_API Vec2 GetMousePos(); // shortcut to Gui::GetIO().MousePos provided by
                            // user, to be consistent with other calls
GUI_API Vec2
GetMousePosOnOpeningCurrentPopup(); // retrieve mouse position at the time of
                                    // opening popup we have BeginPopup() into
                                    // (helper to avoid user backing that value
                                    // themselves)
GUI_API bool IsMouseDragging(
    MouseButton button,
    float lock_threshold = -1.0f); // is mouse dragging? (if lock_threshold <
                                   // -1.0f, uses io.MouseDraggingThreshold)
GUI_API Vec2 GetMouseDragDelta(
    MouseButton button = 0,
    float lock_threshold =
        -1.0f); // return the delta from the initial clicking position while the
                // mouse button is pressed or was just released. This is locked
                // and return 0.0f until the mouse moves past a distance
                // threshold at least once (if lock_threshold < -1.0f, uses
                // io.MouseDraggingThreshold)
GUI_API void ResetMouseDragDelta(MouseButton button = 0); //
GUI_API MouseCursor
GetMouseCursor(); // get desired mouse cursor shape. Important: reset in
                  // Gui::NewFrame(), this is updated during the frame. valid
                  // before Render(). If you use software rendering by setting
                  // io.MouseDrawCursor Gui will render those for you
GUI_API void
SetMouseCursor(MouseCursor cursor_type); // set desired mouse cursor shape
GUI_API void SetNextFrameWantCaptureMouse(
    bool
        want_capture_mouse); // Override io.WantCaptureMouse flag next frame
                             // (said flag is left for your application to
                             // handle, typical when true it instucts your app
                             // to ignore inputs). This is equivalent to setting
                             // "io.WantCaptureMouse = want_capture_mouse;"
                             // after the next NewFrame() call.

// Clipboard Utilities
// - Also see the LogToClipboard() function to capture GUI into clipboard, or
// easily output text data to the clipboard.
GUI_API const char *GetClipboardText();
GUI_API void SetClipboardText(const char *text);

// Settings/.Ini Utilities
// - The disk functions are automatically called if io.IniFilename != NULL
// (default is "gui.ini").
// - Set io.IniFilename to NULL to load/save manually. Read
// io.WantSaveIniSettings description about handling .ini saving manually.
// - Important: default value "gui.ini" is relative to current working dir!
// Most apps will want to lock this to an absolute path (e.g. same path as
// executables).
GUI_API void LoadIniSettingsFromDisk(
    const char
        *ini_filename); // call after CreateContext() and before the first call
                        // to NewFrame(). NewFrame() automatically calls
                        // LoadIniSettingsFromDisk(io.IniFilename).
GUI_API void LoadIniSettingsFromMemory(
    const char *ini_data,
    size_t ini_size =
        0); // call after CreateContext() and before the first call to
            // NewFrame() to provide .ini data from your own data source.
GUI_API void SaveIniSettingsToDisk(
    const char
        *ini_filename); // this is automatically called (if io.IniFilename is
                        // not empty) a few seconds after any modification that
                        // should be reflected in the .ini file (and also by
                        // DestroyContext).
GUI_API const char *SaveIniSettingsToMemory(
    size_t *out_ini_size =
        NULL); // return a zero-terminated string with the .ini data which you
               // can save by your own mean. call when io.WantSaveIniSettings is
               // set, then save data by your own mean and clear
               // io.WantSaveIniSettings.

// Debug Utilities
// - Your main debugging friend is the ShowMetricsWindow() function, which is
// also accessible from Demo->Tools->Metrics Debugger
GUI_API void DebugTextEncoding(const char *text);
GUI_API void DebugFlashStyleColor(Col idx);
GUI_API bool DebugCheckVersionAndDataLayout(
    const char *version_str, size_t sz_io, size_t sz_style, size_t sz_vec2,
    size_t sz_vec4, size_t sz_drawvert,
    size_t sz_drawidx); // This is called by GUI_CHECKVERSION() macro.

// Memory Allocators
// - Those functions are not reliant on the current context.
// - DLL users: heaps and globals are not shared across DLL boundaries! You will
// need to call SetCurrentContext() + SetAllocatorFunctions()
//   for each static/DLL boundary you are calling from. Read "Context and Memory
//   Allocators" section of gui.cpp for more details.
GUI_API void SetAllocatorFunctions(MemAllocFunc alloc_func,
                                   MemFreeFunc free_func,
                                   void *user_data = NULL);
GUI_API void GetAllocatorFunctions(MemAllocFunc *p_alloc_func,
                                   MemFreeFunc *p_free_func,
                                   void **p_user_data);
GUI_API void *MemAlloc(size_t size);
GUI_API void MemFree(void *ptr);

} // namespace Gui

//-----------------------------------------------------------------------------
// [SECTION] Flags & Enumerations
//-----------------------------------------------------------------------------

// Flags for Gui::Begin()
// (Those are per-window flags. There are shared flags in IO:
// io.ConfigWindowsResizeFromEdges and io.ConfigWindowsMoveFromTitleBarOnly)
enum WindowFlags_ {
  WindowFlags_None = 0,
  WindowFlags_NoTitleBar = 1 << 0, // Disable title-bar
  WindowFlags_NoResize =
      1 << 1, // Disable user resizing with the lower-right grip
  WindowFlags_NoMove = 1 << 2,      // Disable user moving the window
  WindowFlags_NoScrollbar = 1 << 3, // Disable scrollbars (window can still
                                    // scroll with mouse or programmatically)
  WindowFlags_NoScrollWithMouse =
      1 << 4, // Disable user vertically scrolling with mouse wheel. On child
              // window, mouse wheel will be forwarded to the parent unless
              // NoScrollbar is also set.
  WindowFlags_NoCollapse =
      1 << 5, // Disable user collapsing window by double-clicking on it. Also
              // referred to as Window Menu Button (e.g. within a docking node).
  WindowFlags_AlwaysAutoResize =
      1 << 6, // Resize every window to its content every frame
  WindowFlags_NoBackground =
      1 << 7, // Disable drawing background color (WindowBg, etc.) and outside
              // border. Similar as using SetNextWindowBgAlpha(0.0f).
  WindowFlags_NoSavedSettings = 1 << 8, // Never load/save settings in .ini file
  WindowFlags_NoMouseInputs =
      1 << 9, // Disable catching mouse, hovering test with pass through.
  WindowFlags_MenuBar = 1 << 10, // Has a menu-bar
  WindowFlags_HorizontalScrollbar =
      1 << 11, // Allow horizontal scrollbar to appear (off by default). You may
               // use SetNextWindowContentSize(Vec2(width,0.0f)); prior to
               // calling Begin() to specify width. Read code in gui_demo in
               // the "Horizontal Scrolling" section.
  WindowFlags_NoFocusOnAppearing =
      1 << 12, // Disable taking focus when transitioning from hidden to visible
               // state
  WindowFlags_NoBringToFrontOnFocus =
      1 << 13, // Disable bringing window to front when taking focus (e.g.
               // clicking on it or programmatically giving it focus)
  WindowFlags_AlwaysVerticalScrollbar =
      1
      << 14, // Always show vertical scrollbar (even if ContentSize.y < Size.y)
  WindowFlags_AlwaysHorizontalScrollbar =
      1 << 15, // Always show horizontal scrollbar (even if ContentSize.x <
               // Size.x)
  WindowFlags_NoNavInputs =
      1 << 16, // No gamepad/keyboard navigation within the window
  WindowFlags_NoNavFocus =
      1 << 17, // No focusing toward this window with gamepad/keyboard
               // navigation (e.g. skipped by CTRL+TAB)
  WindowFlags_UnsavedDocument =
      1 << 18, // Display a dot next to the title. When used in a tab/docking
               // context, tab is selected when clicking the X + closure is not
               // assumed (will wait for user to stop submitting the tab).
               // Otherwise closure is assumed when pressing the X, so if you
               // keep submitting the tab may reappear at end of tab bar.
  WindowFlags_NoNav = WindowFlags_NoNavInputs | WindowFlags_NoNavFocus,
  WindowFlags_NoDecoration = WindowFlags_NoTitleBar | WindowFlags_NoResize |
                             WindowFlags_NoScrollbar | WindowFlags_NoCollapse,
  WindowFlags_NoInputs = WindowFlags_NoMouseInputs | WindowFlags_NoNavInputs |
                         WindowFlags_NoNavFocus,

  // [Internal]
  WindowFlags_NavFlattened =
      1 << 23, // [BETA] On child window: share focus scope, allow
               // gamepad/keyboard navigation to cross over parent border to
               // this child or between sibling child windows.
  WindowFlags_ChildWindow =
      1 << 24, // Don't use! For internal use by BeginChild()
  WindowFlags_Tooltip =
      1 << 25,                 // Don't use! For internal use by BeginTooltip()
  WindowFlags_Popup = 1 << 26, // Don't use! For internal use by BeginPopup()
  WindowFlags_Modal =
      1 << 27, // Don't use! For internal use by BeginPopupModal()
  WindowFlags_ChildMenu = 1 << 28, // Don't use! For internal use by BeginMenu()

// Obsolete names
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
  WindowFlags_AlwaysUseWindowPadding =
      1 << 30, // Obsoleted in 1.90: Use ChildFlags_AlwaysUseWindowPadding
               // in BeginChild() call.
#endif
};

// Flags for Gui::BeginChild()
// (Legacy: bot 0 must always correspond to ChildFlags_Border to be
// backward compatible with old API using 'bool border = false'. About using
// AutoResizeX/AutoResizeY flags:
// - May be combined with SetNextWindowSizeConstraints() to set a min/max size
// for each axis (see "Demo->Child->Auto-resize with Constraints").
// - Size measurement for a given axis is only performed when the child window
// is within visible boundaries, or is just appearing.
//   - This allows BeginChild() to return false when not within boundaries (e.g.
//   when scrolling), which is more optimal. BUT it won't update its auto-size
//   while clipped.
//     While not perfect, it is a better default behavior as the always-on
//     performance gain is more valuable than the occasional "resizing after
//     becoming visible again" glitch.
//   - You may also use ChildFlags_AlwaysAutoResize to force an update even
//   when child window is not in view.
//     HOWEVER PLEASE UNDERSTAND THAT DOING SO WILL PREVENT BeginChild() FROM
//     EVER RETURNING FALSE, disabling benefits of coarse clipping.
enum ChildFlags_ {
  ChildFlags_None = 0,
  ChildFlags_Border =
      1 << 0, // Show an outer border and enable WindowPadding. (Important: this
              // is always == 1 == true for legacy reason)
  ChildFlags_AlwaysUseWindowPadding =
      1 << 1, // Pad with style.WindowPadding even if no border are drawn (no
              // padding by default for non-bordered child windows because it
              // makes more sense)
  ChildFlags_ResizeX =
      1 << 2, // Allow resize from right border (layout direction). Enable .ini
              // saving (unless WindowFlags_NoSavedSettings passed to
              // window flags)
  ChildFlags_ResizeY =
      1 << 3, // Allow resize from bottom border (layout direction). "
  ChildFlags_AutoResizeX = 1
                           << 4, // Enable auto-resizing width. Read "IMPORTANT:
                                 // Size measurement" details above.
  ChildFlags_AutoResizeY = 1
                           << 5, // Enable auto-resizing height. Read
                                 // "IMPORTANT: Size measurement" details above.
  ChildFlags_AlwaysAutoResize =
      1 << 6, // Combined with AutoResizeX/AutoResizeY. Always measure size even
              // when child is hidden, always return true, always disable
              // clipping optimization! NOT RECOMMENDED.
  ChildFlags_FrameStyle =
      1 << 7, // Style the child window like a framed item: use FrameBg,
              // FrameRounding, FrameBorderSize, FramePadding instead of
              // ChildBg, ChildRounding, ChildBorderSize, WindowPadding.
};

// Flags for Gui::InputText()
// (Those are per-item flags. There are shared flags in IO:
// io.ConfigInputTextCursorBlink and io.ConfigInputTextEnterKeepActive)
enum InputTextFlags_ {
  InputTextFlags_None = 0,
  InputTextFlags_CharsDecimal = 1 << 0,     // Allow 0123456789.+-*/
  InputTextFlags_CharsHexadecimal = 1 << 1, // Allow 0123456789ABCDEFabcdef
  InputTextFlags_CharsUppercase = 1 << 2,   // Turn a..z into A..Z
  InputTextFlags_CharsNoBlank = 1 << 3,     // Filter out spaces, tabs
  InputTextFlags_AutoSelectAll =
      1 << 4, // Select entire text when first taking mouse focus
  InputTextFlags_EnterReturnsTrue =
      1 << 5, // Return 'true' when Enter is pressed (as opposed to every time
              // the value was modified). Consider looking at the
              // IsItemDeactivatedAfterEdit() function.
  InputTextFlags_CallbackCompletion =
      1 << 6, // Callback on pressing TAB (for completion handling)
  InputTextFlags_CallbackHistory =
      1 << 7, // Callback on pressing Up/Down arrows (for history handling)
  InputTextFlags_CallbackAlways =
      1 << 8, // Callback on each iteration. User code may query cursor
              // position, modify text buffer.
  InputTextFlags_CallbackCharFilter =
      1 << 9, // Callback on character inputs to replace or discard them. Modify
              // 'EventChar' to replace or discard, or return 1 in callback to
              // discard.
  InputTextFlags_AllowTabInput =
      1 << 10, // Pressing TAB input a '\t' character into the text field
  InputTextFlags_CtrlEnterForNewLine =
      1 << 11, // In multi-line mode, unfocus with Enter, add new line with
               // Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add
               // line with Enter).
  InputTextFlags_NoHorizontalScroll =
      1 << 12, // Disable following the cursor horizontally
  InputTextFlags_AlwaysOverwrite = 1 << 13, // Overwrite mode
  InputTextFlags_ReadOnly = 1 << 14,        // Read-only mode
  InputTextFlags_Password =
      1 << 15, // Password mode, display all characters as '*'
  InputTextFlags_NoUndoRedo =
      1 << 16, // Disable undo/redo. Note that input text owns the text data
               // while active, if you want to provide your own undo/redo stack
               // you need e.g. to call ClearActiveID().
  InputTextFlags_CharsScientific =
      1 << 17, // Allow 0123456789.+-*/eE (Scientific notation input)
  InputTextFlags_CallbackResize =
      1 << 18, // Callback on buffer capacity changes request (beyond 'buf_size'
               // parameter value), allowing the string to grow. Notify when the
               // string wants to be resized (for string types which hold a
               // cache of their Size). You will be provided a new BufSize in
               // the callback and NEED to honor it. (see
               // misc/cpp/gui_stdlib.hpp for an example of using this)
  InputTextFlags_CallbackEdit =
      1 << 19, // Callback on any edit (note that InputText() already returns
               // true on edit, the callback is useful mainly to manipulate the
               // underlying buffer while focus is active)
  InputTextFlags_EscapeClearsAll =
      1 << 20, // Escape key clears content if not empty, and deactivate
               // otherwise (contrast to default behavior of Escape to revert)

  // Obsolete names
  // InputTextFlags_AlwaysInsertMode  = InputTextFlags_AlwaysOverwrite
  // // [renamed in 1.82] name was not matching behavior
};

// Flags for Gui::TreeNodeEx(), Gui::CollapsingHeader*()
enum TreeNodeFlags_ {
  TreeNodeFlags_None = 0,
  TreeNodeFlags_Selected = 1 << 0, // Draw as selected
  TreeNodeFlags_Framed =
      1 << 1, // Draw frame with background (e.g. for CollapsingHeader)
  TreeNodeFlags_AllowOverlap =
      1 << 2, // Hit testing to allow subsequent widgets to overlap this one
  TreeNodeFlags_NoTreePushOnOpen =
      1 << 3, // Don't do a TreePush() when open (e.g. for CollapsingHeader) =
              // no extra indent nor pushing on ID stack
  TreeNodeFlags_NoAutoOpenOnLog =
      1 << 4, // Don't automatically and temporarily open node when Logging is
              // active (by default logging will automatically open tree nodes)
  TreeNodeFlags_DefaultOpen = 1 << 5,       // Default node to be open
  TreeNodeFlags_OpenOnDoubleClick = 1 << 6, // Need double-click to open node
  TreeNodeFlags_OpenOnArrow =
      1 << 7, // Only open when clicking on the arrow part. If
              // TreeNodeFlags_OpenOnDoubleClick is also set, single-click
              // arrow or double-click all box to open.
  TreeNodeFlags_Leaf =
      1 << 8, // No collapsing, no arrow (use as a convenience for leaf nodes).
  TreeNodeFlags_Bullet =
      1 << 9, // Display a bullet instead of arrow. IMPORTANT: node can still be
              // marked open/close if you don't set the _Leaf flag!
  TreeNodeFlags_FramePadding =
      1 << 10, // Use FramePadding (even for an unframed text node) to
               // vertically align text baseline to regular widget height.
               // Equivalent to calling AlignTextToFramePadding().
  TreeNodeFlags_SpanAvailWidth =
      1 << 11, // Extend hit box to the right-most edge, even if not framed.
               // This is not the default in order to allow adding other items
               // on the same line. In the future we may refactor the hit system
               // to be front-to-back, allowing natural overlaps and then this
               // can become the default.
  TreeNodeFlags_SpanFullWidth =
      1 << 12, // Extend hit box to the left-most and right-most edges (bypass
               // the indented area).
  TreeNodeFlags_SpanAllColumns =
      1 << 13, // Frame will span all columns of its container table (text will
               // still fit in current column)
  TreeNodeFlags_NavLeftJumpsBackHere =
      1 << 14, // (WIP) Nav: left direction may move to this TreeNode() from any
               // of its child (items submitted between TreeNode and TreePop)
  // TreeNodeFlags_NoScrollOnOpen     = 1 << 15,  // FIXME: TODO: Disable
  // automatic scroll on TreePop() if node got just open and contents is not
  // visible
  TreeNodeFlags_CollapsingHeader = TreeNodeFlags_Framed |
                                   TreeNodeFlags_NoTreePushOnOpen |
                                   TreeNodeFlags_NoAutoOpenOnLog,

#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
  TreeNodeFlags_AllowItemOverlap =
      TreeNodeFlags_AllowOverlap, // Renamed in 1.89.7
#endif
};

// Flags for OpenPopup*(), BeginPopupContext*(), IsPopupOpen() functions.
// - To be backward compatible with older API which took an 'int mouse_button =
// 1' argument, we need to treat
//   small flags values as a mouse button index, so we encode the mouse button
//   in the first few bits of the flags. It is therefore guaranteed to be legal
//   to pass a mouse button index in PopupFlags.
// - For the same reason, we exceptionally default the PopupFlags argument
// of BeginPopupContextXXX functions to 1 instead of 0.
//   IMPORTANT: because the default parameter is 1
//   (==PopupFlags_MouseButtonRight), if you rely on the default parameter
//   and want to use another flag, you need to pass in the
//   PopupFlags_MouseButtonRight flag explicitly.
// - Multiple buttons currently cannot be combined/or-ed in those functions (we
// could allow it later).
enum PopupFlags_ {
  PopupFlags_None = 0,
  PopupFlags_MouseButtonLeft =
      0, // For BeginPopupContext*(): open on Left Mouse release. Guaranteed to
         // always be == 0 (same as MouseButton_Left)
  PopupFlags_MouseButtonRight =
      1, // For BeginPopupContext*(): open on Right Mouse release. Guaranteed to
         // always be == 1 (same as MouseButton_Right)
  PopupFlags_MouseButtonMiddle =
      2, // For BeginPopupContext*(): open on Middle Mouse release. Guaranteed
         // to always be == 2 (same as MouseButton_Middle)
  PopupFlags_MouseButtonMask_ = 0x1F,
  PopupFlags_MouseButtonDefault_ = 1,
  PopupFlags_NoOpenOverExistingPopup =
      1 << 5, // For OpenPopup*(), BeginPopupContext*(): don't open if there's
              // already a popup at the same level of the popup stack
  PopupFlags_NoOpenOverItems =
      1 << 6, // For BeginPopupContextWindow(): don't return true when hovering
              // items, only when hovering empty space
  PopupFlags_AnyPopupId = 1 << 7, // For IsPopupOpen(): ignore the ID
                                  // parameter and test for any popup.
  PopupFlags_AnyPopupLevel =
      1 << 8, // For IsPopupOpen(): search/test at any level of the popup stack
              // (default test in the current level)
  PopupFlags_AnyPopup = PopupFlags_AnyPopupId | PopupFlags_AnyPopupLevel,
};

// Flags for Gui::Selectable()
enum SelectableFlags_ {
  SelectableFlags_None = 0,
  SelectableFlags_DontClosePopups =
      1 << 0, // Clicking this doesn't close parent popup window
  SelectableFlags_SpanAllColumns =
      1 << 1, // Frame will span all columns of its container table (text will
              // still fit in current column)
  SelectableFlags_AllowDoubleClick =
      1 << 2, // Generate press events on double clicks too
  SelectableFlags_Disabled =
      1 << 3, // Cannot be selected, display grayed out text
  SelectableFlags_AllowOverlap =
      1
      << 4, // (WIP) Hit testing to allow subsequent widgets to overlap this one

#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
  SelectableFlags_AllowItemOverlap =
      SelectableFlags_AllowOverlap, // Renamed in 1.89.7
#endif
};

// Flags for Gui::BeginCombo()
enum ComboFlags_ {
  ComboFlags_None = 0,
  ComboFlags_PopupAlignLeft =
      1 << 0, // Align the popup toward the left by default
  ComboFlags_HeightSmall =
      1 << 1, // Max ~4 items visible. Tip: If you want your combo popup to be a
              // specific size you can use SetNextWindowSizeConstraints() prior
              // to calling BeginCombo()
  ComboFlags_HeightRegular = 1 << 2, // Max ~8 items visible (default)
  ComboFlags_HeightLarge = 1 << 3,   // Max ~20 items visible
  ComboFlags_HeightLargest = 1 << 4, // As many fitting items as possible
  ComboFlags_NoArrowButton =
      1 << 5, // Display on the preview box without the square arrow button
  ComboFlags_NoPreview = 1 << 6, // Display only a square arrow button
  ComboFlags_WidthFitPreview =
      1 << 7, // Width dynamically calculated from preview contents
  ComboFlags_HeightMask_ = ComboFlags_HeightSmall | ComboFlags_HeightRegular |
                           ComboFlags_HeightLarge | ComboFlags_HeightLargest,
};

// Flags for Gui::BeginTabBar()
enum TabBarFlags_ {
  TabBarFlags_None = 0,
  TabBarFlags_Reorderable =
      1 << 0, // Allow manually dragging tabs to re-order them + New tabs are
              // appended at the end of list
  TabBarFlags_AutoSelectNewTabs =
      1 << 1, // Automatically select new tabs when they appear
  TabBarFlags_TabListPopupButton =
      1 << 2, // Disable buttons to open the tab list popup
  TabBarFlags_NoCloseWithMiddleMouseButton =
      1 << 3, // Disable behavior of closing tabs (that are submitted with
              // p_open != NULL) with middle mouse button. You may handle this
              // behavior manually on user's side with if (IsItemHovered() &&
              // IsMouseClicked(2)) *p_open = false.
  TabBarFlags_NoTabListScrollingButtons =
      1 << 4, // Disable scrolling buttons (apply when fitting policy is
              // TabBarFlags_FittingPolicyScroll)
  TabBarFlags_NoTooltip = 1 << 5, // Disable tooltips when hovering a tab
  TabBarFlags_FittingPolicyResizeDown = 1
                                        << 6, // Resize tabs when they don't fit
  TabBarFlags_FittingPolicyScroll =
      1 << 7, // Add scroll buttons when tabs don't fit
  TabBarFlags_FittingPolicyMask_ =
      TabBarFlags_FittingPolicyResizeDown | TabBarFlags_FittingPolicyScroll,
  TabBarFlags_FittingPolicyDefault_ = TabBarFlags_FittingPolicyResizeDown,
};

// Flags for Gui::BeginTabItem()
enum TabItemFlags_ {
  TabItemFlags_None = 0,
  TabItemFlags_UnsavedDocument = 1 << 0, // Display a dot next to the title +
                                         // set TabItemFlags_NoAssumedClosure.
  TabItemFlags_SetSelected = 1
                             << 1, // Trigger flag to programmatically make the
                                   // tab selected when calling BeginTabItem()
  TabItemFlags_NoCloseWithMiddleMouseButton =
      1 << 2, // Disable behavior of closing tabs (that are submitted with
              // p_open != NULL) with middle mouse button. You may handle this
              // behavior manually on user's side with if (IsItemHovered() &&
              // IsMouseClicked(2)) *p_open = false.
  TabItemFlags_NoPushId =
      1 << 3, // Don't call PushID()/PopID() on BeginTabItem()/EndTabItem()
  TabItemFlags_NoTooltip = 1 << 4, // Disable tooltip for the given tab
  TabItemFlags_NoReorder = 1 << 5, // Disable reordering this tab or having
                                   // another tab cross over this tab
  TabItemFlags_Leading = 1 << 6,  // Enforce the tab position to the left of the
                                  // tab bar (after the tab list popup button)
  TabItemFlags_Trailing = 1 << 7, // Enforce the tab position to the right of
                                  // the tab bar (before the scrolling buttons)
  TabItemFlags_NoAssumedClosure =
      1 << 8, // Tab is selected when trying to close + closure is not
              // immediately assumed (will wait for user to stop submitting the
              // tab). Otherwise closure is assumed when pressing the X, so if
              // you keep submitting the tab may reappear at end of tab bar.
};

// Flags for Gui::IsWindowFocused()
enum FocusedFlags_ {
  FocusedFlags_None = 0,
  FocusedFlags_ChildWindows =
      1 << 0, // Return true if any children of the window is focused
  FocusedFlags_RootWindow =
      1
      << 1, // Test from root window (top most parent of the current hierarchy)
  FocusedFlags_AnyWindow =
      1
      << 2, // Return true if any window is focused. Important: If you are
            // trying to tell how to dispatch your low-level inputs, do NOT use
            // this. Use 'io.WantCaptureMouse' instead! Please read the FAQ!
  FocusedFlags_NoPopupHierarchy =
      1 << 3, // Do not consider popup hierarchy (do not treat popup emitter as
              // parent of popup) (when used with _ChildWindows or _RootWindow)
  // FocusedFlags_DockHierarchy               = 1 << 4,   // Consider
  // docking hierarchy (treat dockspace host as parent of docked window) (when
  // used with _ChildWindows or _RootWindow)
  FocusedFlags_RootAndChildWindows =
      FocusedFlags_RootWindow | FocusedFlags_ChildWindows,
};

// Flags for Gui::IsItemHovered(), Gui::IsWindowHovered()
// Note: if you are trying to check whether your mouse should be dispatched to
// Dear Gui or to your app, you should use 'io.WantCaptureMouse' instead!
// Please read the FAQ! Note: windows with the WindowFlags_NoInputs flag
// are ignored by IsWindowHovered() calls.
enum HoveredFlags_ {
  HoveredFlags_None = 0, // Return true if directly over the item/window, not
                         // obstructed by another window, not obstructed by an
                         // active popup or modal blocking inputs under them.
  HoveredFlags_ChildWindows = 1 << 0, // IsWindowHovered() only: Return true if
                                      // any children of the window is hovered
  HoveredFlags_RootWindow =
      1 << 1, // IsWindowHovered() only: Test from root window (top most parent
              // of the current hierarchy)
  HoveredFlags_AnyWindow =
      1 << 2, // IsWindowHovered() only: Return true if any window is hovered
  HoveredFlags_NoPopupHierarchy =
      1 << 3, // IsWindowHovered() only: Do not consider popup hierarchy (do not
              // treat popup emitter as parent of popup) (when used with
              // _ChildWindows or _RootWindow)
  // HoveredFlags_DockHierarchy               = 1 << 4,   //
  // IsWindowHovered() only: Consider docking hierarchy (treat dockspace host as
  // parent of docked window) (when used with _ChildWindows or _RootWindow)
  HoveredFlags_AllowWhenBlockedByPopup =
      1 << 5, // Return true even if a popup window is normally blocking access
              // to this item/window
  // HoveredFlags_AllowWhenBlockedByModal     = 1 << 6,   // Return true
  // even if a modal popup window is normally blocking access to this
  // item/window. FIXME-TODO: Unavailable yet.
  HoveredFlags_AllowWhenBlockedByActiveItem =
      1 << 7, // Return true even if an active item is blocking access to this
              // item/window. Useful for Drag and Drop patterns.
  HoveredFlags_AllowWhenOverlappedByItem =
      1 << 8, // IsItemHovered() only: Return true even if the item uses
              // AllowOverlap mode and is overlapped by another hoverable item.
  HoveredFlags_AllowWhenOverlappedByWindow =
      1 << 9, // IsItemHovered() only: Return true even if the position is
              // obstructed or overlapped by another window.
  HoveredFlags_AllowWhenDisabled =
      1 << 10, // IsItemHovered() only: Return true even if the item is disabled
  HoveredFlags_NoNavOverride =
      1 << 11, // IsItemHovered() only: Disable using gamepad/keyboard
               // navigation state when active, always query mouse
  HoveredFlags_AllowWhenOverlapped = HoveredFlags_AllowWhenOverlappedByItem |
                                     HoveredFlags_AllowWhenOverlappedByWindow,
  HoveredFlags_RectOnly = HoveredFlags_AllowWhenBlockedByPopup |
                          HoveredFlags_AllowWhenBlockedByActiveItem |
                          HoveredFlags_AllowWhenOverlapped,
  HoveredFlags_RootAndChildWindows =
      HoveredFlags_RootWindow | HoveredFlags_ChildWindows,

  // Tooltips mode
  // - typically used in IsItemHovered() + SetTooltip() sequence.
  // - this is a shortcut to pull flags from 'style.HoverFlagsForTooltipMouse'
  // or 'style.HoverFlagsForTooltipNav' where you can reconfigure desired
  // behavior.
  //   e.g. 'TooltipHoveredFlagsForMouse' defaults to
  //   'HoveredFlags_Stationary | HoveredFlags_DelayShort'.
  // - for frequently actioned or hovered items providing a tooltip, you want
  // may to use HoveredFlags_ForTooltip (stationary + delay) so the tooltip
  // doesn't show too often.
  // - for items which main purpose is to be hovered, or items with low
  // affordance, or in less consistent apps, prefer no delay or shorter delay.
  HoveredFlags_ForTooltip = 1 << 12, // Shortcut for standard flags when using
                                     // IsItemHovered() + SetTooltip() sequence.

  // (Advanced) Mouse Hovering delays.
  // - generally you can use HoveredFlags_ForTooltip to use
  // application-standardized flags.
  // - use those if you need specific overrides.
  HoveredFlags_Stationary =
      1 << 13, // Require mouse to be stationary for style.HoverStationaryDelay
               // (~0.15 sec) _at least one time_. After this, can move on same
               // item/window. Using the stationary test tends to reduces the
               // need for a long delay.
  HoveredFlags_DelayNone =
      1 << 14, // IsItemHovered() only: Return true immediately (default). As
               // this is the default you generally ignore this.
  HoveredFlags_DelayShort =
      1 << 15, // IsItemHovered() only: Return true after style.HoverDelayShort
               // elapsed (~0.15 sec) (shared between items) + requires mouse to
               // be stationary for style.HoverStationaryDelay (once per item).
  HoveredFlags_DelayNormal =
      1 << 16, // IsItemHovered() only: Return true after style.HoverDelayNormal
               // elapsed (~0.40 sec) (shared between items) + requires mouse to
               // be stationary for style.HoverStationaryDelay (once per item).
  HoveredFlags_NoSharedDelay =
      1 << 17, // IsItemHovered() only: Disable shared delay system where moving
               // from one item to the next keeps the previous timer for a short
               // time (standard for tooltips with long delays)
};

// Flags for Gui::BeginDragDropSource(), Gui::AcceptDragDropPayload()
enum DragDropFlags_ {
  DragDropFlags_None = 0,
  // BeginDragDropSource() flags
  DragDropFlags_SourceNoPreviewTooltip =
      1 << 0, // Disable preview tooltip. By default, a successful call to
              // BeginDragDropSource opens a tooltip so you can display a
              // preview or description of the source contents. This flag
              // disables this behavior.
  DragDropFlags_SourceNoDisableHover =
      1 << 1, // By default, when dragging we clear data so that IsItemHovered()
              // will return false, to avoid subsequent user code submitting
              // tooltips. This flag disables this behavior so you can still
              // call IsItemHovered() on the source item.
  DragDropFlags_SourceNoHoldToOpenOthers =
      1 << 2, // Disable the behavior that allows to open tree nodes and
              // collapsing header by holding over them while dragging a source
              // item.
  DragDropFlags_SourceAllowNullID =
      1 << 3, // Allow items such as Text(), Image() that have no unique
              // identifier to be used as drag source, by manufacturing a
              // temporary identifier based on their window-relative position.
              // This is extremely unusual within the dear gui ecosystem and
              // so we made it explicit.
  DragDropFlags_SourceExtern =
      1 << 4, // External source (from outside of dear gui), won't attempt to
              // read current item/window info. Will always return true. Only
              // one Extern source can be active simultaneously.
  DragDropFlags_SourceAutoExpirePayload =
      1
      << 5, // Automatically expire the payload if the source cease to be
            // submitted (otherwise payloads are persisting while being dragged)
  // AcceptDragDropPayload() flags
  DragDropFlags_AcceptBeforeDelivery =
      1 << 10, // AcceptDragDropPayload() will returns true even before the
               // mouse button is released. You can then call IsDelivery() to
               // test if the payload needs to be delivered.
  DragDropFlags_AcceptNoDrawDefaultRect =
      1 << 11, // Do not draw the default highlight rectangle when hovering over
               // target.
  DragDropFlags_AcceptNoPreviewTooltip =
      1 << 12, // Request hiding the BeginDragDropSource tooltip from the
               // BeginDragDropTarget site.
  DragDropFlags_AcceptPeekOnly =
      DragDropFlags_AcceptBeforeDelivery |
      DragDropFlags_AcceptNoDrawDefaultRect, // For peeking ahead and
                                             // inspecting the payload
                                             // before delivery.
};

// Standard Drag and Drop payload types. You can define you own payload types
// using short strings. Types starting with '_' are defined by Dear Gui.
#define GUI_PAYLOAD_TYPE_COLOR_3F                                              \
  "_COL3F" // float[3]: Standard type for colors, without alpha. User code may
           // use this type.
#define GUI_PAYLOAD_TYPE_COLOR_4F                                              \
  "_COL4F" // float[4]: Standard type for colors. User code may use this type.

// A primary data type
enum DataType_ {
  DataType_S8,     // signed char / char (with sensible compilers)
  DataType_U8,     // unsigned char
  DataType_S16,    // short
  DataType_U16,    // unsigned short
  DataType_S32,    // int
  DataType_U32,    // unsigned int
  DataType_S64,    // long long / __int64
  DataType_U64,    // unsigned long long / unsigned __int64
  DataType_Float,  // float
  DataType_Double, // double
  DataType_COUNT
};

// A cardinal direction
enum Dir_ {
  Dir_None = -1,
  Dir_Left = 0,
  Dir_Right = 1,
  Dir_Up = 2,
  Dir_Down = 3,
  Dir_COUNT
};

// A sorting direction
enum SortDirection_ {
  SortDirection_None = 0,
  SortDirection_Ascending = 1, // Ascending = 0->9, A->Z etc.
  SortDirection_Descending = 2 // Descending = 9->0, Z->A etc.
};

// Since 1.90, defining GUI_DISABLE_OBSOLETE_FUNCTIONS automatically defines
// GUI_DISABLE_OBSOLETE_KEYIO as well.
#if defined(GUI_DISABLE_OBSOLETE_FUNCTIONS) &&                                 \
    !defined(GUI_DISABLE_OBSOLETE_KEYIO)
#define GUI_DISABLE_OBSOLETE_KEYIO
#endif

// A key identifier (Key_XXX or Mod_XXX value): can represent
// Keyboard, Mouse and Gamepad values. All our named keys are >= 512. Keys value
// 0 to 511 are left unused as legacy native/opaque key values (< 1.87). Since
// >= 1.89 we increased typing (went from int to enum), some legacy code may
// need a cast to Key. Read details about the 1.87 and 1.89 transition :
// https://github.com/ocornut/imgui/issues/4921 Note that "Keys" related to
// physical keys and are not the same concept as input "Characters", the later
// are submitted via io.AddInputCharacter().
enum Key : int {
  // Keyboard
  Key_None = 0,
  Key_Tab = 512, // == Key_NamedKey_BEGIN
  Key_LeftArrow,
  Key_RightArrow,
  Key_UpArrow,
  Key_DownArrow,
  Key_PageUp,
  Key_PageDown,
  Key_Home,
  Key_End,
  Key_Insert,
  Key_Delete,
  Key_Backspace,
  Key_Space,
  Key_Enter,
  Key_Escape,
  Key_LeftCtrl,
  Key_LeftShift,
  Key_LeftAlt,
  Key_LeftSuper,
  Key_RightCtrl,
  Key_RightShift,
  Key_RightAlt,
  Key_RightSuper,
  Key_Menu,
  Key_0,
  Key_1,
  Key_2,
  Key_3,
  Key_4,
  Key_5,
  Key_6,
  Key_7,
  Key_8,
  Key_9,
  Key_A,
  Key_B,
  Key_C,
  Key_D,
  Key_E,
  Key_F,
  Key_G,
  Key_H,
  Key_I,
  Key_J,
  Key_K,
  Key_L,
  Key_M,
  Key_N,
  Key_O,
  Key_P,
  Key_Q,
  Key_R,
  Key_S,
  Key_T,
  Key_U,
  Key_V,
  Key_W,
  Key_X,
  Key_Y,
  Key_Z,
  Key_F1,
  Key_F2,
  Key_F3,
  Key_F4,
  Key_F5,
  Key_F6,
  Key_F7,
  Key_F8,
  Key_F9,
  Key_F10,
  Key_F11,
  Key_F12,
  Key_F13,
  Key_F14,
  Key_F15,
  Key_F16,
  Key_F17,
  Key_F18,
  Key_F19,
  Key_F20,
  Key_F21,
  Key_F22,
  Key_F23,
  Key_F24,
  Key_Apostrophe,   // '
  Key_Comma,        // ,
  Key_Minus,        // -
  Key_Period,       // .
  Key_Slash,        // /
  Key_Semicolon,    // ;
  Key_Equal,        // =
  Key_LeftBracket,  // [
  Key_Backslash,    // \ (this text inhibit multiline comment caused by
                    // backslash)
  Key_RightBracket, // ]
  Key_GraveAccent,  // `
  Key_CapsLock,
  Key_ScrollLock,
  Key_NumLock,
  Key_PrintScreen,
  Key_Pause,
  Key_Keypad0,
  Key_Keypad1,
  Key_Keypad2,
  Key_Keypad3,
  Key_Keypad4,
  Key_Keypad5,
  Key_Keypad6,
  Key_Keypad7,
  Key_Keypad8,
  Key_Keypad9,
  Key_KeypadDecimal,
  Key_KeypadDivide,
  Key_KeypadMultiply,
  Key_KeypadSubtract,
  Key_KeypadAdd,
  Key_KeypadEnter,
  Key_KeypadEqual,
  Key_AppBack, // Available on some keyboard/mouses. Often referred as
               // "Browser Back"
  Key_AppForward,

  // Gamepad (some of those are analog values, 0.0f to 1.0f) // NAVIGATION
  // ACTION (download controller mapping PNG/PSD at
  // http://dearimgui.com/controls_sheets)
  Key_GamepadStart,       // Menu (Xbox)      + (Switch)   Start/Options (PS)
  Key_GamepadBack,        // View (Xbox)      - (Switch)   Share (PS)
  Key_GamepadFaceLeft,    // X (Xbox)         Y (Switch)   Square (PS) // Tap:
                          // Toggle Menu. Hold: Windowing mode
                          // (Focus/Move/Resize windows)
  Key_GamepadFaceRight,   // B (Xbox)         A (Switch)   Circle (PS) //
                          // Cancel / Close / Exit
  Key_GamepadFaceUp,      // Y (Xbox)         X (Switch)   Triangle (PS)      //
                          // Text Input / On-screen Keyboard
  Key_GamepadFaceDown,    // A (Xbox)         B (Switch)   Cross (PS) //
                          // Activate / Open / Toggle / Tweak
  Key_GamepadDpadLeft,    // D-pad Left // Move / Tweak / Resize Window (in
                          // Windowing mode)
  Key_GamepadDpadRight,   // D-pad Right // Move / Tweak / Resize Window (in
                          // Windowing mode)
  Key_GamepadDpadUp,      // D-pad Up                                         //
                          // Move / Tweak / Resize Window (in Windowing mode)
  Key_GamepadDpadDown,    // D-pad Down // Move / Tweak / Resize Window (in
                          // Windowing mode)
  Key_GamepadL1,          // L Bumper (Xbox)  L (Switch)   L1 (PS)            //
                          // Tweak Slower / Focus Previous (in Windowing mode)
  Key_GamepadR1,          // R Bumper (Xbox)  R (Switch)   R1 (PS)            //
                          // Tweak Faster / Focus Next (in Windowing mode)
  Key_GamepadL2,          // L Trig. (Xbox)   ZL (Switch)  L2 (PS) [Analog]
  Key_GamepadR2,          // R Trig. (Xbox)   ZR (Switch)  R2 (PS) [Analog]
  Key_GamepadL3,          // L Stick (Xbox)   L3 (Switch)  L3 (PS)
  Key_GamepadR3,          // R Stick (Xbox)   R3 (Switch)  R3 (PS)
  Key_GamepadLStickLeft,  // [Analog] // Move Window (in Windowing mode)
  Key_GamepadLStickRight, // [Analog] // Move Window (in Windowing mode)
  Key_GamepadLStickUp,    // [Analog] // Move Window (in Windowing mode)
  Key_GamepadLStickDown,  // [Analog] // Move Window (in Windowing mode)
  Key_GamepadRStickLeft,  // [Analog]
  Key_GamepadRStickRight, // [Analog]
  Key_GamepadRStickUp,    // [Analog]
  Key_GamepadRStickDown,  // [Analog]

  // Aliases: Mouse Buttons (auto-submitted from AddMouseButtonEvent() calls)
  // - This is mirroring the data also written to io.MouseDown[], io.MouseWheel,
  // in a format allowing them to be accessed via standard key API.
  Key_MouseLeft,
  Key_MouseRight,
  Key_MouseMiddle,
  Key_MouseX1,
  Key_MouseX2,
  Key_MouseWheelX,
  Key_MouseWheelY,

  // [Internal] Reserved for mod storage
  Key_ReservedForModCtrl,
  Key_ReservedForModShift,
  Key_ReservedForModAlt,
  Key_ReservedForModSuper,
  Key_COUNT,

  // Keyboard Modifiers (explicitly submitted by backend via AddKeyEvent()
  // calls)
  // - This is mirroring the data also written to io.KeyCtrl, io.KeyShift,
  // io.KeyAlt, io.KeySuper, in a format allowing
  //   them to be accessed via standard key API, allowing calls such as
  //   IsKeyPressed(), IsKeyReleased(), querying duration etc.
  // - Code polling every key (e.g. an interface to detect a key press for input
  // mapping) might want to ignore those
  //   and prefer using the real keys (e.g. Key_LeftCtrl,
  //   Key_RightCtrl instead of Mod_Ctrl).
  // - In theory the value of keyboard modifiers should be roughly equivalent to
  // a logical or of the equivalent left/right keys.
  //   In practice: it's complicated; mods are often provided from different
  //   sources. Keyboard layout, IME, sticky keys and backends tend to interfere
  //   and break that equivalence. The safer decision is to relay that ambiguity
  //   down to the end-user...
  Mod_None = 0,
  Mod_Ctrl = 1 << 12,     // Ctrl
  Mod_Shift = 1 << 13,    // Shift
  Mod_Alt = 1 << 14,      // Option/Menu
  Mod_Super = 1 << 15,    // Cmd/Super/Windows
  Mod_Shortcut = 1 << 11, // Alias for Ctrl (non-macOS) _or_ Super (macOS).
  Mod_Mask_ = 0xF800,     // 5-bits

  // [Internal] Prior to 1.87 we required user to fill io.KeysDown[512] using
  // their own native index + the io.KeyMap[] array. We are ditching this method
  // but keeping a legacy path for user code doing e.g.
  // IsKeyPressed(MY_NATIVE_KEY_CODE) If you need to iterate all keys (for e.g.
  // an input mapper) you may use
  // Key_NamedKey_BEGIN..Key_NamedKey_END.
  Key_NamedKey_BEGIN = 512,
  Key_NamedKey_END = Key_COUNT,
  Key_NamedKey_COUNT = Key_NamedKey_END - Key_NamedKey_BEGIN,
#ifdef GUI_DISABLE_OBSOLETE_KEYIO
  Key_KeysData_SIZE =
      Key_NamedKey_COUNT, // Size of KeysData[]: only hold named keys
  Key_KeysData_OFFSET =
      Key_NamedKey_BEGIN, // Accesses to io.KeysData[] must use (key -
                          // Key_KeysData_OFFSET) index.
#else
  Key_KeysData_SIZE = Key_COUNT, // Size of KeysData[]: hold legacy
                                 // 0..512 keycodes + named keys
  Key_KeysData_OFFSET = 0,       // Accesses to io.KeysData[] must use (key -
                                 // Key_KeysData_OFFSET) index.
#endif

#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
  Key_ModCtrl = Mod_Ctrl,
  Key_ModShift = Mod_Shift,
  Key_ModAlt = Mod_Alt,
  Key_ModSuper = Mod_Super, // Renamed in 1.89
                            // Key_KeyPadEnter = Key_KeypadEnter, //
                            // Renamed in 1.87
#endif
};

#ifndef GUI_DISABLE_OBSOLETE_KEYIO
// OBSOLETED in 1.88 (from July 2022): NavInput and io.NavInputs[].
// Official backends between 1.60 and 1.86: will keep working and feed gamepad
// inputs as long as GUI_DISABLE_OBSOLETE_KEYIO is not set. Custom backends:
// feed gamepad inputs via io.AddKeyEvent() and Key_GamepadXXX enums.
enum NavInput {
  NavInput_Activate,
  NavInput_Cancel,
  NavInput_Input,
  NavInput_Menu,
  NavInput_DpadLeft,
  NavInput_DpadRight,
  NavInput_DpadUp,
  NavInput_DpadDown,
  NavInput_LStickLeft,
  NavInput_LStickRight,
  NavInput_LStickUp,
  NavInput_LStickDown,
  NavInput_FocusPrev,
  NavInput_FocusNext,
  NavInput_TweakSlow,
  NavInput_TweakFast,
  NavInput_COUNT,
};
#endif

// Configuration flags stored in io.ConfigFlags. Set by user/application.
enum ConfigFlags_ {
  ConfigFlags_None = 0,
  ConfigFlags_NavEnableKeyboard =
      1 << 0, // Master keyboard navigation enable flag. Enable full Tabbing +
              // directional arrows + space/enter to activate.
  ConfigFlags_NavEnableGamepad =
      1 << 1, // Master gamepad navigation enable flag. Backend also needs to
              // set BackendFlags_HasGamepad.
  ConfigFlags_NavEnableSetMousePos =
      1 << 2, // Instruct navigation to move the mouse cursor. May be useful on
              // TV/console systems where moving a virtual mouse is awkward.
              // Will update io.MousePos and set io.WantSetMousePos=true. If
              // enabled you MUST honor io.WantSetMousePos requests in your
              // backend, otherwise Gui will react as if the mouse is jumping
              // around back and forth.
  ConfigFlags_NavNoCaptureKeyboard =
      1 << 3, // Instruct navigation to not set the io.WantCaptureKeyboard flag
              // when io.NavActive is set.
  ConfigFlags_NoMouse =
      1 << 4, // Instruct gui to clear mouse position/buttons in NewFrame().
              // This allows ignoring the mouse information set by the backend.
  ConfigFlags_NoMouseCursorChange =
      1 << 5, // Instruct backend to not alter mouse cursor shape and
              // visibility. Use if the backend cursor changes are interfering
              // with yours and you don't want to use SetMouseCursor() to change
              // mouse cursor. You may want to honor requests from gui by
              // reading GetMouseCursor() yourself instead.

  // User storage (to allow your backend/engine to communicate to code that may
  // be shared between multiple projects. Those flags are NOT used by core Dear
  // Gui)
  ConfigFlags_IsSRGB = 1 << 20, // Application is SRGB-aware.
  ConfigFlags_IsTouchScreen =
      1 << 21, // Application is using a touch screen instead of a mouse.
};

// Backend capabilities flags stored in io.BackendFlags. Set by gui_impl_xxx
// or custom backend.
enum BackendFlags_ {
  BackendFlags_None = 0,
  BackendFlags_HasGamepad = 1 << 0, // Backend Platform supports gamepad
                                    // and currently has one connected.
  BackendFlags_HasMouseCursors =
      1 << 1, // Backend Platform supports honoring GetMouseCursor() value to
              // change the OS cursor shape.
  BackendFlags_HasSetMousePos =
      1 << 2, // Backend Platform supports io.WantSetMousePos requests to
              // reposition the OS mouse position (only used if
              // ConfigFlags_NavEnableSetMousePos is set).
  BackendFlags_RendererHasVtxOffset =
      1 << 3, // Backend Renderer supports DrawCmd::VtxOffset. This enables
              // output of large meshes (64K+ vertices) while still using 16-bit
              // indices.
};

// Enumeration for PushStyleColor() / PopStyleColor()
enum Col_ {
  Col_Text,
  Col_TextDisabled,
  Col_WindowBg, // Background of normal windows
  Col_ChildBg,  // Background of child windows
  Col_PopupBg,  // Background of popups, menus, tooltips windows
  Col_Border,
  Col_BorderShadow,
  Col_FrameBg, // Background of checkbox, radio button, plot, slider, text
               // input
  Col_FrameBgHovered,
  Col_FrameBgActive,
  Col_TitleBg,          // Title bar
  Col_TitleBgActive,    // Title bar when focused
  Col_TitleBgCollapsed, // Title bar when collapsed
  Col_MenuBarBg,
  Col_ScrollbarBg,
  Col_ScrollbarGrab,
  Col_ScrollbarGrabHovered,
  Col_ScrollbarGrabActive,
  Col_CheckMark, // Checkbox tick and RadioButton circle
  Col_SliderGrab,
  Col_SliderGrabActive,
  Col_Button,
  Col_ButtonHovered,
  Col_ButtonActive,
  Col_Header, // Header* colors are used for CollapsingHeader, TreeNode,
              // Selectable, MenuItem
  Col_HeaderHovered,
  Col_HeaderActive,
  Col_Separator,
  Col_SeparatorHovered,
  Col_SeparatorActive,
  Col_ResizeGrip, // Resize grip in lower-right and lower-left corners of
                  // windows.
  Col_ResizeGripHovered,
  Col_ResizeGripActive,
  Col_Tab, // TabItem in a TabBar
  Col_TabHovered,
  Col_TabActive,
  Col_TabUnfocused,
  Col_TabUnfocusedActive,
  Col_PlotLines,
  Col_PlotLinesHovered,
  Col_PlotHistogram,
  Col_PlotHistogramHovered,
  Col_TableHeaderBg,     // Table header background
  Col_TableBorderStrong, // Table outer and header borders (prefer using
                         // Alpha=1.0 here)
  Col_TableBorderLight,  // Table inner borders (prefer using Alpha=1.0
                         // here)
  Col_TableRowBg,        // Table row background (even rows)
  Col_TableRowBgAlt,     // Table row background (odd rows)
  Col_TextSelectedBg,
  Col_DragDropTarget,        // Rectangle highlighting a drop target
  Col_NavHighlight,          // Gamepad/keyboard: current highlighted item
  Col_NavWindowingHighlight, // Highlight window when using CTRL+TAB
  Col_NavWindowingDimBg,     // Darken/colorize entire screen behind the
                             // CTRL+TAB window list, when active
  Col_ModalWindowDimBg,      // Darken/colorize entire screen behind a modal
                             // window, when one is active
  Col_COUNT
};

// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the
// Style structure.
// - The enum only refers to fields of Style which makes sense to be
// pushed/popped inside UI code.
//   During initialization or between frames, feel free to just poke into
//   Style directly.
// - Tip: Use your programming IDE navigation facilities on the names in the
// _second column_ below to find the actual members and their description.
//   In Visual Studio IDE: CTRL+comma ("Edit.GoToAll") can follow symbols in
//   comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot. With Visual
//   Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow
//   symbols in comments.
// - When changing this enum, you need to update the associated internal table
// GStyleVarInfo[] accordingly. This is where we link enum values to members
// offset/type.
enum StyleVar_ {
  // Enum name --------------------- // Member in Style structure (see
  // Style for descriptions)
  StyleVar_Alpha,                   // float     Alpha
  StyleVar_DisabledAlpha,           // float     DisabledAlpha
  StyleVar_WindowPadding,           // Vec2    WindowPadding
  StyleVar_WindowRounding,          // float     WindowRounding
  StyleVar_WindowBorderSize,        // float     WindowBorderSize
  StyleVar_WindowMinSize,           // Vec2    WindowMinSize
  StyleVar_WindowTitleAlign,        // Vec2    WindowTitleAlign
  StyleVar_ChildRounding,           // float     ChildRounding
  StyleVar_ChildBorderSize,         // float     ChildBorderSize
  StyleVar_PopupRounding,           // float     PopupRounding
  StyleVar_PopupBorderSize,         // float     PopupBorderSize
  StyleVar_FramePadding,            // Vec2    FramePadding
  StyleVar_FrameRounding,           // float     FrameRounding
  StyleVar_FrameBorderSize,         // float     FrameBorderSize
  StyleVar_ItemSpacing,             // Vec2    ItemSpacing
  StyleVar_ItemInnerSpacing,        // Vec2    ItemInnerSpacing
  StyleVar_IndentSpacing,           // float     IndentSpacing
  StyleVar_CellPadding,             // Vec2    CellPadding
  StyleVar_ScrollbarSize,           // float     ScrollbarSize
  StyleVar_ScrollbarRounding,       // float     ScrollbarRounding
  StyleVar_GrabMinSize,             // float     GrabMinSize
  StyleVar_GrabRounding,            // float     GrabRounding
  StyleVar_TabRounding,             // float     TabRounding
  StyleVar_TabBarBorderSize,        // float     TabBarBorderSize
  StyleVar_ButtonTextAlign,         // Vec2    ButtonTextAlign
  StyleVar_SelectableTextAlign,     // Vec2    SelectableTextAlign
  StyleVar_SeparatorTextBorderSize, // float  SeparatorTextBorderSize
  StyleVar_SeparatorTextAlign,      // Vec2    SeparatorTextAlign
  StyleVar_SeparatorTextPadding,    // Vec2    SeparatorTextPadding
  StyleVar_COUNT
};

// Flags for InvisibleButton() [extended in gui_internal.hpp]
enum ButtonFlags_ {
  ButtonFlags_None = 0,
  ButtonFlags_MouseButtonLeft = 1 << 0,  // React on left mouse button (default)
  ButtonFlags_MouseButtonRight = 1 << 1, // React on right mouse button
  ButtonFlags_MouseButtonMiddle = 1 << 2, // React on center mouse button

  // [Internal]
  ButtonFlags_MouseButtonMask_ = ButtonFlags_MouseButtonLeft |
                                 ButtonFlags_MouseButtonRight |
                                 ButtonFlags_MouseButtonMiddle,
  ButtonFlags_MouseButtonDefault_ = ButtonFlags_MouseButtonLeft,
};

// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() /
// ColorButton()
enum ColorEditFlags_ {
  ColorEditFlags_None = 0,
  ColorEditFlags_NoAlpha =
      1 << 1, //              // ColorEdit, ColorPicker, ColorButton: ignore
              //              Alpha component (will only read 3 components from
              //              the input pointer).
  ColorEditFlags_NoPicker = 1
                            << 2, //              // ColorEdit: disable picker
                                  //              when clicking on color square.
  ColorEditFlags_NoOptions =
      1 << 3, //              // ColorEdit: disable toggling options menu when
              //              right-clicking on inputs/small preview.
  ColorEditFlags_NoSmallPreview =
      1 << 4, //              // ColorEdit, ColorPicker: disable color square
              //              preview next to the inputs. (e.g. to show only the
              //              inputs)
  ColorEditFlags_NoInputs =
      1 << 5, //              // ColorEdit, ColorPicker: disable inputs
              //              sliders/text widgets (e.g. to show only the small
              //              preview color square).
  ColorEditFlags_NoTooltip =
      1 << 6, //              // ColorEdit, ColorPicker, ColorButton: disable
              //              tooltip when hovering the preview.
  ColorEditFlags_NoLabel =
      1 << 7, //              // ColorEdit, ColorPicker: disable display of
              //              inline text label (the label is still forwarded to
              //              the tooltip and picker).
  ColorEditFlags_NoSidePreview =
      1 << 8, //              // ColorPicker: disable bigger color preview on
              //              right side of the picker, use small color square
              //              preview instead.
  ColorEditFlags_NoDragDrop =
      1 << 9, //              // ColorEdit: disable drag and drop target.
              //              ColorButton: disable drag and drop source.
  ColorEditFlags_NoBorder =
      1 << 10, //              // ColorButton: disable border (which is enforced
               //              by default)

  // User Options (right-click on widget to change some of them).
  ColorEditFlags_AlphaBar =
      1 << 16, //              // ColorEdit, ColorPicker: show vertical alpha
               //              bar/gradient in picker.
  ColorEditFlags_AlphaPreview =
      1 << 17, //              // ColorEdit, ColorPicker, ColorButton: display
               //              preview as a transparent color over a
               //              checkerboard, instead of opaque.
  ColorEditFlags_AlphaPreviewHalf =
      1
      << 18, //              // ColorEdit, ColorPicker, ColorButton: display
             //              half opaque / half checkerboard, instead of opaque.
  ColorEditFlags_HDR =
      1 << 19, //              // (WIP) ColorEdit: Currently only disable
               //              0.0f..1.0f limits in RGBA edition (note: you
               //              probably want to use ColorEditFlags_Float
               //              flag as well).
  ColorEditFlags_DisplayRGB =
      1 << 20, // [Display]    // ColorEdit: override _display_ type among
               // RGB/HSV/Hex. ColorPicker: select any combination using one or
               // more of RGB/HSV/Hex.
  ColorEditFlags_DisplayHSV = 1 << 21, // [Display]    // "
  ColorEditFlags_DisplayHex = 1 << 22, // [Display]    // "
  ColorEditFlags_Uint8 =
      1 << 23, // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_
               // values formatted as 0..255.
  ColorEditFlags_Float =
      1 << 24, // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_
               // values formatted as 0.0f..1.0f floats instead of 0..255
               // integers. No round-trip of value via integers.
  ColorEditFlags_PickerHueBar = 1 << 25,   // [Picker]     // ColorPicker: bar
                                           // for Hue, rectangle for Sat/Value.
  ColorEditFlags_PickerHueWheel = 1 << 26, // [Picker]     // ColorPicker: wheel
                                           // for Hue, triangle for Sat/Value.
  ColorEditFlags_InputRGB = 1 << 27, // [Input]      // ColorEdit, ColorPicker:
                                     // input and output data in RGB format.
  ColorEditFlags_InputHSV = 1 << 28, // [Input]      // ColorEdit, ColorPicker:
                                     // input and output data in HSV format.

  // Defaults Options. You can set application defaults using
  // SetColorEditOptions(). The intent is that you probably don't want to
  // override them in most of your calls. Let the user choose via the option
  // menu and/or call SetColorEditOptions() once during startup.
  ColorEditFlags_DefaultOptions_ =
      ColorEditFlags_Uint8 | ColorEditFlags_DisplayRGB |
      ColorEditFlags_InputRGB | ColorEditFlags_PickerHueBar,

  // [Internal] Masks
  ColorEditFlags_DisplayMask_ = ColorEditFlags_DisplayRGB |
                                ColorEditFlags_DisplayHSV |
                                ColorEditFlags_DisplayHex,
  ColorEditFlags_DataTypeMask_ = ColorEditFlags_Uint8 | ColorEditFlags_Float,
  ColorEditFlags_PickerMask_ =
      ColorEditFlags_PickerHueWheel | ColorEditFlags_PickerHueBar,
  ColorEditFlags_InputMask_ = ColorEditFlags_InputRGB | ColorEditFlags_InputHSV,

  // Obsolete names
  // ColorEditFlags_RGB = ColorEditFlags_DisplayRGB,
  // ColorEditFlags_HSV = ColorEditFlags_DisplayHSV,
  // ColorEditFlags_HEX = ColorEditFlags_DisplayHex  // [renamed
  // in 1.69]
};

// Flags for DragFloat(), DragInt(), SliderFloat(), SliderInt() etc.
// We use the same sets of flags for DragXXX() and SliderXXX() functions as the
// features are the same and it makes it easier to swap them. (Those are
// per-item flags. There are shared flags in IO:
// io.ConfigDragClickToInputText)
enum SliderFlags_ {
  SliderFlags_None = 0,
  SliderFlags_AlwaysClamp =
      1 << 4, // Clamp value to min/max bounds when input manually with
              // CTRL+Click. By default CTRL+Click allows going out of bounds.
  SliderFlags_Logarithmic =
      1 << 5, // Make the widget logarithmic (linear otherwise). Consider using
              // SliderFlags_NoRoundToFormat with this if using a
              // format-string with small amount of digits.
  SliderFlags_NoRoundToFormat =
      1 << 6, // Disable rounding underlying value to match precision of the
              // display format string (e.g. %.3f values are rounded to those 3
              // digits)
  SliderFlags_NoInput = 1 << 7, // Disable CTRL+Click or Enter key allowing
                                // to input text directly into the widget
  SliderFlags_InvalidMask_ =
      0x7000000F, // [Internal] We treat using those bits as being potentially a
                  // 'float power' argument from the previous API that has got
                  // miscast to this enum, and will trigger an assert if needed.

  // Obsolete names
  // SliderFlags_ClampOnInput = SliderFlags_AlwaysClamp, // [renamed
  // in 1.79]
};

// Identify a mouse button.
// Those values are guaranteed to be stable and we frequently use 0/1 directly.
// Named enums provided for convenience.
enum MouseButton_ {
  MouseButton_Left = 0,
  MouseButton_Right = 1,
  MouseButton_Middle = 2,
  MouseButton_COUNT = 5
};

// Enumeration for GetMouseCursor()
// User code may request backend to display given cursor by calling
// SetMouseCursor(), which is why we have some cursors that are marked unused
// here
enum MouseCursor_ {
  MouseCursor_None = -1,
  MouseCursor_Arrow = 0,
  MouseCursor_TextInput,  // When hovering over InputText, etc.
  MouseCursor_ResizeAll,  // (Unused by Dear Gui functions)
  MouseCursor_ResizeNS,   // When hovering over a horizontal border
  MouseCursor_ResizeEW,   // When hovering over a vertical border or a column
  MouseCursor_ResizeNESW, // When hovering over the bottom-left corner of a
                          // window
  MouseCursor_ResizeNWSE, // When hovering over the bottom-right corner of
                          // a window
  MouseCursor_Hand,       // (Unused by Dear Gui functions. Use for e.g.
                          // hyperlinks)
  MouseCursor_NotAllowed, // When hovering something with disallowed
                          // interaction. Usually a crossed circle.
  MouseCursor_COUNT
};

// Enumeration for AddMouseSourceEvent() actual source of Mouse Input data.
// Historically we use "Mouse" terminology everywhere to indicate pointer data,
// e.g. MousePos, IsMousePressed(), io.AddMousePosEvent() But that "Mouse" data
// can come from different source which occasionally may be useful for
// application to know about. You can submit a change of pointer type using
// io.AddMouseSourceEvent().
enum MouseSource : int {
  MouseSource_Mouse = 0,   // Input is coming from an actual mouse.
  MouseSource_TouchScreen, // Input is coming from a touch screen (no
                           // hovering prior to initial press, less precise
                           // initial press aiming, dual-axis wheeling
                           // possible).
  MouseSource_Pen, // Input is coming from a pressure/magnetic pen (often
                   // used in conjunction with high-sampling rates).
  MouseSource_COUNT
};

// Enumeration for Gui::SetNextWindow***(), SetWindow***(), SetNextItem***()
// functions Represent a condition. Important: Treat as a regular enum! Do NOT
// combine multiple values using binary operators! All the functions above treat
// 0 as a shortcut to Cond_Always.
enum Cond_ {
  Cond_None = 0, // No condition (always set the variable), same as _Always
  Cond_Always = 1 << 0, // No condition (always set the variable), same as _None
  Cond_Once = 1 << 1,   // Set the variable once per runtime session (only
                        // the first call will succeed)
  Cond_FirstUseEver = 1 << 2, // Set the variable if the object/window has no
                              // persistently saved data (no entry in .ini file)
  Cond_Appearing = 1 << 3, // Set the variable if the object/window is appearing
                           // after being hidden/inactive (or the first time)
};

//-----------------------------------------------------------------------------
// [SECTION] Tables API flags and structures (TableFlags,
// TableColumnFlags, TableRowFlags, TableBgTarget,
// TableSortSpecs, TableColumnSortSpecs)
//-----------------------------------------------------------------------------

// Flags for Gui::BeginTable()
// - Important! Sizing policies have complex and subtle side effects, much more
// so than you would expect.
//   Read comments/demos carefully + experiment with live demos to get
//   acquainted with them.
// - The DEFAULT sizing policies are:
//    - Default to TableFlags_SizingFixedFit    if ScrollX is on, or if
//    host window has WindowFlags_AlwaysAutoResize.
//    - Default to TableFlags_SizingStretchSame if ScrollX is off.
// - When ScrollX is off:
//    - Table defaults to TableFlags_SizingStretchSame -> all Columns
//    defaults to TableColumnFlags_WidthStretch with same weight.
//    - Columns sizing policy allowed: Stretch (default), Fixed/Auto.
//    - Fixed Columns (if any) will generally obtain their requested width
//    (unless the table cannot fit them all).
//    - Stretch Columns will share the remaining width according to their
//    respective weight.
//    - Mixed Fixed/Stretch columns is possible but has various side-effects on
//    resizing behaviors.
//      The typical use of mixing sizing policies is: any number of LEADING
//      Fixed columns, followed by one or two TRAILING Stretch columns. (this is
//      because the visible order of columns have subtle but necessary effects
//      on how they react to manual resizing).
// - When ScrollX is on:
//    - Table defaults to TableFlags_SizingFixedFit -> all Columns defaults
//    to TableColumnFlags_WidthFixed
//    - Columns sizing policy allowed: Fixed/Auto mostly.
//    - Fixed Columns can be enlarged as needed. Table will show a horizontal
//    scrollbar if needed.
//    - When using auto-resizing (non-resizable) fixed columns, querying the
//    content width to use item right-alignment e.g. SetNextItemWidth(-FLT_MIN)
//    doesn't make sense, would create a feedback loop.
//    - Using Stretch columns OFTEN DOES NOT MAKE SENSE if ScrollX is on, UNLESS
//    you have specified a value for 'inner_width' in BeginTable().
//      If you specify a value for 'inner_width' then effectively the scrolling
//      space is known and Stretch or mixed Fixed/Stretch columns become
//      meaningful again.
// - Read on documentation at the top of gui_tables.hpp for details.
enum TableFlags_ {
  // Features
  TableFlags_None = 0,
  TableFlags_Resizable = 1 << 0, // Enable resizing columns.
  TableFlags_Reorderable =
      1 << 1, // Enable reordering columns in header row (need calling
              // TableSetupColumn() + TableHeadersRow() to display headers)
  TableFlags_Hideable =
      1 << 2, // Enable hiding/disabling columns in context menu.
  TableFlags_Sortable =
      1 << 3, // Enable sorting. Call TableGetSortSpecs() to obtain sort specs.
              // Also see TableFlags_SortMulti and
              // TableFlags_SortTristate.
  TableFlags_NoSavedSettings =
      1 << 4, // Disable persisting columns order, width and sort settings in
              // the .ini file.
  TableFlags_ContextMenuInBody =
      1 << 5, // Right-click on columns body/contents will display table context
              // menu. By default it is available in TableHeadersRow().
              // Decorations
  TableFlags_RowBg = 1 << 6, // Set each RowBg color with Col_TableRowBg or
  // Col_TableRowBgAlt (equivalent of calling TableSetBgColor
  // with TableBgFlags_RowBg0 on each row manually)
  TableFlags_BordersInnerH = 1 << 7, // Draw horizontal borders between rows.
  TableFlags_BordersOuterH =
      1 << 8, // Draw horizontal borders at the top and bottom.
  TableFlags_BordersInnerV = 1 << 9, // Draw vertical borders between columns.
  TableFlags_BordersOuterV =
      1 << 10, // Draw vertical borders on the left and right sides.
  TableFlags_BordersH = TableFlags_BordersInnerH |
                        TableFlags_BordersOuterH, // Draw horizontal borders.
  TableFlags_BordersV = TableFlags_BordersInnerV |
                        TableFlags_BordersOuterV, // Draw vertical borders.
  TableFlags_BordersInner = TableFlags_BordersInnerV |
                            TableFlags_BordersInnerH, // Draw inner borders.
  TableFlags_BordersOuter = TableFlags_BordersOuterV |
                            TableFlags_BordersOuterH, // Draw outer borders.
  TableFlags_Borders =
      TableFlags_BordersInner | TableFlags_BordersOuter, // Draw all borders.
  TableFlags_NoBordersInBody =
      1 << 11, // [ALPHA] Disable vertical borders in columns Body (borders will
               // always appear in Headers). -> May move to style
  TableFlags_NoBordersInBodyUntilResize =
      1 << 12, // [ALPHA] Disable vertical borders in columns Body until hovered
               // for resize (borders will always appear in Headers). -> May
               // move to style Sizing Policy (read above for defaults)
  TableFlags_SizingFixedFit =
      1 << 13, // Columns default to _WidthFixed or _WidthAuto (if resizable or
               // not resizable), matching contents width.
  TableFlags_SizingFixedSame =
      2 << 13, // Columns default to _WidthFixed or _WidthAuto (if resizable or
               // not resizable), matching the maximum contents width of all
               // columns. Implicitly enable TableFlags_NoKeepColumnsVisible.
  TableFlags_SizingStretchProp =
      3 << 13, // Columns default to _WidthStretch with default weights
               // proportional to each columns contents widths.
  TableFlags_SizingStretchSame =
      4
      << 13, // Columns default to _WidthStretch with default weights all equal,
             // unless overridden by TableSetupColumn(). Sizing Extra Options
  TableFlags_NoHostExtendX =
      1 << 16, // Make outer width auto-fit to columns, overriding outer_size.x
               // value. Only available when ScrollX/ScrollY are disabled and
               // Stretch columns are not used.
  TableFlags_NoHostExtendY =
      1 << 17, // Make outer height stop exactly at outer_size.y (prevent
               // auto-extending table past the limit). Only available when
               // ScrollX/ScrollY are disabled. Data below the limit will be
               // clipped and not visible.
  TableFlags_NoKeepColumnsVisible =
      1 << 18, // Disable keeping column always minimally visible when ScrollX
               // is off and table gets too small. Not recommended if columns
               // are resizable.
  TableFlags_PreciseWidths =
      1
      << 19, // Disable distributing remainder width to stretched columns (width
             // allocation on a 100-wide table with 3 columns: Without this
             // flag: 33,33,34. With this flag: 33,33,33). With larger number of
             // columns, resizing will appear to be less smooth. Clipping
  TableFlags_NoClip =
      1 << 20, // Disable clipping rectangle for every individual columns
               // (reduce draw command count, items will be able to overflow
               // into other columns). Generally incompatible with
               // TableSetupScrollFreeze(). Padding
  TableFlags_PadOuterX =
      1 << 21, // Default if BordersOuterV is on. Enable outermost padding.
               // Generally desirable if you have headers.
  TableFlags_NoPadOuterX =
      1 << 22, // Default if BordersOuterV is off. Disable outermost padding.
  TableFlags_NoPadInnerX =
      1 << 23, // Disable inner padding between columns (double inner padding if
               // BordersOuterV is on, single inner padding if BordersOuterV is
               // off). Scrolling
  TableFlags_ScrollX =
      1 << 24, // Enable horizontal scrolling. Require 'outer_size' parameter of
               // BeginTable() to specify the container size. Changes default
               // sizing policy. Because this creates a child window, ScrollY is
               // currently generally recommended when using ScrollX.
  TableFlags_ScrollY =
      1 << 25, // Enable vertical scrolling. Require 'outer_size' parameter of
               // BeginTable() to specify the container size. Sorting
  TableFlags_SortMulti =
      1 << 26, // Hold shift when clicking headers to sort on multiple column.
               // TableGetSortSpecs() may return specs where (SpecsCount > 1).
  TableFlags_SortTristate =
      1 << 27, // Allow no sorting, disable default sorting. TableGetSortSpecs()
               // may return specs where (SpecsCount == 0). Miscellaneous
  TableFlags_HighlightHoveredColumn =
      1 << 28, // Highlight column headers when hovered (may evolve into a
               // fuller highlight)

  // [Internal] Combinations and masks
  TableFlags_SizingMask_ =
      TableFlags_SizingFixedFit | TableFlags_SizingFixedSame |
      TableFlags_SizingStretchProp | TableFlags_SizingStretchSame,
};

// Flags for Gui::TableSetupColumn()
enum TableColumnFlags_ {
  // Input configuration flags
  TableColumnFlags_None = 0,
  TableColumnFlags_Disabled =
      1 << 0, // Overriding/master disable flag: hide column, won't show in
              // context menu (unlike calling TableSetColumnEnabled() which
              // manipulates the user accessible state)
  TableColumnFlags_DefaultHide = 1 << 1, // Default as a hidden/disabled column.
  TableColumnFlags_DefaultSort = 1 << 2, // Default as a sorting column.
  TableColumnFlags_WidthStretch =
      1 << 3, // Column will stretch. Preferable with horizontal scrolling
              // disabled (default if table sizing policy is _SizingStretchSame
              // or _SizingStretchProp).
  TableColumnFlags_WidthFixed =
      1 << 4, // Column will not stretch. Preferable with horizontal scrolling
              // enabled (default if table sizing policy is _SizingFixedFit and
              // table is resizable).
  TableColumnFlags_NoResize = 1 << 5, // Disable manual resizing.
  TableColumnFlags_NoReorder =
      1 << 6, // Disable manual reordering this column, this will also prevent
              // other columns from crossing over this column.
  TableColumnFlags_NoHide =
      1 << 7, // Disable ability to hide/disable this column.
  TableColumnFlags_NoClip =
      1 << 8, // Disable clipping for this column (all NoClip columns will
              // render in a same draw command).
  TableColumnFlags_NoSort =
      1 << 9, // Disable ability to sort on this field (even if
              // TableFlags_Sortable is set on the table).
  TableColumnFlags_NoSortAscending =
      1 << 10, // Disable ability to sort in the ascending direction.
  TableColumnFlags_NoSortDescending =
      1 << 11, // Disable ability to sort in the descending direction.
  TableColumnFlags_NoHeaderLabel =
      1 << 12, // TableHeadersRow() will not submit horizontal label for this
               // column. Convenient for some small columns. Name will still
               // appear in context menu or in angled headers.
  TableColumnFlags_NoHeaderWidth =
      1 << 13, // Disable header text width contribution to automatic column
               // width.
  TableColumnFlags_PreferSortAscending =
      1 << 14, // Make the initial sort direction Ascending when first sorting
               // on this column (default).
  TableColumnFlags_PreferSortDescending =
      1 << 15, // Make the initial sort direction Descending when first sorting
               // on this column.
  TableColumnFlags_IndentEnable =
      1 << 16, // Use current Indent value when entering cell (default for
               // column 0).
  TableColumnFlags_IndentDisable =
      1 << 17, // Ignore current Indent value when entering cell (default for
               // columns > 0). Indentation changes _within_ the cell will still
               // be honored.
  TableColumnFlags_AngledHeader =
      1 << 18, // TableHeadersRow() will submit an angled header row for this
               // column. Note this will add an extra row.

  // Output status flags, read-only via TableGetColumnFlags()
  TableColumnFlags_IsEnabled =
      1 << 24, // Status: is enabled == not hidden by user/api (referred to as
               // "Hide" in _DefaultHide and _NoHide) flags.
  TableColumnFlags_IsVisible =
      1 << 25, // Status: is visible == is enabled AND not clipped by scrolling.
  TableColumnFlags_IsSorted =
      1 << 26, // Status: is currently part of the sort specs
  TableColumnFlags_IsHovered = 1 << 27, // Status: is hovered by mouse

  // [Internal] Combinations and masks
  TableColumnFlags_WidthMask_ =
      TableColumnFlags_WidthStretch | TableColumnFlags_WidthFixed,
  TableColumnFlags_IndentMask_ =
      TableColumnFlags_IndentEnable | TableColumnFlags_IndentDisable,
  TableColumnFlags_StatusMask_ =
      TableColumnFlags_IsEnabled | TableColumnFlags_IsVisible |
      TableColumnFlags_IsSorted | TableColumnFlags_IsHovered,
  TableColumnFlags_NoDirectResize_ =
      1 << 30, // [Internal] Disable user resizing this column directly (it may
               // however we resized indirectly from its left edge)
};

// Flags for Gui::TableNextRow()
enum TableRowFlags_ {
  TableRowFlags_None = 0,
  TableRowFlags_Headers =
      1 << 0, // Identify header row (set default background color + width of
              // its contents accounted differently for auto column width)
};

// Enum for Gui::TableSetBgColor()
// Background colors are rendering in 3 layers:
//  - Layer 0: draw with RowBg0 color if set, otherwise draw with ColumnBg0 if
//  set.
//  - Layer 1: draw with RowBg1 color if set, otherwise draw with ColumnBg1 if
//  set.
//  - Layer 2: draw with CellBg color if set.
// The purpose of the two row/columns layers is to let you decide if a
// background color change should override or blend with the existing color.
// When using TableFlags_RowBg on the table, each row has the RowBg0 color
// automatically set for odd/even rows. If you set the color of RowBg0 target,
// your color will override the existing RowBg0 color. If you set the color of
// RowBg1 or ColumnBg1 target, your color will blend over the RowBg0 color.
enum TableBgTarget_ {
  TableBgTarget_None = 0,
  TableBgTarget_RowBg0 =
      1, // Set row background color 0 (generally used for background,
         // automatically set when TableFlags_RowBg is used)
  TableBgTarget_RowBg1 =
      2, // Set row background color 1 (generally used for selection marking)
  TableBgTarget_CellBg = 3, // Set cell background color (top-most color)
};

// Sorting specifications for a table (often handling sort specs for a single
// column, occasionally more) Obtained by calling TableGetSortSpecs(). When
// 'SpecsDirty == true' you can sort your data. It will be true with sorting
// specs have changed since last call, or the first time. Make sure to set
// 'SpecsDirty = false' after sorting, else you may wastefully sort your data
// every frame!
struct TableSortSpecs {
  const TableColumnSortSpecs *Specs; // Pointer to sort spec array.
  int SpecsCount;  // Sort spec count. Most often 1. May be > 1 when
                   // TableFlags_SortMulti is enabled. May be == 0 when
                   // TableFlags_SortTristate is enabled.
  bool SpecsDirty; // Set to true when specs have changed since last time! Use
                   // this to sort again, then clear the flag.

  TableSortSpecs() { memset(this, 0, sizeof(*this)); }
};

// Sorting specification for one column of a table (sizeof == 12 bytes)
struct TableColumnSortSpecs {
  ID ColumnUserID; // User id of the column (if specified by a
                   // TableSetupColumn() call)
  S16 ColumnIndex; // Index of the column
  S16 SortOrder;   // Index within parent TableSortSpecs (always stored in
                   // order starting from 0, tables sorted on a single criteria
                   // will always have a 0 here)
  SortDirection SortDirection : 8; // SortDirection_Ascending or
                                   // SortDirection_Descending

  TableColumnSortSpecs() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Helpers: Memory allocations macros, Vector<>
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// GUI_MALLOC(), GUI_FREE(), GUI_NEW(), GUI_PLACEMENT_NEW(), GUI_DELETE()
// We call C++ constructor on own allocated memory via the placement "new(ptr)
// Type()" syntax. Defining a custom placement new() with a custom parameter
// allows us to bypass including <new> which on some platforms complains when
// user has disabled exceptions.
//-----------------------------------------------------------------------------

struct NewWrapper {};
inline void *operator new(size_t, NewWrapper, void *ptr) { return ptr; }
inline void operator delete(void *, NewWrapper, void *) {
} // This is only required so we can use the symmetrical new()
#define GUI_ALLOC(_SIZE) Gui::MemAlloc(_SIZE)
#define GUI_FREE(_PTR) Gui::MemFree(_PTR)
#define GUI_PLACEMENT_NEW(_PTR) new (NewWrapper(), _PTR)
#define GUI_NEW(_TYPE) new (NewWrapper(), Gui::MemAlloc(sizeof(_TYPE))) _TYPE
template <typename T> void GUI_DELETE(T *p) {
  if (p) {
    p->~T();
    Gui::MemFree(p);
  }
}

//-----------------------------------------------------------------------------
// Vector<>
// Lightweight std::vector<>-like class to avoid dragging dependencies (also,
// some implementations of STL with debug enabled are absurdly slow, we bypass
// it so our code runs fast in debug).
//-----------------------------------------------------------------------------
// - You generally do NOT need to care or use this ever. But we need to make it
// available in gui.hpp because some of our public structures are relying on it.
// - We use std-like naming convention here, which is a little unusual for this
// codebase.
// - Important: clear() frees memory, resize(0) keep the allocated buffer. We
// use resize(0) a lot to intentionally recycle allocated buffers across frames
// and amortize our costs.
// - Important: our implementation does NOT call C++ constructors/destructors,
// we treat everything as raw data! This is intentional but be extra mindful of
// that,
//   Do NOT use this class as a std::vector replacement in your own code! Many
//   of the structures used by dear gui can be safely initialized by a
//   zero-memset.
//-----------------------------------------------------------------------------

GUI_MSVC_RUNTIME_CHECKS_OFF
template <typename T> struct Vector {
  int Size;
  int Capacity;
  T *Data;

  // Provide standard typedefs but we don't use them ourselves.
  typedef T value_type;
  typedef value_type *iterator;
  typedef const value_type *const_iterator;

  // Constructors, destructor
  inline Vector() {
    Size = Capacity = 0;
    Data = NULL;
  }
  inline Vector(const Vector<T> &src) {
    Size = Capacity = 0;
    Data = NULL;
    operator=(src);
  }
  inline Vector<T> &operator=(const Vector<T> &src) {
    clear();
    resize(src.Size);
    if (src.Data)
      memcpy(Data, src.Data, (size_t)Size * sizeof(T));
    return *this;
  }
  inline ~Vector() {
    if (Data)
      GUI_FREE(Data);
  } // Important: does not destruct anything

  inline void clear() {
    if (Data) {
      Size = Capacity = 0;
      GUI_FREE(Data);
      Data = NULL;
    }
  } // Important: does not destruct anything
  inline void clear_delete() {
    for (int n = 0; n < Size; n++)
      GUI_DELETE(Data[n]);
    clear();
  } // Important: never called automatically! always explicit.
  inline void clear_destruct() {
    for (int n = 0; n < Size; n++)
      Data[n].~T();
    clear();
  } // Important: never called automatically! always explicit.

  inline bool empty() const { return Size == 0; }
  inline int size() const { return Size; }
  inline int size_in_bytes() const { return Size * (int)sizeof(T); }
  inline int max_size() const { return 0x7FFFFFFF / (int)sizeof(T); }
  inline int capacity() const { return Capacity; }
  inline T &operator[](int i) {
    GUI_ASSERT(i >= 0 && i < Size);
    return Data[i];
  }
  inline const T &operator[](int i) const {
    GUI_ASSERT(i >= 0 && i < Size);
    return Data[i];
  }

  inline T *begin() { return Data; }
  inline const T *begin() const { return Data; }
  inline T *end() { return Data + Size; }
  inline const T *end() const { return Data + Size; }
  inline T &front() {
    GUI_ASSERT(Size > 0);
    return Data[0];
  }
  inline const T &front() const {
    GUI_ASSERT(Size > 0);
    return Data[0];
  }
  inline T &back() {
    GUI_ASSERT(Size > 0);
    return Data[Size - 1];
  }
  inline const T &back() const {
    GUI_ASSERT(Size > 0);
    return Data[Size - 1];
  }
  inline void swap(Vector<T> &rhs) {
    int rhs_size = rhs.Size;
    rhs.Size = Size;
    Size = rhs_size;
    int rhs_cap = rhs.Capacity;
    rhs.Capacity = Capacity;
    Capacity = rhs_cap;
    T *rhs_data = rhs.Data;
    rhs.Data = Data;
    Data = rhs_data;
  }

  inline int _grow_capacity(int sz) const {
    int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8;
    return new_capacity > sz ? new_capacity : sz;
  }
  inline void resize(int new_size) {
    if (new_size > Capacity)
      reserve(_grow_capacity(new_size));
    Size = new_size;
  }
  inline void resize(int new_size, const T &v) {
    if (new_size > Capacity)
      reserve(_grow_capacity(new_size));
    if (new_size > Size)
      for (int n = Size; n < new_size; n++)
        memcpy(&Data[n], &v, sizeof(v));
    Size = new_size;
  }
  inline void shrink(int new_size) {
    GUI_ASSERT(new_size <= Size);
    Size = new_size;
  } // Resize a vector to a smaller size, guaranteed not to cause a reallocation
  inline void reserve(int new_capacity) {
    if (new_capacity <= Capacity)
      return;
    T *new_data = (T *)GUI_ALLOC((size_t)new_capacity * sizeof(T));
    if (Data) {
      memcpy(new_data, Data, (size_t)Size * sizeof(T));
      GUI_FREE(Data);
    }
    Data = new_data;
    Capacity = new_capacity;
  }
  inline void reserve_discard(int new_capacity) {
    if (new_capacity <= Capacity)
      return;
    if (Data)
      GUI_FREE(Data);
    Data = (T *)GUI_ALLOC((size_t)new_capacity * sizeof(T));
    Capacity = new_capacity;
  }

  // NB: It is illegal to call push_back/push_front/insert with a reference
  // pointing inside the Vector data itself! e.g. v.push_back(v[10]) is
  // forbidden.
  inline void push_back(const T &v) {
    if (Size == Capacity)
      reserve(_grow_capacity(Size + 1));
    memcpy(&Data[Size], &v, sizeof(v));
    Size++;
  }
  inline void pop_back() {
    GUI_ASSERT(Size > 0);
    Size--;
  }
  inline void push_front(const T &v) {
    if (Size == 0)
      push_back(v);
    else
      insert(Data, v);
  }
  inline T *erase(const T *it) {
    GUI_ASSERT(it >= Data && it < Data + Size);
    const ptrdiff_t off = it - Data;
    memmove(Data + off, Data + off + 1,
            ((size_t)Size - (size_t)off - 1) * sizeof(T));
    Size--;
    return Data + off;
  }
  inline T *erase(const T *it, const T *it_last) {
    GUI_ASSERT(it >= Data && it < Data + Size && it_last >= it &&
               it_last <= Data + Size);
    const ptrdiff_t count = it_last - it;
    const ptrdiff_t off = it - Data;
    memmove(Data + off, Data + off + count,
            ((size_t)Size - (size_t)off - (size_t)count) * sizeof(T));
    Size -= (int)count;
    return Data + off;
  }
  inline T *erase_unsorted(const T *it) {
    GUI_ASSERT(it >= Data && it < Data + Size);
    const ptrdiff_t off = it - Data;
    if (it < Data + Size - 1)
      memcpy(Data + off, Data + Size - 1, sizeof(T));
    Size--;
    return Data + off;
  }
  inline T *insert(const T *it, const T &v) {
    GUI_ASSERT(it >= Data && it <= Data + Size);
    const ptrdiff_t off = it - Data;
    if (Size == Capacity)
      reserve(_grow_capacity(Size + 1));
    if (off < (int)Size)
      memmove(Data + off + 1, Data + off,
              ((size_t)Size - (size_t)off) * sizeof(T));
    memcpy(&Data[off], &v, sizeof(v));
    Size++;
    return Data + off;
  }
  inline bool contains(const T &v) const {
    const T *data = Data;
    const T *data_end = Data + Size;
    while (data < data_end)
      if (*data++ == v)
        return true;
    return false;
  }
  inline T *find(const T &v) {
    T *data = Data;
    const T *data_end = Data + Size;
    while (data < data_end)
      if (*data == v)
        break;
      else
        ++data;
    return data;
  }
  inline const T *find(const T &v) const {
    const T *data = Data;
    const T *data_end = Data + Size;
    while (data < data_end)
      if (*data == v)
        break;
      else
        ++data;
    return data;
  }
  inline int find_index(const T &v) const {
    const T *data_end = Data + Size;
    const T *it = find(v);
    if (it == data_end)
      return -1;
    const ptrdiff_t off = it - Data;
    return (int)off;
  }
  inline bool find_erase(const T &v) {
    const T *it = find(v);
    if (it < Data + Size) {
      erase(it);
      return true;
    }
    return false;
  }
  inline bool find_erase_unsorted(const T &v) {
    const T *it = find(v);
    if (it < Data + Size) {
      erase_unsorted(it);
      return true;
    }
    return false;
  }
  inline int index_from_ptr(const T *it) const {
    GUI_ASSERT(it >= Data && it < Data + Size);
    const ptrdiff_t off = it - Data;
    return (int)off;
  }
};
GUI_MSVC_RUNTIME_CHECKS_RESTORE

//-----------------------------------------------------------------------------
// [SECTION] Style
//-----------------------------------------------------------------------------
// You may modify the Gui::GetStyle() main instance during initialization and
// before NewFrame(). During the frame, use
// Gui::PushStyleVar(StyleVar_XXXX)/PopStyleVar() to alter the main style
// values, and Gui::PushStyleColor(Col_XXX)/PopStyleColor() for colors.
//-----------------------------------------------------------------------------

struct Style {
  float Alpha;         // Global alpha applies to everything in Dear Gui.
  float DisabledAlpha; // Additional alpha multiplier applied by
                       // BeginDisabled(). Multiply over current value of Alpha.
  Vec2 WindowPadding;  // Padding within a window.
  float WindowRounding;   // Radius of window corners rounding. Set to 0.0f to
                          // have rectangular windows. Large values tend to lead
                          // to variety of artifacts and are not recommended.
  float WindowBorderSize; // Thickness of border around windows. Generally set
                          // to 0.0f or 1.0f. (Other values are not well tested
                          // and more CPU/GPU costly).
  Vec2 WindowMinSize; // Minimum window size. This is a global setting. If you
                      // want to constrain individual windows, use
                      // SetNextWindowSizeConstraints().
  Vec2 WindowTitleAlign; // Alignment for title bar text. Defaults to
                         // (0.0f,0.5f) for left-aligned,vertically centered.
  Dir WindowMenuButtonPosition; // Side of the collapsing/docking button in
                                // the title bar (None/Left/Right).
                                // Defaults to Dir_Left.
  float ChildRounding;   // Radius of child window corners rounding. Set to 0.0f
                         // to have rectangular windows.
  float ChildBorderSize; // Thickness of border around child windows. Generally
                         // set to 0.0f or 1.0f. (Other values are not well
                         // tested and more CPU/GPU costly).
  float PopupRounding;   // Radius of popup window corners rounding. (Note that
                         // tooltip windows use WindowRounding)
  float PopupBorderSize; // Thickness of border around popup/tooltip windows.
                         // Generally set to 0.0f or 1.0f. (Other values are not
                         // well tested and more CPU/GPU costly).
  Vec2
      FramePadding; // Padding within a framed rectangle (used by most widgets).
  float FrameRounding; // Radius of frame corners rounding. Set to 0.0f to have
                       // rectangular frame (used by most widgets).
  float FrameBorderSize; // Thickness of border around frames. Generally set to
                         // 0.0f or 1.0f. (Other values are not well tested and
                         // more CPU/GPU costly).
  Vec2 ItemSpacing; // Horizontal and vertical spacing between widgets/lines.
  Vec2 ItemInnerSpacing;  // Horizontal and vertical spacing between within
                          // elements of a composed widget (e.g. a slider and
                          // its label).
  Vec2 CellPadding;       // Padding within a table cell. CellPadding.y may be
                          // altered between different rows.
  Vec2 TouchExtraPadding; // Expand reactive bounding box for touch-based
                          // system where touch position is not accurate
                          // enough. Unfortunately we don't sort widgets so
                          // priority on overlap will always be given to the
                          // first widget. So don't grow this too much!
  float IndentSpacing; // Horizontal indentation when e.g. entering a tree node.
                       // Generally == (FontSize + FramePadding.x*2).
  float ColumnsMinSpacing; // Minimum horizontal spacing between two columns.
                           // Preferably > (FramePadding.x + 1).
  float ScrollbarSize;     // Width of the vertical scrollbar, Height of the
                           // horizontal scrollbar.
  float ScrollbarRounding; // Radius of grab corners for scrollbar.
  float GrabMinSize; // Minimum width/height of a grab box for slider/scrollbar.
  float GrabRounding; // Radius of grabs corners rounding. Set to 0.0f to have
                      // rectangular slider grabs.
  float LogSliderDeadzone; // The size in pixels of the dead-zone around zero on
                           // logarithmic sliders that cross zero.
  float TabRounding;   // Radius of upper corners of a tab. Set to 0.0f to have
                       // rectangular tabs.
  float TabBorderSize; // Thickness of border around tabs.
  float
      TabMinWidthForCloseButton; // Minimum width for close button to appear on
                                 // an unselected tab when hovered. Set to 0.0f
                                 // to always show when hovering, set to FLT_MAX
                                 // to never show close button unless selected.
  float TabBarBorderSize; // Thickness of tab-bar separator, which takes on the
                          // tab active color to denote focus.
  float
      TableAngledHeadersAngle; // Angle of angled headers (supported values
                               // range from -50.0f degrees to +50.0f degrees).
  Dir ColorButtonPosition;     // Side of the color button in the ColorEdit4
                               // widget (left/right). Defaults to Dir_Right.
  Vec2 ButtonTextAlign; // Alignment of button text when button is larger than
                        // text. Defaults to (0.5f, 0.5f) (centered).
  Vec2 SelectableTextAlign; // Alignment of selectable text. Defaults to
                            // (0.0f, 0.0f) (top-left aligned). It's generally
                            // important to keep this left-aligned if you want
                            // to lay multiple items on a same line.
  float SeparatorTextBorderSize; // Thickkness of border in SeparatorText()
  Vec2 SeparatorTextAlign;   // Alignment of text within the separator. Defaults
                             // to (0.0f, 0.5f) (left aligned, center).
  Vec2 SeparatorTextPadding; // Horizontal offset of text from each edge of
                             // the separator + spacing on other axis.
                             // Generally small values. .y is recommended to
                             // be == FramePadding.y.
  Vec2 DisplayWindowPadding; // Window position are clamped to be visible within
                             // the display area or monitors by at least this
                             // amount. Only applies to regular windows.
  Vec2 DisplaySafeAreaPadding; // If you cannot see the edges of your screen
                               // (e.g. on a TV) increase the safe area
                               // padding. Apply to popups/tooltips as well
                               // regular windows. NB: Prefer configuring your
                               // TV sets correctly!
  float
      MouseCursorScale; // Scale software rendered mouse cursor (when
                        // io.MouseDrawCursor is enabled). May be removed later.
  bool AntiAliasedLines; // Enable anti-aliased lines/borders. Disable if you
                         // are really tight on CPU/GPU. Latched at the
                         // beginning of the frame (copied to DrawList).
  bool AntiAliasedLinesUseTex; // Enable anti-aliased lines/borders using
                               // textures where possible. Require backend to
                               // render with bilinear filtering (NOT
                               // point/nearest filtering). Latched at the
                               // beginning of the frame (copied to DrawList).
  bool AntiAliasedFill;        // Enable anti-aliased edges around filled shapes
                        // (rounded rectangles, circles, etc.). Disable if you
                        // are really tight on CPU/GPU. Latched at the beginning
                        // of the frame (copied to DrawList).
  float CurveTessellationTol; // Tessellation tolerance when using
                              // PathBezierCurveTo() without a specific number
                              // of segments. Decrease for highly tessellated
                              // curves (higher quality, more polygons),
                              // increase to reduce quality.
  float
      CircleTessellationMaxError; // Maximum error (in pixels) allowed when
                                  // using AddCircle()/AddCircleFilled() or
                                  // drawing rounded corner rectangles with no
                                  // explicit segment count specified. Decrease
                                  // for higher quality but more geometry.
  Vec4 Colors[Col_COUNT];

  // Behaviors
  // (It is possible to modify those fields mid-frame if specific behavior need
  // it, unlike e.g. configuration fields in IO)
  float HoverStationaryDelay; // Delay for
                              // IsItemHovered(HoveredFlags_Stationary).
                              // Time required to consider mouse stationary.
  float HoverDelayShort;  // Delay for IsItemHovered(HoveredFlags_DelayShort).
                          // Usually used along with HoverStationaryDelay.
  float HoverDelayNormal; // Delay for
                          // IsItemHovered(HoveredFlags_DelayNormal). "
  HoveredFlags
      HoverFlagsForTooltipMouse; // Default flags when using
                                 // IsItemHovered(HoveredFlags_ForTooltip)
                                 // or BeginItemTooltip()/SetItemTooltip() while
                                 // using mouse.
  HoveredFlags
      HoverFlagsForTooltipNav; // Default flags when using
                               // IsItemHovered(HoveredFlags_ForTooltip) or
                               // BeginItemTooltip()/SetItemTooltip() while
                               // using keyboard/gamepad.

  GUI_API Style();
  GUI_API void ScaleAllSizes(float scale_factor);
};

//-----------------------------------------------------------------------------
// [SECTION] IO
//-----------------------------------------------------------------------------
// Communicate most settings and inputs/outputs to Dear Gui using this
// structure. Access via Gui::GetIO(). Read 'Programmer guide' section in .cpp
// file for general usage.
//-----------------------------------------------------------------------------

// [Internal] Storage used by IsKeyDown(), IsKeyPressed() etc functions.
// If prior to 1.87 you used io.KeysDownDuration[] (which was marked as
// internal), you should use GetKeyData(key)->DownDuration and *NOT*
// io.KeysData[key]->DownDuration.
struct KeyData {
  bool Down;              // True for if key is down
  float DownDuration;     // Duration the key has been down (<0.0f: not pressed,
                          // 0.0f: just pressed, >0.0f: time held)
  float DownDurationPrev; // Last frame duration the key has been down
  float AnalogValue;      // 0.0f..1.0f for gamepad values
};

struct IO {
  //------------------------------------------------------------------
  // Configuration                            // Default value
  //------------------------------------------------------------------

  ConfigFlags ConfigFlags; // = 0              // See ConfigFlags_
                           // enum. Set by user/application.
                           // Gamepad/keyboard navigation options, etc.
  BackendFlags
      BackendFlags;    // = 0              // See BackendFlags_ enum. Set by
                       // backend (gui_impl_xxx files or custom backend) to
                       // communicate features supported by the backend.
  Vec2 DisplaySize;    // <unset>          // Main display size, in pixels
                       // (generally == GetMainViewport()->Size). May change
                       // every frame.
  float DeltaTime;     // = 1.0f/60.0f     // Time elapsed since last frame, in
                       // seconds. May change every frame.
  float IniSavingRate; // = 5.0f           // Minimum time between saving
                       // positions/sizes to .ini file, in seconds.
  const char
      *IniFilename; // = "gui.ini"    // Path to .ini file (important: default
                    // "gui.ini" is relative to current working dir!). Set
                    // NULL to disable automatic .ini loading/saving or if you
                    // want to manually call LoadIniSettingsXXX() /
                    // SaveIniSettingsXXX() functions.
  const char
      *LogFilename; // = "gui_log.txt"// Path to .log file (default parameter
                    // to Gui::LogToFile when no file is specified).
  void *UserData;   // = NULL           // Store your own data.

  FontAtlas *Fonts;      // <auto>           // Font atlas: load, rasterize and
                         // pack one or more fonts into a single texture.
  float FontGlobalScale; // = 1.0f           // Global scale all fonts
  bool FontAllowUserScaling; // = false          // Allow user scaling text of
                             // individual window with CTRL+Wheel.
  Font *FontDefault; // = NULL           // Font to use on NewFrame(). Use
                     // NULL to uses Fonts->Fonts[0].
  Vec2 DisplayFramebufferScale; // = (1, 1)         // For retina display or
                                // other situations where window coordinates
                                // are different from framebuffer coordinates.
                                // This generally ends up in
                                // DrawData::FramebufferScale.

  // Miscellaneous options
  bool MouseDrawCursor; // = false          // Request Gui to draw a mouse
                        // cursor for you (if you are on a platform without a
                        // mouse cursor). Cannot be easily renamed to
                        // 'io.ConfigXXX' because this is frequently used by
                        // backend implementations.
  bool
      ConfigMacOSXBehaviors; // = defined(__APPLE__) // OS X style: Text editing
                             // cursor movement using Alt instead of Ctrl,
                             // Shortcuts using Cmd/Super instead of Ctrl,
                             // Line/Text Start and End using Cmd+Arrows instead
                             // of Home/End, Double click selects by word
                             // instead of selecting whole text, Multi-selection
                             // in lists uses Cmd/Super instead of Ctrl.
  bool ConfigInputTrickleEventQueue; // = true           // Enable input queue
                                     // trickling: some types of events
                                     // submitted during the same frame (e.g.
                                     // button down + up) will be spread over
                                     // multiple frames, improving interactions
                                     // with low framerates.
  bool ConfigInputTextCursorBlink; // = true           // Enable blinking cursor
                                   // (optional as some users consider it to be
                                   // distracting).
  bool ConfigInputTextEnterKeepActive; // = false          // [BETA] Pressing
                                       // Enter will keep item active and select
                                       // contents (single-line only).
  bool ConfigDragClickToInputText; // = false          // [BETA] Enable turning
                                   // DragXXX widgets into text input with a
                                   // simple mouse click-release (without
                                   // moving). Not desirable on devices without
                                   // a keyboard.
  bool ConfigWindowsResizeFromEdges; // = true           // Enable resizing of
                                     // windows from their edges and from the
                                     // lower-left corner. This requires
                                     // (io.BackendFlags &
                                     // BackendFlags_HasMouseCursors)
                                     // because it needs mouse cursor feedback.
                                     // (This used to be a per-window
                                     // WindowFlags_ResizeFromAnySide flag)
  bool ConfigWindowsMoveFromTitleBarOnly; // = false       // Enable allowing to
                                          // move windows only when clicking on
                                          // their title bar. Does not apply to
                                          // windows without a title bar.
  float
      ConfigMemoryCompactTimer; // = 60.0f          // Timer (in seconds) to
                                // free transient windows/tables memory buffers
                                // when unused. Set to -1.0f to disable.

  // Inputs Behaviors
  // (other variables, ones which are expected to be tweaked within UI code, are
  // exposed in Style)
  float MouseDoubleClickTime; // = 0.30f          // Time for a double-click, in
                              // seconds.
  float
      MouseDoubleClickMaxDist; // = 6.0f           // Distance threshold to stay
                               // in to validate a double-click, in pixels.
  float MouseDragThreshold;    // = 6.0f           // Distance threshold before
                               // considering we are dragging.
  float KeyRepeatDelay; // = 0.275f         // When holding a key/button, time
                        // before it starts repeating, in seconds (for buttons
                        // in Repeat mode, etc.).
  float KeyRepeatRate; // = 0.050f         // When holding a key/button, rate at
                       // which it repeats, in seconds.

  //------------------------------------------------------------------
  // Debug options
  //------------------------------------------------------------------

  // Tools to test correct Begin/End and BeginChild/EndChild behaviors.
  // Presently Begin()/End() and BeginChild()/EndChild() needs to ALWAYS be
  // called in tandem, regardless of return value of BeginXXX() This is
  // inconsistent with other BeginXXX functions and create confusion for many
  // users. We expect to update the API eventually. In the meanwhile we provide
  // tools to facilitate checking user-code behavior.
  bool ConfigDebugBeginReturnValueOnce; // = false          // First-time calls
                                        // to Begin()/BeginChild() will return
                                        // false. NEEDS TO BE SET AT APPLICATION
                                        // BOOT TIME if you don't want to miss
                                        // windows.
  bool ConfigDebugBeginReturnValueLoop; // = false          // Some calls to
                                        // Begin()/BeginChild() will return
                                        // false. Will cycle through window
                                        // depths then repeat. Suggested use:
                                        // add "io.ConfigDebugBeginReturnValue =
                                        // io.KeyShift" in your main loop then
                                        // occasionally press SHIFT. Windows
                                        // should be flickering while running.

  // Option to deactivate io.AddFocusEvent(false) handling. May facilitate
  // interactions with a debugger when focus loss leads to clearing inputs data.
  // Backends may have other side-effects on focus loss, so this will reduce
  // side-effects but not necessary remove all of them. Consider using e.g.
  // Win32's IsDebuggerPresent() as an additional filter (or see
  // OsIsDebuggerPresent() in gui_test_engine/gui_te_utils.cpp for a Unix
  // compatible version).
  bool ConfigDebugIgnoreFocusLoss; // = false          // Ignore
                                   // io.AddFocusEvent(false), consequently not
                                   // calling io.ClearInputKeys() in input
                                   // processing.

  // Options to audit .ini data
  bool ConfigDebugIniSettings; // = false          // Save .ini data with extra
                               // comments (particularly helpful for Docking,
                               // but makes saving slower)

  //------------------------------------------------------------------
  // Platform Functions
  // (the gui_impl_xxxx backend files are setting those up for you)
  //------------------------------------------------------------------

  // Optional: Platform/Renderer backend name (informational only! will be
  // displayed in About Window) + User data for backend/wrappers to store their
  // own stuff.
  const char *BackendPlatformName; // = NULL
  const char *BackendRendererName; // = NULL
  void *BackendPlatformUserData;   // = NULL           // User data for platform
                                   // backend
  void *BackendRendererUserData;   // = NULL           // User data for renderer
                                   // backend
  void *BackendLanguageUserData;   // = NULL           // User data for non C++
                                   // programming language backend

  // Optional: Access OS clipboard
  // (default to use native Win32 clipboard on Windows, otherwise uses a private
  // clipboard. Override to access OS clipboard on other architectures)
  const char *(*GetClipboardTextFn)(void *user_data);
  void (*SetClipboardTextFn)(void *user_data, const char *text);
  void *ClipboardUserData;

  // Optional: Notify OS Input Method Editor of the screen position of your
  // cursor for text input position (e.g. when using Japanese/Chinese IME on
  // Windows) (default to use native imm32 api on Windows)
  void (*SetPlatformImeDataFn)(Viewport *viewport, PlatformImeData *data);

  // Optional: Platform locale
  Wchar PlatformLocaleDecimalPoint; // '.'              // [Experimental]
                                    // Configure decimal point e.g. '.' or ','
                                    // useful for some languages (e.g.
                                    // German), generally pulled from
                                    // *localeconv()->decimal_point

  //------------------------------------------------------------------
  // Input - Call before calling NewFrame()
  //------------------------------------------------------------------

  // Input Functions
  GUI_API void AddKeyEvent(Key key, bool down) {
    if (!AppAcceptingEvents)
      return;
    AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);
  }
  // Queue a new key down/up event. Key should be
  // "translated" (as in, generally Key_A matches the
  // key end-user would use to emit an 'A' character)
  GUI_API void
  AddKeyAnalogEvent(Key key, bool down,
                    float v); // Queue a new key down/up event for analog values
                              // (e.g. Key_Gamepad_ values). Dead-zones
                              // should be handled by the backend.
  GUI_API void AddMousePosEvent(
      float x,
      float y); // Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to
                // signify no mouse (e.g. app not focused and not hovered)
  GUI_API void AddMouseButtonEvent(int button,
                                   bool down); // Queue a mouse button change
  GUI_API void AddMouseWheelEvent(
      float wheel_x,
      float wheel_y); // Queue a mouse wheel update. wheel_y<0: scroll down,
                      // wheel_y>0: scroll up, wheel_x<0: scroll right,
                      // wheel_x>0: scroll left.
  GUI_API void
  AddMouseSourceEvent(MouseSource source); // Queue a mouse source change
                                           // (Mouse/TouchScreen/Pen)
  GUI_API void AddFocusEvent(
      bool focused); // Queue a gain/loss of focus for the application
                     // (generally based on OS/platform focus of your window)
  GUI_API void AddInputCharacter(unsigned int c); // Queue a new character input
  GUI_API void
  AddInputCharacterUTF16(Wchar16 c); // Queue a new character input from a
                                     // UTF-16 character, it can be a surrogate
  GUI_API void AddInputCharactersUTF8(
      const char *str); // Queue a new characters input from a UTF-8 string

  GUI_API void SetKeyEventNativeData(
      Key key, int native_keycode, int native_scancode,
      int native_legacy_index =
          -1); // [Optional] Specify index for legacy <1.87 IsKeyXXX() functions
               // with native indices + specify native keycode, scancode.
  GUI_API void SetAppAcceptingEvents(bool accepting_events) {
    AppAcceptingEvents = accepting_events;
  }
  // Set master flag for accepting key/mouse/text
  // events (default to true). Useful if you have
  // native dialog boxes that are interrupting your
  // application loop/refresh, and you want to
  // disable events being queued while your app is
  // frozen.
  GUI_API void ClearEventsQueue(); // Clear all incoming events.
  GUI_API void ClearInputKeys();   // Clear current keyboard/mouse/gamepad state
                                   // + current frame text input buffer.
                                   // Equivalent to releasing all keys/buttons.
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
  GUI_API void ClearInputCharacters() { InputQueueCharacters.resize(0); }
  // [Obsoleted in 1.89.8] Clear the current frame text
  // input buffer. Now included within ClearInputKeys().
#endif

  //------------------------------------------------------------------
  // Output - Updated by NewFrame() or EndFrame()/Render()
  // (when reading from the io.WantCaptureMouse, io.WantCaptureKeyboard flags to
  // dispatch your inputs, it is
  //  generally easier and more correct to use their state BEFORE calling
  //  NewFrame(). See FAQ for details!)
  //------------------------------------------------------------------

  bool WantCaptureMouse; // Set when Dear Gui will use mouse inputs, in this
                         // case do not dispatch them to your main
                         // game/application (either way, always pass on mouse
                         // inputs to gui). (e.g. unclicked mouse is hovering
                         // over an gui window, widget is active, mouse was
                         // clicked over an gui window, etc.).
  bool WantCaptureKeyboard; // Set when Dear Gui will use keyboard inputs, in
                            // this case do not dispatch them to your main
                            // game/application (either way, always pass
                            // keyboard inputs to gui). (e.g. InputText
                            // active, or an gui window is focused and
                            // navigation is enabled, etc.).
  bool WantTextInput; // Mobile/console: when set, you may display an on-screen
                      // keyboard. This is set by Dear Gui when it wants
                      // textual keyboard input to happen (e.g. when a InputText
                      // widget is active).
  bool WantSetMousePos; // MousePos has been altered, backend should reposition
                        // mouse on next frame. Rarely used! Set only when
                        // ConfigFlags_NavEnableSetMousePos flag is enabled.
  bool WantSaveIniSettings; // When manual .ini load/save is active
                            // (io.IniFilename == NULL), this will be set to
                            // notify your application that you can call
                            // SaveIniSettingsToMemory() and save yourself.
                            // Important: clear io.WantSaveIniSettings yourself
                            // after saving!
  bool NavActive;  // Keyboard/Gamepad navigation is currently allowed (will
                   // handle Key_NavXXX events) = a window is focused and it
                   // doesn't use the WindowFlags_NoNavInputs flag.
  bool NavVisible; // Keyboard/Gamepad navigation is visible and allowed (will
                   // handle Key_NavXXX events).
  float Framerate; // Estimate of application framerate (rolling average over 60
                   // frames, based on io.DeltaTime), in frame per second.
                   // Solely for convenience. Slow applications may not want to
                   // use a moving average or may want to reset underlying
                   // buffers occasionally.
  int MetricsRenderVertices; // Vertices output during last call to Render()
  int MetricsRenderIndices;  // Indices output during last call to Render() =
                             // number of triangles * 3
  int MetricsRenderWindows;  // Number of visible windows
  int MetricsActiveWindows;  // Number of active windows
  Vec2 MouseDelta; // Mouse delta. Note that this is zero if either current or
                   // previous position are invalid (-FLT_MAX,-FLT_MAX), so a
                   // disappearing/reappearing mouse won't have a huge delta.

  // Legacy: before 1.87, we required backend to fill io.KeyMap[] (imgui->native
  // map) during initialization and io.KeysDown[] (native indices) every frame.
  // This is still temporarily supported as a legacy feature. However the new
  // preferred scheme is for backend to call io.AddKeyEvent().
  //   Old (<1.87):  Gui::IsKeyPressed(Gui::GetIO().KeyMap[Key_Space]) -->
  //   New (1.87+) Gui::IsKeyPressed(Key_Space)
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  int KeyMap[Key_COUNT];    // [LEGACY] Input: map of indices into the
                            // KeysDown[512] entries array which represent
                            // your "native" keyboard state. The first 512 are
                            // now unused and should be kept zero. Legacy
                            // backend will write into KeyMap[] using
                            // Key_ indices which are always >512.
  bool KeysDown[Key_COUNT]; // [LEGACY] Input: Keyboard keys that are
                            // pressed (ideally left in the "native" order
                            // your engine has access to keyboard keys, so
                            // you can use your own defines/enums for
                            // keys). This used to be [512] sized. It is
                            // now Key_COUNT to allow legacy
                            // io.KeysDown[GetKeyIndex(...)] to work
                            // without an overflow.
  float NavInputs[NavInput_COUNT]; // [LEGACY] Since 1.88, NavInputs[] was
                                   // removed. Backends from 1.60 to 1.86
                                   // won't build. Feed gamepad inputs via
                                   // io.AddKeyEvent() and
                                   // Key_GamepadXXX enums.
#endif
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
  void *ImeWindowHandle; // = NULL   // [Obsoleted in 1.87] Set
                         // Viewport::PlatformHandleRaw instead. Set this to
                         // your HWND to get automatic IME cursor positioning.
#else
  void *_UnusedPadding;
#endif

  //------------------------------------------------------------------
  // [Internal] Dear Gui will maintain those fields. Forward compatibility not
  // guaranteed!
  //------------------------------------------------------------------

  Context *Ctx; // Parent UI context (needs to be set explicitly by parent).

  // Main Input State
  // (this block used to be written by backend, since 1.87 it is best to NOT
  // write to those directly, call the AddXXX functions above instead) (reading
  // from those variables is fair game, as they are extremely unlikely to be
  // moving anywhere)
  Vec2 MousePos; // Mouse position, in pixels. Set to Vec2(-FLT_MAX, -FLT_MAX)
                 // if mouse is unavailable (on another screen, etc.)
  bool MouseDown[5]; // Mouse buttons: 0=left, 1=right, 2=middle + extras
                     // (MouseButton_COUNT == 5). Dear Gui mostly uses
                     // left and right buttons. Other buttons allow us to track
                     // if the mouse is being used by your application +
                     // available to user as a convenience via IsMouse** API.
  float MouseWheel;  // Mouse wheel Vertical: 1 unit scrolls about 5 lines text.
                     // >0 scrolls Up, <0 scrolls Down. Hold SHIFT to turn
                     // vertical scroll into horizontal scroll.
  float MouseWheelH; // Mouse wheel Horizontal. >0 scrolls Left, <0 scrolls
                     // Right. Most users don't have a mouse with a horizontal
                     // wheel, may not be filled by all backends.
  MouseSource
      MouseSource; // Mouse actual input peripheral (Mouse/TouchScreen/Pen).
  bool KeyCtrl;    // Keyboard modifier down: Control
  bool KeyShift;   // Keyboard modifier down: Shift
  bool KeyAlt;     // Keyboard modifier down: Alt
  bool KeySuper;   // Keyboard modifier down: Cmd/Super/Windows

  // Other state maintained from data above + IO function calls
  KeyChord KeyMods; // Key mods flags (any of
                    // Mod_Ctrl/Mod_Shift/Mod_Alt/Mod_Super
                    // flags, same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but
                    // merged into flags. DOES NOT CONTAINS Mod_Shortcut
                    // which is pretranslated). Read-only, updated by NewFrame()
  KeyData KeysData[Key_KeysData_SIZE];   // Key state for all known keys. Use
                                         // IsKeyXXX() functions to access this.
  bool WantCaptureMouseUnlessPopupClose; // Alternative to WantCaptureMouse:
                                         // (WantCaptureMouse == true &&
                                         // WantCaptureMouseUnlessPopupClose ==
                                         // false) when a click over void is
                                         // expected to close a popup.
  Vec2 MousePosPrev; // Previous mouse position (note that MouseDelta is not
                     // necessary == MousePos-MousePosPrev, in case either
                     // position is invalid)
  Vec2 MouseClickedPos[5];    // Position at time of clicking
  double MouseClickedTime[5]; // Time of last click (used to figure out
                              // double-click)
  bool MouseClicked[5];       // Mouse button went from !Down to Down (same as
                              // MouseClickedCount[x] != 0)
  bool MouseDoubleClicked[5]; // Has mouse button been double-clicked? (same as
                              // MouseClickedCount[x] == 2)
  U16 MouseClickedCount[5];   // == 0 (not clicked), == 1 (same as
                              // MouseClicked[]), == 2 (double-clicked), == 3
                              // (triple-clicked) etc. when going from !Down to
                              // Down
  U16 MouseClickedLastCount[5]; // Count successive number of clicks. Stays
                                // valid after mouse release. Reset after
                                // another click is done.
  bool MouseReleased[5];        // Mouse button went from Down to !Down
  bool MouseDownOwned[5];       // Track if button was clicked inside a dear gui
                          // window or over void blocked by a popup. We don't
                          // request mouse capture from the application if click
                          // started outside Gui bounds.
  bool MouseDownOwnedUnlessPopupClose[5]; // Track if button was clicked inside
                                          // a dear gui window.
  bool MouseWheelRequestAxisSwap; // On a non-Mac system, holding SHIFT requests
                                  // WheelY to perform the equivalent of a
                                  // WheelX event. On a Mac system this is
                                  // already enforced by the system.
  float MouseDownDuration[5]; // Duration the mouse button has been down (0.0f
                              // == just clicked)
  float
      MouseDownDurationPrev[5]; // Previous time the mouse button has been down
  float MouseDragMaxDistanceSqr[5]; // Squared maximum distance of how much
                                    // mouse has traveled from the clicking
                                    // point (used for moving thresholds)
  float PenPressure; // Touch/Pen pressure (0.0f to 1.0f, should be >0.0f only
                     // when MouseDown[0] == true). Helper storage currently
                     // unused by Dear Gui.
  bool AppFocusLost; // Only modify via AddFocusEvent()
  bool AppAcceptingEvents;        // Only modify via SetAppAcceptingEvents()
  S8 BackendUsingLegacyKeyArrays; // -1: unknown, 0: using AddKeyEvent(), 1:
                                  // using legacy io.KeysDown[]
  bool BackendUsingLegacyNavInputArray; // 0: using AddKeyAnalogEvent(), 1:
                                        // writing to legacy io.NavInputs[]
                                        // directly
  Wchar16 InputQueueSurrogate;          // For AddInputCharacterUTF16()
  Vector<Wchar>
      InputQueueCharacters; // Queue of _characters_ input (obtained by platform
                            // backend). Fill using AddInputCharacter() helper.

  GUI_API IO();
};

//-----------------------------------------------------------------------------
// [SECTION] Misc data structures (InputTextCallbackData,
// SizeCallbackData, Payload)
//-----------------------------------------------------------------------------

// Shared state of InputText(), passed as an argument to your callback when a
// InputTextFlags_Callback* flag is used. The callback function should
// return 0 by default. Callbacks (follow a flag name and see comments in
// InputTextFlags_ declarations for more details)
// - InputTextFlags_CallbackEdit:        Callback on buffer edit (note that
// InputText() already returns true on edit, the callback is useful mainly to
// manipulate the underlying buffer while focus is active)
// - InputTextFlags_CallbackAlways:      Callback on each iteration
// - InputTextFlags_CallbackCompletion:  Callback on pressing TAB
// - InputTextFlags_CallbackHistory:     Callback on pressing Up/Down
// arrows
// - InputTextFlags_CallbackCharFilter:  Callback on character inputs to
// replace or discard them. Modify 'EventChar' to replace or discard, or return
// 1 in callback to discard.
// - InputTextFlags_CallbackResize:      Callback on buffer capacity
// changes request (beyond 'buf_size' parameter value), allowing the string to
// grow.
struct InputTextCallbackData {
  Context *Ctx;             // Parent UI context
  InputTextFlags EventFlag; // One InputTextFlags_Callback*    // Read-only
  InputTextFlags Flags;     // What user passed to InputText()      // Read-only
  void *UserData;           // What user passed to InputText()      // Read-only

  // Arguments for the different callback events
  // - To modify the text buffer in a callback, prefer using the InsertChars() /
  // DeleteChars() function. InsertChars() will take care of calling the resize
  // callback if necessary.
  // - If you know your edits are not going to resize the underlying buffer
  // allocation, you may modify the contents of 'Buf[]' directly. You need to
  // update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set
  // 'BufDirty'' to true so InputText can update its internal state.
  Wchar
      EventChar; // Character input                      // Read-write   //
                 // [CharFilter] Replace character with another one, or set to
                 // zero to drop. return 1 is equivalent to setting EventChar=0;
  Key EventKey;  // Key pressed (Up/Down/TAB)            // Read-only    //
                 // [Completion,History]
  char *Buf; // Text buffer                          // Read-write   // [Resize]
             // Can replace pointer / [Completion,History,Always] Only write to
             // pointed data, don't replace the actual pointer!
  int BufTextLen; // Text length (in bytes)               // Read-write   //
                  // [Resize,Completion,History,Always] Exclude zero-terminator
                  // storage. In C land: == strlen(some_text), in C++ land:
                  // string.length()
  int BufSize;    // Buffer size (in bytes) = capacity+1  // Read-only    //
                  // [Resize,Completion,History,Always] Include zero-terminator
  // storage. In C land == ARRAYSIZE(my_char_array), in C++ land:
  // string.capacity()+1
  bool BufDirty; // Set if you modify Buf/BufTextLen!    // Write        //
                 // [Completion,History,Always]
  int CursorPos; //                                      // Read-write   //
                 //                                      [Completion,History,Always]
  int SelectionStart; //                                      // Read-write   //
                      //                                      [Completion,History,Always]
                      //                                      == to SelectionEnd
                      //                                      when no selection)
  int SelectionEnd; //                                      // Read-write   //
                    //                                      [Completion,History,Always]

  // Helper functions for text manipulation.
  // Use those function to benefit from the CallbackResize behaviors. Calling
  // those function reset the selection.
  GUI_API InputTextCallbackData();
  GUI_API void DeleteChars(int pos, int bytes_count);
  GUI_API void InsertChars(int pos, const char *text,
                           const char *text_end = NULL);
  void SelectAll() {
    SelectionStart = 0;
    SelectionEnd = BufTextLen;
  }
  void ClearSelection() { SelectionStart = SelectionEnd = BufTextLen; }
  bool HasSelection() const { return SelectionStart != SelectionEnd; }
};

// Resizing callback data to apply custom constraint. As enabled by
// SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the
// callback! The SetNextWindowSizeConstraints() parameters are enough.
struct SizeCallbackData {
  void *UserData; // Read-only.   What user passed to
                  // SetNextWindowSizeConstraints(). Generally store an integer
                  // or float in here (need reinterpret_cast<>).
  Vec2 Pos;       // Read-only.   Window position, for reference.
  Vec2 CurrentSize; // Read-only.   Current window size.
  Vec2 DesiredSize; // Read-write.  Desired size, based on user's mouse
                    // position. Write to this field to restrain resizing.
};

// Data payload for Drag and Drop operations: AcceptDragDropPayload(),
// GetDragDropPayload()
struct Payload {
  // Members
  void *Data;   // Data (copied and owned by dear gui)
  int DataSize; // Data size

  // [Internal]
  ID SourceId;           // Source item id
  ID SourceParentId;     // Source parent id (if available)
  int DataFrameCount;    // Data timestamp
  char DataType[32 + 1]; // Data type tag (short user-supplied string, 32
                         // characters max)
  bool
      Preview; // Set when AcceptDragDropPayload() was called and mouse has been
               // hovering the target item (nb: handle overlapping drag targets)
  bool Delivery; // Set when AcceptDragDropPayload() was called and mouse button
                 // is released over the target item.

  Payload() { Clear(); }
  void Clear() {
    SourceId = SourceParentId = 0;
    Data = NULL;
    DataSize = 0;
    memset(DataType, 0, sizeof(DataType));
    DataFrameCount = -1;
    Preview = Delivery = false;
  }
  bool IsDataType(const char *type) const {
    return DataFrameCount != -1 && strcmp(type, DataType) == 0;
  }
  bool IsPreview() const { return Preview; }
  bool IsDelivery() const { return Delivery; }
};

//-----------------------------------------------------------------------------
// [SECTION] Helpers (OnceUponAFrame, TextFilter, TextBuffer,
// Storage, ListClipper, Math Operators, Color)
//-----------------------------------------------------------------------------

// Helper: Unicode defines
#define GUI_UNICODE_CODEPOINT_INVALID                                          \
  0xFFFD // Invalid Unicode code point (standard value).
#ifdef GUI_USE_WCHAR32
#define GUI_UNICODE_CODEPOINT_MAX                                              \
  0x10FFFF // Maximum Unicode code point supported by this build.
#else
#define GUI_UNICODE_CODEPOINT_MAX                                              \
  0xFFFF // Maximum Unicode code point supported by this build.
#endif

// Helper: Execute a block of code at maximum once a frame. Convenient if you
// want to quickly create a UI within deep-nested code that runs multiple times
// every frame. Usage: static OnceUponAFrame oaf; if (oaf) Gui::Text("This
// will be called only once per frame");
struct OnceUponAFrame {
  OnceUponAFrame() { RefFrame = -1; }
  mutable int RefFrame;
  operator bool() const {
    int current_frame = Gui::GetFrameCount();
    if (RefFrame == current_frame)
      return false;
    RefFrame = current_frame;
    return true;
  }
};

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
struct TextFilter {
  GUI_API TextFilter(const char *default_filter = "");
  GUI_API bool Draw(const char *label = "Filter (inc,-exc)",
                    float width = 0.0f) {
    if (width != 0.0f)
      Gui::SetNextItemWidth(width);
    bool value_changed =
        Gui::InputText(label, InputBuf, GUI_ARRAYSIZE(InputBuf));
    if (value_changed)
      Build();
    return value_changed;
  }
  // Helper calling InputText+Build
  GUI_API bool PassFilter(const char *text, const char *text_end = NULL) const;
  GUI_API void Build();
  void Clear() {
    InputBuf[0] = 0;
    Build();
  }
  bool IsActive() const { return !Filters.empty(); }

  // [Internal]
  struct TextRange {
    const char *b;
    const char *e;

    TextRange() { b = e = NULL; }
    TextRange(const char *_b, const char *_e) {
      b = _b;
      e = _e;
    }
    bool empty() const { return b == e; }
    GUI_API void split(char separator, Vector<TextRange> *out) const {
      out->resize(0);
      const char *wb = b;
      const char *we = wb;
      while (we < e) {
        if (*we == separator) {
          out->push_back(TextRange(wb, we));
          wb = we + 1;
        }
        we++;
      }
      if (wb != we)
        out->push_back(TextRange(wb, we));
    }
  };
  char InputBuf[256];
  Vector<TextRange> Filters;
  int CountGrep;
};

// Helper: Growable text buffer for logging/accumulating text
// (this could be called 'TextBuilder' / 'StringBuilder')
struct TextBuffer {
  Vector<char> Buf;
  GUI_API static char EmptyString[1];

  TextBuffer() {}
  inline char operator[](int i) const {
    GUI_ASSERT(Buf.Data != NULL);
    return Buf.Data[i];
  }
  const char *begin() const { return Buf.Data ? &Buf.front() : EmptyString; }
  const char *end() const {
    return Buf.Data ? &Buf.back() : EmptyString;
  } // Buf is zero-terminated, so end() will point on the zero-terminator
  int size() const { return Buf.Size ? Buf.Size - 1 : 0; }
  bool empty() const { return Buf.Size <= 1; }
  void clear() { Buf.clear(); }
  void reserve(int capacity) { Buf.reserve(capacity); }
  const char *c_str() const { return Buf.Data ? Buf.Data : EmptyString; }
  GUI_API void append(const char *str, const char *str_end = NULL);
  GUI_API void appendf(const char *fmt, ...) GUI_FMTARGS(2);
  GUI_API void appendfv(const char *fmt, va_list args) GUI_FMTLIST(2);
};

// Helper: Key->Value storage
// Typically you don't have to worry about this since a storage is held within
// each Window. We use it to e.g. store collapse state for a tree (Int 0/1) This
// is optimized for efficient lookup (dichotomy into a contiguous buffer) and
// rare insertion (typically tied to user interactions aka max once a frame) You
// can use it as custom user storage for temporary values. Declare your own
// storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in
// your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing
// structures in your code (probably not efficient, but convenient) Types are
// NOT stored, so it is up to you to make sure your Key don't collide with
// different types.
struct Storage {
  // [Internal]
  struct StoragePair {
    ID key;
    union {
      int val_i;
      float val_f;
      void *val_p;
    };
    StoragePair(ID _key, int _val) {
      key = _key;
      val_i = _val;
    }
    StoragePair(ID _key, float _val) {
      key = _key;
      val_f = _val;
    }
    StoragePair(ID _key, void *_val) {
      key = _key;
      val_p = _val;
    }
  };

  Vector<StoragePair> Data;

  // - Get***() functions find pair, never add/allocate. Pairs are sorted so a
  // query is O(log N)
  // - Set***() functions find pair, insertion on demand if missing.
  // - Sorted insertion is costly, paid once. A typical frame shouldn't need to
  // insert any new pair.
  void Clear() { Data.clear(); }
  GUI_API int GetInt(ID key, int default_val = 0) const;
  GUI_API void SetInt(ID key, int val);
  GUI_API bool GetBool(ID key, bool default_val = false) const {
    return GetInt(key, default_val ? 1 : 0) != 0;
  }

  GUI_API void SetBool(ID key, bool val) { SetInt(key, val ? 1 : 0); }

  GUI_API float GetFloat(ID key, float default_val = 0.0f) const;
  GUI_API void SetFloat(ID key, float val);
  GUI_API void *GetVoidPtr(ID key) const; // default_val is NULL
  GUI_API void SetVoidPtr(ID key, void *val);

  // - Get***Ref() functions finds pair, insert on demand if missing, return
  // pointer. Useful if you intend to do Get+Set.
  // - References are only valid until a new value is added to the storage.
  // Calling a Set***() function or a Get***Ref() function invalidates the
  // pointer.
  // - A typical use case where this is convenient for quick hacking (e.g. add
  // storage during a live Edit&Continue session if you can't modify existing
  // struct)
  //      float* pvar = Gui::GetFloatRef(key); Gui::SliderFloat("var", pvar, 0,
  //      100.0f); some_var += *pvar;
  GUI_API int *GetIntRef(ID key, int default_val = 0);
  GUI_API bool *GetBoolRef(ID key, bool default_val = false) {
    return (bool *)GetIntRef(key, default_val ? 1 : 0);
  }

  GUI_API float *GetFloatRef(ID key, float default_val = 0.0f);
  GUI_API void **GetVoidPtrRef(ID key, void *default_val = NULL);

  // Advanced: for quicker full rebuild of a storage (instead of an incremental
  // one), you may add all your contents and then sort once.
  GUI_API void BuildSortByKey();
  // Obsolete: use on your own storage if you know only integer are being stored
  // (open/close all tree nodes)
  GUI_API void SetAllInt(int v) {
    for (int i = 0; i < Data.Size; i++)
      Data[i].val_i = v;
  }
};

// Helper: Manually clip large list of items.
// If you have lots evenly spaced items and you have random access to the list,
// you can perform coarse clipping based on visibility to only submit items that
// are in view. The clipper calculates the range of visible items and advance
// the cursor to compensate for the non-visible items we have skipped. (Dear
// Gui already clip items based on their bounds but: it needs to first layout
// the item to do so, and generally
//  fetching/submitting your own data incurs additional cost. Coarse clipping
//  using ListClipper allows you to easily scale using lists with tens of
//  thousands of items without a problem)
// Usage:
//   ListClipper clipper;
//   clipper.Begin(1000);         // We have 1000 elements, evenly spaced.
//   while (clipper.Step())
//       for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//           Gui::Text("line number %d", i);
// Generally what happens is:
// - Clipper lets you process the first element (DisplayStart = 0, DisplayEnd =
// 1) regardless of it being visible or not.
// - User code submit that one element.
// - Clipper can measure the height of the first element
// - Clipper calculate the actual range of elements to display based on the
// current clipping rectangle, position the cursor before the first visible
// element.
// - User code submit visible elements.
// - The clipper also handles various subtleties related to keyboard/gamepad
// navigation, wrapping etc.
struct ListClipper {
  Context *Ctx;      // Parent UI context
  int DisplayStart;  // First item to display, updated by each call to Step()
  int DisplayEnd;    // End of items to display (exclusive)
  int ItemsCount;    // [Internal] Number of items
  float ItemsHeight; // [Internal] Height of item after a first step and item
                     // submission can calculate it
  float StartPosY; // [Internal] Cursor position at the time of Begin() or after
                   // table frozen rows are all processed
  void *TempData;  // [Internal] Internal data

  // items_count: Use INT_MAX if you don't know how many items you have (in
  // which case the cursor won't be advanced in the final step) items_height:
  // Use -1.0f to be calculated automatically on first step. Otherwise pass in
  // the distance between your items, typically GetTextLineHeightWithSpacing()
  // or GetFrameHeightWithSpacing().
  GUI_API ListClipper();
  GUI_API ~ListClipper() { End(); }

  GUI_API void Begin(int items_count, float items_height = -1.0f);
  GUI_API void
  End(); // Automatically called on the last call of Step() that returns false.
  GUI_API bool
  Step(); // Call until it returns false. The DisplayStart/DisplayEnd fields
          // will be set and you can process/draw those items.

  // Call IncludeItemByIndex() or IncludeItemsByIndex() *BEFORE* first call to
  // Step() if you need a range of items to not be clipped, regardless of their
  // visibility. (Due to alignment / padding of certain items it is possible
  // that an extra item may be included on either end of the display range).
  inline void IncludeItemByIndex(int item_index) {
    IncludeItemsByIndex(item_index, item_index + 1);
  }
  GUI_API void
  IncludeItemsByIndex(int item_begin,
                      int item_end); // item_end is exclusive e.g. use (42,
                                     // 42+1) to make item 42 never clipped.

#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
  inline void IncludeRangeByIndices(int item_begin, int item_end) {
    IncludeItemsByIndex(item_begin, item_end);
  } // [renamed in 1.89.9]
  inline void ForceDisplayRangeByIndices(int item_begin, int item_end) {
    IncludeItemsByIndex(item_begin, item_end);
  } // [renamed in 1.89.6]
    // inline ListClipper(int items_count, float items_height = -1.0f) {
  // memset(this, 0, sizeof(*this)); ItemsCount = -1; Begin(items_count,
  // items_height); } // [removed in 1.79]
#endif
};

// Helpers: Vec2/Vec4 operators
// - It is important that we are keeping those disabled by default so they don't
// leak in user space.
// - This is in order to allow user enabling implicit cast operators between
// Vec2/Vec4 and their own types (using GUI_VEC2_CLASS_EXTRA in config.hpp)
// - You can use '#define GUI_DEFINE_MATH_OPERATORS' to import our operators,
// provided as a courtesy.
#ifdef GUI_DEFINE_MATH_OPERATORS
#define GUI_DEFINE_MATH_OPERATORS_IMPLEMENTED
GUI_MSVC_RUNTIME_CHECKS_OFF
static inline Vec2 operator*(const Vec2 &lhs, const float rhs) {
  return Vec2(lhs.x * rhs, lhs.y * rhs);
}
static inline Vec2 operator/(const Vec2 &lhs, const float rhs) {
  return Vec2(lhs.x / rhs, lhs.y / rhs);
}
static inline Vec2 operator+(const Vec2 &lhs, const Vec2 &rhs) {
  return Vec2(lhs.x + rhs.x, lhs.y + rhs.y);
}
static inline Vec2 operator-(const Vec2 &lhs, const Vec2 &rhs) {
  return Vec2(lhs.x - rhs.x, lhs.y - rhs.y);
}
static inline Vec2 operator*(const Vec2 &lhs, const Vec2 &rhs) {
  return Vec2(lhs.x * rhs.x, lhs.y * rhs.y);
}
static inline Vec2 operator/(const Vec2 &lhs, const Vec2 &rhs) {
  return Vec2(lhs.x / rhs.x, lhs.y / rhs.y);
}
static inline Vec2 operator-(const Vec2 &lhs) { return Vec2(-lhs.x, -lhs.y); }
static inline Vec2 &operator*=(Vec2 &lhs, const float rhs) {
  lhs.x *= rhs;
  lhs.y *= rhs;
  return lhs;
}
static inline Vec2 &operator/=(Vec2 &lhs, const float rhs) {
  lhs.x /= rhs;
  lhs.y /= rhs;
  return lhs;
}
static inline Vec2 &operator+=(Vec2 &lhs, const Vec2 &rhs) {
  lhs.x += rhs.x;
  lhs.y += rhs.y;
  return lhs;
}
static inline Vec2 &operator-=(Vec2 &lhs, const Vec2 &rhs) {
  lhs.x -= rhs.x;
  lhs.y -= rhs.y;
  return lhs;
}
static inline Vec2 &operator*=(Vec2 &lhs, const Vec2 &rhs) {
  lhs.x *= rhs.x;
  lhs.y *= rhs.y;
  return lhs;
}
static inline Vec2 &operator/=(Vec2 &lhs, const Vec2 &rhs) {
  lhs.x /= rhs.x;
  lhs.y /= rhs.y;
  return lhs;
}
static inline bool operator==(const Vec2 &lhs, const Vec2 &rhs) {
  return lhs.x == rhs.x && lhs.y == rhs.y;
}
static inline bool operator!=(const Vec2 &lhs, const Vec2 &rhs) {
  return lhs.x != rhs.x || lhs.y != rhs.y;
}
static inline Vec4 operator+(const Vec4 &lhs, const Vec4 &rhs) {
  return Vec4(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z, lhs.w + rhs.w);
}
static inline Vec4 operator-(const Vec4 &lhs, const Vec4 &rhs) {
  return Vec4(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z, lhs.w - rhs.w);
}
static inline Vec4 operator*(const Vec4 &lhs, const Vec4 &rhs) {
  return Vec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w);
}
static inline bool operator==(const Vec4 &lhs, const Vec4 &rhs) {
  return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z && lhs.w == rhs.w;
}
static inline bool operator!=(const Vec4 &lhs, const Vec4 &rhs) {
  return lhs.x != rhs.x || lhs.y != rhs.y || lhs.z != rhs.z || lhs.w != rhs.w;
}
GUI_MSVC_RUNTIME_CHECKS_RESTORE
#endif

// Helpers macros to generate 32-bit encoded colors
// User can declare their own format by #defining the 5 _SHIFT/_MASK macros in
// their imconfig file.
#ifndef GUI_COL32_R_SHIFT
#ifdef GUI_USE_BGRA_PACKED_COLOR
#define GUI_COL32_R_SHIFT 16
#define GUI_COL32_G_SHIFT 8
#define GUI_COL32_B_SHIFT 0
#define GUI_COL32_A_SHIFT 24
#define GUI_COL32_A_MASK 0xFF000000
#else
#define GUI_COL32_R_SHIFT 0
#define GUI_COL32_G_SHIFT 8
#define GUI_COL32_B_SHIFT 16
#define GUI_COL32_A_SHIFT 24
#define GUI_COL32_A_MASK 0xFF000000
#endif
#endif
#define GUI_COL32(R, G, B, A)                                                  \
  (((U32)(A) << GUI_COL32_A_SHIFT) | ((U32)(B) << GUI_COL32_B_SHIFT) |         \
   ((U32)(G) << GUI_COL32_G_SHIFT) | ((U32)(R) << GUI_COL32_R_SHIFT))
#define GUI_COL32_WHITE                                                        \
  GUI_COL32(255, 255, 255, 255)                 // Opaque white = 0xFFFFFFFF
#define GUI_COL32_BLACK GUI_COL32(0, 0, 0, 255) // Opaque black
#define GUI_COL32_BLACK_TRANS                                                  \
  GUI_COL32(0, 0, 0, 0) // Transparent black = 0x00000000

// Helper: Color() implicitly converts colors to eitherU32 (packed 4x1
// byte) or Vec4 (4x1 float) Prefer using GUI_COL32() macros if you want a
// guaranteed compile-timeU32 for usage with DrawList API.
// **Avoid storing Color! Store either u32 of Vec4. This is not a
// full-featured color class. MAY OBSOLETE.
// **None of the Gui API are using Color directly but you can use it as a
// convenience to pass colors in eitherU32 or Vec4 formats. Explicitly cast
// toU32 or Vec4 if needed.
struct Color {
  Vec4 Value;

  constexpr Color() {}
  constexpr Color(float r, float g, float b, float a = 1.0f)
      : Value(r, g, b, a) {}
  constexpr Color(const Vec4 &col) : Value(col) {}
  constexpr Color(int r, int g, int b, int a = 255)
      : Value((float)r * (1.0f / 255.0f), (float)g * (1.0f / 255.0f),
              (float)b * (1.0f / 255.0f), (float)a * (1.0f / 255.0f)) {}
  constexpr Color(U32 rgba)
      : Value((float)((rgba >> GUI_COL32_R_SHIFT) & 0xFF) * (1.0f / 255.0f),
              (float)((rgba >> GUI_COL32_G_SHIFT) & 0xFF) * (1.0f / 255.0f),
              (float)((rgba >> GUI_COL32_B_SHIFT) & 0xFF) * (1.0f / 255.0f),
              (float)((rgba >> GUI_COL32_A_SHIFT) & 0xFF) * (1.0f / 255.0f)) {}
  inline operator U32() const { return Gui::ColorConvertFloat4ToU32(Value); }
  inline operator Vec4() const { return Value; }

  // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
  inline void SetHSV(float h, float s, float v, float a = 1.0f) {
    Gui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z);
    Value.w = a;
  }
  static Color HSV(float h, float s, float v, float a = 1.0f) {
    float r, g, b;
    Gui::ColorConvertHSVtoRGB(h, s, v, r, g, b);
    return Color(r, g, b, a);
  }
};

//-----------------------------------------------------------------------------
// [SECTION] Drawing API (DrawCmd, DrawIdx, DrawVert, DrawChannel,
// DrawListSplitter, DrawListFlags, DrawList, DrawData) Hold a series of
// drawing commands. The user provides a renderer for DrawData which
// essentially contains an array of DrawList.
//-----------------------------------------------------------------------------

// The maximum line width to bake anti-aliased textures for. Build atlas with
// FontAtlasFlags_NoBakedLines to disable baking.
#ifndef GUI_DRAWLIST_TEX_LINES_WIDTH_MAX
#define GUI_DRAWLIST_TEX_LINES_WIDTH_MAX (63)
#endif

// DrawCallback: Draw callbacks for advanced uses [configurable type: override
// in config.hpp] NB: You most likely do NOT need to use draw callbacks just to
// create your own widget or customized UI rendering, you can poke into the draw
// list for that! Draw callback may be useful for example to:
//  A) Change your GPU render state,
//  B) render a complex 3D scene inside a UI element without an intermediate
//  texture/render target, etc.
// The expected behavior from your rendering function is 'if (cmd.UserCallback
// != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'
// If you want to override the signature of DrawCallback, you can simply use
// e.g. '#define DrawCallback DrawCallback' (in config.hpp) + update
// rendering backend accordingly.
#ifndef DrawCallback
typedef void (*DrawCallback)(const DrawList *parent_list, const DrawCmd *cmd);
#endif

// Special Draw callback value to request renderer backend to reset the
// graphics/render state. The renderer backend needs to handle this special
// value, otherwise it will crash trying to call a function at this address.
// This is useful, for example, if you submitted callbacks which you know have
// altered the render state and you want it to be restored. Render state is not
// reset by default because they are many perfectly useful way of altering
// render state (e.g. changing shader/blending settings before an Image call).
#define DrawCallback_ResetRenderState (DrawCallback)(-8)

// Typically, 1 command = 1 GPU draw call (unless command is a callback)
// - VtxOffset: When 'io.BackendFlags & BackendFlags_RendererHasVtxOffset'
// is enabled,
//   this fields allow us to render meshes larger than 64K vertices while
//   keeping 16-bit indices. Backends made for <1.71. will typically ignore the
//   VtxOffset fields.
// - The ClipRect/TextureId/VtxOffset fields must be contiguous as we memcmp()
// them together (this is asserted for).
struct DrawCmd {
  Vec4 ClipRect;       // 4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract
                       // DrawData->DisplayPos to get clipping rectangle in
                       // "viewport" coordinates
  TextureID TextureId; // 4-8  // User-provided texture ID. Set by user in
                       // ImfontAtlas::SetTexID() for fonts or passed to
                       // Image*() functions. Ignore if never using images or
                       // multiple fonts atlas.
  unsigned int VtxOffset; // 4    // Start offset in vertex buffer.
                          // BackendFlags_RendererHasVtxOffset: always 0,
                          // otherwise may be >0 to support meshes larger than
                          // 64K vertices with 16-bit indices.
  unsigned int IdxOffset; // 4    // Start offset in index buffer.
  unsigned int
      ElemCount; // 4    // Number of indices (multiple of 3) to be rendered as
                 // triangles. Vertices are stored in the callee DrawList's
                 // vtx_buffer[] array, indices in idx_buffer[].
  DrawCallback UserCallback; // 4-8  // If != NULL, call the function instead
                             // of rendering the vertices. clip_rect and
                             // texture_id will be set normally.
  void *UserCallbackData;    // 4-8  // The draw callback code can access this.

  DrawCmd() {
    memset(this, 0, sizeof(*this));
  } // Also ensure our padding fields are zeroed

  // Since 1.83: returns TextureID associated with this draw call. Warning: DO
  // NOT assume this is always same as 'TextureId' (we will change this function
  // for an upcoming feature)
  inline TextureID GetTexID() const { return TextureId; }
};

// Vertex layout
#ifndef GUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT
struct DrawVert {
  Vec2 pos;
  Vec2 uv;
  U32 col;
};
#else
// You can override the vertex format layout by defining
// GUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in config.hpp The code expect Vec2
// pos (8 bytes), Vec2 uv (8 bytes),U32 col (4 bytes), but you can re-order
// them or add other fields as needed to simplify integration in your engine.
// The type has to be described within the macro (you can either declare the
// struct or use a typedef). This is because Vec2/U32 are likely not
// declared at the time you'd want to set your type up. NOTE: GUI DOESN'T
// CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL
// BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU
// WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.
GUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;
#endif

// [Internal] For use by DrawList
struct DrawCmdHeader {
  Vec4 ClipRect;
  TextureID TextureId;
  unsigned int VtxOffset;
};

// [Internal] For use by DrawListSplitter
struct DrawChannel {
  Vector<DrawCmd> _CmdBuffer;
  Vector<DrawIdx> _IdxBuffer;
};

// Split/Merge functions are used to split the draw list into different layers
// which can be drawn into out of order. This is used by the Columns/Tables API,
// so items of each column can be batched together in a same draw call.
struct DrawListSplitter {
  int _Current;                  // Current channel number (0)
  int _Count;                    // Number of active channels (1+)
  Vector<DrawChannel> _Channels; // Draw channels (not resized down so
                                 // _Count might be < Channels.Size)

  inline DrawListSplitter() { memset(this, 0, sizeof(*this)); }
  inline ~DrawListSplitter() { ClearFreeMemory(); }
  inline void Clear() {
    _Current = 0;
    _Count = 1;
  } // Do not clear Channels[] so our allocations are reused next frame
  GUI_API void ClearFreeMemory();
  GUI_API void Split(DrawList *draw_list, int count);
  GUI_API void Merge(DrawList *draw_list);
  GUI_API void SetCurrentChannel(DrawList *draw_list, int channel_idx);
};

// Flags for DrawList functions
// (Legacy: bit 0 must always correspond to DrawFlags_Closed to be backward
// compatible with old API using a bool. Bits 1..3 must be unused)
enum DrawFlags_ {
  DrawFlags_None = 0,
  DrawFlags_Closed =
      1 << 0, // PathStroke(), AddPolyline(): specify that shape should be
              // closed (Important: this is always == 1 for legacy reason)
  DrawFlags_RoundCornersTopLeft =
      1 << 4, // AddRect(), AddRectFilled(), PathRect(): enable rounding
              // top-left corner only (when rounding > 0.0f, we default to all
              // corners). Was 0x01.
  DrawFlags_RoundCornersTopRight =
      1 << 5, // AddRect(), AddRectFilled(), PathRect(): enable rounding
              // top-right corner only (when rounding > 0.0f, we default to all
              // corners). Was 0x02.
  DrawFlags_RoundCornersBottomLeft =
      1 << 6, // AddRect(), AddRectFilled(), PathRect(): enable rounding
              // bottom-left corner only (when rounding > 0.0f, we default to
              // all corners). Was 0x04.
  DrawFlags_RoundCornersBottomRight =
      1 << 7, // AddRect(), AddRectFilled(), PathRect(): enable rounding
              // bottom-right corner only (when rounding > 0.0f, we default to
              // all corners). Wax 0x08.
  DrawFlags_RoundCornersNone =
      1 << 8, // AddRect(), AddRectFilled(), PathRect(): disable rounding on all
              // corners (when rounding > 0.0f). This is NOT zero, NOT an
              // implicit flag!
  DrawFlags_RoundCornersTop =
      DrawFlags_RoundCornersTopLeft | DrawFlags_RoundCornersTopRight,
  DrawFlags_RoundCornersBottom =
      DrawFlags_RoundCornersBottomLeft | DrawFlags_RoundCornersBottomRight,
  DrawFlags_RoundCornersLeft =
      DrawFlags_RoundCornersBottomLeft | DrawFlags_RoundCornersTopLeft,
  DrawFlags_RoundCornersRight =
      DrawFlags_RoundCornersBottomRight | DrawFlags_RoundCornersTopRight,
  DrawFlags_RoundCornersAll =
      DrawFlags_RoundCornersTopLeft | DrawFlags_RoundCornersTopRight |
      DrawFlags_RoundCornersBottomLeft | DrawFlags_RoundCornersBottomRight,
  DrawFlags_RoundCornersDefault_ =
      DrawFlags_RoundCornersAll, // Default to ALL corners if none of the
                                 // _RoundCornersXX flags are specified.
  DrawFlags_RoundCornersMask_ =
      DrawFlags_RoundCornersAll | DrawFlags_RoundCornersNone,
};

// Flags for DrawList instance. Those are set automatically by Gui:: functions
// from IO settings, and generally not manipulated directly. It is however
// possible to temporarily alter flags between calls to DrawList:: functions.
enum DrawListFlags_ {
  DrawListFlags_None = 0,
  DrawListFlags_AntiAliasedLines =
      1 << 0, // Enable anti-aliased lines/borders (*2 the number of triangles
              // for 1.0f wide line or lines thin enough to be drawn using
              // textures, otherwise *3 the number of triangles)
  DrawListFlags_AntiAliasedLinesUseTex =
      1 << 1, // Enable anti-aliased lines/borders using textures when possible.
              // Require backend to render with bilinear filtering (NOT
              // point/nearest filtering).
  DrawListFlags_AntiAliasedFill =
      1 << 2, // Enable anti-aliased edge around filled shapes (rounded
              // rectangles, circles).
  DrawListFlags_AllowVtxOffset =
      1 << 3, // Can emit 'VtxOffset > 0' to allow large meshes. Set when
              // 'BackendFlags_RendererHasVtxOffset' is enabled.
};

// Draw command list
// This is the low-level list of polygons that Gui:: functions are filling. At
// the end of the frame, all command lists are passed to your
// IO::RenderDrawListFn function for rendering. Each dear gui window
// contains its own DrawList. You can use Gui::GetWindowDrawList() to access
// the current window draw list and draw custom primitives. You can interleave
// normal Gui:: calls and adding primitives to the current draw list. In single
// viewport mode, top-left is == GetMainViewport()->Pos (generally 0,0),
// bottom-right is == GetMainViewport()->Pos+Size (generally io.DisplaySize).
// You are totally free to apply whatever transformation matrix to want to the
// data (depending on the use of the transformation you may want to apply it to
// ClipRect as well!) Important: Primitives are always added to the list and not
// culled (culling is done at higher-level by Gui:: functions), if you use this
// API a lot consider coarse culling your drawn objects.
struct DrawList {
  // This is what you have to render
  Vector<DrawCmd> CmdBuffer;  // Draw commands. Typically 1 command = 1 GPU
                              // draw call, unless the command is a callback.
  Vector<DrawIdx> IdxBuffer;  // Index buffer. Each command consume
                              // DrawCmd::ElemCount of those
  Vector<DrawVert> VtxBuffer; // Vertex buffer.
  DrawListFlags Flags;        // Flags, you may poke into these to adjust
                              // anti-aliasing settings per-primitive.

  // [Internal, used while building lists]
  unsigned int
      _VtxCurrentIdx; // [Internal] generally == VtxBuffer.Size unless we are
                      // past 64K vertices, in which case this gets reset to 0.
  DrawListSharedData *_Data; // Pointer to shared draw data (you can use
                             // Gui::GetDrawListSharedData() to get the one
                             // from current Gui context)
  const char *_OwnerName;    // Pointer to owner window's name for debugging
  DrawVert *_VtxWritePtr; // [Internal] point within VtxBuffer.Data after each
                          // add command (to avoid using the Vector<>
                          // operators too much)
  DrawIdx *_IdxWritePtr;  // [Internal] point within IdxBuffer.Data after each
                          // add command (to avoid using the Vector<>
                          // operators too much)
  Vector<Vec4> _ClipRectStack;       // [Internal]
  Vector<TextureID> _TextureIdStack; // [Internal]
  Vector<Vec2> _Path;                // [Internal] current path building
  DrawCmdHeader _CmdHeader; // [Internal] template of active commands. Fields
                            // should match those of CmdBuffer.back().
  DrawListSplitter
      _Splitter; // [Internal] for channels api (note: prefer using your own
                 // persistent instance of DrawListSplitter!)
  float _FringeScale; // [Internal] anti-alias fringe is scaled by this value,
                      // this helps to keep things sharp while zooming at vertex
                      // buffer content

  // If you want to create DrawList instances, pass them
  // Gui::GetDrawListSharedData() or create and use your own
  // DrawListSharedData (so you can use DrawList without Gui)
  DrawList(DrawListSharedData *shared_data) {
    memset(this, 0, sizeof(*this));
    _Data = shared_data;
  }

  ~DrawList() { _ClearFreeMemory(); }
  GUI_API void PushClipRect(
      const Vec2 &clip_rect_min, const Vec2 &clip_rect_max,
      bool intersect_with_current_clip_rect =
          false); // Render-level scissoring. This is passed down to your render
                  // function but not used for CPU-side coarse clipping. Prefer
                  // using higher-level Gui::PushClipRect() to affect logic
                  // (hit-testing and widget culling)
  GUI_API void PushClipRectFullScreen();
  GUI_API void PopClipRect();
  GUI_API void PushTextureID(TextureID texture_id) {
    _TextureIdStack.push_back(texture_id);
    _CmdHeader.TextureId = texture_id;
    _OnChangedTextureID();
  }

  GUI_API void PopTextureID() {
    _TextureIdStack.pop_back();
    _CmdHeader.TextureId = (_TextureIdStack.Size == 0)
                               ? (TextureID)NULL
                               : _TextureIdStack.Data[_TextureIdStack.Size - 1];
    _OnChangedTextureID();
  }

  inline Vec2 GetClipRectMin() const {
    const Vec4 &cr = _ClipRectStack.back();
    return Vec2(cr.x, cr.y);
  }
  inline Vec2 GetClipRectMax() const {
    const Vec4 &cr = _ClipRectStack.back();
    return Vec2(cr.z, cr.w);
  }

  // Primitives
  // - Filled shapes must always use clockwise winding order. The anti-aliasing
  // fringe depends on it. Counter-clockwise shapes will have "inward"
  // anti-aliasing.
  // - For rectangular primitives, "p_min" and "p_max" represent the upper-left
  // and lower-right corners.
  // - For circle primitives, use "num_segments == 0" to automatically calculate
  // tessellation (preferred).
  //   In older versions (until Dear Gui 1.77) the AddCircle functions
  //   defaulted to num_segments == 12. In future versions we will use textures
  //   to provide cheaper and higher-quality circles. Use AddNgon() and
  //   AddNgonFilled() functions if you need to guarantee a specific number of
  //   sides.
  GUI_API void AddLine(const Vec2 &p1, const Vec2 &p2, U32 col,
                       float thickness = 1.0f);
  GUI_API void
  AddRect(const Vec2 &p_min, const Vec2 &p_max, U32 col, float rounding = 0.0f,
          DrawFlags flags = 0,
          float thickness =
              1.0f); // a: upper-left, b: lower-right (== upper-left + size)
  GUI_API void AddRectFilled(const Vec2 &p_min, const Vec2 &p_max, U32 col,
                             float rounding = 0.0f, DrawFlags flags = 0) {
    if ((col & GUI_COL32_A_MASK) == 0)
      return;
    if (rounding < 0.5f ||
        (flags & DrawFlags_RoundCornersMask_) == DrawFlags_RoundCornersNone) {
      PrimReserve(6, 4);
      PrimRect(p_min, p_max, col);
    } else {
      PathRect(p_min, p_max, rounding, flags);
      PathFillConvex(col);
    }
  }
  // a: upper-left, b: lower-right (== upper-left + size)
  GUI_API void AddRectFilledMultiColor(const Vec2 &p_min, const Vec2 &p_max,
                                       U32 col_upr_left, U32 col_upr_right,
                                       U32 col_bot_right, U32 col_bot_left);
  GUI_API void AddQuad(const Vec2 &p1, const Vec2 &p2, const Vec2 &p3,
                       const Vec2 &p4, U32 col, float thickness = 1.0f) {
    if ((col & GUI_COL32_A_MASK) == 0)
      return;

    PathLineTo(p1);
    PathLineTo(p2);
    PathLineTo(p3);
    PathLineTo(p4);
    PathStroke(col, DrawFlags_Closed, thickness);
  }

  GUI_API void AddQuadFilled(const Vec2 &p1, const Vec2 &p2, const Vec2 &p3,
                             const Vec2 &p4, U32 col) {
    if ((col & GUI_COL32_A_MASK) == 0)
      return;

    PathLineTo(p1);
    PathLineTo(p2);
    PathLineTo(p3);
    PathLineTo(p4);
    PathFillConvex(col);
  }

  GUI_API void AddTriangle(const Vec2 &p1, const Vec2 &p2, const Vec2 &p3,
                           U32 col, float thickness = 1.0f) {
    if ((col & GUI_COL32_A_MASK) == 0)
      return;

    PathLineTo(p1);
    PathLineTo(p2);
    PathLineTo(p3);
    PathStroke(col, DrawFlags_Closed, thickness);
  }

  GUI_API void AddTriangleFilled(const Vec2 &p1, const Vec2 &p2, const Vec2 &p3,
                                 U32 col) {
    if ((col & GUI_COL32_A_MASK) == 0)
      return;

    PathLineTo(p1);
    PathLineTo(p2);
    PathLineTo(p3);
    PathFillConvex(col);
  }

  GUI_API void AddCircle(const Vec2 &center, float radius, U32 col,
                         int num_segments = 0, float thickness = 1.0f);
  GUI_API void AddCircleFilled(const Vec2 &center, float radius, U32 col,
                               int num_segments = 0);
  GUI_API void AddNgon(const Vec2 &center, float radius, U32 col,
                       int num_segments, float thickness = 1.0f);
  GUI_API void AddNgonFilled(const Vec2 &center, float radius, U32 col,
                             int num_segments);
  GUI_API void AddEllipse(const Vec2 &center, float radius_x, float radius_y,
                          U32 col, float rot = 0.0f, int num_segments = 0,
                          float thickness = 1.0f);
  GUI_API void AddEllipseFilled(const Vec2 &center, float radius_x,
                                float radius_y, U32 col, float rot = 0.0f,
                                int num_segments = 0);
  GUI_API void AddText(const Vec2 &pos, U32 col, const char *text_begin,
                       const char *text_end = NULL) {
    AddText(NULL, 0.0f, pos, col, text_begin, text_end);
  }

  GUI_API void AddText(const Font *font, float font_size, const Vec2 &pos,
                       U32 col, const char *text_begin,
                       const char *text_end = NULL, float wrap_width = 0.0f,
                       const Vec4 *cpu_fine_clip_rect = NULL);
  GUI_API void AddPolyline(const Vec2 *points, int num_points, U32 col,
                           DrawFlags flags, float thickness);
  GUI_API void AddConvexPolyFilled(const Vec2 *points, int num_points, U32 col);
  GUI_API void AddBezierCubic(const Vec2 &p1, const Vec2 &p2, const Vec2 &p3,
                              const Vec2 &p4, U32 col, float thickness,
                              int num_segments = 0) {
    if ((col & GUI_COL32_A_MASK) == 0)
      return;

    PathLineTo(p1);
    PathBezierCubicCurveTo(p2, p3, p4, num_segments);
    PathStroke(col, 0, thickness);
  }
  // Cubic Bezier (4 control points)
  GUI_API void AddBezierQuadratic(const Vec2 &p1, const Vec2 &p2,
                                  const Vec2 &p3, U32 col, float thickness,
                                  int num_segments = 0) {
    if ((col & GUI_COL32_A_MASK) == 0)
      return;

    PathLineTo(p1);
    PathBezierQuadraticCurveTo(p2, p3, num_segments);
    PathStroke(col, 0, thickness);
  }
  // Quadratic Bezier (3 control points)

  // Image primitives
  // - Read FAQ to understand what TextureID is.
  // - "p_min" and "p_max" represent the upper-left and lower-right corners of
  // the rectangle.
  // - "uv_min" and "uv_max" represent the normalized texture coordinates to use
  // for those corners. Using (0,0)->(1,1) texture coordinates will generally
  // display the entire texture.
  GUI_API void AddImage(TextureID user_texture_id, const Vec2 &p_min,
                        const Vec2 &p_max, const Vec2 &uv_min = Vec2(0, 0),
                        const Vec2 &uv_max = Vec2(1, 1),
                        U32 col = GUI_COL32_WHITE) {
    if ((col & GUI_COL32_A_MASK) == 0)
      return;

    const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
    if (push_texture_id)
      PushTextureID(user_texture_id);

    PrimReserve(6, 4);
    PrimRectUV(p_min, p_max, uv_min, uv_max, col);

    if (push_texture_id)
      PopTextureID();
  }

  GUI_API void
  AddImageQuad(TextureID user_texture_id, const Vec2 &p1, const Vec2 &p2,
               const Vec2 &p3, const Vec2 &p4, const Vec2 &uv1 = Vec2(0, 0),
               const Vec2 &uv2 = Vec2(1, 0), const Vec2 &uv3 = Vec2(1, 1),
               const Vec2 &uv4 = Vec2(0, 1), U32 col = GUI_COL32_WHITE) {
    if ((col & GUI_COL32_A_MASK) == 0)
      return;

    const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
    if (push_texture_id)
      PushTextureID(user_texture_id);

    PrimReserve(6, 4);
    PrimQuadUV(p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);

    if (push_texture_id)
      PopTextureID();
  }

  GUI_API void AddImageRounded(TextureID user_texture_id, const Vec2 &p_min,
                               const Vec2 &p_max, const Vec2 &uv_min,
                               const Vec2 &uv_max, U32 col, float rounding,
                               DrawFlags flags = 0);

  // Stateful path API, add points then finish with PathFillConvex() or
  // PathStroke()
  // - Filled shapes must always use clockwise winding order. The anti-aliasing
  // fringe depends on it. Counter-clockwise shapes will have "inward"
  // anti-aliasing.
  inline void PathClear() { _Path.Size = 0; }
  inline void PathLineTo(const Vec2 &pos) { _Path.push_back(pos); }
  inline void PathLineToMergeDuplicate(const Vec2 &pos) {
    if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size - 1], &pos, 8) != 0)
      _Path.push_back(pos);
  }
  inline void PathFillConvex(U32 col) {
    AddConvexPolyFilled(_Path.Data, _Path.Size, col);
    _Path.Size = 0;
  }
  inline void PathStroke(U32 col, DrawFlags flags = 0, float thickness = 1.0f) {
    AddPolyline(_Path.Data, _Path.Size, col, flags, thickness);
    _Path.Size = 0;
  }
  GUI_API void PathArcTo(const Vec2 &center, float radius, float a_min,
                         float a_max, int num_segments = 0);
  GUI_API void PathArcToFast(
      const Vec2 &center, float radius, int a_min_of_12,
      int a_max_of_12); // Use precomputed angles for a 12 steps circle
  GUI_API void PathEllipticalArcTo(const Vec2 &center, float radius_x,
                                   float radius_y, float rot, float a_min,
                                   float a_max,
                                   int num_segments = 0); // Ellipse
  GUI_API void PathBezierCubicCurveTo(
      const Vec2 &p2, const Vec2 &p3, const Vec2 &p4,
      int num_segments = 0); // Cubic Bezier (4 control points)
  GUI_API void PathBezierQuadraticCurveTo(
      const Vec2 &p2, const Vec2 &p3,
      int num_segments = 0); // Quadratic Bezier (3 control points)
  GUI_API void PathRect(const Vec2 &rect_min, const Vec2 &rect_max,
                        float rounding = 0.0f, DrawFlags flags = 0);

  // Advanced
  GUI_API void
  AddCallback(DrawCallback callback,
              void *callback_data); // Your rendering function must check for
                                    // 'UserCallback' in DrawCmd and call the
                                    // function instead of rendering triangles.
  GUI_API void
  AddDrawCmd(); // This is useful if you need to forcefully create a new draw
                // call (to allow for dependent rendering / blending). Otherwise
                // primitives are merged into the same draw-call as much as
                // possible
  GUI_API DrawList *CloneOutput() const {
    DrawList *dst = GUI_NEW(DrawList(_Data));
    dst->CmdBuffer = CmdBuffer;
    dst->IdxBuffer = IdxBuffer;
    dst->VtxBuffer = VtxBuffer;
    dst->Flags = Flags;
    return dst;
  }
  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.

  // Advanced: Channels
  // - Use to split render into layers. By switching channels to can render
  // out-of-order (e.g. submit FG primitives before BG primitives)
  // - Use to minimize draw calls (e.g. if going back-and-forth between multiple
  // clipping rectangles, prefer to append into separate channels then merge at
  // the end)
  // - This API shouldn't have been in DrawList in the first place!
  //   Prefer using your own persistent instance of DrawListSplitter as you
  //   can stack them. Using the DrawList::ChannelsXXXX you cannot stack a
  //   split over another.
  inline void ChannelsSplit(int count) { _Splitter.Split(this, count); }
  inline void ChannelsMerge() { _Splitter.Merge(this); }
  inline void ChannelsSetCurrent(int n) {
    _Splitter.SetCurrentChannel(this, n);
  }

  // Advanced: Primitives allocations
  // - We render triangles (three vertices)
  // - All primitives needs to be reserved via PrimReserve() beforehand.
  GUI_API void PrimReserve(int idx_count, int vtx_count);
  GUI_API void PrimUnreserve(int idx_count, int vtx_count);
  GUI_API void
  PrimRect(const Vec2 &a, const Vec2 &b,
           U32 col); // Axis aligned rectangle (composed of two triangles)
  GUI_API void PrimRectUV(const Vec2 &a, const Vec2 &c, const Vec2 &uv_a,
                          const Vec2 &uv_c, U32 col) {
    Vec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);
    DrawIdx idx = (DrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx;
    _IdxWritePtr[1] = (DrawIdx)(idx + 1);
    _IdxWritePtr[2] = (DrawIdx)(idx + 2);
    _IdxWritePtr[3] = idx;
    _IdxWritePtr[4] = (DrawIdx)(idx + 2);
    _IdxWritePtr[5] = (DrawIdx)(idx + 3);
    _VtxWritePtr[0].pos = a;
    _VtxWritePtr[0].uv = uv_a;
    _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b;
    _VtxWritePtr[1].uv = uv_b;
    _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c;
    _VtxWritePtr[2].uv = uv_c;
    _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d;
    _VtxWritePtr[3].uv = uv_d;
    _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
  }

  GUI_API void PrimQuadUV(const Vec2 &a, const Vec2 &b, const Vec2 &c,
                          const Vec2 &d, const Vec2 &uv_a, const Vec2 &uv_b,
                          const Vec2 &uv_c, const Vec2 &uv_d, U32 col) {
    DrawIdx idx = (DrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx;
    _IdxWritePtr[1] = (DrawIdx)(idx + 1);
    _IdxWritePtr[2] = (DrawIdx)(idx + 2);
    _IdxWritePtr[3] = idx;
    _IdxWritePtr[4] = (DrawIdx)(idx + 2);
    _IdxWritePtr[5] = (DrawIdx)(idx + 3);
    _VtxWritePtr[0].pos = a;
    _VtxWritePtr[0].uv = uv_a;
    _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b;
    _VtxWritePtr[1].uv = uv_b;
    _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c;
    _VtxWritePtr[2].uv = uv_c;
    _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d;
    _VtxWritePtr[3].uv = uv_d;
    _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
  }

  inline void PrimWriteVtx(const Vec2 &pos, const Vec2 &uv, U32 col) {
    _VtxWritePtr->pos = pos;
    _VtxWritePtr->uv = uv;
    _VtxWritePtr->col = col;
    _VtxWritePtr++;
    _VtxCurrentIdx++;
  }
  inline void PrimWriteIdx(DrawIdx idx) {
    *_IdxWritePtr = idx;
    _IdxWritePtr++;
  }
  inline void PrimVtx(const Vec2 &pos, const Vec2 &uv, U32 col) {
    PrimWriteIdx((DrawIdx)_VtxCurrentIdx);
    PrimWriteVtx(pos, uv, col);
  } // Write vertex with unique index

  // Obsolete names
  // inline  void  AddBezierCurve(const Vec2& p1, const Vec2& p2, const
  // Vec2& p3, const Vec2& p4,U32 col, float thickness, int num_segments
  // = 0) { AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments); } //
  // OBSOLETED in 1.80 (Jan 2021) inline  void  PathBezierCurveTo(const Vec2&
  // p2, const Vec2& p3, const Vec2& p4, int num_segments = 0) {
  // PathBezierCubicCurveTo(p2, p3, p4, num_segments); } // OBSOLETED in 1.80
  // (Jan 2021)

  // [Internal helpers]
  GUI_API void _ResetForNewFrame();
  GUI_API void _ClearFreeMemory() {
    CmdBuffer.clear();
    IdxBuffer.clear();
    VtxBuffer.clear();
    Flags = DrawListFlags_None;
    _VtxCurrentIdx = 0;
    _VtxWritePtr = NULL;
    _IdxWritePtr = NULL;
    _ClipRectStack.clear();
    _TextureIdStack.clear();
    _Path.clear();
    _Splitter.ClearFreeMemory();
  }

  GUI_API void _PopUnusedDrawCmd() {
    while (CmdBuffer.Size > 0) {
      DrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
      if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)
        return; // break;
      CmdBuffer.pop_back();
    }
  }

  GUI_API void _TryMergeDrawCmds();
  GUI_API void _OnChangedClipRect();
  GUI_API void _OnChangedTextureID();
  GUI_API void _OnChangedVtxOffset();
  GUI_API int _CalcCircleAutoSegmentCount(float radius) const;
  GUI_API void _PathArcToFastEx(const Vec2 &center, float radius,
                                int a_min_sample, int a_max_sample, int a_step);
  GUI_API void _PathArcToN(const Vec2 &center, float radius, float a_min,
                           float a_max, int num_segments);
};

// All draw data to render a Dear Gui frame
// (NB: the style and the naming convention here is a little inconsistent, we
// currently preserve them for backward compatibility purpose, as this is one of
// the oldest structure exposed by the library! Basically, DrawList ==
// CmdList)
struct DrawData {
  bool Valid;        // Only valid after Render() is called and before the next
                     // NewFrame() is called.
  int CmdListsCount; // Number of DrawList* to render (should always be ==
                     // CmdLists.size)
  int TotalIdxCount; // For convenience, sum of all DrawList's IdxBuffer.Size
  int TotalVtxCount; // For convenience, sum of all DrawList's VtxBuffer.Size
  Vector<DrawList *>
      CmdLists;     // Array of DrawList* to render. The DrawLists are owned by
                    // Context and only pointed to from here.
  Vec2 DisplayPos;  // Top-left position of the viewport to render (== top-left
                    // of the orthogonal projection matrix to use) (==
                    // GetMainViewport()->Pos for the main viewport, == (0.0)
                    // in most single-viewport applications)
  Vec2 DisplaySize; // Size of the viewport to render (==
                    // GetMainViewport()->Size for the main viewport, ==
                    // io.DisplaySize in most single-viewport applications)
  Vec2 FramebufferScale; // Amount of pixels for each unit of DisplaySize. Based
                         // on io.DisplayFramebufferScale. Generally (1,1) on
                         // normal display, (2,2) on OSX with Retina display.
  Viewport *OwnerViewport; // Viewport carrying the DrawData instance, might
                           // be of use to the renderer (generally not).

  // Functions
  DrawData() { Clear(); }
  GUI_API void Clear() {
    Valid = false;
    CmdListsCount = TotalIdxCount = TotalVtxCount = 0;
    CmdLists.resize(0); // The DrawList are NOT owned by DrawData but e.g. by
                        // Context, so we don't clear them.
    DisplayPos = DisplaySize = FramebufferScale = Vec2(0.0f, 0.0f);
    OwnerViewport = NULL;
  }

  GUI_API void
  AddDrawList(DrawList *draw_list); // Helper to add an external draw list
                                    // into an existing DrawData.
  GUI_API void DeIndexAllBuffers() {
    Vector<DrawVert> new_vtx_buffer;
    TotalVtxCount = TotalIdxCount = 0;
    for (int i = 0; i < CmdListsCount; i++) {
      DrawList *cmd_list = CmdLists[i];
      if (cmd_list->IdxBuffer.empty())
        continue;
      new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);
      for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)
        new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];
      cmd_list->VtxBuffer.swap(new_vtx_buffer);
      cmd_list->IdxBuffer.resize(0);
      TotalVtxCount += cmd_list->VtxBuffer.Size;
    }
  }
  // Helper to convert all buffers from indexed to
  // non-indexed, in case you cannot render indexed. Note:
  // this is slow and most likely a waste of resources.
  // Always prefer indexed rendering!
  GUI_API void ScaleClipRects(const Vec2 &fb_scale) {
    for (DrawList *draw_list : CmdLists)
      for (DrawCmd &cmd : draw_list->CmdBuffer)
        cmd.ClipRect =
            Vec4(cmd.ClipRect.x * fb_scale.x, cmd.ClipRect.y * fb_scale.y,
                 cmd.ClipRect.z * fb_scale.x, cmd.ClipRect.w * fb_scale.y);
  }
  // Helper to scale the ClipRect field of each
  // DrawCmd. Use if your final output buffer is
  // at a different scale than Dear Gui expects,
  // or if there is a difference between your
  // window resolution and framebuffer resolution.
};

//-----------------------------------------------------------------------------
// [SECTION] Font API (FontConfig, FontGlyph, FontAtlasFlags, FontAtlas,
// FontGlyphRangesBuilder, Font)
//-----------------------------------------------------------------------------

struct FontConfig {
  void *FontData;            //          // TTF/OTF data
  int FontDataSize;          //          // TTF/OTF data size
  bool FontDataOwnedByAtlas; // true     // TTF/OTF data ownership taken by the
                             // container FontAtlas (will delete memory
                             // itself).
  int FontNo;                // 0        // Index of font within TTF/OTF file
  float SizePixels; //          // Size in pixels for rasterizer (more or less
                    //          maps to the resulting font height).
  int OversampleH;  // 2        // Rasterize at higher quality for sub-pixel
                    // positioning. Note the difference between 2 and 3 is
                    // minimal. You can reduce this to 1 for large glyphs save
                    // memory. Read
  // https://github.com/nothings/stb/blob/master/tests/oversample/README.md
  // for details.
  int OversampleV; // 1        // Rasterize at higher quality for sub-pixel
                   // positioning. This is not really useful as we don't use
                   // sub-pixel positions on the Y axis.
  bool PixelSnapH; // false    // Align every glyph to pixel boundary. Useful
                   // e.g. if you are merging a non-pixel aligned font with the
                   // default font. If enabled, you can set OversampleH/V to 1.
  Vec2 GlyphExtraSpacing; // 0, 0     // Extra spacing (in pixels) between
                          // glyphs. Only X axis is supported for now.
  Vec2 GlyphOffset;       // 0, 0     // Offset all glyphs from this font input.
  const Wchar
      *GlyphRanges; // NULL     // THE ARRAY DATA NEEDS TO PERSIST AS LONG AS
                    // THE FONT IS ALIVE. Pointer to a user-provided list of
                    // Unicode range (2 value per range, values are inclusive,
                    // zero-terminated list).
  float GlyphMinAdvanceX; // 0        // Minimum AdvanceX for glyphs, set Min to
                          // align font icons, set both Min/Max to enforce
                          // mono-space font
  float GlyphMaxAdvanceX; // FLT_MAX  // Maximum AdvanceX for glyphs
  bool MergeMode; // false    // Merge into previous Font, so you can combine
                  // multiple inputs font into one Font (e.g. ASCII font +
                  // icons + Japanese glyphs). You may want to use GlyphOffset.y
                  // when merge font of different heights.
  unsigned int FontBuilderFlags; // 0        // Settings for custom font
                                 // builder. THIS IS BUILDER IMPLEMENTATION
                                 // DEPENDENT. Leave as zero if unsure.
  float
      RasterizerMultiply; // 1.0f     // Linearly brighten (>1.0f) or darken
                          // (<1.0f) font output. Brightening small fonts may be
                          // a good workaround to make them more readable. This
                          // is a silly thing we may remove in the future.
  float RasterizerDensity; // 1.0f     // DPI scale for rasterization, not
                           // altering other font metrics: make it easy to swap
                           // between e.g. a 100% and a 400% fonts for a zooming
                           // display. IMPORTANT: If you increase this it is
                           // expected that you increase font scale accordingly,
                           // otherwise quality may look lowered.
  Wchar EllipsisChar; // -1       // Explicitly specify unicode codepoint of
                      // ellipsis character. When fonts are being merged first
                      // specified ellipsis will be used.

  // [Internal]
  char Name[40]; // Name (strictly to ease debugging)
  Font *DstFont;

  GUI_API FontConfig();
};

// Hold rendering data for one glyph.
// (Note: some language parsers may fail to convert the 31+1 bitfield members,
// in this case maybe drop store a single u32 or we can rework this)
struct FontGlyph {
  unsigned int Colored : 1; // Flag to indicate glyph is colored and should
                            // generally ignore tinting (make it usable with no
                            // shift on little-endian as this is used in loops)
  unsigned int Visible : 1; // Flag to indicate glyph has no visible pixels
                            // (e.g. space). Allow early out when rendering.
  unsigned int Codepoint : 30; // 0x0000..0x10FFFF
  float AdvanceX;              // Distance to next character (= data from font +
                               // FontConfig::GlyphExtraSpacing.x baked in)
  float X0, Y0, X1, Y1;        // Glyph corners
  float U0, V0, U1, V1;        // Texture coordinates
};

// Helper to build glyph ranges from text/string data. Feed your application
// strings/characters to it then call BuildRanges(). This is essentially a
// tightly packed of vector of 64k booleans = 8KB storage.
struct FontGlyphRangesBuilder {
  Vector<U32>
      UsedChars; // Store 1-bit per Unicode code point (0=unused, 1=used)

  FontGlyphRangesBuilder() { Clear(); }
  inline void Clear() {
    int size_in_bytes = (GUI_UNICODE_CODEPOINT_MAX + 1) / 8;
    UsedChars.resize(size_in_bytes / (int)sizeof(U32));
    memset(UsedChars.Data, 0, (size_t)size_in_bytes);
  }
  inline bool GetBit(size_t n) const {
    int off = (int)(n >> 5);
    U32 mask = 1u << (n & 31);
    return (UsedChars[off] & mask) != 0;
  } // Get bit n in the array
  inline void SetBit(size_t n) {
    int off = (int)(n >> 5);
    U32 mask = 1u << (n & 31);
    UsedChars[off] |= mask;
  }                                           // Set bit n in the array
  inline void AddChar(Wchar c) { SetBit(c); } // Add character
  GUI_API void AddText(
      const char *text,
      const char *text_end =
          NULL); // Add string (each character of the UTF-8 string are added)
  GUI_API void AddRanges(const Wchar *ranges) {
    for (; ranges[0]; ranges += 2)
      for (unsigned int c = ranges[0];
           c <= ranges[1] && c <= GUI_UNICODE_CODEPOINT_MAX; c++) //-V560
        AddChar((Wchar)c);
  }
  // Add ranges, e.g.
  // builder.AddRanges(FontAtlas::GetGlyphRangesDefault())
  // to force add all of ASCII/Latin+Ext
  GUI_API void BuildRanges(Vector<Wchar> *out_ranges) {
    const int max_codepoint = GUI_UNICODE_CODEPOINT_MAX;
    for (int n = 0; n <= max_codepoint; n++)
      if (GetBit(n)) {
        out_ranges->push_back((Wchar)n);
        while (n < max_codepoint && GetBit(n + 1))
          n++;
        out_ranges->push_back((Wchar)n);
      }
    out_ranges->push_back(0);
  }
  // Output new ranges
};

// See FontAtlas::AddCustomRectXXX functions.
struct FontAtlasCustomRect {
  unsigned short Width, Height; // Input    // Desired rectangle dimension
  unsigned short X, Y;          // Output   // Packed position in Atlas
  unsigned int
      GlyphID; // Input    // For custom font glyphs only (ID < 0x110000)
  float
      GlyphAdvanceX; // Input    // For custom font glyphs only: glyph xadvance
  Vec2 GlyphOffset;  // Input    // For custom font glyphs only: glyph display
                     // offset
  Font *Font;        // Input    // For custom font glyphs only: target font
  FontAtlasCustomRect() {
    Width = Height = 0;
    X = Y = 0xFFFF;
    GlyphID = 0;
    GlyphAdvanceX = 0.0f;
    GlyphOffset = Vec2(0, 0);
    Font = NULL;
  }
  bool IsPacked() const { return X != 0xFFFF; }
};

// Flags for FontAtlas build
enum FontAtlasFlags_ {
  FontAtlasFlags_None = 0,
  FontAtlasFlags_NoPowerOfTwoHeight =
      1 << 0, // Don't round the height to next power of two
  FontAtlasFlags_NoMouseCursors =
      1 << 1, // Don't build software mouse cursors into the atlas (save a
              // little texture memory)
  FontAtlasFlags_NoBakedLines =
      1 << 2, // Don't build thick line textures into the atlas (save a little
              // texture memory, allow support for point/nearest filtering). The
              // AntiAliasedLinesUseTex features uses them, otherwise they will
              // be rendered using polygons (more expensive for CPU/GPU).
};

// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas
// will build a single texture holding:
//  - One or more fonts.
//  - Custom graphics data needed to render the shapes needed by Dear Gui.
//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags
//  |= FontAtlasFlags_NoMouseCursors' in the font atlas).
// It is the user-code responsibility to setup/build the atlas, then upload the
// pixel data into a texture accessible by your graphics api.
//  - Optionally, call any of the AddFont*** functions. If you don't call any,
//  the default font embedded in the code will be loaded for you.
//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve
//  pixels data.
//  - Upload the pixels data into a texture within your graphics system (see
//  gui_impl_xxxx.cpp examples)
//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture
//  in a format natural to your graphics API.
//    This value will be passed back to you during rendering to identify the
//    texture. Read FAQ entry about TextureID for more details.
// Common pitfalls:
// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to
// make sure that your array persist up until the
//   atlas is build (when calling GetTexData*** or Build()). We only copy the
//   pointer, not the data.
// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data.
// Even though we are not writing to it, we will free the pointer on
// destruction.
//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your
//   data and it won't be freed,
// - Even though many functions are suffixed with "TTF", OTF data is supported
// just as well.
// - This is an old API and it is currently awkward for those and various other
// reasons! We will address them in the future!
struct FontAtlas {
  GUI_API FontAtlas();
  GUI_API ~FontAtlas();
  GUI_API Font *AddFont(const FontConfig *font_cfg);
  GUI_API Font *AddFontDefault(const FontConfig *font_cfg = NULL);
  GUI_API Font *AddFontFromFileTTF(const char *filename, float size_pixels,
                                   const FontConfig *font_cfg = NULL,
                                   const Wchar *glyph_ranges = NULL);
  GUI_API Font *AddFontFromMemoryTTF(
      void *font_data, int font_data_size, float size_pixels,
      const FontConfig *font_cfg = NULL,
      const Wchar *glyph_ranges =
          NULL); // Note: Transfer ownership of 'ttf_data' to FontAtlas! Will
                 // be deleted after destruction of the atlas. Set
                 // font_cfg->FontDataOwnedByAtlas=false to keep ownership of
                 // your data and it won't be freed.
  GUI_API Font *AddFontFromMemoryCompressedTTF(
      const void *compressed_font_data, int compressed_font_data_size,
      float size_pixels, const FontConfig *font_cfg = NULL,
      const Wchar *glyph_ranges =
          NULL); // 'compressed_font_data' still owned by caller. Compress with
                 // binary_to_compressed_c.cpp.
  GUI_API Font *AddFontFromMemoryCompressedBase85TTF(
      const char *compressed_font_data_base85, float size_pixels,
      const FontConfig *font_cfg = NULL,
      const Wchar *glyph_ranges =
          NULL); // 'compressed_font_data_base85' still owned by caller.
                 // Compress with binary_to_compressed_c.cpp with -base85
                 // parameter.
  GUI_API void
  ClearInputData(); // Clear input data (all FontConfig structures including
                    // sizes, TTF data, glyph ranges, etc.) = all the data used
                    // to build the texture and fonts.
  GUI_API void
  ClearTexData(); // Clear output texture data (CPU side). Saves RAM once the
                  // texture has been copied to graphics memory.
  GUI_API void
  ClearFonts(); // Clear output font data (glyphs storage, UV coordinates).
  GUI_API void Clear() {
    ClearInputData();
    ClearTexData();
    ClearFonts();
  }
  // Clear all input and output.

  // Build atlas, retrieve pixel data.
  // User is in charge of copying the pixels into graphics memory (e.g. create a
  // texture with your engine). Then store your texture handle with SetTexID().
  // The pitch is always = Width * BytesPerPixels (1 or 4)
  // Building in RGBA32 format is provided for convenience and compatibility,
  // but note that unless you manually manipulate or copy color data into the
  // texture (e.g. when using the AddCustomRect*** api), then the RGB pixels
  // emitted will always be white (~75% of memory/bandwidth waste.
  GUI_API bool Build(); // Build pixels data. This is called automatically for
                        // you by the GetTexData*** functions.
  GUI_API void GetTexDataAsAlpha8(unsigned char **out_pixels, int *out_width,
                                  int *out_height,
                                  int *out_bytes_per_pixel = NULL) {
    // Build atlas on demand
    if (TexPixelsAlpha8 == NULL)
      Build();

    *out_pixels = TexPixelsAlpha8;
    if (out_width)
      *out_width = TexWidth;
    if (out_height)
      *out_height = TexHeight;
    if (out_bytes_per_pixel)
      *out_bytes_per_pixel = 1;
  }
  // 1 byte per-pixel
  GUI_API void
  GetTexDataAsRGBA32(unsigned char **out_pixels, int *out_width,
                     int *out_height,
                     int *out_bytes_per_pixel = NULL); // 4 bytes-per-pixel
  bool IsBuilt() const {
    return Fonts.Size > 0 && TexReady;
  } // Bit ambiguous: used to detect when user didn't build texture but
    // effectively we should check TexID != 0 except that would be backend
    // dependent...
  void SetTexID(TextureID id) { TexID = id; }

  //-------------------------------------------
  // Glyph Ranges
  //-------------------------------------------

  // Helpers to retrieve list of common Unicode ranges (2 value per range,
  // values are inclusive, zero-terminated list) NB: Make sure that your string
  // are UTF-8 and NOT in your local code page. Read
  // https://github.com/ocornut/imgui/blob/master/docs/FONTS.md/#about-utf-8-encoding
  // for details. NB: Consider using FontGlyphRangesBuilder to build glyph
  // ranges from textual data.
  GUI_API const Wchar *GetGlyphRangesDefault() {
    static const Wchar ranges[] = {
        0x0020,
        0x00FF, // Basic Latin + Latin Supplement
        0,
    };
    return &ranges[0];
  }
  // Basic Latin, Extended Latin
  GUI_API const Wchar *GetGlyphRangesGreek() {
    static const Wchar ranges[] = {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x0370, 0x03FF, // Greek and Coptic
        0,
    };
    return &ranges[0];
  }
  // Default + Greek and Coptic
  GUI_API const Wchar *GetGlyphRangesKorean() {
    static const Wchar ranges[] = {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x3131, 0x3163, // Korean alphabets
        0xAC00, 0xD7A3, // Korean characters
        0xFFFD, 0xFFFD, // Invalid
        0,
    };
    return &ranges[0];
  }
  // Default + Korean characters
  GUI_API const Wchar *
  GetGlyphRangesJapanese(); // Default + Hiragana, Katakana, Half-Width,
                            // Selection of 2999 Ideographs
  GUI_API const Wchar *GetGlyphRangesChineseFull() {
    static const Wchar ranges[] = {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x2000, 0x206F, // General Punctuation
        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF, // Half-width characters
        0xFFFD, 0xFFFD, // Invalid
        0x4e00, 0x9FAF, // CJK Ideograms
        0,
    };
    return &ranges[0];
  }
  // Default + Half-Width + Japanese
  // Hiragana/Katakana + full set of about 21000
  // CJK Unified Ideographs
  GUI_API const Wchar *
  GetGlyphRangesChineseSimplifiedCommon(); // Default + Half-Width + Japanese
                                           // Hiragana/Katakana + set of 2500
                                           // CJK Unified Ideographs for common
                                           // simplified Chinese
  GUI_API const Wchar *GetGlyphRangesCyrillic() {
    static const Wchar ranges[] = {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
        0x2DE0, 0x2DFF, // Cyrillic Extended-A
        0xA640, 0xA69F, // Cyrillic Extended-B
        0,
    };
    return &ranges[0];
  }
  // Default + about 400 Cyrillic characters
  GUI_API const Wchar *GetGlyphRangesThai() {
    static const Wchar ranges[] = {
        0x0020, 0x00FF, // Basic Latin
        0x2010, 0x205E, // Punctuations
        0x0E00, 0x0E7F, // Thai
        0,
    };
    return &ranges[0];
  }
  // Default + Thai characters
  GUI_API const Wchar *GetGlyphRangesVietnamese() {
    static const Wchar ranges[] = {
        0x0020, 0x00FF, // Basic Latin
        0x0102, 0x0103, 0x0110, 0x0111, 0x0128, 0x0129, 0x0168, 0x0169,
        0x01A0, 0x01A1, 0x01AF, 0x01B0, 0x1EA0, 0x1EF9, 0,
    };
    return &ranges[0];
  }
  // Default + Vietnamese characters

  //-------------------------------------------
  // [BETA] Custom Rectangles/Glyphs API
  //-------------------------------------------

  // You can request arbitrary rectangles to be packed into the atlas, for your
  // own purposes.
  // - After calling Build(), you can query the rectangle position and render
  // your pixels.
  // - If you render colored output, set 'atlas->TexPixelsUseColors = true' as
  // this may help some backends decide of prefered texture format.
  // - You can also request your rectangles to be mapped as font glyph (given a
  // font + Unicode point),
  //   so you can render e.g. custom colorful icons and use them as regular
  //   glyphs.
  // - Read docs/FONTS.md for more details about using colorful icons.
  // - Note: this API may be redesigned later in order to support multi-monitor
  // varying DPI settings.
  GUI_API int AddCustomRectRegular(int width, int height);
  GUI_API int AddCustomRectFontGlyph(Font *font, Wchar id, int width,
                                     int height, float advance_x,
                                     const Vec2 &offset = Vec2(0, 0));
  FontAtlasCustomRect *GetCustomRectByIndex(int index) {
    GUI_ASSERT(index >= 0);
    return &CustomRects[index];
  }

  // [Internal]
  GUI_API void CalcCustomRectUV(const FontAtlasCustomRect *rect,
                                Vec2 *out_uv_min, Vec2 *out_uv_max) const;
  GUI_API bool GetMouseCursorTexData(MouseCursor cursor, Vec2 *out_offset,
                                     Vec2 *out_size, Vec2 out_uv_border[2],
                                     Vec2 out_uv_fill[2]);

  //-------------------------------------------
  // Members
  //-------------------------------------------

  FontAtlasFlags Flags; // Build flags (see FontAtlasFlags_)
  TextureID TexID;      // User data to refer to the texture once it has been
                   // uploaded to user's graphic systems. It is passed back to
                   // you during rendering via the DrawCmd structure.
  int TexDesiredWidth; // Texture width desired by user before Build(). Must be
                       // a power-of-two. If have many glyphs your graphics API
                       // have texture size restrictions you may want to
                       // increase texture width to decrease height.
  int TexGlyphPadding; // Padding between glyphs within texture in pixels.
                       // Defaults to 1. If your rendering method doesn't rely
                       // on bilinear filtering you may set this to 0 (will also
                       // need to set AntiAliasedLinesUseTex = false).
  bool Locked; // Marked as Locked by Gui::NewFrame() so attempt to modify the
               // atlas will assert.
  void *UserData; // Store your own atlas related user-data (if e.g. you have
                  // multiple font atlas).

  // [Internal]
  // NB: Access texture data via GetTexData*() calls! Which will setup a default
  // font for you.
  bool TexReady; // Set when texture was built matching current font input
  bool TexPixelsUseColors; // Tell whether our texture data is known to use
                           // colors (rather than just alpha channel), in order
                           // to help backend select a format.
  unsigned char
      *TexPixelsAlpha8; // 1 component per pixel, each component is unsigned
                        // 8-bit. Total size = TexWidth * TexHeight
  unsigned int
      *TexPixelsRGBA32; // 4 component per pixel, each component is unsigned
                        // 8-bit. Total size = TexWidth * TexHeight * 4
  int TexWidth;         // Texture width calculated during Build().
  int TexHeight;        // Texture height calculated during Build().
  Vec2 TexUvScale;      // = (1.0f/TexWidth, 1.0f/TexHeight)
  Vec2 TexUvWhitePixel; // Texture coordinates to a white pixel
  Vector<Font *> Fonts; // Hold all the fonts returned by AddFont*. Fonts[0] is
                        // the default font upon calling Gui::NewFrame(), use
                        // Gui::PushFont()/PopFont() to change the current font.
  Vector<FontAtlasCustomRect>
      CustomRects; // Rectangles for packing custom texture data into the atlas.
  Vector<FontConfig> ConfigData; // Configuration data
  Vec4 TexUvLines[GUI_DRAWLIST_TEX_LINES_WIDTH_MAX +
                  1]; // UVs for baked anti-aliased lines

  // [Internal] Font builder
  const FontBuilderIO
      *FontBuilderIO; // Opaque interface to a font builder (default to
                      // stb_truetype, can be changed to use FreeType by
                      // defining GUI_ENABLE_FREETYPE).
  unsigned int
      FontBuilderFlags; // Shared flags (for all fonts) for custom font builder.
                        // THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font
                        // override is also available in FontConfig.

  // [Internal] Packing data
  int PackIdMouseCursors; // Custom texture rectangle ID for white pixel and
                          // mouse cursors
  int PackIdLines; // Custom texture rectangle ID for baked anti-aliased lines

  // [Obsolete]
  // typedef FontAtlasCustomRect    CustomRect;         // OBSOLETED in 1.72+
  // typedef FontGlyphRangesBuilder GlyphRangesBuilder; // OBSOLETED in 1.67+
};

// Font runtime data and rendering
// FontAtlas automatically loads a default embedded font for you when you call
// GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
struct Font {
  // Members: Hot ~20/24 bytes (for CalcTextSize)
  Vector<float>
      IndexAdvanceX; // 12-16 // out //            // Sparse. Glyphs->AdvanceX
                     // in a directly indexable way (cache-friendly for
                     // CalcTextSize functions which only this this info, and
                     // are often bottleneck in large UI).
  float FallbackAdvanceX; // 4     // out // = FallbackGlyph->AdvanceX
  float FontSize; // 4     // in  //            // Height of characters/line,
                  // set during loading (don't change after loading)

  // Members: Hot ~28/40 bytes (for CalcTextSize + render loop)
  Vector<Wchar> IndexLookup; // 12-16 // out //            // Sparse. Index
                             // glyphs by Unicode code-point.
  Vector<FontGlyph> Glyphs;  // 12-16 // out //            // All glyphs.
  const FontGlyph
      *FallbackGlyph; // 4-8   // out // = FindGlyph(FontFallbackChar)

  // Members: Cold ~32/40 bytes
  FontAtlas *ContainerAtlas; // 4-8   // out //            // What we has been
                             // loaded into
  const FontConfig *ConfigData; // 4-8   // in  //            // Pointer
                                // within ContainerAtlas->ConfigData
  short ConfigDataCount;   // 2     // in  // ~ 1        // Number of FontConfig
                           // involved in creating this font. Bigger than 1 when
                           // merging multiple font sources into one Font.
  Wchar FallbackChar;      // 2     // out // = FFFD/'?' // Character used if a
                           // glyph isn't found.
  Wchar EllipsisChar;      // 2     // out // = '...'/'.'// Character used for
                           // ellipsis rendering.
  short EllipsisCharCount; // 1     // out // 1 or 3
  float EllipsisWidth;     // 4     // out               // Width
  float EllipsisCharStep;  // 4     // out               // Step between
                           // characters when EllipsisCount > 0
  bool DirtyLookupTables;  // 1     // out //
  float Scale; // 4     // in  // = 1.f      // Base font scale, multiplied by
               // the per-window font scale which you can adjust with
               // SetWindowFontScale()
  float Ascent, Descent; // 4+4   // out //            // Ascent: distance from
                         // top to bottom of e.g. 'A' [0..FontSize]
  int MetricsTotalSurface; // 4     // out //            // Total surface in
                           // pixels to get an idea of the font
                           // rasterization/texture cost (not exact, we
                           // approximate the cost of padding between glyphs)
  U8 Used4kPagesMap[(GUI_UNICODE_CODEPOINT_MAX + 1) / 4096 /
                    8]; // 2 bytes if Wchar=Wchar16, 34 bytes if
                        //  Wchar==Wchar32. Store 1-bit for each block of
                        // 4K codepoints that has one active glyph. This is
                        // mainly used to facilitate iterations across all
                        // used codepoints.

  // Methods
  GUI_API Font();
  GUI_API ~Font() { ClearOutputData(); }

  GUI_API const FontGlyph *FindGlyph(Wchar c) const;
  GUI_API const FontGlyph *FindGlyphNoFallback(Wchar c) const;
  float GetCharAdvance(Wchar c) const {
    return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c]
                                         : FallbackAdvanceX;
  }
  bool IsLoaded() const { return ContainerAtlas != NULL; }
  const char *GetDebugName() const {
    return ConfigData ? ConfigData->Name : "<unknown>";
  }

  // 'max_width' stops rendering after a certain width (could be turned into a
  // 2d size). FLT_MAX to disable. 'wrap_width' enable automatic word-wrapping
  // across multiple lines to fit into given width. 0.0f to disable.
  GUI_API Vec2 CalcTextSizeA(float size, float max_width, float wrap_width,
                             const char *text_begin,
                             const char *text_end = NULL,
                             const char **remaining = NULL) const; // utf8
  GUI_API const char *CalcWordWrapPositionA(float scale, const char *text,
                                            const char *text_end,
                                            float wrap_width) const;
  GUI_API void RenderChar(DrawList *draw_list, float size, const Vec2 &pos,
                          U32 col, Wchar c) const;
  GUI_API void RenderText(DrawList *draw_list, float size, const Vec2 &pos,
                          U32 col, const Vec4 &clip_rect,
                          const char *text_begin, const char *text_end,
                          float wrap_width = 0.0f,
                          bool cpu_fine_clip = false) const;

  // [Internal] Don't use!
  GUI_API void BuildLookupTable();
  GUI_API void ClearOutputData() {
    FontSize = 0.0f;
    FallbackAdvanceX = 0.0f;
    Glyphs.clear();
    IndexAdvanceX.clear();
    IndexLookup.clear();
    FallbackGlyph = NULL;
    ContainerAtlas = NULL;
    DirtyLookupTables = true;
    Ascent = Descent = 0.0f;
    MetricsTotalSurface = 0;
  }

  GUI_API void GrowIndex(int new_size);
  GUI_API void AddGlyph(const FontConfig *src_cfg, Wchar c, float x0, float y0,
                        float x1, float y1, float u0, float v0, float u1,
                        float v1, float advance_x);
  GUI_API void AddRemapChar(
      Wchar dst, Wchar src,
      bool overwrite_dst =
          true); // Makes 'dst' character/glyph points to 'src' character/glyph.
                 // Currently needs to be called AFTER fonts have been built.
  GUI_API void SetGlyphVisible(Wchar c, bool visible) {
    if (FontGlyph *glyph = (FontGlyph *)(void *)FindGlyph((Wchar)c))
      glyph->Visible = visible ? 1 : 0;
  }

  GUI_API bool IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last) {
    unsigned int page_begin = (c_begin / 4096);
    unsigned int page_last = (c_last / 4096);
    for (unsigned int page_n = page_begin; page_n <= page_last; page_n++)
      if ((page_n >> 3) < sizeof(Used4kPagesMap))
        if (Used4kPagesMap[page_n >> 3] & (1 << (page_n & 7)))
          return false;
    return true;
  }
};

//-----------------------------------------------------------------------------
// [SECTION] Viewports
//-----------------------------------------------------------------------------

// Flags stored in Viewport::Flags, giving indications to the platform
// backends.
enum ViewportFlags_ {
  ViewportFlags_None = 0,
  ViewportFlags_IsPlatformWindow = 1 << 0, // Represent a Platform Window
  ViewportFlags_IsPlatformMonitor =
      1 << 1, // Represent a Platform Monitor (unused yet)
  ViewportFlags_OwnedByApp =
      1 << 2, // Platform Window: is created/managed by the application (rather
              // than a dear gui backend)
};

// - Currently represents the Platform Window created by the application which
// is hosting our Dear Gui windows.
// - In 'docking' branch with multi-viewport enabled, we extend this concept to
// have multiple active viewports.
// - In the future we will extend this concept further to also represent
// Platform Monitor and support a "no main platform window" operation mode.
// - About Main Area vs Work Area:
//   - Main Area = entire viewport.
//   - Work Area = entire viewport minus sections used by main menu bars (for
//   platform windows), or by task bar (for platform monitor).
//   - Windows are generally trying to stay within the Work Area of their host
//   viewport.
struct Viewport {
  ViewportFlags Flags; // See ViewportFlags_
  Vec2 Pos;     // Main Area: Position of the viewport (Dear Gui coordinates are
                // the same as OS desktop/native coordinates)
  Vec2 Size;    // Main Area: Size of the viewport.
  Vec2 WorkPos; // Work Area: Position of the viewport minus task bars, menus
                // bars, status bars (>= Pos)
  Vec2 WorkSize; // Work Area: Size of the viewport minus task bars, menu
                 // bars, status bars (<= Size)

  // Platform/Backend Dependent Data
  void *PlatformHandleRaw; // void* to hold lower-level, platform-native window
                           // handle (under Win32 this is expected to be a HWND,
                           // unused for other platforms)

  Viewport() { memset(this, 0, sizeof(*this)); }

  // Helpers
  Vec2 GetCenter() const {
    return Vec2(Pos.x + Size.x * 0.5f, Pos.y + Size.y * 0.5f);
  }
  Vec2 GetWorkCenter() const {
    return Vec2(WorkPos.x + WorkSize.x * 0.5f, WorkPos.y + WorkSize.y * 0.5f);
  }
};

//-----------------------------------------------------------------------------
// [SECTION] Platform Dependent Interfaces
//-----------------------------------------------------------------------------

// (Optional) Support for IME (Input Method Editor) via the
// io.SetPlatformImeDataFn() function.
struct PlatformImeData {
  bool WantVisible;      // A widget wants the IME to be visible
  Vec2 InputPos;         // Position of the input cursor
  float InputLineHeight; // Line height

  PlatformImeData() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Obsolete functions and types
// (Will be removed! Read 'API BREAKING CHANGES' section in gui.cpp for
// details) Please keep your copy of dear gui up to date! Occasionally set
// '#define GUI_DISABLE_OBSOLETE_FUNCTIONS' in config.hpp to stay ahead.
//-----------------------------------------------------------------------------

namespace Gui {
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
GUI_API Key GetKeyIndex(Key key); // map Key_* values into legacy
                                  // native key index. == io.KeyMap[key]
#else
static inline Key GetKeyIndex(Key key) {
  GUI_ASSERT(key >= Key_NamedKey_BEGIN && key < Key_NamedKey_END &&
             "Key and native_index was merged together and native_index is "
             "disabled by GUI_DISABLE_OBSOLETE_KEYIO. Please switch to Key.");
  return key;
}
#endif
} // namespace Gui

#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
namespace Gui {
// OBSOLETED in 1.90.0 (from September 2023)
static inline bool BeginChildFrame(ID id, const Vec2 &size,
                                   WindowFlags window_flags = 0) {
  return BeginChild(id, size, ChildFlags_FrameStyle, window_flags);
}
static inline void EndChildFrame() { EndChild(); }
// static inline bool BeginChild(const char* str_id, const Vec2& size_arg,
// bool border, WindowFlags window_flags){ return BeginChild(str_id,
// size_arg, border ? ChildFlags_Border : ChildFlags_None,
// window_flags); } // Unnecessary as true == ChildFlags_Border static
// inline bool BeginChild(ID id, const Vec2& size_arg, bool border,
// WindowFlags window_flags)        { return BeginChild(id, size_arg,
// border ? ChildFlags_Border : ChildFlags_None, window_flags);     }
// // Unnecessary as true == ChildFlags_Border
static inline void ShowStackToolWindow(bool *p_open = NULL) {
  ShowIDStackToolWindow(p_open);
}
GUI_API bool
ListBox(const char *label, int *current_item,
        bool (*old_callback)(void *user_data, int idx, const char **out_text),
        void *user_data, int items_count, int height_in_items = -1);
GUI_API bool
Combo(const char *label, int *current_item,
      bool (*old_callback)(void *user_data, int idx, const char **out_text),
      void *user_data, int items_count, int popup_max_height_in_items = -1);
// OBSOLETED in 1.89.7 (from June 2023)
GUI_API void
SetItemAllowOverlap(); // Use SetNextItemAllowOverlap() before item.
// OBSOLETED in 1.89.4 (from March 2023)
static inline void PushAllowKeyboardFocus(bool tab_stop) {
  PushTabStop(tab_stop);
}
static inline void PopAllowKeyboardFocus() { PopTabStop(); }
// OBSOLETED in 1.89 (from August 2022)
GUI_API bool ImageButton(
    TextureID user_texture_id, const Vec2 &size, const Vec2 &uv0 = Vec2(0, 0),
    const Vec2 &uv1 = Vec2(1, 1), int frame_padding = -1,
    const Vec4 &bg_col = Vec4(0, 0, 0, 0),
    const Vec4 &tint_col = Vec4(1, 1, 1,
                                1)); // Use new ImageButton() signature
                                     // (explicit item id, regular FramePadding)
// OBSOLETED in 1.88 (from May 2022)
static inline void CaptureKeyboardFromApp(bool want_capture_keyboard = true) {
  SetNextFrameWantCaptureKeyboard(want_capture_keyboard);
} // Renamed as name was misleading + removed default value.
static inline void CaptureMouseFromApp(bool want_capture_mouse = true) {
  SetNextFrameWantCaptureMouse(want_capture_mouse);
} // Renamed as name was misleading + removed default value.

// Some of the older obsolete names along with their replacement (commented out
// so they are not reported in IDE)
//-- OBSOLETED in 1.86 (from November 2021)
// GUI_API void      CalcListClipping(int items_count, float items_height,
// int* out_items_display_start, int* out_items_display_end); // Code removed,
// see 1.90 for last version of the code. Calculate range of visible items for
// large list of evenly sized items. Prefer using ListClipper.
//-- OBSOLETED in 1.85 (from August 2021)
// static inline float GetWindowContentRegionWidth() { return
// GetWindowContentRegionMax().x - GetWindowContentRegionMin().x; }
//-- OBSOLETED in 1.81 (from February 2021)
// static inline bool  ListBoxHeader(const char* label, const Vec2& size =
// Vec2(0, 0))         { return BeginListBox(label, size); } static inline
// bool  ListBoxHeader(const char* label, int items_count, int height_in_items =
// -1) { float height = GetTextLineHeightWithSpacing() * ((height_in_items < 0 ?
// Min(items_count, 7) : height_in_items) + 0.25f) + GetStyle().FramePadding.y
// * 2.0f; return BeginListBox(label, Vec2(0.0f, height)); } // Helper to
// calculate size from items_count and height_in_items static inline void
// ListBoxFooter()                                                             {
// EndListBox(); }
//-- OBSOLETED in 1.79 (from August 2020)
// static inline void  OpenPopupContextItem(const char* str_id = NULL,
// MouseButton mb = 1)    { OpenPopupOnItemClick(str_id, mb); } // Bool
// return value removed. Use IsWindowAppearing() in BeginPopup() instead.
// Renamed in 1.77, renamed back in 1.79. Sorry!
//-- OBSOLETED in 1.78 (from June 2020): Old drag/sliders functions that took a
//'float power > 1.0f' argument instead of SliderFlags_Logarithmic. See
// github.com/ocornut/imgui/issues/3361 for details. GUI_API bool
// DragScalar(const char* label, DataType data_type, void* p_data, float
// v_speed, const void* p_min, const void* p_max, const char* format, float
// power = 1.0f)                                                            //
// OBSOLETED in 1.78 (from June 2020) GUI_API bool      DragScalarN(const
// char* label, DataType data_type, void* p_data, int components, float
// v_speed, const void* p_min, const void* p_max, const char* format, float
// power = 1.0f);                                          // OBSOLETED in 1.78
// (from June 2020) GUI_API bool      SliderScalar(const char* label,
// DataType data_type, void* p_data, const void* p_min, const void* p_max,
// const char* format, float power = 1.0f); // OBSOLETED in 1.78 (from June
// 2020) GUI_API bool      SliderScalarN(const char* label, DataType
// data_type, void* p_data, int components, const void* p_min, const void*
// p_max, const char* format, float power = 1.0f); // OBSOLETED in 1.78 (from
// June 2020) static inline bool  DragFloat(const char* label, float* v, float
// v_speed, float v_min, float v_max, const char* format, float power = 1.0f) {
// return DragScalar(label, DataType_Float, v, v_speed, &v_min, &v_max,
// format, power); }     // OBSOLETED in 1.78 (from June 2020) static inline
// bool  DragFloat2(const char* label, float v[2], float v_speed, float v_min,
// float v_max, const char* format, float power = 1.0f) { return
// DragScalarN(label, DataType_Float, v, 2, v_speed, &v_min, &v_max,
// format, power); } // OBSOLETED in 1.78 (from June 2020) static inline bool
// DragFloat3(const char* label, float v[3], float v_speed, float v_min, float
// v_max, const char* format, float power = 1.0f) { return DragScalarN(label,
// DataType_Float, v, 3, v_speed, &v_min, &v_max, format, power); } //
// OBSOLETED in 1.78 (from June 2020) static inline bool  DragFloat4(const char*
// label, float v[4], float v_speed, float v_min, float v_max, const char*
// format, float power = 1.0f) { return DragScalarN(label, DataType_Float,
// v, 4, v_speed, &v_min, &v_max, format, power); } // OBSOLETED in 1.78 (from
// June 2020) static inline bool  SliderFloat(const char* label, float* v, float
// v_min, float v_max, const char* format, float power = 1.0f)                 {
// return SliderScalar(label, DataType_Float, v, &v_min, &v_max, format,
// power); }            // OBSOLETED in 1.78 (from June 2020) static inline bool
// SliderFloat2(const char* label, float v[2], float v_min, float v_max, const
// char* format, float power = 1.0f)              { return SliderScalarN(label,
// DataType_Float, v, 2, &v_min, &v_max, format, power); }        //
// OBSOLETED in 1.78 (from June 2020) static inline bool  SliderFloat3(const
// char* label, float v[3], float v_min, float v_max, const char* format, float
// power = 1.0f)              { return SliderScalarN(label, DataType_Float,
// v, 3, &v_min, &v_max, format, power); }        // OBSOLETED in 1.78 (from
// June 2020) static inline bool  SliderFloat4(const char* label, float v[4],
// float v_min, float v_max, const char* format, float power = 1.0f) { return
// SliderScalarN(label, DataType_Float, v, 4, &v_min, &v_max, format,
// power); }        // OBSOLETED in 1.78 (from June 2020)
//-- OBSOLETED in 1.77 and before
// static inline bool  BeginPopupContextWindow(const char* str_id,
// MouseButton mb, bool over_items) { return
// BeginPopupContextWindow(str_id, mb | (over_items ? 0 :
// PopupFlags_NoOpenOverItems)); } // OBSOLETED in 1.77 (from June 2020)
// static inline void  TreeAdvanceToLabelPos()               {
// SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()); }   //
// OBSOLETED in 1.72 (from July 2019) static inline void
// SetNextTreeNodeOpen(bool open, Cond cond = 0) { SetNextItemOpen(open,
// cond); }                       // OBSOLETED in 1.71 (from June 2019) static
// inline float GetContentRegionAvailWidth()          { return
// GetContentRegionAvail().x; }                               // OBSOLETED
// in 1.70 (from May 2019) static inline DrawList* GetOverlayDrawList() {
// return GetForegroundDrawList(); }                                 //
// OBSOLETED in 1.69 (from Mar 2019) static inline void  SetScrollHere(float
// ratio = 0.5f)     { SetScrollHereY(ratio); } // OBSOLETED in 1.66 (from Nov
// 2018) static inline bool  IsItemDeactivatedAfterChange()        { return
// IsItemDeactivatedAfterEdit(); }                            // OBSOLETED
// in 1.63 (from Aug 2018)
//-- OBSOLETED in 1.60 and before
// static inline bool  IsAnyWindowFocused()                  { return
// IsWindowFocused(FocusedFlags_AnyWindow); }            // OBSOLETED
// in 1.60 (from Apr 2018) static inline bool  IsAnyWindowHovered() { return
// IsWindowHovered(HoveredFlags_AnyWindow); }            // OBSOLETED
// in 1.60 (between Dec 2017 and Apr 2018) static inline void  ShowTestWindow()
// { return ShowDemoWindow(); }                                        //
// OBSOLETED in 1.53 (between Oct 2017 and Dec 2017) static inline bool
// IsRootWindowFocused()                 { return
// IsWindowFocused(FocusedFlags_RootWindow); }           // OBSOLETED
// in 1.53 (between Oct 2017 and Dec 2017) static inline bool
// IsRootWindowOrAnyChildFocused()       { return
// IsWindowFocused(FocusedFlags_RootAndChildWindows); }  // OBSOLETED
// in 1.53 (between Oct 2017 and Dec 2017) static inline void
// SetNextWindowContentWidth(float w)    { SetNextWindowContentSize(Vec2(w,
// 0.0f)); }                      // OBSOLETED in 1.53 (between Oct 2017 and Dec
// 2017) static inline float GetItemsLineHeightWithSpacing()       { return
// GetFrameHeightWithSpacing(); }                             // OBSOLETED
// in 1.53 (between Oct 2017 and Dec 2017) GUI_API bool      Begin(char* name,
// bool* p_open, Vec2 size_first_use, float bg_alpha = -1.0f, WindowFlags
// flags=0); // OBSOLETED in 1.52 (between Aug 2017 and Oct 2017): Equivalent of
// using SetNextWindowSize(size, Cond_FirstUseEver) and
// SetNextWindowBgAlpha(). static inline bool  IsRootWindowOrAnyChildHovered()
// { return IsWindowHovered(HoveredFlags_RootAndChildWindows); }  //
// OBSOLETED in 1.52 (between Aug 2017 and Oct 2017) static inline void
// AlignFirstTextHeightToWidgets()       { AlignTextToFramePadding(); } //
// OBSOLETED in 1.52 (between Aug 2017 and Oct 2017) static inline void
// SetNextWindowPosCenter(Cond c=0) {
// SetNextWindowPos(GetMainViewport()->GetCenter(), c, Vec2(0.5f,0.5f)); } //
// OBSOLETED in 1.52 (between Aug 2017 and Oct 2017) static inline bool
// IsItemHoveredRect()                   { return
// IsItemHovered(HoveredFlags_RectOnly); }               // OBSOLETED
// in 1.51 (between Jun 2017 and Aug 2017) static inline bool
// IsPosHoveringAnyWindow(const Vec2&) { GUI_ASSERT(0); return false; } //
// OBSOLETED in 1.51 (between Jun 2017 and Aug 2017): This was misleading and
// partly broken. You probably want to use the io.WantCaptureMouse flag instead.
// static inline bool  IsMouseHoveringAnyWindow()            { return
// IsWindowHovered(HoveredFlags_AnyWindow); }            // OBSOLETED
// in 1.51 (between Jun 2017 and Aug 2017) static inline bool
// IsMouseHoveringWindow()               { return
// IsWindowHovered(HoveredFlags_AllowWhenBlockedByPopup |
// HoveredFlags_AllowWhenBlockedByActiveItem); }       // OBSOLETED in 1.51
// (between Jun 2017 and Aug 2017)
//-- OBSOLETED in 1.50 and before
// static inline bool  CollapsingHeader(char* label, const char* str_id, bool
// framed = true, bool default_open = false) { return CollapsingHeader(label,
// (default_open ? (1 << 5) : 0)); } // OBSOLETED in 1.49 static inline
// Font*GetWindowFont()                      { return GetFont(); } //
// OBSOLETED in 1.48 static inline float GetWindowFontSize()                   {
// return GetFontSize(); }                                           //
// OBSOLETED in 1.48 static inline void  SetScrollPosHere()                    {
// SetScrollHere(); }                                                //
// OBSOLETED in 1.42
} // namespace Gui

//-- OBSOLETED in 1.82 (from Mars 2021): flags for AddRect(), AddRectFilled(),
// AddImageRounded(), PathRect() typedef DrawFlags DrawCornerFlags; enum
// DrawCornerFlags_
//{
//    DrawCornerFlags_None      = DrawFlags_RoundCornersNone,         // Was
//    == 0 prior to 1.82, this is now == DrawFlags_RoundCornersNone which is
//    != 0 and not implicit DrawCornerFlags_TopLeft   =
//    DrawFlags_RoundCornersTopLeft,      // Was == 0x01 (1 << 0) prior
//    to 1.82. Order matches DrawFlags_NoRoundCorner* flag (we exploit this
//    internally). DrawCornerFlags_TopRight  =
//    DrawFlags_RoundCornersTopRight,     // Was == 0x02 (1 << 1) prior
//    to 1.82. DrawCornerFlags_BotLeft   = DrawFlags_RoundCornersBottomLeft,
//    // Was == 0x04 (1 << 2) prior to 1.82. DrawCornerFlags_BotRight  =
//    DrawFlags_RoundCornersBottomRight,  // Was == 0x08 (1 << 3) prior
//    to 1.82. DrawCornerFlags_All       = DrawFlags_RoundCornersAll, // Was
//    == 0x0F prior to 1.82 DrawCornerFlags_Top       =
//    DrawCornerFlags_TopLeft | DrawCornerFlags_TopRight,
//    DrawCornerFlags_Bot       = DrawCornerFlags_BotLeft |
//    DrawCornerFlags_BotRight, DrawCornerFlags_Left      =
//    DrawCornerFlags_TopLeft | DrawCornerFlags_BotLeft,
//    DrawCornerFlags_Right     = DrawCornerFlags_TopRight |
//    DrawCornerFlags_BotRight,
//};

// RENAMED and MERGED both Key_ModXXX and ModFlags_XXX into
// Mod_XXX (from September 2022) RENAMED KeyModFlags -> ModFlags
// in 1.88 (from April 2022). Exceptionally commented out ahead of obscolescence
// schedule to reduce confusion and because they were not meant to be used in
// the first place.
typedef KeyChord ModFlags; // == int. We generally use KeyChord to mean "a
                           // Key or-ed with any number of Mod_XXX value",
                           // but you may store only mods in there.
enum ModFlags_ {
  ModFlags_None = 0,
  ModFlags_Ctrl = Mod_Ctrl,
  ModFlags_Shift = Mod_Shift,
  ModFlags_Alt = Mod_Alt,
  ModFlags_Super = Mod_Super
};
// typedef KeyChord KeyModFlags; // == int
// enum KeyModFlags_ { KeyModFlags_None = 0, KeyModFlags_Ctrl =
// Mod_Ctrl, KeyModFlags_Shift = Mod_Shift, KeyModFlags_Alt
// = Mod_Alt, KeyModFlags_Super = Mod_Super };

#define GUI_OFFSETOF(_TYPE, _MEMBER)                                           \
  offsetof(_TYPE,                                                              \
           _MEMBER) // OBSOLETED IN 1.90 (now using C++11 standard version)

#endif // #ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS

// RENAMED GUI_DISABLE_METRICS_WINDOW > GUI_DISABLE_DEBUG_TOOLS in 1.88
// (from June 2022)
#if defined(GUI_DISABLE_METRICS_WINDOW) &&                                     \
    !defined(GUI_DISABLE_OBSOLETE_FUNCTIONS) &&                                \
    !defined(GUI_DISABLE_DEBUG_TOOLS)
#define GUI_DISABLE_DEBUG_TOOLS
#endif
#if defined(GUI_DISABLE_METRICS_WINDOW) &&                                     \
    defined(GUI_DISABLE_OBSOLETE_FUNCTIONS)
#error GUI_DISABLE_METRICS_WINDOW was renamed to GUI_DISABLE_DEBUG_TOOLS, please use new name.
#endif

//-----------------------------------------------------------------------------

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning(pop)
#endif

// Include gui_user.h at the end of gui.hpp
// May be convenient for some users to only explicitly include vanilla gui.hpp
// and have extra stuff included.
#ifdef GUI_INCLUDE_GUI_USER_H
#ifdef GUI_USER_H_FILENAME
#include GUI_USER_H_FILENAME
#else
#include "gui_user.h"
#endif
#endif

#endif // #ifndef GUI_DISABLE
       // // dear gui, v1.90.1 WIP
// (internal structures/api)

// You may use this file to debug, understand or extend Dear Gui features but
// we don't provide any guarantee of forward compatibility.

/*

Index of this file:

// [SECTION] Header mess
// [SECTION] Forward declarations
// [SECTION] Context pointer
// [SECTION] STB libraries includes
// [SECTION] Macros
// [SECTION] Generic helpers
// [SECTION] DrawList support
// [SECTION] Widgets support: flags, enums, data structures
// [SECTION] Inputs support
// [SECTION] Clipper support
// [SECTION] Navigation support
// [SECTION] Typing-select support
// [SECTION] Columns support
// [SECTION] Multi-select support
// [SECTION] Docking support
// [SECTION] Viewport support
// [SECTION] Settings support
// [SECTION] Localization support
// [SECTION] Metrics, Debug tools
// [SECTION] Generic context hooks
// [SECTION] Context (main gui context)
// [SECTION] WindowTempData, Window
// [SECTION] Tab bar, Tab item support
// [SECTION] Table support
// [SECTION] Gui internal API
// [SECTION] FontAtlas internal API
// [SECTION] Test Engine specific hooks (gui_test_engine)

*/

#pragma once
#ifndef GUI_DISABLE

//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

// Enable SSE intrinsics if available
#if (defined __SSE__ || defined __x86_64__ || defined _M_X64 ||                \
     (defined(_M_IX86_FP) && (_M_IX86_FP >= 1))) &&                            \
    !defined(GUI_DISABLE_SSE)
#define GUI_ENABLE_SSE
#include <immintrin.h>
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4251) // class 'xxx' needs to have dll-interface to be
                                // used by clients of struct 'xxx' // when
                                // GUI_API is set to__declspec(dllexport)
#pragma warning(                                                               \
    disable : 26812) // The enum type 'xxx' is unscoped. Prefer 'enum class'
                     // over 'enum' (Enum.3). [MSVC Static Analyzer)
#pragma warning(                                                               \
    disable : 26495) // [Static Analyzer] Variable 'XXX' is uninitialized.
                     // Always initialize a member variable (type.6).
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning(disable : 5054) // operator '|': deprecated between enumerations
                                // of different types
#endif
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic push
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored                                               \
    "-Wunknown-warning-option" // warning: unknown warning group 'xxx'
#endif
#pragma clang diagnostic ignored                                               \
    "-Wunknown-pragmas" // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored                                               \
    "-Wfloat-equal" // warning: comparing floating point with == or != is unsafe
                    // // storing and comparing against same constants ok, for
                    // Floor()
#pragma clang diagnostic ignored "-Wunused-function"    // for textedit.hpp
#pragma clang diagnostic ignored "-Wmissing-prototypes" // for textedit.hpp
#pragma clang diagnostic ignored "-Wold-style-cast"
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#pragma clang diagnostic ignored "-Wdouble-promotion"
#pragma clang diagnostic ignored                                               \
    "-Wimplicit-int-float-conversion" // warning: implicit conversion from 'xxx'
                                      // to 'float' may lose precision
#pragma clang diagnostic ignored                                               \
    "-Wmissing-noreturn" // warning: function 'xxx' could be declared with
                         // attribute 'noreturn'
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored                                                 \
    "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored                                                 \
    "-Wclass-memaccess" // [__GNUC__ >= 8] warning: 'memset/memcpy'
                        // clearing/writing an object of type 'xxxx' with no
                        // trivial copy-assignment; use assignment or
                        // value-initialization instead
#endif

// In 1.89.4, we moved the implementation of "courtesy maths operators" from
// gui_internal.hpp in gui.hpp As they are frequently requested, we do not want
// to encourage to many people using gui_internal.hpp
#if defined(GUI_DEFINE_MATH_OPERATORS) &&                                      \
    !defined(GUI_DEFINE_MATH_OPERATORS_IMPLEMENTED)
#error Please '#define GUI_DEFINE_MATH_OPERATORS' _BEFORE_ including gui.hpp!
#endif

// Legacy defines
#ifdef GUI_DISABLE_FORMAT_STRING_FUNCTIONS // Renamed in 1.74
#error Use GUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
#endif
#ifdef GUI_DISABLE_MATH_FUNCTIONS // Renamed in 1.74
#error Use GUI_DISABLE_DEFAULT_MATH_FUNCTIONS
#endif

// Enable stb_truetype by default unless FreeType is enabled.
// You can compile with both by defining both GUI_ENABLE_FREETYPE and
// GUI_ENABLE_STB_TRUETYPE together.
#ifndef GUI_ENABLE_FREETYPE
#define GUI_ENABLE_STB_TRUETYPE
#endif

//-----------------------------------------------------------------------------
// [SECTION] Forward declarations
//-----------------------------------------------------------------------------

struct BitVector;          // Store 1-bit per value
struct Rect;               // An axis-aligned rectangle (2 points)
struct DrawDataBuilder;    // Helper to build a DrawData instance
struct DrawListSharedData; // Data shared between all DrawList instances
struct ColorMod;       // Stacked color modifier, backup of modified data so we
                       // can restore it
struct Context;        // Main Dear Gui context
struct ContextHook;    // Hook for extensions like TestEngine
struct DataVarInfo;    // Variable information (e.g. to avoid style variables
                       // from an enum)
struct DataTypeInfo;   // Type information associated to a DataType enum
struct GroupData;      // Stacked storage data for BeginGroup()/EndGroup()
struct InputTextState; // Internal state of the currently focused/edited
                       // text input box
struct InputTextDeactivateData; // Short term storage to backup text of a
                                // deactivating InputText() while another
                                // is stealing active id
struct LastItemData;            // Status storage for last submitted items
struct LocEntry;                // A localization entry.
struct MenuColumns;             // Simple column measurement, currently used for
                                // MenuItem() only
struct NavItemData;     // Result of a gamepad/keyboard directional navigation
                        // move query result
struct NavTreeNodeData; // Temporary storage for last TreeNode() being a
                        // Left arrow landing candidate.
struct MetricsConfig;   // Storage for ShowMetricsWindow() and DebugNodeXXX()
                        // functions
struct NextWindowData;  // Storage for SetNextWindow** functions
struct NextItemData;    // Storage for SetNextItem** functions
struct OldColumnData;   // Storage data for a single column for legacy
                        // Columns() api
struct OldColumns;      // Storage data for a columns set for legacy Columns()
                        // api
struct PopupData;       // Storage for current popup stack
struct SettingsHandler; // Storage for one type registered in the .ini file
struct StackSizes;      // Storage of stack sizes for debugging/asserting
struct StyleMod;        // Stacked style modifier, backup of modified data so we
                        // can restore it
struct TabBar;          // Storage for a tab bar
struct TabItem;         // Storage for a tab item (within a tab bar)
struct Table;           // Storage for a table
struct TableColumn;     // Storage for one column of a table
struct TableInstanceData; // Storage for one instance of a same table
struct TableTempData;     // Temporary storage for one table (one per table in
                          // the stack), shared between tables.
struct TableSettings;     // Storage for a table .ini settings
struct TableColumnsSettings; // Storage for a column .ini settings
struct TypingSelectState;    // Storage for GetTypingSelectRequest()
struct TypingSelectRequest;  // Storage for GetTypingSelectRequest() (aimed
                             // to be public)
struct Window;               // Storage for one window
struct WindowTempData; // Temporary storage for one window (that's the data
                       // which in theory we could ditch at the end of the
                       // frame, in practice we currently keep it for each
                       // window)
struct WindowSettings; // Storage for a window .ini settings (we keep one
                       // of those even if the actual window wasn't
                       // instanced during this session)

// Enumerations
// Use your programming IDE "Go to definition" facility on the names of the
// center columns to find the actual flags/enum lists.
enum LocKey : int;      // -> enum LocKey              // Enum: a
                        // localization entry for translation.
typedef int LayoutType; // -> enum LayoutType_         // Enum:
                        // Horizontal or vertical

// Flags
typedef int ActivateFlags;     // -> enum ActivateFlags_      // Flags:
                               // for navigation/focus function (will be for
                               // ActivateItem() later)
typedef int DebugLogFlags;     // -> enum DebugLogFlags_      // Flags:
                               // for ShowDebugLogWindow(), g.DebugLogFlags
typedef int FocusRequestFlags; // -> enum FocusRequestFlags_  //
                               // Flags: for FocusWindow();
typedef int InputFlags;        // -> enum InputFlags_         // Flags: for
                        // IsKeyPressed(), IsMouseClicked(), SetKeyOwner(),
                        // SetItemKeyOwner() etc.
typedef int ItemFlags;           // -> enum ItemFlags_          // Flags: for
                                 // PushItemFlag(), g.LastItemData.InFlags
typedef int ItemStatusFlags;     // -> enum ItemStatusFlags_    // Flags:
                                 // for g.LastItemData.StatusFlags
typedef int OldColumnFlags;      // -> enum OldColumnFlags_     // Flags:
                                 // for BeginColumns()
typedef int NavHighlightFlags;   // -> enum NavHighlightFlags_  //
                                 // Flags: for RenderNavHighlight()
typedef int NavMoveFlags;        // -> enum NavMoveFlags_       // Flags: for
                                 // navigation requests
typedef int NextItemDataFlags;   // -> enum NextItemDataFlags_  //
                                 // Flags: for SetNextItemXXX() functions
typedef int NextWindowDataFlags; // -> enum NextWindowDataFlags_//
                                 // Flags: for SetNextWindowXXX() functions
typedef int ScrollFlags;         // -> enum ScrollFlags_        // Flags: for
                                 // ScrollToItem() and navigation requests
typedef int SeparatorFlags;      // -> enum SeparatorFlags_     // Flags:
                                 // for SeparatorEx()
typedef int TextFlags;    // -> enum TextFlags_          // Flags: for TextEx()
typedef int TooltipFlags; // -> enum TooltipFlags_       // Flags: for
                          // BeginTooltipEx()
typedef int TypingSelectFlags; // -> enum TypingSelectFlags_  //
                               // Flags: for GetTypingSelectRequest()

typedef void (*ErrorLogCallback)(void *user_data, const char *fmt, ...);

//-----------------------------------------------------------------------------
// [SECTION] Context pointer
// See implementation of this variable in gui.cpp for comments and details.
//-----------------------------------------------------------------------------

#ifndef GGui
extern GUI_API Context *GGui; // Current implicit context pointer
#endif

//-------------------------------------------------------------------------
// [SECTION] STB libraries includes
//-------------------------------------------------------------------------

namespace Stb {

#undef IMSTB_TEXTEDIT_STRING
#undef IMSTB_TEXTEDIT_CHARTYPE
#define IMSTB_TEXTEDIT_STRING InputTextState
#define IMSTB_TEXTEDIT_CHARTYPE Wchar
#define IMSTB_TEXTEDIT_GETWIDTH_NEWLINE (-1.0f)
#define IMSTB_TEXTEDIT_UNDOSTATECOUNT 99
#define IMSTB_TEXTEDIT_UNDOCHARCOUNT 999

} // namespace Stb

//-----------------------------------------------------------------------------
// [SECTION] Macros
//-----------------------------------------------------------------------------

// Debug Printing Into TTY
// (since GUI_VERSION_NUM >= 18729: GUI_DEBUG_LOG was reworked into
// GUI_DEBUG_PRINTF (and removed framecount from it). If you were using a
// #define GUI_DEBUG_LOG please rename)
#ifndef GUI_DEBUG_PRINTF
#ifndef GUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
#define GUI_DEBUG_PRINTF(_FMT, ...) printf(_FMT, __VA_ARGS__)
#else
#define GUI_DEBUG_PRINTF(_FMT, ...) ((void)0)
#endif
#endif

// Debug Logging for ShowDebugLogWindow(). This is designed for relatively rare
// events so please don't spam.
#ifndef GUI_DISABLE_DEBUG_TOOLS
#define GUI_DEBUG_LOG(...) Gui::DebugLog(__VA_ARGS__)
#else
#define GUI_DEBUG_LOG(...) ((void)0)
#endif
#define GUI_DEBUG_LOG_ACTIVEID(...)                                            \
  do {                                                                         \
    if (g.DebugLogFlags & DebugLogFlags_EventActiveId)                         \
      GUI_DEBUG_LOG(__VA_ARGS__);                                              \
  } while (0)
#define GUI_DEBUG_LOG_FOCUS(...)                                               \
  do {                                                                         \
    if (g.DebugLogFlags & DebugLogFlags_EventFocus)                            \
      GUI_DEBUG_LOG(__VA_ARGS__);                                              \
  } while (0)
#define GUI_DEBUG_LOG_POPUP(...)                                               \
  do {                                                                         \
    if (g.DebugLogFlags & DebugLogFlags_EventPopup)                            \
      GUI_DEBUG_LOG(__VA_ARGS__);                                              \
  } while (0)
#define GUI_DEBUG_LOG_NAV(...)                                                 \
  do {                                                                         \
    if (g.DebugLogFlags & DebugLogFlags_EventNav)                              \
      GUI_DEBUG_LOG(__VA_ARGS__);                                              \
  } while (0)
#define GUI_DEBUG_LOG_SELECTION(...)                                           \
  do {                                                                         \
    if (g.DebugLogFlags & DebugLogFlags_EventSelection)                        \
      GUI_DEBUG_LOG(__VA_ARGS__);                                              \
  } while (0)
#define GUI_DEBUG_LOG_CLIPPER(...)                                             \
  do {                                                                         \
    if (g.DebugLogFlags & DebugLogFlags_EventClipper)                          \
      GUI_DEBUG_LOG(__VA_ARGS__);                                              \
  } while (0)
#define GUI_DEBUG_LOG_IO(...)                                                  \
  do {                                                                         \
    if (g.DebugLogFlags & DebugLogFlags_EventIO)                               \
      GUI_DEBUG_LOG(__VA_ARGS__);                                              \
  } while (0)

// Static Asserts
#define GUI_STATIC_ASSERT(_COND) static_assert(_COND, "")

// "Paranoid" Debug Asserts are meant to only be enabled during specific
// debugging/work, otherwise would slow down the code too much. We currently
// don't have many of those so the effect is currently negligible, but onward
// intent to add more aggressive ones in the code.
// #define GUI_DEBUG_PARANOID
#ifdef GUI_DEBUG_PARANOID
#define GUI_ASSERT_PARANOID(_EXPR) GUI_ASSERT(_EXPR)
#else
#define GUI_ASSERT_PARANOID(_EXPR)
#endif

// Error handling
// Down the line in some frameworks/languages we would like to have a way to
// redirect those to the programmer and recover from more faults.
#ifndef GUI_ASSERT_USER_ERROR
#define GUI_ASSERT_USER_ERROR(_EXP, _MSG)                                      \
  GUI_ASSERT((_EXP) && _MSG) // Recoverable User Error
#endif

// Misc Macros
#define GUI_PI 3.14159265358979323846f
#ifdef _WIN32
#define GUI_NEWLINE                                                            \
  "\r\n" // Play it nice with Windows users (Update: since 2018-05, Notepad
         // finally appears to support Unix-style carriage returns!)
#else
#define GUI_NEWLINE "\n"
#endif
#ifndef GUI_TABSIZE // Until we move this to runtime and/or add proper tab
                    // support, at least allow users to compile-time override
#define GUI_TABSIZE (4)
#endif
#define GUI_MEMALIGN(_OFF, _ALIGN)                                             \
  (((_OFF) + ((_ALIGN)-1)) &                                                   \
   ~((_ALIGN)-1)) // Memory align e.g. GUI_ALIGN(0,4)=0, GUI_ALIGN(1,4)=4,
                  // GUI_ALIGN(4,4)=4, GUI_ALIGN(5,4)=8
#define GUI_F32_TO_INT8_UNBOUND(_VAL)                                          \
  ((int)((_VAL) * 255.0f +                                                     \
         ((_VAL) >= 0 ? 0.5f : -0.5f))) // Unsaturated, for display purpose
#define GUI_F32_TO_INT8_SAT(_VAL)                                              \
  ((int)(Saturate(_VAL) * 255.0f + 0.5f)) // Saturated, always output 0..255
#define GUI_TRUNC(_VAL)                                                        \
  ((float)(int)(_VAL)) // Trunc() is not inlined in MSVC debug builds
#define GUI_ROUND(_VAL) ((float)(int)((_VAL) + 0.5f)) //
#define GUI_STRINGIFY_HELPER(_X) #_X
#define GUI_STRINGIFY(_X)                                                      \
  GUI_STRINGIFY_HELPER(_X) // Preprocessor idiom to stringify e.g. an integer.
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
#define GUI_FLOOR GUI_TRUNC
#endif

// Enforce cdecl calling convention for functions called by the standard
// library, in case compilation settings changed the default to e.g.
// __vectorcall
#ifdef _MSC_VER
#define GUI_CDECL __cdecl
#else
#define GUI_CDECL
#endif

// Warnings
#if defined(_MSC_VER) && !defined(__clang__)
#define GUI_MSVC_WARNING_SUPPRESS(XXXX) __pragma(warning(suppress : XXXX))
#else
#define GUI_MSVC_WARNING_SUPPRESS(XXXX)
#endif

// Debug Tools
// Use 'Metrics/Debugger->Tools->Item Picker' to break into the call-stack of a
// specific item. This will call GUI_DEBUG_BREAK() which you may redefine
// yourself. See https://github.com/scottt/debugbreak for more reference.
#ifndef GUI_DEBUG_BREAK
#if defined(_MSC_VER)
#define GUI_DEBUG_BREAK() __debugbreak()
#elif defined(__clang__)
#define GUI_DEBUG_BREAK() __builtin_debugtrap()
#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define GUI_DEBUG_BREAK() __asm__ volatile("int $0x03")
#elif defined(__GNUC__) && defined(__thumb__)
#define GUI_DEBUG_BREAK() __asm__ volatile(".inst 0xde01")
#elif defined(__GNUC__) && defined(__arm__) && !defined(__thumb__)
#define GUI_DEBUG_BREAK() __asm__ volatile(".inst 0xe7f001f0");
#else
#define GUI_DEBUG_BREAK()                                                      \
  GUI_ASSERT(                                                                  \
      0) // It is expected that you define GUI_DEBUG_BREAK() into something
// that will break nicely in a debugger!
#endif
#endif // #ifndef GUI_DEBUG_BREAK

// Format specifiers, printing 64-bit hasn't been decently standardized...
// In a real application you should be using PRId64 and PRIu64 from <inttypes.h>
// (non-windows) and on Windows define them yourself.
#if defined(_MSC_VER) && !defined(__clang__)
#define GUI_PRId64 "I64d"
#define GUI_PRIu64 "I64u"
#define GUI_PRIX64 "I64X"
#else
#define GUI_PRId64 "lld"
#define GUI_PRIu64 "llu"
#define GUI_PRIX64 "llX"
#endif

//-----------------------------------------------------------------------------
// [SECTION] Generic helpers
// Note that the XXX helpers functions are lower-level than Gui functions.
// Gui functions or the Gui context are never called/used from other XXX
// functions.
//-----------------------------------------------------------------------------
// - Helpers: Hashing
// - Helpers: Sorting
// - Helpers: Bit manipulation
// - Helpers: String
// - Helpers: Formatting
// - Helpers: UTF-8 <> wchar conversions
// - Helpers: Vec2/Vec4 operators
// - Helpers: Maths
// - Helpers: Geometry
// - Helper: Vec1
// - Helper: Vec2ih
// - Helper: Rect
// - Helper: BitArray
// - Helper: BitVector
// - Helper:Span<>,SpanAllocator<>
// - Helper: Pool<>
// - Helper: ChunkStream<>
// - Helper: TextIndex
//-----------------------------------------------------------------------------

// Helpers: Hashing
GUI_API ID HashData(const void *data, size_t data_size, ID seed = 0);
GUI_API ID HashStr(const char *data, size_t data_size = 0, ID seed = 0);

// Helpers: Sorting
#ifndef Qsort
static inline void Qsort(void *base, size_t count, size_t size_of_element,
                         int(GUI_CDECL *compare_func)(void const *,
                                                      void const *)) {
  if (count > 1)
    qsort(base, count, size_of_element, compare_func);
}
#endif

// Helpers: Color Blending
GUI_API U32 AlphaBlendColors(U32 col_a, U32 col_b);

// Helpers: Bit manipulation
static inline bool IsPowerOfTwo(int v) { return v != 0 && (v & (v - 1)) == 0; }
static inline bool IsPowerOfTwo(U64 v) { return v != 0 && (v & (v - 1)) == 0; }
static inline int UpperPowerOfTwo(int v) {
  v--;
  v |= v >> 1;
  v |= v >> 2;
  v |= v >> 4;
  v |= v >> 8;
  v |= v >> 16;
  v++;
  return v;
}

// Helpers: String
GUI_API int Stricmp(const char *str1,
                    const char *str2); // Case insensitive compare.
GUI_API int
Strnicmp(const char *str1, const char *str2,
         size_t count); // Case insensitive compare to a certain count.
GUI_API void Strncpy(char *dst, const char *src,
                     size_t count);    // Copy to a certain count and always
                                       // zero terminate (strncpy doesn't).
GUI_API char *Strdup(const char *str); // Duplicate a string.
GUI_API char *Strdupcpy(
    char *dst, size_t *p_dst_size,
    const char *str); // Copy in provided buffer, recreate buffer if needed.
GUI_API const char *
StrchrRange(const char *str_begin, const char *str_end,
            char c); // Find first occurrence of 'c' in string range.
GUI_API const char *StreolRange(const char *str,
                                const char *str_end); // End end-of-line
GUI_API const char *
Stristr(const char *haystack, const char *haystack_end, const char *needle,
        const char *needle_end); // Find a substring in a string range.
GUI_API void
StrTrimBlanks(char *str); // Remove leading and trailing blanks from a buffer.
GUI_API inline const char *StrSkipBlank(const char *str) {
  while (str[0] == ' ' || str[0] == '\t')
    str++;
  return str;
}
// Find first non-blank character.
GUI_API inline int StrlenW(const Wchar *str) {
  // return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when
  // wchar_t are 16-bit
  int n = 0;
  while (*str++)
    n++;
  return n;
}
// Computer string length (Wchar string)
GUI_API inline const Wchar *StrbolW(const Wchar *buf_mid_line,
                                    const Wchar *buf_begin) {
  while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')
    buf_mid_line--;
  return buf_mid_line;
}
// Find beginning-of-line (Wchar string)
GUI_MSVC_RUNTIME_CHECKS_OFF
static inline char ToUpper(char c) {
  return (c >= 'a' && c <= 'z') ? c &= ~32 : c;
}
static inline bool CharIsBlankA(char c) { return c == ' ' || c == '\t'; }
static inline bool CharIsBlankW(unsigned int c) {
  return c == ' ' || c == '\t' || c == 0x3000;
}
GUI_MSVC_RUNTIME_CHECKS_RESTORE

// Helpers: Formatting
GUI_API int FormatString(char *buf, size_t buf_size, const char *fmt, ...)
    GUI_FMTARGS(3);
GUI_API int FormatStringV(char *buf, size_t buf_size, const char *fmt,
                          va_list args) GUI_FMTLIST(3);
GUI_API void FormatStringToTempBuffer(const char **out_buf,
                                      const char **out_buf_end, const char *fmt,
                                      ...) GUI_FMTARGS(3);
GUI_API void FormatStringToTempBufferV(const char **out_buf,
                                       const char **out_buf_end,
                                       const char *fmt, va_list args)
    GUI_FMTLIST(3);
GUI_API inline const char *ParseFormatFindStart(const char *fmt) {
  while (char c = fmt[0]) {
    if (c == '%' && fmt[1] != '%')
      return fmt;
    else if (c == '%')
      fmt++;
    fmt++;
  }
  return fmt;
}

GUI_API inline const char *ParseFormatFindEnd(const char *fmt) {
  // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters
  // qualify as types aka end of the format.
  if (fmt[0] != '%')
    return fmt;
  const unsigned int ignored_uppercase_mask =
      (1 << ('I' - 'A')) | (1 << ('L' - 'A'));
  const unsigned int ignored_lowercase_mask =
      (1 << ('h' - 'a')) | (1 << ('j' - 'a')) | (1 << ('l' - 'a')) |
      (1 << ('t' - 'a')) | (1 << ('w' - 'a')) | (1 << ('z' - 'a'));
  for (char c; (c = *fmt) != 0; fmt++) {
    if (c >= 'A' && c <= 'Z' &&
        ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)
      return fmt + 1;
    if (c >= 'a' && c <= 'z' &&
        ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)
      return fmt + 1;
  }
  return fmt;
}

GUI_API const char *ParseFormatTrimDecorations(const char *format, char *buf,
                                               size_t buf_size);
GUI_API void ParseFormatSanitizeForPrinting(const char *fmt_in, char *fmt_out,
                                            size_t fmt_out_size);
GUI_API const char *ParseFormatSanitizeForScanning(const char *fmt_in,
                                                   char *fmt_out,
                                                   size_t fmt_out_size);
GUI_API int ParseFormatPrecision(const char *format, int default_value);

// Helpers: UTF-8 <> wchar conversions
GUI_API const char *TextCharToUtf8(char out_buf[5],
                                   unsigned int c); // return out_buf
GUI_API int
TextStrToUtf8(char *out_buf, int out_buf_size, const Wchar *in_text,
              const Wchar *in_text_end); // return output UTF-8 bytes count
GUI_API int TextCharFromUtf8(
    unsigned int *out_char, const char *in_text,
    const char
        *in_text_end); // read one character. return input UTF-8 bytes count
GUI_API inline int TextStrFromUtf8(Wchar *buf, int buf_size,
                                   const char *in_text, const char *in_text_end,
                                   const char **in_text_remaining = NULL) {
  Wchar *buf_out = buf;
  Wchar *buf_end = buf + buf_size;
  while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) &&
         *in_text) {
    unsigned int c;
    in_text += TextCharFromUtf8(&c, in_text, in_text_end);
    *buf_out++ = (Wchar)c;
  }
  *buf_out = 0;
  if (in_text_remaining)
    *in_text_remaining = in_text;
  return (int)(buf_out - buf);
}
// return input UTF-8 bytes count
GUI_API inline int TextCountCharsFromUtf8(const char *in_text,
                                          const char *in_text_end) {
  int char_count = 0;
  while ((!in_text_end || in_text < in_text_end) && *in_text) {
    unsigned int c;
    in_text += TextCharFromUtf8(&c, in_text, in_text_end);
    char_count++;
  }
  return char_count;
}
// return number of UTF-8 code-points (NOT bytes count)
GUI_API inline int TextCountUtf8BytesFromChar(const char *in_text,
                                              const char *in_text_end) {
  unsigned int unused = 0;
  return TextCharFromUtf8(&unused, in_text, in_text_end);
}
// return number of bytes to express one char in UTF-8
GUI_API int TextCountUtf8BytesFromStr(
    const Wchar *in_text,
    const Wchar
        *in_text_end); // return number of bytes to express string in UTF-8
GUI_API inline const char *
TextFindPreviousUtf8Codepoint(const char *in_text_start,
                              const char *in_text_curr) {
  while (in_text_curr > in_text_start) {
    in_text_curr--;
    if ((*in_text_curr & 0xC0) != 0x80)
      return in_text_curr;
  }
  return in_text_start;
}
// return previous UTF-8 code-point.

// Helpers: File System
#ifdef GUI_DISABLE_FILE_FUNCTIONS
#define GUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef void *FileHandle;
static inline FileHandle FileOpen(const char *, const char *) { return NULL; }
static inline bool FileClose(FileHandle) { return false; }
static inlineU64 FileGetSize(FileHandle) { return (U64)-1; }
static inlineU64 FileRead(void *, U64, U64, FileHandle) { return 0; }
static inlineU64 FileWrite(const void *, U64, U64, FileHandle) { return 0; }
#endif
#ifndef GUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef FILE *FileHandle;
GUI_API FileHandle FileOpen(const char *filename, const char *mode);
GUI_API bool FileClose(FileHandle file);
GUI_API U64 FileGetSize(FileHandle file);
GUI_API U64 FileRead(void *data, U64 size, U64 count, FileHandle file);
GUI_API U64 FileWrite(const void *data, U64 size, U64 count, FileHandle file);
#else
#define GUI_DISABLE_TTY_FUNCTIONS // Can't use stdout, fflush if we are not
                                  // using default file functions
#endif
GUI_API void *FileLoadToMemory(const char *filename, const char *mode,
                               size_t *out_file_size = NULL,
                               int padding_bytes = 0);

// Helpers: Maths
GUI_MSVC_RUNTIME_CHECKS_OFF
// - Wrapper for standard libs functions. (Note that gui_demo.cpp does _not_
// use them to keep the code easy to copy)
#ifndef GUI_DISABLE_DEFAULT_MATH_FUNCTIONS
#define Fabs(X) fabsf(X)
#define Sqrt(X) sqrtf(X)
#define Fmod(X, Y) fmodf((X), (Y))
#define Cos(X) cosf(X)
#define Sin(X) sinf(X)
#define Acos(X) acosf(X)
#define Atan2(Y, X) atan2f((Y), (X))
#define Atof(STR) atof(STR)
#define Ceil(X) ceilf(X)
static inline float Pow(float x, float y) {
  return powf(x, y);
} // DragBehaviorT/SliderBehaviorT uses Pow with either float/double and need
  // the precision
static inline double Pow(double x, double y) { return pow(x, y); }
static inline float Log(float x) {
  return logf(x);
} // DragBehaviorT/SliderBehaviorT uses Log with either float/double and need
  // the precision
static inline double Log(double x) { return log(x); }
static inline int Abs(int x) { return x < 0 ? -x : x; }
static inline float Abs(float x) { return fabsf(x); }
static inline double Abs(double x) { return fabs(x); }
static inline float Sign(float x) {
  return (x < 0.0f) ? -1.0f : (x > 0.0f) ? 1.0f : 0.0f;
} // Sign operator - returns -1, 0 or 1 based on sign of argument
static inline double Sign(double x) {
  return (x < 0.0) ? -1.0 : (x > 0.0) ? 1.0 : 0.0;
}
#ifdef GUI_ENABLE_SSE
static inline float Rsqrt(float x) {
  return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x)));
}
#else
static inline float Rsqrt(float x) { return 1.0f / sqrtf(x); }
#endif
static inline double Rsqrt(double x) { return 1.0 / sqrt(x); }
#endif
// - Min/Max/Clamp/Lerp/Swap are used by widgets which support variety
// of types: signed/unsigned int/long long float/double (Exceptionally using
// templates here but we could also redefine them for those types)
template <typename T> static inline T Min(T lhs, T rhs) {
  return lhs < rhs ? lhs : rhs;
}
template <typename T> static inline T Max(T lhs, T rhs) {
  return lhs >= rhs ? lhs : rhs;
}
template <typename T> static inline T Clamp(T v, T mn, T mx) {
  return (v < mn) ? mn : (v > mx) ? mx : v;
}
template <typename T> static inline T Lerp(T a, T b, float t) {
  return (T)(a + (b - a) * t);
}
template <typename T> static inline void Swap(T &a, T &b) {
  T tmp = a;
  a = b;
  b = tmp;
}
template <typename T> static inline T AddClampOverflow(T a, T b, T mn, T mx) {
  if (b < 0 && (a < mn - b))
    return mn;
  if (b > 0 && (a > mx - b))
    return mx;
  return a + b;
}
template <typename T> static inline T SubClampOverflow(T a, T b, T mn, T mx) {
  if (b > 0 && (a < mn + b))
    return mn;
  if (b < 0 && (a > mx + b))
    return mx;
  return a - b;
}
// - Misc maths helpers
static inline Vec2 Min(const Vec2 &lhs, const Vec2 &rhs) {
  return Vec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y);
}
static inline Vec2 Max(const Vec2 &lhs, const Vec2 &rhs) {
  return Vec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y);
}
static inline Vec2 Clamp(const Vec2 &v, const Vec2 &mn, Vec2 mx) {
  return Vec2((v.x < mn.x)   ? mn.x
              : (v.x > mx.x) ? mx.x
                             : v.x,
              (v.y < mn.y)   ? mn.y
              : (v.y > mx.y) ? mx.y
                             : v.y);
}
static inline Vec2 Lerp(const Vec2 &a, const Vec2 &b, float t) {
  return Vec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
}
static inline Vec2 Lerp(const Vec2 &a, const Vec2 &b, const Vec2 &t) {
  return Vec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y);
}
static inline Vec4 Lerp(const Vec4 &a, const Vec4 &b, float t) {
  return Vec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t,
              a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t);
}
static inline float Saturate(float f) {
  return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f;
}
static inline float LengthSqr(const Vec2 &lhs) {
  return (lhs.x * lhs.x) + (lhs.y * lhs.y);
}
static inline float LengthSqr(const Vec4 &lhs) {
  return (lhs.x * lhs.x) + (lhs.y * lhs.y) + (lhs.z * lhs.z) + (lhs.w * lhs.w);
}
static inline float InvLength(const Vec2 &lhs, float fail_value) {
  float d = (lhs.x * lhs.x) + (lhs.y * lhs.y);
  if (d > 0.0f)
    return Rsqrt(d);
  return fail_value;
}
static inline float Trunc(float f) { return (float)(int)(f); }
static inline Vec2 Trunc(const Vec2 &v) {
  return Vec2((float)(int)(v.x), (float)(int)(v.y));
}
static inline float Floor(float f) {
  return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1);
} // Decent replacement for floorf()
static inline Vec2 Floor(const Vec2 &v) { return Vec2(Floor(v.x), Floor(v.y)); }
static inline int ModPositive(int a, int b) { return (a + b) % b; }
static inline float Dot(const Vec2 &a, const Vec2 &b) {
  return a.x * b.x + a.y * b.y;
}
static inline Vec2 Rotate(const Vec2 &v, float cos_a, float sin_a) {
  return Vec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a);
}
static inline float LinearSweep(float current, float target, float speed) {
  if (current < target)
    return Min(current + speed, target);
  if (current > target)
    return Max(current - speed, target);
  return current;
}
static inline Vec2 Mul(const Vec2 &lhs, const Vec2 &rhs) {
  return Vec2(lhs.x * rhs.x, lhs.y * rhs.y);
}
static inline bool IsFloatAboveGuaranteedIntegerPrecision(float f) {
  return f <= -16777216 || f >= 16777216;
}
static inline float ExponentialMovingAverage(float avg, float sample, int n) {
  avg -= avg / n;
  avg += sample / n;
  return avg;
}
GUI_MSVC_RUNTIME_CHECKS_RESTORE

// Helpers: Geometry
GUI_API inline Vec2 BezierCubicCalc(const Vec2 &p1, const Vec2 &p2,
                                    const Vec2 &p3, const Vec2 &p4, float t) {
  float u = 1.0f - t;
  float w1 = u * u * u;
  float w2 = 3 * u * u * t;
  float w3 = 3 * u * t * t;
  float w4 = t * t * t;
  return Vec2(w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x,
              w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y);
}

GUI_API Vec2 BezierCubicClosestPoint(
    const Vec2 &p1, const Vec2 &p2, const Vec2 &p3, const Vec2 &p4,
    const Vec2 &p,
    int num_segments); // For curves with explicit number of segments
GUI_API Vec2 BezierCubicClosestPointCasteljau(
    const Vec2 &p1, const Vec2 &p2, const Vec2 &p3, const Vec2 &p4,
    const Vec2 &p, float tess_tol); // For auto-tessellated curves you can use
                                    // tess_tol = style.CurveTessellationTol
GUI_API inline Vec2 BezierQuadraticCalc(const Vec2 &p1, const Vec2 &p2,
                                        const Vec2 &p3, float t) {
  float u = 1.0f - t;
  float w1 = u * u;
  float w2 = 2 * u * t;
  float w3 = t * t;
  return Vec2(w1 * p1.x + w2 * p2.x + w3 * p3.x,
              w1 * p1.y + w2 * p2.y + w3 * p3.y);
}

GUI_API Vec2 LineClosestPoint(const Vec2 &a, const Vec2 &b, const Vec2 &p);
GUI_API inline bool TriangleContainsPoint(const Vec2 &a, const Vec2 &b,
                                          const Vec2 &c, const Vec2 &p) {
  bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
  bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;
  bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;
  return ((b1 == b2) && (b2 == b3));
}

GUI_API Vec2 TriangleClosestPoint(const Vec2 &a, const Vec2 &b, const Vec2 &c,
                                  const Vec2 &p);
GUI_API void TriangleBarycentricCoords(const Vec2 &a, const Vec2 &b,
                                       const Vec2 &c, const Vec2 &p,
                                       float &out_u, float &out_v,
                                       float &out_w);
inline float TriangleArea(const Vec2 &a, const Vec2 &b, const Vec2 &c) {
  return Fabs((a.x * (b.y - c.y)) + (b.x * (c.y - a.y)) + (c.x * (a.y - b.y))) *
         0.5f;
}

// Helper: Vec1 (1D vector)
// (this odd construct is used to facilitate the transition between 1D and 2D,
// and the maintenance of some branches/patches)
GUI_MSVC_RUNTIME_CHECKS_OFF
struct Vec1 {
  float x;
  constexpr Vec1() : x(0.0f) {}
  constexpr Vec1(float _x) : x(_x) {}
};

// Helper: Vec2ih (2D vector, half-size integer, for long-term packed storage)
struct Vec2ih {
  short x, y;
  constexpr Vec2ih() : x(0), y(0) {}
  constexpr Vec2ih(short _x, short _y) : x(_x), y(_y) {}
  constexpr explicit Vec2ih(const Vec2 &rhs)
      : x((short)rhs.x), y((short)rhs.y) {}
};

// Helper: Rect (2D axis aligned bounding-box)
// NB: we can't rely on Vec2 math operators being available here!
struct GUI_API Rect {
  Vec2 Min; // Upper-left
  Vec2 Max; // Lower-right

  constexpr Rect() : Min(0.0f, 0.0f), Max(0.0f, 0.0f) {}
  constexpr Rect(const Vec2 &min, const Vec2 &max) : Min(min), Max(max) {}
  constexpr Rect(const Vec4 &v) : Min(v.x, v.y), Max(v.z, v.w) {}
  constexpr Rect(float x1, float y1, float x2, float y2)
      : Min(x1, y1), Max(x2, y2) {}

  Vec2 GetCenter() const {
    return Vec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f);
  }
  Vec2 GetSize() const { return Vec2(Max.x - Min.x, Max.y - Min.y); }
  float GetWidth() const { return Max.x - Min.x; }
  float GetHeight() const { return Max.y - Min.y; }
  float GetArea() const { return (Max.x - Min.x) * (Max.y - Min.y); }
  Vec2 GetTL() const { return Min; }                // Top-left
  Vec2 GetTR() const { return Vec2(Max.x, Min.y); } // Top-right
  Vec2 GetBL() const { return Vec2(Min.x, Max.y); } // Bottom-left
  Vec2 GetBR() const { return Max; }                // Bottom-right
  bool Contains(const Vec2 &p) const {
    return p.x >= Min.x && p.y >= Min.y && p.x < Max.x && p.y < Max.y;
  }
  bool Contains(const Rect &r) const {
    return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x &&
           r.Max.y <= Max.y;
  }
  bool ContainsWithPad(const Vec2 &p, const Vec2 &pad) const {
    return p.x >= Min.x - pad.x && p.y >= Min.y - pad.y &&
           p.x < Max.x + pad.x && p.y < Max.y + pad.y;
  }
  bool Overlaps(const Rect &r) const {
    return r.Min.y < Max.y && r.Max.y > Min.y && r.Min.x < Max.x &&
           r.Max.x > Min.x;
  }
  void Add(const Vec2 &p) {
    if (Min.x > p.x)
      Min.x = p.x;
    if (Min.y > p.y)
      Min.y = p.y;
    if (Max.x < p.x)
      Max.x = p.x;
    if (Max.y < p.y)
      Max.y = p.y;
  }
  void Add(const Rect &r) {
    if (Min.x > r.Min.x)
      Min.x = r.Min.x;
    if (Min.y > r.Min.y)
      Min.y = r.Min.y;
    if (Max.x < r.Max.x)
      Max.x = r.Max.x;
    if (Max.y < r.Max.y)
      Max.y = r.Max.y;
  }
  void Expand(const float amount) {
    Min.x -= amount;
    Min.y -= amount;
    Max.x += amount;
    Max.y += amount;
  }
  void Expand(const Vec2 &amount) {
    Min.x -= amount.x;
    Min.y -= amount.y;
    Max.x += amount.x;
    Max.y += amount.y;
  }
  void Translate(const Vec2 &d) {
    Min.x += d.x;
    Min.y += d.y;
    Max.x += d.x;
    Max.y += d.y;
  }
  void TranslateX(float dx) {
    Min.x += dx;
    Max.x += dx;
  }
  void TranslateY(float dy) {
    Min.y += dy;
    Max.y += dy;
  }
  void ClipWith(const Rect &r) {
    Min = ::Max(Min, r.Min);
    Max = ::Min(Max, r.Max);
  } // Simple version, may lead to an inverted rectangle, which is fine for
    // Contains/Overlaps test but not for display.
  void ClipWithFull(const Rect &r) {
    Min = Clamp(Min, r.Min, r.Max);
    Max = Clamp(Max, r.Min, r.Max);
  } // Full version, ensure both points are fully clipped.
  void Floor() {
    Min.x = GUI_TRUNC(Min.x);
    Min.y = GUI_TRUNC(Min.y);
    Max.x = GUI_TRUNC(Max.x);
    Max.y = GUI_TRUNC(Max.y);
  }
  bool IsInverted() const { return Min.x > Max.x || Min.y > Max.y; }
  Vec4 ToVec4() const { return Vec4(Min.x, Min.y, Max.x, Max.y); }
};

// Helper: BitArray
#define GUI_BITARRAY_TESTBIT(_ARRAY, _N)                                       \
  ((_ARRAY[(_N) >> 5] & ((U32)1 << ((_N) & 31))) !=                            \
   0) // Macro version of BitArrayTestBit(): ensure args have side-effect or
      // are costly!
#define GUI_BITARRAY_CLEARBIT(_ARRAY, _N)                                      \
  ((_ARRAY[(_N) >> 5] &=                                                       \
    ~((U32)1 << ((_N) & 31)))) // Macro version of BitArrayClearBit(): ensure
                               // args have side-effect or are costly!
inline size_t BitArrayGetStorageSizeInBytes(int bitcount) {
  return (size_t)((bitcount + 31) >> 5) << 2;
}
inline void BitArrayClearAllBits(U32 *arr, int bitcount) {
  memset(arr, 0, BitArrayGetStorageSizeInBytes(bitcount));
}
inline bool BitArrayTestBit(const U32 *arr, int n) {
  U32 mask = (U32)1 << (n & 31);
  return (arr[n >> 5] & mask) != 0;
}
inline void BitArrayClearBit(U32 *arr, int n) {
  U32 mask = (U32)1 << (n & 31);
  arr[n >> 5] &= ~mask;
}
inline void BitArraySetBit(U32 *arr, int n) {
  U32 mask = (U32)1 << (n & 31);
  arr[n >> 5] |= mask;
}
inline void BitArraySetBitRange(U32 *arr, int n,
                                int n2) // Works on range [n..n2)
{
  n2--;
  while (n <= n2) {
    int a_mod = (n & 31);
    int b_mod = (n2 > (n | 31) ? 31 : (n2 & 31)) + 1;
    U32 mask = (U32)(((U64)1 << b_mod) - 1) & ~(U32)(((U64)1 << a_mod) - 1);
    arr[n >> 5] |= mask;
    n = (n + 32) & ~31;
  }
}

typedef U32 *BitArrayPtr; // Name for use in structs

// Helper: BitArray class (wrapper over BitArray functions)
// Store 1-bit per value.
template <int BITCOUNT, int OFFSET = 0> struct BitArray {
  U32 Storage[(BITCOUNT + 31) >> 5];
  BitArray() { ClearAllBits(); }
  void ClearAllBits() { memset(Storage, 0, sizeof(Storage)); }
  void SetAllBits() { memset(Storage, 255, sizeof(Storage)); }
  bool TestBit(int n) const {
    n += OFFSET;
    GUI_ASSERT(n >= 0 && n < BITCOUNT);
    return GUI_BITARRAY_TESTBIT(Storage, n);
  }
  void SetBit(int n) {
    n += OFFSET;
    GUI_ASSERT(n >= 0 && n < BITCOUNT);
    BitArraySetBit(Storage, n);
  }
  void ClearBit(int n) {
    n += OFFSET;
    GUI_ASSERT(n >= 0 && n < BITCOUNT);
    BitArrayClearBit(Storage, n);
  }
  void SetBitRange(int n, int n2) {
    n += OFFSET;
    n2 += OFFSET;
    GUI_ASSERT(n >= 0 && n < BITCOUNT && n2 > n && n2 <= BITCOUNT);
    BitArraySetBitRange(Storage, n, n2);
  } // Works on range [n..n2)
  bool operator[](int n) const {
    n += OFFSET;
    GUI_ASSERT(n >= 0 && n < BITCOUNT);
    return GUI_BITARRAY_TESTBIT(Storage, n);
  }
};

// Helper: BitVector
// Store 1-bit per value.
struct GUI_API BitVector {
  Vector<U32> Storage;
  void Create(int sz) {
    Storage.resize((sz + 31) >> 5);
    memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0]));
  }
  void Clear() { Storage.clear(); }
  bool TestBit(int n) const {
    GUI_ASSERT(n < (Storage.Size << 5));
    return GUI_BITARRAY_TESTBIT(Storage.Data, n);
  }
  void SetBit(int n) {
    GUI_ASSERT(n < (Storage.Size << 5));
    BitArraySetBit(Storage.Data, n);
  }
  void ClearBit(int n) {
    GUI_ASSERT(n < (Storage.Size << 5));
    BitArrayClearBit(Storage.Data, n);
  }
};
GUI_MSVC_RUNTIME_CHECKS_RESTORE

// Helper:Span<>
// Pointing to a span of data we don't own.
template <typename T> struct Span {
  T *Data;
  T *DataEnd;

  // Constructors, destructor
  inline Span() { Data = DataEnd = NULL; }
  inline Span(T *data, int size) {
    Data = data;
    DataEnd = data + size;
  }
  inline Span(T *data, T *data_end) {
    Data = data;
    DataEnd = data_end;
  }

  inline void set(T *data, int size) {
    Data = data;
    DataEnd = data + size;
  }
  inline void set(T *data, T *data_end) {
    Data = data;
    DataEnd = data_end;
  }
  inline int size() const { return (int)(ptrdiff_t)(DataEnd - Data); }
  inline int size_in_bytes() const {
    return (int)(ptrdiff_t)(DataEnd - Data) * (int)sizeof(T);
  }
  inline T &operator[](int i) {
    T *p = Data + i;
    GUI_ASSERT(p >= Data && p < DataEnd);
    return *p;
  }
  inline const T &operator[](int i) const {
    const T *p = Data + i;
    GUI_ASSERT(p >= Data && p < DataEnd);
    return *p;
  }

  inline T *begin() { return Data; }
  inline const T *begin() const { return Data; }
  inline T *end() { return DataEnd; }
  inline const T *end() const { return DataEnd; }

  // Utilities
  inline int index_from_ptr(const T *it) const {
    GUI_ASSERT(it >= Data && it < DataEnd);
    const ptrdiff_t off = it - Data;
    return (int)off;
  }
};

// Helper:SpanAllocator<>
// Facilitate storing multiple chunks into a single large block (the "arena")
// - Usage: call Reserve() N times, allocate GetArenaSizeInBytes() worth, pass
// it to SetArenaBasePtr(), call GetSpan() N times to retrieve the aligned
// ranges.
template <int CHUNKS> struct SpanAllocator {
  char *BasePtr;
  int CurrOff;
  int CurrIdx;
  int Offsets[CHUNKS];
  int Sizes[CHUNKS];

  SpanAllocator() { memset(this, 0, sizeof(*this)); }
  inline void Reserve(int n, size_t sz, int a = 4) {
    GUI_ASSERT(n == CurrIdx && n < CHUNKS);
    CurrOff = GUI_MEMALIGN(CurrOff, a);
    Offsets[n] = CurrOff;
    Sizes[n] = (int)sz;
    CurrIdx++;
    CurrOff += (int)sz;
  }
  inline int GetArenaSizeInBytes() { return CurrOff; }
  inline void SetArenaBasePtr(void *base_ptr) { BasePtr = (char *)base_ptr; }
  inline void *GetSpanPtrBegin(int n) {
    GUI_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS);
    return (void *)(BasePtr + Offsets[n]);
  }
  inline void *GetSpanPtrEnd(int n) {
    GUI_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS);
    return (void *)(BasePtr + Offsets[n] + Sizes[n]);
  }
  template <typename T> inline void GetSpan(int n, Span<T> *span) {
    span->set((T *)GetSpanPtrBegin(n), (T *)GetSpanPtrEnd(n));
  }
};

// Helper: Pool<>
// Basic keyed storage for contiguous instances, slow/amortized insertion, O(1)
// indexable, O(Log N) queries by ID over a dense/hot buffer, Honor
// constructor/destructor. Add/remove invalidate all pointers. Indexes have the
// same lifetime as the associated object.
typedef int PoolIdx;
template <typename T> struct Pool {
  Vector<T> Buf;      // Contiguous data
  Storage Map;        // ID->Index
  PoolIdx FreeIdx;    // Next free idx to use
  PoolIdx AliveCount; // Number of active/alive items (for display purpose)

  Pool() { FreeIdx = AliveCount = 0; }
  ~Pool() { Clear(); }
  T *GetByKey(ID key) {
    int idx = Map.GetInt(key, -1);
    return (idx != -1) ? &Buf[idx] : NULL;
  }
  T *GetByIndex(PoolIdx n) { return &Buf[n]; }
  PoolIdx GetIndex(const T *p) const {
    GUI_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size);
    return (PoolIdx)(p - Buf.Data);
  }
  T *GetOrAddByKey(ID key) {
    int *p_idx = Map.GetIntRef(key, -1);
    if (*p_idx != -1)
      return &Buf[*p_idx];
    *p_idx = FreeIdx;
    return Add();
  }
  bool Contains(const T *p) const {
    return (p >= Buf.Data && p < Buf.Data + Buf.Size);
  }
  void Clear() {
    for (int n = 0; n < Map.Data.Size; n++) {
      int idx = Map.Data[n].val_i;
      if (idx != -1)
        Buf[idx].~T();
    }
    Map.Clear();
    Buf.clear();
    FreeIdx = AliveCount = 0;
  }
  T *Add() {
    int idx = FreeIdx;
    if (idx == Buf.Size) {
      Buf.resize(Buf.Size + 1);
      FreeIdx++;
    } else {
      FreeIdx = *(int *)&Buf[idx];
    }
    GUI_PLACEMENT_NEW(&Buf[idx]) T();
    AliveCount++;
    return &Buf[idx];
  }
  void Remove(ID key, const T *p) { Remove(key, GetIndex(p)); }
  void Remove(ID key, PoolIdx idx) {
    Buf[idx].~T();
    *(int *)&Buf[idx] = FreeIdx;
    FreeIdx = idx;
    Map.SetInt(key, -1);
    AliveCount--;
  }
  void Reserve(int capacity) {
    Buf.reserve(capacity);
    Map.Data.reserve(capacity);
  }

  // To iterate a Pool: for (int n = 0; n < pool.GetMapSize(); n++) if (T* t =
  // pool.TryGetMapData(n)) { ... } Can be avoided if you know .Remove() has
  // never been called on the pool, or AliveCount == GetMapSize()
  int GetAliveCount() const {
    return AliveCount;
  } // Number of active/alive items in the pool (for display purpose)
  int GetBufSize() const { return Buf.Size; }
  int GetMapSize() const {
    return Map.Data.Size;
  } // It is the map we need iterate to find valid items, since we don't have
    // "alive" storage anywhere
  T *TryGetMapData(PoolIdx n) {
    int idx = Map.Data[n].val_i;
    if (idx == -1)
      return NULL;
    return GetByIndex(idx);
  }
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
  int GetSize() {
    return GetMapSize();
  } // For Plot: should use GetMapSize() from (GUI_VERSION_NUM >= 18304)
#endif
};

// Helper: ChunkStream<>
// Build and iterate a contiguous stream of variable-sized structures.
// This is used by Settings to store persistent data while reducing allocation
// count. We store the chunk size first, and align the final size on 4 bytes
// boundaries. The tedious/zealous amount of casting is to avoid -Wcast-align
// warnings.
template <typename T> struct ChunkStream {
  Vector<char> Buf;

  void clear() { Buf.clear(); }
  bool empty() const { return Buf.Size == 0; }
  int size() const { return Buf.Size; }
  T *alloc_chunk(size_t sz) {
    size_t HDR_SZ = 4;
    sz = GUI_MEMALIGN(HDR_SZ + sz, 4u);
    int off = Buf.Size;
    Buf.resize(off + (int)sz);
    ((int *)(void *)(Buf.Data + off))[0] = (int)sz;
    return (T *)(void *)(Buf.Data + off + (int)HDR_SZ);
  }
  T *begin() {
    size_t HDR_SZ = 4;
    if (!Buf.Data)
      return NULL;
    return (T *)(void *)(Buf.Data + HDR_SZ);
  }
  T *next_chunk(T *p) {
    size_t HDR_SZ = 4;
    GUI_ASSERT(p >= begin() && p < end());
    p = (T *)(void *)((char *)(void *)p + chunk_size(p));
    if (p == (T *)(void *)((char *)end() + HDR_SZ))
      return (T *)0;
    GUI_ASSERT(p < end());
    return p;
  }
  int chunk_size(const T *p) { return ((const int *)p)[-1]; }
  T *end() { return (T *)(void *)(Buf.Data + Buf.Size); }
  int offset_from_ptr(const T *p) {
    GUI_ASSERT(p >= begin() && p < end());
    const ptrdiff_t off = (const char *)p - Buf.Data;
    return (int)off;
  }
  T *ptr_from_offset(int off) {
    GUI_ASSERT(off >= 4 && off < Buf.Size);
    return (T *)(void *)(Buf.Data + off);
  }
  void swap(ChunkStream<T> &rhs) { rhs.Buf.swap(Buf); }
};

// Helper: TextIndex<>
// Maintain a line index for a text buffer. This is a strong candidate to be
// moved into the public API.
struct TextIndex {
  Vector<int> LineOffsets;
  int EndOffset = 0; // Because we don't own text buffer we need to maintain
                     // EndOffset (may bake in LineOffsets?)

  void clear() {
    LineOffsets.clear();
    EndOffset = 0;
  }
  int size() { return LineOffsets.Size; }
  const char *get_line_begin(const char *base, int n) {
    return base + LineOffsets[n];
  }
  const char *get_line_end(const char *base, int n) {
    return base +
           (n + 1 < LineOffsets.Size ? (LineOffsets[n + 1] - 1) : EndOffset);
  }
  void append(const char *base, int old_size, int new_size);
};

//-----------------------------------------------------------------------------
// [SECTION] DrawList support
//-----------------------------------------------------------------------------

// DrawList: Helper function to calculate a circle's segment count given its
// radius and a "maximum error" value. Estimation of number of circle segment
// based on error is derived using method described in
// https://stackoverflow.com/a/2244088/15194693 Number of segments (N) is
// calculated using equation:
//   N = ceil ( pi / acos(1 - error / r) )     where r > 0, error <= r
// Our equation is significantly simpler that one in the post thanks for
// choosing segment that is perpendicular to X axis. Follow steps in the article
// from this starting condition and you will will get this result.
//
// Rendering circles with an odd number of segments, while mathematically
// correct will produce asymmetrical results on the raster grid. Therefore we're
// rounding N to next even number (7->8, 8->8, 9->10 etc.)
#define GUI_ROUNDUP_TO_EVEN(_V) ((((_V) + 1) / 2) * 2)
#define GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN 4
#define GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX 512
#define GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD, _MAXERROR)                 \
  Clamp(GUI_ROUNDUP_TO_EVEN(                                                   \
            (int)Ceil(GUI_PI / Acos(1 - Min((_MAXERROR), (_RAD)) / (_RAD)))),  \
        GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN,                                  \
        GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)

// Raw equation from GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC rewritten for 'r' and
// 'error'.
#define GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N, _MAXERROR)                 \
  ((_MAXERROR) / (1 - Cos(GUI_PI / Max((float)(_N), GUI_PI))))
#define GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_ERROR(_N, _RAD)                  \
  ((1 - Cos(GUI_PI / Max((float)(_N), GUI_PI))) / (_RAD))

// DrawList: Lookup table size for adaptive arc drawing, cover full circle.
#ifndef GUI_DRAWLIST_ARCFAST_TABLE_SIZE
#define GUI_DRAWLIST_ARCFAST_TABLE_SIZE 48 // Number of samples in lookup table.
#endif
#define GUI_DRAWLIST_ARCFAST_SAMPLE_MAX                                        \
  GUI_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360
                                  // angle.

// Data shared between all DrawList instances
// You may want to create your own instance of this if you want to use
// DrawList completely without Gui. In that case, watch out for future
// changes to this structure.
struct GUI_API DrawListSharedData {
  Vec2 TexUvWhitePixel; // UV of white pixel in the atlas
  Font
      *Font; // Current/default font (optional, for simplified AddText overload)
  float FontSize; // Current/default font size (optional, for simplified AddText
                  // overload)
  float CurveTessellationTol;  // Tessellation tolerance when using
                               // PathBezierCurveTo()
  float CircleSegmentMaxError; // Number of circle segments to use per pixel of
                               // radius for AddCircle() etc
  Vec4 ClipRectFullscreen;     // Value for PushClipRectFullscreen()
  DrawListFlags InitialFlags;  // Initial flags at the beginning of the frame
                               // (it is possible to alter flags on a
                               // per-drawlist basis afterwards)

  // [Internal] Temp write buffer
  Vector<Vec2> TempBuffer;

  // [Internal] Lookup tables
  Vec2 ArcFastVtx[GUI_DRAWLIST_ARCFAST_TABLE_SIZE]; // Sample points on the
                                                    // quarter of the circle.
  float ArcFastRadiusCutoff;  // Cutoff radius after which arc drawing will
                              // fallback to slower PathArcTo()
  U8 CircleSegmentCounts[64]; // Precomputed segment count for given radius
                              // before we calculate it dynamically (to avoid
                              // calculation overhead)
  const Vec4 *TexUvLines;     // UV of anti-aliased lines in the atlas

  DrawListSharedData();
  void SetCircleTessellationMaxError(float max_error);
};

struct DrawDataBuilder {
  Vector<DrawList *> *Layers[2]; // Pointers to global layers for: regular,
                                 // tooltip. LayersP[0] is owned by DrawData.
  Vector<DrawList *> LayerData1;

  DrawDataBuilder() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Widgets support: flags, enums, data structures
//-----------------------------------------------------------------------------

// Flags used by upcoming items
// - input: PushItemFlag() manipulates g.CurrentItemFlags, ItemAdd() calls may
// add extra flags.
// - output: stored in g.LastItemData.InFlags
// Current window shared by all windows.
// This is going to be exposed in gui.hpp when stabilized enough.
enum ItemFlags_ {
  // Controlled by user
  ItemFlags_None = 0,
  ItemFlags_NoTabStop =
      1 << 0, // false     // Disable keyboard tabbing. This is a "lighter"
              // version of ItemFlags_NoNav.
  ItemFlags_ButtonRepeat =
      1 << 1, // false     // Button() will return true multiple times based on
              // io.KeyRepeatDelay and io.KeyRepeatRate settings.
  ItemFlags_Disabled =
      1 << 2, // false     // Disable interactions but doesn't affect visuals.
              // See BeginDisabled()/EndDisabled(). See
              // github.com/ocornut/imgui/issues/211
  ItemFlags_NoNav =
      1 << 3, // false     // Disable any form of focusing (keyboard/gamepad
              // directional navigation and SetKeyboardFocusHere() calls)
  ItemFlags_NoNavDefaultFocus =
      1 << 4, // false     // Disable item being a candidate for default focus
              // (e.g. used by title bar items)
  ItemFlags_SelectableDontClosePopup =
      1 << 5, // false     // Disable MenuItem/Selectable() automatically
              // closing their popup window
  ItemFlags_MixedValue =
      1 << 6, // false     // [BETA] Represent a mixed/indeterminate value,
              // generally multi-selection where values differ. Currently only
              // supported by Checkbox() (later should support all sorts of
              // widgets)
  ItemFlags_ReadOnly =
      1 << 7, // false     // [ALPHA] Allow hovering interactions but underlying
              // value is not changed.
  ItemFlags_NoWindowHoverableCheck =
      1 << 8, // false     // Disable hoverable check in ItemHoverable()
  ItemFlags_AllowOverlap =
      1 << 9, // false     // Allow being overlapped by another widget.
              // Not-hovered to Hovered transition deferred by a frame.

  // Controlled by widget code
  ItemFlags_Inputable =
      1 << 10, // false     // [WIP] Auto-activate input mode when tab focused.
               // Currently only used and supported by a few items before it
               // becomes a generic feature.
  ItemFlags_HasSelectionUserData =
      1 << 11, // false     // Set by SetNextItemSelectionUserData()
};

// Status flags for an already submitted item
// - output: stored in g.LastItemData.StatusFlags
enum ItemStatusFlags_ {
  ItemStatusFlags_None = 0,
  ItemStatusFlags_HoveredRect =
      1 << 0, // Mouse position is within item rectangle (does NOT mean that the
              // window is in correct z-order and can be hovered!, this is only
              // one part of the most-common IsItemHovered test)
  ItemStatusFlags_HasDisplayRect = 1
                                   << 1, // g.LastItemData.DisplayRect is valid
  ItemStatusFlags_Edited =
      1 << 2, // Value exposed by item was edited in the current frame (should
              // match the bool return value of most widgets)
  ItemStatusFlags_ToggledSelection =
      1 << 3, // Set when Selectable(), TreeNode() reports toggling a selection.
              // We can't report "Selected", only state changes, in order to
              // easily handle clipping with less issues.
  ItemStatusFlags_ToggledOpen =
      1 << 4, // Set when TreeNode() reports toggling their open state.
  ItemStatusFlags_HasDeactivated =
      1 << 5, // Set if the widget/group is able to provide data for the
              // ItemStatusFlags_Deactivated flag.
  ItemStatusFlags_Deactivated =
      1 << 6, // Only valid if ItemStatusFlags_HasDeactivated is set.
  ItemStatusFlags_HoveredWindow = 1 << 7, // Override the HoveredWindow test to
                                          // allow cross-window hover testing.
  ItemStatusFlags_Visible =
      1 << 8, // [WIP] Set when item is overlapping the current clipping
              // rectangle (Used internally. Please don't use yet: API/system
              // will change as we refactor Itemadd()).
  ItemStatusFlags_HasClipRect = 1 << 9, // g.LastItemData.ClipRect is valid

// Additional status + semantic for TestEngine
#ifdef GUI_ENABLE_TEST_ENGINE
  ItemStatusFlags_Openable = 1 << 20, // Item is an openable (e.g. TreeNode)
  ItemStatusFlags_Opened = 1 << 21,   // Opened status
  ItemStatusFlags_Checkable =
      1 << 22, // Item is a checkable (e.g. CheckBox, MenuItem)
  ItemStatusFlags_Checked = 1 << 23, // Checked status
  ItemStatusFlags_Inputable =
      1 << 24, // Item is a text-inputable (e.g. InputText, SliderXXX, DragXXX)
#endif
};

// Extend HoveredFlags_
enum HoveredFlagsPrivate_ {
  HoveredFlags_DelayMask_ = HoveredFlags_DelayNone | HoveredFlags_DelayShort |
                            HoveredFlags_DelayNormal |
                            HoveredFlags_NoSharedDelay,
  HoveredFlags_AllowedMaskForIsWindowHovered =
      HoveredFlags_ChildWindows | HoveredFlags_RootWindow |
      HoveredFlags_AnyWindow | HoveredFlags_NoPopupHierarchy |
      HoveredFlags_AllowWhenBlockedByPopup |
      HoveredFlags_AllowWhenBlockedByActiveItem | HoveredFlags_ForTooltip |
      HoveredFlags_Stationary,
  HoveredFlags_AllowedMaskForIsItemHovered =
      HoveredFlags_AllowWhenBlockedByPopup |
      HoveredFlags_AllowWhenBlockedByActiveItem |
      HoveredFlags_AllowWhenOverlapped | HoveredFlags_AllowWhenDisabled |
      HoveredFlags_NoNavOverride | HoveredFlags_ForTooltip |
      HoveredFlags_Stationary | HoveredFlags_DelayMask_,
};

// Extend InputTextFlags_
enum InputTextFlagsPrivate_ {
  // [Internal]
  InputTextFlags_Multiline = 1
                             << 26, // For internal use by InputTextMultiline()
  InputTextFlags_NoMarkEdited =
      1 << 27, // For internal use by functions using InputText() before
               // reformatting data
  InputTextFlags_MergedItem =
      1 << 28, // For internal use by TempInputText(), will skip calling
               // ItemAdd(). Require bounding-box to strictly match.
};

// Extend ButtonFlags_
enum ButtonFlagsPrivate_ {
  ButtonFlags_PressedOnClick = 1
                               << 4, // return true on click (mouse down event)
  ButtonFlags_PressedOnClickRelease =
      1 << 5, // [Default] return true on click + release on same item <-- this
              // is what the majority of Button are using
  ButtonFlags_PressedOnClickReleaseAnywhere =
      1 << 6, // return true on click + release even if the release event is not
              // done while hovering the item
  ButtonFlags_PressedOnRelease =
      1 << 7, // return true on release (default requires click+release)
  ButtonFlags_PressedOnDoubleClick =
      1 << 8, // return true on double-click (default requires click+release)
  ButtonFlags_PressedOnDragDropHold =
      1 << 9, // return true when held into while we are drag and dropping
              // another item (used by e.g. tree nodes, collapsing headers)
  ButtonFlags_Repeat = 1 << 10, // hold to repeat
  ButtonFlags_FlattenChildren =
      1 << 11, // allow interactions even if a child window is overlapping
  ButtonFlags_AllowOverlap =
      1 << 12, // require previous frame HoveredId to either match id or be null
               // before being usable.
  ButtonFlags_DontClosePopups =
      1
      << 13, // disable automatically closing parent popup on press // [UNUSED]
  // ButtonFlags_Disabled             = 1 << 14,  // disable interactions
  // -> use BeginDisabled() or ItemFlags_Disabled
  ButtonFlags_AlignTextBaseLine =
      1 << 15, // vertically align button to match text baseline - ButtonEx()
               // only // FIXME: Should be removed and handled by SmallButton(),
               // not possible currently because of DC.CursorPosPrevLine
  ButtonFlags_NoKeyModifiers =
      1 << 16, // disable mouse interaction if a key modifier is held
  ButtonFlags_NoHoldingActiveId =
      1 << 17, // don't set ActiveId while holding the mouse
               // (ButtonFlags_PressedOnClick only)
  ButtonFlags_NoNavFocus =
      1 << 18, // don't override navigation focus when activated (FIXME: this is
               // essentially used everytime an item uses ItemFlags_NoNav,
               // but because legacy specs don't requires LastItemData to be set
               // ButtonBehavior(), we can't poll g.LastItemData.InFlags)
  ButtonFlags_NoHoveredOnFocus =
      1 << 19, // don't report as hovered when nav focus is on this item
  ButtonFlags_NoSetKeyOwner =
      1 << 20, // don't set key/input owner on the initial click (note: mouse
               // buttons are keys! often, the key in question will be
               // Key_MouseLeft!)
  ButtonFlags_NoTestKeyOwner =
      1 << 21, // don't test key/input owner when polling the key (note: mouse
               // buttons are keys! often, the key in question will be
               // Key_MouseLeft!)
  ButtonFlags_PressedOnMask_ =
      ButtonFlags_PressedOnClick | ButtonFlags_PressedOnClickRelease |
      ButtonFlags_PressedOnClickReleaseAnywhere | ButtonFlags_PressedOnRelease |
      ButtonFlags_PressedOnDoubleClick | ButtonFlags_PressedOnDragDropHold,
  ButtonFlags_PressedOnDefault_ = ButtonFlags_PressedOnClickRelease,
};

// Extend ComboFlags_
enum ComboFlagsPrivate_ {
  ComboFlags_CustomPreview = 1 << 20, // enable BeginComboPreview()
};

// Extend SliderFlags_
enum SliderFlagsPrivate_ {
  SliderFlags_Vertical =
      1 << 20, // Should this slider be orientated vertically?
  SliderFlags_ReadOnly = 1 << 21, // Consider using g.NextItemData.ItemFlags
                                  // |= ItemFlags_ReadOnly instead.
};

// Extend SelectableFlags_
enum SelectableFlagsPrivate_ {
  // NB: need to be in sync with last value of SelectableFlags_
  SelectableFlags_NoHoldingActiveID = 1 << 20,
  SelectableFlags_SelectOnNav =
      1 << 21, // (WIP) Auto-select when moved into. This is not exposed in
               // public API as to handle multi-select and modifiers we will
               // need user to explicitly control focus scope. May be replaced
               // with a BeginSelection() API.
  SelectableFlags_SelectOnClick =
      1 << 22, // Override button behavior to react on Click (default is
               // Click+Release)
  SelectableFlags_SelectOnRelease =
      1 << 23, // Override button behavior to react on Release (default is
               // Click+Release)
  SelectableFlags_SpanAvailWidth =
      1 << 24, // Span all avail width even if we declared less for layout
               // purpose. FIXME: We may be able to remove this (added in
               // 6251d379, 2bcafc86 for menus)
  SelectableFlags_SetNavIdOnHover =
      1 << 25, // Set Nav/Focus ID on mouse hover (used by MenuItem)
  SelectableFlags_NoPadWithHalfSpacing =
      1 << 26, // Disable padding each side with ItemSpacing * 0.5f
  SelectableFlags_NoSetKeyOwner =
      1 << 27, // Don't set key/input owner on the initial click (note: mouse
               // buttons are keys! often, the key in question will be
               // Key_MouseLeft!)
};

// Extend TreeNodeFlags_
enum TreeNodeFlagsPrivate_ {
  TreeNodeFlags_ClipLabelForTrailingButton = 1 << 20,
  TreeNodeFlags_UpsideDownArrow = 1
                                  << 21, // (FIXME-WIP) Turn Down arrow into an
                                         // Up arrow, but reversed trees (#6517)
};

enum SeparatorFlags_ {
  SeparatorFlags_None = 0,
  SeparatorFlags_Horizontal =
      1 << 0, // Axis default to current layout type, so generally Horizontal
              // unless e.g. in a menu bar
  SeparatorFlags_Vertical = 1 << 1,
  SeparatorFlags_SpanAllColumns =
      1 << 2, // Make separator cover all columns of a legacy Columns() set.
};

// Flags for FocusWindow(). This is not called FocusFlags to avoid
// confusion with public-facing FocusedFlags.
// FIXME: Once we finishing replacing more uses of
// GetTopMostPopupModal()+IsWindowWithinBeginStackOf() and FindBlockingModal()
// with this, we may want to change the flag to be opt-out instead of opt-in.
enum FocusRequestFlags_ {
  FocusRequestFlags_None = 0,
  FocusRequestFlags_RestoreFocusedChild =
      1 << 0, // Find last focused child (if any) and focus it instead.
  FocusRequestFlags_UnlessBelowModal =
      1 << 1, // Do not set focus if the window is below a modal.
};

enum TextFlags_ {
  TextFlags_None = 0,
  TextFlags_NoWidthForLargeClippedText = 1 << 0,
};

enum TooltipFlags_ {
  TooltipFlags_None = 0,
  TooltipFlags_OverridePrevious =
      1 << 1, // Clear/ignore previously submitted tooltip (defaults to append)
};

// FIXME: this is in development, not exposed/functional as a generic feature
// yet. Horizontal/Vertical enums are fixed to 0/1 so they may be used to index
// Vec2
enum LayoutType_ { LayoutType_Horizontal = 0, LayoutType_Vertical = 1 };

enum LogType {
  LogType_None = 0,
  LogType_TTY,
  LogType_File,
  LogType_Buffer,
  LogType_Clipboard,
};

// X/Y enums are fixed to 0/1 so they may be used to index Vec2
enum Axis { Axis_None = -1, Axis_X = 0, Axis_Y = 1 };

enum PlotType {
  PlotType_Lines,
  PlotType_Histogram,
};

enum PopupPositionPolicy {
  PopupPositionPolicy_Default,
  PopupPositionPolicy_ComboBox,
  PopupPositionPolicy_Tooltip,
};

struct DataVarInfo {
  DataType Type;
  U32 Count;  // 1+
  U32 Offset; // Offset in parent structure
  void *GetVarPtr(void *parent) const {
    return (void *)((unsigned char *)parent + Offset);
  }
};

struct DataTypeTempStorage {
  U8 Data[8]; // Can fit any data up to DataType_COUNT
};

// Type information associated to one DataType. Retrieve with
// DataTypeGetInfo().
struct DataTypeInfo {
  size_t Size;          // Size in bytes
  const char *Name;     // Short descriptive name for the type, for debugging
  const char *PrintFmt; // Default printf format for the type
  const char *ScanFmt;  // Default scanf format for the type
};

// Extend DataType_
enum DataTypePrivate_ {
  DataType_String = DataType_COUNT + 1,
  DataType_Pointer,
  DataType_ID,
};

// Stacked color modifier, backup of modified data so we can restore it
struct ColorMod {
  Col Col;
  Vec4 BackupValue;
};

// Stacked style modifier, backup of modified data so we can restore it. Data
// type inferred from the variable.
struct StyleMod {
  StyleVar VarIdx;
  union {
    int BackupInt[2];
    float BackupFloat[2];
  };
  StyleMod(StyleVar idx, int v) {
    VarIdx = idx;
    BackupInt[0] = v;
  }
  StyleMod(StyleVar idx, float v) {
    VarIdx = idx;
    BackupFloat[0] = v;
  }
  StyleMod(StyleVar idx, Vec2 v) {
    VarIdx = idx;
    BackupFloat[0] = v.x;
    BackupFloat[1] = v.y;
  }
};

// Storage data for BeginComboPreview()/EndComboPreview()
struct GUI_API ComboPreviewData {
  Rect PreviewRect;
  Vec2 BackupCursorPos;
  Vec2 BackupCursorMaxPos;
  Vec2 BackupCursorPosPrevLine;
  float BackupPrevLineTextBaseOffset;
  LayoutType BackupLayout;

  ComboPreviewData() { memset(this, 0, sizeof(*this)); }
};

// Stacked storage data for BeginGroup()/EndGroup()
struct GUI_API GroupData {
  ID WindowID;
  Vec2 BackupCursorPos;
  Vec2 BackupCursorMaxPos;
  Vec2 BackupCursorPosPrevLine;
  Vec1 BackupIndent;
  Vec1 BackupGroupOffset;
  Vec2 BackupCurrLineSize;
  float BackupCurrLineTextBaseOffset;
  ID BackupActiveIdIsAlive;
  bool BackupActiveIdPreviousFrameIsAlive;
  bool BackupHoveredIdIsAlive;
  bool BackupIsSameLine;
  bool EmitItem;
};

// Simple column measurement, currently used for MenuItem() only.. This is very
// short-sighted/throw-away code and NOT a generic helper.
struct GUI_API MenuColumns {
  U32 TotalWidth;
  U32 NextTotalWidth;
  U16 Spacing;
  U16 OffsetIcon;  // Always zero for now
  U16 OffsetLabel; // Offsets are locked in Update()
  U16 OffsetShortcut;
  U16 OffsetMark;
  U16 Widths[4]; // Width of:   Icon, Label, Shortcut, Mark  (accumulators for
                 // current frame)

  MenuColumns() { memset(this, 0, sizeof(*this)); }
  void Update(float spacing, bool window_reappearing);
  float DeclColumns(float w_icon, float w_label, float w_shortcut,
                    float w_mark) {
    Widths[0] = Max(Widths[0], (U16)w_icon);
    Widths[1] = Max(Widths[1], (U16)w_label);
    Widths[2] = Max(Widths[2], (U16)w_shortcut);
    Widths[3] = Max(Widths[3], (U16)w_mark);
    CalcNextTotalWidth(false);
    return (float)Max(TotalWidth, NextTotalWidth);
  }

  void CalcNextTotalWidth(bool update_offsets) {
    U16 offset = 0;
    bool want_spacing = false;
    for (int i = 0; i < GUI_ARRAYSIZE(Widths); i++) {
      U16 width = Widths[i];
      if (want_spacing && width > 0)
        offset += Spacing;
      want_spacing |= (width > 0);
      if (update_offsets) {
        if (i == 1) {
          OffsetLabel = offset;
        }
        if (i == 2) {
          OffsetShortcut = offset;
        }
        if (i == 3) {
          OffsetMark = offset;
        }
      }
      offset += width;
    }
    NextTotalWidth = offset;
  }
};

// Internal temporary state for deactivating InputText() instances.
struct GUI_API InputTextDeactivatedState {
  ID ID; // widget id owning the text state (which just got deactivated)
  Vector<char> TextA; // text buffer

  InputTextDeactivatedState() { memset(this, 0, sizeof(*this)); }
  void ClearFreeMemory() {
    ID = 0;
    TextA.clear();
  }
};
// Internal state of the currently focused/edited text input box
// For a given item ID, access with Gui::GetInputTextState()
struct GUI_API InputTextState {
  Context *Ctx; // parent UI context (needs to be set explicitly by parent).
  ID ID;        // widget id owning the text state
  int CurLenW,
      CurLenA; // we need to maintain our buffer length in both UTF-8 and wchar
               // format. UTF-8 length is valid even if TextA is not.
  Vector<Wchar> TextW; // edit buffer, we need to persist but can't
                       // guarantee the persistence of the user-provided
                       // buffer. so we copy into own buffer.
  Vector<char>
      TextA; // temporary UTF8 buffer for callbacks and other operations. this
             // is not updated in every code-path! size=capacity.
  Vector<char> InitialTextA; // backup of end-user buffer at the time of focus
                             // (in UTF-8, unaltered)
  bool TextAIsValid; // temporary UTF8 buffer is not initially valid before we
                     // make the widget active (until then we pull the data from
                     // user argument)
  int BufCapacityA;  // end-user buffer capacity
  float ScrollX;     // horizontal scrolling/offset
  STB_TexteditState Stb; // state for textedit.hpp
  float CursorAnim; // timer for cursor blink, reset on every user action so the
                    // cursor reappears immediately
  bool CursorFollow; // set when we want scrolling to follow the current cursor
                     // position (not always!)
  bool SelectedAllMouseLock; // after a double-click to select all, we ignore
                             // further mouse drags to update selection
  bool Edited;               // edited this frame
  InputTextFlags Flags;      // copy of InputText() flags. may be used to check
                             // if e.g. InputTextFlags_Password is set.

  InputTextState() { memset(this, 0, sizeof(*this)); }
  void ClearText() {
    CurLenW = CurLenA = 0;
    TextW[0] = 0;
    TextA[0] = 0;
    CursorClamp();
  }
  void ClearFreeMemory() {
    TextW.clear();
    TextA.clear();
    InitialTextA.clear();
  }
  int GetUndoAvailCount() const { return Stb.undostate.undo_point; }
  int GetRedoAvailCount() const {
    return IMSTB_TEXTEDIT_UNDOSTATECOUNT - Stb.undostate.redo_point;
  }
  void OnKeyPressed(int key); // Cannot be inline because we call in code in
                              // textedit.hpp implementation

  // Cursor & Selection
  void CursorAnimReset() {
    CursorAnim = -0.30f;
  } // After a user-input the cursor stays on for a while without blinking
  void CursorClamp() {
    Stb.cursor = Min(Stb.cursor, CurLenW);
    Stb.select_start = Min(Stb.select_start, CurLenW);
    Stb.select_end = Min(Stb.select_end, CurLenW);
  }
  bool HasSelection() const { return Stb.select_start != Stb.select_end; }
  void ClearSelection() { Stb.select_start = Stb.select_end = Stb.cursor; }
  int GetCursorPos() const { return Stb.cursor; }
  int GetSelectionStart() const { return Stb.select_start; }
  int GetSelectionEnd() const { return Stb.select_end; }
  void SelectAll() {
    Stb.select_start = 0;
    Stb.cursor = Stb.select_end = CurLenW;
    Stb.has_preferred_x = 0;
  }
};

// Storage for current popup stack
struct PopupData {
  ID PopupId;       // Set on OpenPopup()
  ::Window *Window; // Resolved on BeginPopup() - may stay unresolved if user
                    // never calls OpenPopup()
  ::Window *BackupNavWindow; // Set on OpenPopup(), a NavWindow that will be
                             // restored on popup close
  int ParentNavLayer; // Resolved on BeginPopup(). Actually a NavLayer type
                      // (declared down below), initialized to -1 which is not
                      // part of an enum, but serves well-enough as "not any of
                      // layers" value
  int OpenFrameCount; // Set on OpenPopup()
  ID OpenParentId;    // Set on OpenPopup(), we need this to differentiate
                      // multiple menu sets from each others (e.g. inside menu
                      // bar vs loose menu items)
  Vec2 OpenPopupPos;  // Set on OpenPopup(), preferred popup position
                      // (typically == OpenMousePos when using mouse)
  Vec2 OpenMousePos;  // Set on OpenPopup(), copy of mouse position at the time
                      // of opening popup

  PopupData() {
    memset(this, 0, sizeof(*this));
    ParentNavLayer = OpenFrameCount = -1;
  }
};

enum NextWindowDataFlags_ {
  NextWindowDataFlags_None = 0,
  NextWindowDataFlags_HasPos = 1 << 0,
  NextWindowDataFlags_HasSize = 1 << 1,
  NextWindowDataFlags_HasContentSize = 1 << 2,
  NextWindowDataFlags_HasCollapsed = 1 << 3,
  NextWindowDataFlags_HasSizeConstraint = 1 << 4,
  NextWindowDataFlags_HasFocus = 1 << 5,
  NextWindowDataFlags_HasBgAlpha = 1 << 6,
  NextWindowDataFlags_HasScroll = 1 << 7,
  NextWindowDataFlags_HasChildFlags = 1 << 8,
};

// Storage for SetNexWindow** functions
struct NextWindowData {
  NextWindowDataFlags Flags;
  Cond PosCond;
  Cond SizeCond;
  Cond CollapsedCond;
  Vec2 PosVal;
  Vec2 PosPivotVal;
  Vec2 SizeVal;
  Vec2 ContentSizeVal;
  Vec2 ScrollVal;
  ChildFlags ChildFlags;
  bool CollapsedVal;
  Rect SizeConstraintRect;
  SizeCallback SizeCallback;
  void *SizeCallbackUserData;
  float BgAlphaVal;         // Override background alpha
  Vec2 MenuBarOffsetMinVal; // (Always on) This is not exposed publicly, so we
                            // don't clear it and it doesn't have a
                            // corresponding flag (could we? for consistency?)

  NextWindowData() { memset(this, 0, sizeof(*this)); }
  inline void ClearFlags() { Flags = NextWindowDataFlags_None; }
};

// Multi-Selection item index or identifier when using
// SetNextItemSelectionUserData()/BeginMultiSelect() (Most users are likely to
// use this store an item INDEX but this may be used to store a POINTER as
// well.)
typedef S64 SelectionUserData;

enum NextItemDataFlags_ {
  NextItemDataFlags_None = 0,
  NextItemDataFlags_HasWidth = 1 << 0,
  NextItemDataFlags_HasOpen = 1 << 1,
};

struct NextItemData {
  NextItemDataFlags Flags;
  ItemFlags ItemFlags; // Currently only tested/used for ItemFlags_AllowOverlap.
  // Non-flags members are NOT cleared by ItemAdd() meaning they are still valid
  // during NavProcessItem()
  float Width;                         // Set by SetNextItemWidth()
  SelectionUserData SelectionUserData; // Set by SetNextItemSelectionUserData()
                                       // (note that NULL/0 is a valid value, we
                                       // use -1 == SelectionUserData_Invalid to
                                       // mark invalid values)
  Cond OpenCond;
  bool OpenVal; // Set by SetNextItemOpen()

  NextItemData() {
    memset(this, 0, sizeof(*this));
    SelectionUserData = -1;
  }
  inline void ClearFlags() {
    Flags = NextItemDataFlags_None;
    ItemFlags = ItemFlags_None;
  } // Also cleared manually by ItemAdd()!
};

// Status storage for the last submitted item
struct LastItemData {
  ID ID;
  ItemFlags InFlags;           // See ItemFlags_
  ItemStatusFlags StatusFlags; // See ItemStatusFlags_
  Rect Rect;                   // Full rectangle
  ::Rect NavRect;              // Navigation scoring rectangle (not displayed)
  // Rarely used fields are not explicitly cleared, only valid when the
  // corresponding ItemStatusFlags is set.
  ::Rect DisplayRect; // Display rectangle (ONLY VALID IF
                      // ItemStatusFlags_HasDisplayRect is set)
  ::Rect ClipRect; // Clip rectangle at the time of submitting item (ONLY VALID
                   // IF ItemStatusFlags_HasClipRect is set)

  LastItemData() { memset(this, 0, sizeof(*this)); }
};

// Store data emitted by TreeNode() for usage by TreePop() to implement
// TreeNodeFlags_NavLeftJumpsBackHere. This is the minimum amount of data
// that we need to perform the equivalent of NavApplyItemToResult() and which we
// can't infer in TreePop() Only stored when the node is a potential candidate
// for landing on a Left arrow jump.
struct NavTreeNodeData {
  ID ID;
  ItemFlags InFlags;
  Rect NavRect;
};

struct GUI_API StackSizes {
  short SizeOfIDStack;
  short SizeOfColorStack;
  short SizeOfStyleVarStack;
  short SizeOfFontStack;
  short SizeOfFocusScopeStack;
  short SizeOfGroupStack;
  short SizeOfItemFlagsStack;
  short SizeOfBeginPopupStack;
  short SizeOfDisabledStack;

  StackSizes() { memset(this, 0, sizeof(*this)); }
  void SetToContextState(Context *ctx);
  void CompareWithContextState(Context *ctx);
};

// Data saved for each window pushed into the stack
struct WindowStackData {
  Window *Window;
  LastItemData ParentLastItemDataBackup;
  StackSizes StackSizesOnBegin; // Store size of various stacks for asserting
};

struct ShrinkWidthItem {
  int Index;
  float Width;
  float InitialWidth;
};

struct PtrOrIndex {
  void *Ptr; // Either field can be set, not both. e.g. Dock node tab bars are
             // loose while BeginTabBar() ones are in a pool.
  int Index; // Usually index in a main pool.

  PtrOrIndex(void *ptr) {
    Ptr = ptr;
    Index = -1;
  }
  PtrOrIndex(int index) {
    Ptr = NULL;
    Index = index;
  }
};

//-----------------------------------------------------------------------------
// [SECTION] Inputs support
//-----------------------------------------------------------------------------

// Bit array for named keys
typedef BitArray<Key_NamedKey_COUNT, -Key_NamedKey_BEGIN> BitArrayForNamedKeys;

// [Internal] Key ranges
#define Key_LegacyNativeKey_BEGIN 0
#define Key_LegacyNativeKey_END 512
#define Key_Keyboard_BEGIN (Key_NamedKey_BEGIN)
#define Key_Keyboard_END (Key_GamepadStart)
#define Key_Gamepad_BEGIN (Key_GamepadStart)
#define Key_Gamepad_END (Key_GamepadRStickDown + 1)
#define Key_Mouse_BEGIN (Key_MouseLeft)
#define Key_Mouse_END (Key_MouseWheelY + 1)
#define Key_Aliases_BEGIN (Key_Mouse_BEGIN)
#define Key_Aliases_END (Key_Mouse_END)

// [Internal] Named shortcuts for Navigation
#define Key_NavKeyboardTweakSlow Mod_Ctrl
#define Key_NavKeyboardTweakFast Mod_Shift
#define Key_NavGamepadTweakSlow Key_GamepadL1
#define Key_NavGamepadTweakFast Key_GamepadR1
#define Key_NavGamepadActivate Key_GamepadFaceDown
#define Key_NavGamepadCancel Key_GamepadFaceRight
#define Key_NavGamepadMenu Key_GamepadFaceLeft
#define Key_NavGamepadInput Key_GamepadFaceUp

enum InputEventType {
  InputEventType_None = 0,
  InputEventType_MousePos,
  InputEventType_MouseWheel,
  InputEventType_MouseButton,
  InputEventType_Key,
  InputEventType_Text,
  InputEventType_Focus,
  InputEventType_COUNT
};

enum InputSource {
  InputSource_None = 0,
  InputSource_Mouse, // Note: may be Mouse or TouchScreen or Pen. See
                     // io.MouseSource to distinguish them.
  InputSource_Keyboard,
  InputSource_Gamepad,
  InputSource_Clipboard, // Currently only used by InputText()
  InputSource_COUNT
};

// FIXME: Structures in the union below need to be declared as anonymous unions
// appears to be an extension? Using Vec2() would fail on Clang 'union member
// 'MousePos' has a non-trivial default constructor'
struct InputEventMousePos {
  float PosX, PosY;
  MouseSource MouseSource;
};
struct InputEventMouseWheel {
  float WheelX, WheelY;
  MouseSource MouseSource;
};
struct InputEventMouseButton {
  int Button;
  bool Down;
  MouseSource MouseSource;
};
struct InputEventKey {
  Key Key;
  bool Down;
  float AnalogValue;
};
struct InputEventText {
  unsigned int Char;
};
struct InputEventAppFocused {
  bool Focused;
};

struct InputEvent {
  InputEventType Type;
  InputSource Source;
  U32 EventId; // Unique, sequential increasing integer to identify an event
               // (if you need to correlate them to other data).
  union {
    InputEventMousePos MousePos;       // if Type == InputEventType_MousePos
    InputEventMouseWheel MouseWheel;   // if Type == InputEventType_MouseWheel
    InputEventMouseButton MouseButton; // if Type == InputEventType_MouseButton
    InputEventKey Key;                 // if Type == InputEventType_Key
    InputEventText Text;               // if Type == InputEventType_Text
    InputEventAppFocused AppFocused;   // if Type == InputEventType_Focus
  };
  bool AddedByTestEngine;

  InputEvent() { memset(this, 0, sizeof(*this)); }
};

// Input function taking an 'ID owner_id' argument defaults to
// (KeyOwner_Any == 0) aka don't test ownership, which matches legacy
// behavior.
#define KeyOwner_Any                                                           \
  ((ID)0) // Accept key that have an owner, UNLESS a call to SetKeyOwner()
          // explicitly used InputFlags_LockThisFrame or
          // InputFlags_LockUntilRelease.
#define KeyOwner_None ((ID)-1) // Require key to have no owner.

typedef S16 KeyRoutingIndex;

// Routing table entry (sizeof() == 16 bytes)
struct KeyRoutingData {
  KeyRoutingIndex NextEntryIndex;
  U16 Mods; // Technically we'd only need 4-bits but for simplify we store
            // Mod_ values which need 16-bits. Mod_Shortcut is
            // already translated to Ctrl/Super.
  U8 RoutingNextScore; // Lower is better (0: perfect score)
  ID RoutingCurr;
  ID RoutingNext;

  KeyRoutingData() {
    NextEntryIndex = -1;
    Mods = 0;
    RoutingNextScore = 255;
    RoutingCurr = RoutingNext = KeyOwner_None;
  }
};

// Routing table: maintain a desired owner for each possible key-chord (key +
// mods), and setup owner in NewFrame() when mods are matching. Stored in main
// context (1 instance)
struct KeyRoutingTable {
  KeyRoutingIndex
      Index[Key_NamedKey_COUNT]; // Index of first entry in Entries[]
  Vector<KeyRoutingData> Entries;
  Vector<KeyRoutingData> EntriesNext; // Double-buffer to avoid reallocation
                                      // (could use a shared buffer)

  KeyRoutingTable() { Clear(); }
  void Clear() {
    for (int n = 0; n < GUI_ARRAYSIZE(Index); n++)
      Index[n] = -1;
    Entries.clear();
    EntriesNext.clear();
  }
};

// This extends KeyData but only for named keys (legacy keys don't support
// the new features) Stored in main context (1 per named key). In the future it
// might be merged into KeyData.
struct KeyOwnerData {
  ID OwnerCurr;
  ID OwnerNext;
  bool LockThisFrame; // Reading this key requires explicit owner id (until end
                      // of frame). Set by InputFlags_LockThisFrame.
  bool LockUntilRelease; // Reading this key requires explicit owner id (until
                         // key is released). Set by
                         // InputFlags_LockUntilRelease. When this is true
                         // LockThisFrame is always true as well.

  KeyOwnerData() {
    OwnerCurr = OwnerNext = KeyOwner_None;
    LockThisFrame = LockUntilRelease = false;
  }
};

// Flags for extended versions of IsKeyPressed(), IsMouseClicked(), Shortcut(),
// SetKeyOwner(), SetItemKeyOwner() Don't mistake with InputTextFlags! (for
// Gui::InputText() function)
enum InputFlags_ {
  // Flags for IsKeyPressed(), IsMouseClicked(), Shortcut()
  InputFlags_None = 0,
  InputFlags_Repeat = 1 << 0, // Return true on successive repeats. Default
                              // for legacy IsKeyPressed(). NOT Default for
                              // legacy IsMouseClicked(). MUST BE == 1.
  InputFlags_RepeatRateDefault = 1 << 1,  // Repeat rate: Regular (default)
  InputFlags_RepeatRateNavMove = 1 << 2,  // Repeat rate: Fast
  InputFlags_RepeatRateNavTweak = 1 << 3, // Repeat rate: Faster
  InputFlags_RepeatRateMask_ = InputFlags_RepeatRateDefault |
                               InputFlags_RepeatRateNavMove |
                               InputFlags_RepeatRateNavTweak,

  // Flags for SetItemKeyOwner()
  InputFlags_CondHovered =
      1 << 4, // Only set if item is hovered (default to both)
  InputFlags_CondActive = 1
                          << 5, // Only set if item is active (default to both)
  InputFlags_CondDefault_ = InputFlags_CondHovered | InputFlags_CondActive,
  InputFlags_CondMask_ = InputFlags_CondHovered | InputFlags_CondActive,

  // Flags for SetKeyOwner(), SetItemKeyOwner()
  InputFlags_LockThisFrame =
      1 << 6, // Access to key data will require EXPLICIT owner ID
              // (KeyOwner_Any/0 will NOT accepted for polling). Cleared at
              // end of frame. This is useful to make input-owner-aware code
              // steal keys from non-input-owner-aware code.
  InputFlags_LockUntilRelease =
      1 << 7, // Access to key data will require EXPLICIT owner ID
              // (KeyOwner_Any/0 will NOT accepted for polling). Cleared
              // when the key is released or at end of each frame if key is
              // released. This is useful to make input-owner-aware code steal
              // keys from non-input-owner-aware code.

  // Routing policies for Shortcut() + low-level SetShortcutRouting()
  // - The general idea is that several callers register interest in a shortcut,
  // and only one owner gets it.
  // - When a policy (other than _RouteAlways) is set, Shortcut() will register
  // itself with SetShortcutRouting(),
  //   allowing the system to decide where to route the input among other
  //   route-aware calls.
  // - Shortcut() uses InputFlags_RouteFocused by default: meaning that a
  // simple Shortcut() poll
  //   will register a route and only succeed when parent window is in the focus
  //   stack and if no-one with a higher priority is claiming the shortcut.
  // - Using InputFlags_RouteAlways is roughly equivalent to doing e.g.
  // IsKeyPressed(key) + testing mods.
  // - Priorities: GlobalHigh > Focused (when owner is active item) > Global >
  // Focused (when focused window) > GlobalLow.
  // - Can select only 1 policy among all available.
  InputFlags_RouteFocused =
      1 << 8, // (Default) Register focused route: Accept inputs if window is in
              // focus stack. Deep-most focused window takes inputs. ActiveId
              // takes inputs over deep-most focused window.
  InputFlags_RouteGlobalLow =
      1 << 9, // Register route globally (lowest priority: unless a focused
              // window or active item registered the route) -> recommended
              // Global priority.
  InputFlags_RouteGlobal =
      1
      << 10, // Register route globally (medium priority: unless an active item
             // registered the route, e.g. CTRL+A registered by InputText).
  InputFlags_RouteGlobalHigh =
      1 << 11, // Register route globally (highest priority: unlikely you need
               // to use that: will interfere with every active items)
  InputFlags_RouteMask_ =
      InputFlags_RouteFocused | InputFlags_RouteGlobal |
      InputFlags_RouteGlobalLow |
      InputFlags_RouteGlobalHigh, // _Always not part of this!
  InputFlags_RouteAlways = 1
                           << 12, // Do not register route, poll keys directly.
  InputFlags_RouteUnlessBgFocused =
      1 << 13, // Global routes will not be applied if underlying
               // background/void is focused (== no Dear Gui windows are
               // focused). Useful for overlay applications.
  InputFlags_RouteExtraMask_ =
      InputFlags_RouteAlways | InputFlags_RouteUnlessBgFocused,

  // [Internal] Mask of which function support which flags
  InputFlags_SupportedByIsKeyPressed =
      InputFlags_Repeat | InputFlags_RepeatRateMask_,
  InputFlags_SupportedByShortcut =
      InputFlags_Repeat | InputFlags_RepeatRateMask_ | InputFlags_RouteMask_ |
      InputFlags_RouteExtraMask_,
  InputFlags_SupportedBySetKeyOwner =
      InputFlags_LockThisFrame | InputFlags_LockUntilRelease,
  InputFlags_SupportedBySetItemKeyOwner =
      InputFlags_SupportedBySetKeyOwner | InputFlags_CondMask_,
};

//-----------------------------------------------------------------------------
// [SECTION] Clipper support
//-----------------------------------------------------------------------------

// Note that Max is exclusive, so perhaps should be using a Begin/End
// convention.
struct ListClipperRange {
  int Min;
  int Max;
  bool PosToIndexConvert; // Begin/End are absolute position (will be converted
                          // to indices later)
  S8 PosToIndexOffsetMin; // Add to Min after converting to indices
  S8 PosToIndexOffsetMax; // Add to Min after converting to indices

  static ListClipperRange FromIndices(int min, int max) {
    ListClipperRange r = {min, max, false, 0, 0};
    return r;
  }
  static ListClipperRange FromPositions(float y1, float y2, int off_min,
                                        int off_max) {
    ListClipperRange r = {(int)y1, (int)y2, true, (S8)off_min, (S8)off_max};
    return r;
  }
};

// Temporary clipper data, buffers shared/reused between instances
struct ListClipperData {
  ListClipper *ListClipper;
  float LossynessOffset;
  int StepNo;
  int ItemsFrozen;
  Vector<ListClipperRange> Ranges;

  ListClipperData() { memset(this, 0, sizeof(*this)); }
  void Reset(struct ListClipper *clipper) {
    ListClipper = clipper;
    StepNo = ItemsFrozen = 0;
    Ranges.resize(0);
  }
};

//-----------------------------------------------------------------------------
// [SECTION] Navigation support
//-----------------------------------------------------------------------------

enum ActivateFlags_ {
  ActivateFlags_None = 0,
  ActivateFlags_PreferInput =
      1 << 0, // Favor activation that requires keyboard text input (e.g. for
              // Slider/Drag). Default for Enter key.
  ActivateFlags_PreferTweak =
      1
      << 1, // Favor activation for tweaking with arrows or gamepad (e.g. for
            // Slider/Drag). Default for Space key and if keyboard is not used.
  ActivateFlags_TryToPreserveState =
      1 << 2, // Request widget to preserve state if it can (e.g. InputText will
              // try to preserve cursor/selection)
  ActivateFlags_FromTabbing = 1
                              << 3, // Activation requested by a tabbing request
};

// Early work-in-progress API for ScrollToItem()
enum ScrollFlags_ {
  ScrollFlags_None = 0,
  ScrollFlags_KeepVisibleEdgeX =
      1 << 0, // If item is not visible: scroll as little as possible on X axis
              // to bring item back into view [default for X axis]
  ScrollFlags_KeepVisibleEdgeY =
      1 << 1, // If item is not visible: scroll as little as possible on Y axis
              // to bring item back into view [default for Y axis for windows
              // that are already visible]
  ScrollFlags_KeepVisibleCenterX =
      1 << 2, // If item is not visible: scroll to make the item centered on X
              // axis [rarely used]
  ScrollFlags_KeepVisibleCenterY = 1 << 3, // If item is not visible: scroll to
                                           // make the item centered on Y axis
  ScrollFlags_AlwaysCenterX =
      1 << 4, // Always center the result item on X axis [rarely used]
  ScrollFlags_AlwaysCenterY = 1
                              << 5, // Always center the result item on Y axis
                                    // [default for Y axis for appearing window)
  ScrollFlags_NoScrollParent =
      1 << 6, // Disable forwarding scrolling to parent window if required to
              // keep item/rect visible (only scroll window the function was
              // applied to).
  ScrollFlags_MaskX_ = ScrollFlags_KeepVisibleEdgeX |
                       ScrollFlags_KeepVisibleCenterX |
                       ScrollFlags_AlwaysCenterX,
  ScrollFlags_MaskY_ = ScrollFlags_KeepVisibleEdgeY |
                       ScrollFlags_KeepVisibleCenterY |
                       ScrollFlags_AlwaysCenterY,
};

enum NavHighlightFlags_ {
  NavHighlightFlags_None = 0,
  NavHighlightFlags_TypeDefault = 1 << 0,
  NavHighlightFlags_TypeThin = 1 << 1,
  NavHighlightFlags_AlwaysDraw = 1
                                 << 2, // Draw rectangular highlight if (g.NavId
                                       // == id) _even_ when using the mouse.
  NavHighlightFlags_NoRounding = 1 << 3,
};

enum NavMoveFlags_ {
  NavMoveFlags_None = 0,
  NavMoveFlags_LoopX = 1 << 0, // On failed request, restart from opposite side
  NavMoveFlags_LoopY = 1 << 1,
  NavMoveFlags_WrapX =
      1 << 2, // On failed request, request from opposite side one line down
              // (when NavDir==right) or one line up (when NavDir==left)
  NavMoveFlags_WrapY =
      1 << 3, // This is not super useful but provided for completeness
  NavMoveFlags_WrapMask_ = NavMoveFlags_LoopX | NavMoveFlags_LoopY |
                           NavMoveFlags_WrapX | NavMoveFlags_WrapY,
  NavMoveFlags_AllowCurrentNavId =
      1 << 4, // Allow scoring and considering the current NavId as a move
              // target candidate. This is used when the move source is offset
              // (e.g. pressing PageDown actually needs to send a Up move
              // request, if we are pressing PageDown from the bottom-most item
              // we need to stay in place)
  NavMoveFlags_AlsoScoreVisibleSet =
      1 << 5, // Store alternate result in NavMoveResultLocalVisible that only
              // comprise elements that are already fully visible (used by
              // PageUp/PageDown)
  NavMoveFlags_ScrollToEdgeY =
      1 << 6, // Force scrolling to min/max (used by Home/End) // FIXME-NAV: Aim
              // to remove or reword, probably unnecessary
  NavMoveFlags_Forwarded = 1 << 7,
  NavMoveFlags_DebugNoResult =
      1 << 8, // Dummy scoring for debug purpose, don't apply result
  NavMoveFlags_FocusApi =
      1 << 9, // Requests from focus API can land/focus/activate items even if
              // they are marked with _NoTabStop (see
              // NavProcessItemForTabbingRequest() for details)
  NavMoveFlags_IsTabbing = 1 << 10,  // == Focus + Activate if item is
                                     // Inputable + DontChangeNavHighlight
  NavMoveFlags_IsPageMove = 1 << 11, // Identify a PageDown/PageUp request.
  NavMoveFlags_Activate = 1 << 12,   // Activate/select target item.
  NavMoveFlags_NoSelect =
      1 << 13, // Don't trigger selection by not setting g.NavJustMovedTo
  NavMoveFlags_NoSetNavHighlight = 1 << 14, // Do not alter the visible state of
                                            // keyboard vs mouse nav highlight
};

enum NavLayer {
  NavLayer_Main = 0, // Main scrolling layer
  NavLayer_Menu = 1, // Menu layer (access with Alt)
  NavLayer_COUNT
};

struct NavItemData {
  Window *Window; // Init,Move    // Best candidate window
                  // (result->ItemWindow->RootWindowForNav == request->Window)
  ID ID;          // Init,Move    // Best candidate item ID
  ::ID FocusScopeId; // Init,Move    // Best candidate focus scope ID
  Rect RectRel;      // Init,Move    // Best candidate bounding box in window
                     // relative space
  ItemFlags InFlags; // ????,Move    // Best candidate item flags
  SelectionUserData SelectionUserData; // I+Mov    // Best candidate
                                       // SetNextItemSelectionData() value.
  float DistBox; //      Move    // Best candidate box distance to current NavId
  float DistCenter; //      Move    // Best candidate center distance to current
                    //      NavId
  float DistAxial;  //      Move    // Best candidate axial distance to current
                    //      NavId

  NavItemData() { Clear(); }
  void Clear() {
    Window = NULL;
    ID = FocusScopeId = 0;
    InFlags = 0;
    SelectionUserData = -1;
    DistBox = DistCenter = DistAxial = FLT_MAX;
  }
};

//-----------------------------------------------------------------------------
// [SECTION] Typing-select support
//-----------------------------------------------------------------------------

// Flags for GetTypingSelectRequest()
enum TypingSelectFlags_ {
  TypingSelectFlags_None = 0,
  TypingSelectFlags_AllowBackspace =
      1 << 0, // Backspace to delete character inputs. If using: ensure
              // GetTypingSelectRequest() is not called more than once per frame
              // (filter by e.g. focus state)
  TypingSelectFlags_AllowSingleCharMode =
      1 << 1, // Allow "single char" search mode which is activated when
              // pressing the same character multiple times.
};

// Returned by GetTypingSelectRequest(), designed to eventually be public.
struct GUI_API TypingSelectRequest {
  TypingSelectFlags Flags; // Flags passed to GetTypingSelectRequest()
  int SearchBufferLen;
  const char *
      SearchBuffer; // Search buffer contents (use full string. unless
                    // SingleCharMode is set, in which case use SingleCharSize).
  bool SelectRequest; // Set when buffer was modified this frame, requesting a
                      // selection.
  bool
      SingleCharMode; // Notify when buffer contains same character repeated, to
                      // implement special mode. In this situation it preferred
                      // to not display any on-screen search indication.
  S8 SingleCharSize;  // Length in bytes of first letter codepoint (1 for ascii,
                      // 2-4 for UTF-8). If (SearchBufferLen==RepeatCharSize)
                      // only 1 letter has been input.
};

// Storage for GetTypingSelectRequest()
struct GUI_API TypingSelectState {
  TypingSelectRequest Request; // User-facing data
  char SearchBuffer[64];       // Search buffer: no need to make dynamic as this
                               // search is very transient.
  ID FocusScope;
  int LastRequestFrame = 0;
  float LastRequestTime = 0.0f;
  bool SingleCharModeLock =
      false; // After a certain single char repeat count we lock into
             // SingleCharMode. Two benefits: 1) buffer never fill, 2) we can
             // provide an immediate SingleChar mode without timer elapsing.

  TypingSelectState() { memset(this, 0, sizeof(*this)); }
  void Clear() {
    SearchBuffer[0] = 0;
    SingleCharModeLock = false;
  } // We preserve remaining data for easier debugging
};

//-----------------------------------------------------------------------------
// [SECTION] Columns support
//-----------------------------------------------------------------------------

// Flags for internal's BeginColumns(). This is an obsolete API. Prefer using
// BeginTable() nowadays!
enum OldColumnFlags_ {
  OldColumnFlags_None = 0,
  OldColumnFlags_NoBorder = 1 << 0, // Disable column dividers
  OldColumnFlags_NoResize =
      1 << 1, // Disable resizing columns when clicking on the dividers
  OldColumnFlags_NoPreserveWidths =
      1 << 2, // Disable column width preservation when adjusting columns
  OldColumnFlags_NoForceWithinWindow =
      1 << 3, // Disable forcing columns to fit within window
  OldColumnFlags_GrowParentContentsSize =
      1 << 4, // Restore pre-1.51 behavior of extending the parent window
              // contents size but _without affecting the columns width at all_.
              // Will eventually remove.

// Obsolete names (will be removed)
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
// ColumnsFlags_None                    = OldColumnFlags_None,
// ColumnsFlags_NoBorder                = OldColumnFlags_NoBorder,
// ColumnsFlags_NoResize                = OldColumnFlags_NoResize,
// ColumnsFlags_NoPreserveWidths        =
// OldColumnFlags_NoPreserveWidths, ColumnsFlags_NoForceWithinWindow
// = OldColumnFlags_NoForceWithinWindow,
// ColumnsFlags_GrowParentContentsSize  =
// OldColumnFlags_GrowParentContentsSize,
#endif
};

struct OldColumnData {
  float OffsetNorm; // Column start offset, normalized 0.0 (far left) -> 1.0
                    // (far right)
  float OffsetNormBeforeResize;
  OldColumnFlags Flags; // Not exposed
  Rect ClipRect;

  OldColumnData() { memset(this, 0, sizeof(*this)); }
};

struct OldColumns {
  ID ID;
  OldColumnFlags Flags;
  bool IsFirstFrame;
  bool IsBeingResized;
  int Current;
  int Count;
  float OffMinX, OffMaxX; // Offsets from HostWorkRect.Min.x
  float LineMinY, LineMaxY;
  float HostCursorPosY; // Backup of CursorPos at the time of BeginColumns()
  float
      HostCursorMaxPosX; // Backup of CursorMaxPos at the time of BeginColumns()
  Rect HostInitialClipRect; // Backup of ClipRect at the time of BeginColumns()
  Rect HostBackupClipRect;  // Backup of ClipRect during
                            // PushColumnsBackground()/PopColumnsBackground()
  Rect HostBackupParentWorkRect; // Backup of WorkRect at the time of
                                 // BeginColumns()
  Vector<OldColumnData> Columns;
  DrawListSplitter Splitter;

  OldColumns() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Multi-select support
//-----------------------------------------------------------------------------

// We always assume that -1 is an invalid value (which works for indices and
// pointers)
#define SelectionUserData_Invalid ((SelectionUserData)-1)

#ifdef GUI_HAS_MULTI_SELECT
// <this is filled in 'range_select' branch>
#endif // #ifdef GUI_HAS_MULTI_SELECT

//-----------------------------------------------------------------------------
// [SECTION] Docking support
//-----------------------------------------------------------------------------

#ifdef GUI_HAS_DOCK
// <this is filled in 'docking' branch>
#endif // #ifdef GUI_HAS_DOCK

//-----------------------------------------------------------------------------
// [SECTION] Viewport support
//-----------------------------------------------------------------------------

// Viewport Private/Internals fields (cardinal sin: we are using
// inheritance!) Every instance of Viewport is in fact a ViewportP.
struct ViewportP : public Viewport {
  int BgFgDrawListsLastFrame[2]; // Last frame number the background (0) and
                                 // foreground (1) draw lists were used
  DrawList *BgFgDrawLists[2]; // Convenience background (0) and foreground (1)
                              // draw lists. We use them to draw software
                              // mouser cursor when io.MouseDrawCursor is set
                              // and to draw most debug overlays.
  DrawData DrawDataP;
  DrawDataBuilder
      DrawDataBuilder; // Temporary data while building final DrawData
  Vec2
      WorkOffsetMin; // Work Area: Offset from Pos to top-left corner of Work
                     // Area. Generally (0,0) or (0,+main_menu_bar_height). Work
                     // Area is Full Area but without menu-bars/status-bars (so
                     // WorkArea always fit inside Pos/Size!)
  Vec2
      WorkOffsetMax; // Work Area: Offset from Pos+Size to bottom-right corner
                     // of Work Area. Generally (0,0) or (0,-status_bar_height).
  Vec2 BuildWorkOffsetMin; // Work Area: Offset being built during current
                           // frame. Generally >= 0.0f.
  Vec2 BuildWorkOffsetMax; // Work Area: Offset being built during current
                           // frame. Generally <= 0.0f.

  ViewportP() {
    BgFgDrawListsLastFrame[0] = BgFgDrawListsLastFrame[1] = -1;
    BgFgDrawLists[0] = BgFgDrawLists[1] = NULL;
  }
  ~ViewportP() {
    if (BgFgDrawLists[0])
      GUI_DELETE(BgFgDrawLists[0]);
    if (BgFgDrawLists[1])
      GUI_DELETE(BgFgDrawLists[1]);
  }

  // Calculate work rect pos/size given a set of offset (we have 1 pair of
  // offset for rect locked from last frame data, and 1 pair for currently
  // building rect)
  Vec2 CalcWorkRectPos(const Vec2 &off_min) const {
    return Vec2(Pos.x + off_min.x, Pos.y + off_min.y);
  }
  Vec2 CalcWorkRectSize(const Vec2 &off_min, const Vec2 &off_max) const {
    return Vec2(Max(0.0f, Size.x - off_min.x + off_max.x),
                Max(0.0f, Size.y - off_min.y + off_max.y));
  }
  void UpdateWorkRect() {
    WorkPos = CalcWorkRectPos(WorkOffsetMin);
    WorkSize = CalcWorkRectSize(WorkOffsetMin, WorkOffsetMax);
  } // Update public fields

  // Helpers to retrieve Rect (we don't need to store BuildWorkRect as every
  // access tend to change it, hence the code asymmetry)
  Rect GetMainRect() const {
    return Rect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y);
  }
  Rect GetWorkRect() const {
    return Rect(WorkPos.x, WorkPos.y, WorkPos.x + WorkSize.x,
                WorkPos.y + WorkSize.y);
  }
  Rect GetBuildWorkRect() const {
    Vec2 pos = CalcWorkRectPos(BuildWorkOffsetMin);
    Vec2 size = CalcWorkRectSize(BuildWorkOffsetMin, BuildWorkOffsetMax);
    return Rect(pos.x, pos.y, pos.x + size.x, pos.y + size.y);
  }
};

//-----------------------------------------------------------------------------
// [SECTION] Settings support
//-----------------------------------------------------------------------------

// Windows data saved in gui.ini file
// Because we never destroy or rename WindowSettings, we can store the
// names in a separate buffer easily. (this is designed to be stored in a
// ChunkStream buffer, with the variable-length Name following our structure)
struct WindowSettings {
  ID ID;
  Vec2ih Pos;
  Vec2ih Size;
  bool Collapsed;
  bool IsChild;
  bool WantApply;  // Set when loaded from .ini data (to enable merging/loading
                   // .ini data into an already running context)
  bool WantDelete; // Set to invalidate/delete the settings entry

  WindowSettings() { memset(this, 0, sizeof(*this)); }
  char *GetName() { return (char *)(this + 1); }
};

struct SettingsHandler {
  const char *TypeName; // Short description stored in .ini file. Disallowed
                        // characters: '[' ']'
  ID TypeHash;          // == HashStr(TypeName)
  void (*ClearAllFn)(Context *ctx,
                     SettingsHandler *handler); // Clear all settings data
  void (*ReadInitFn)(Context *ctx,
                     SettingsHandler *handler); // Read: Called before reading
                                                // (in registration order)
  void *(*ReadOpenFn)(Context *ctx, SettingsHandler *handler,
                      const char *name); // Read: Called when entering into a
                                         // new ini entry e.g. "[Window][Name]"
  void (*ReadLineFn)(Context *ctx, SettingsHandler *handler, void *entry,
                     const char *line); // Read: Called for every line of text
                                        // within an ini entry
  void (*ApplyAllFn)(Context *ctx,
                     SettingsHandler *handler); // Read: Called after reading
                                                // (in registration order)
  void (*WriteAllFn)(
      Context *ctx, SettingsHandler *handler,
      TextBuffer *out_buf); // Write: Output every entries into 'out_buf'
  void *UserData;

  SettingsHandler() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Localization support
//-----------------------------------------------------------------------------

// This is experimental and not officially supported, it'll probably fall short
// of features, if/when it does we may backtrack.
enum LocKey : int {
  LocKey_VersionStr,
  LocKey_TableSizeOne,
  LocKey_TableSizeAllFit,
  LocKey_TableSizeAllDefault,
  LocKey_TableResetOrder,
  LocKey_WindowingMainMenuBar,
  LocKey_WindowingPopup,
  LocKey_WindowingUntitled,
  LocKey_COUNT
};

struct LocEntry {
  LocKey Key;
  const char *Text;
};

//-----------------------------------------------------------------------------
// [SECTION] Metrics, Debug Tools
//-----------------------------------------------------------------------------

enum DebugLogFlags_ {
  // Event types
  DebugLogFlags_None = 0,
  DebugLogFlags_EventActiveId = 1 << 0,
  DebugLogFlags_EventFocus = 1 << 1,
  DebugLogFlags_EventPopup = 1 << 2,
  DebugLogFlags_EventNav = 1 << 3,
  DebugLogFlags_EventClipper = 1 << 4,
  DebugLogFlags_EventSelection = 1 << 5,
  DebugLogFlags_EventIO = 1 << 6,
  DebugLogFlags_EventMask_ =
      DebugLogFlags_EventActiveId | DebugLogFlags_EventFocus |
      DebugLogFlags_EventPopup | DebugLogFlags_EventNav |
      DebugLogFlags_EventClipper | DebugLogFlags_EventSelection |
      DebugLogFlags_EventIO,
  DebugLogFlags_OutputToTTY = 1 << 10,        // Also send output to TTY
  DebugLogFlags_OutputToTestEngine = 1 << 11, // Also send output to Test Engine
};

struct DebugAllocEntry {
  int FrameCount;
  S16 AllocCount;
  S16 FreeCount;
};

struct DebugAllocInfo {
  int TotalAllocCount; // Number of call to MemAlloc().
  int TotalFreeCount;
  S16 LastEntriesIdx;                // Current index in buffer
  DebugAllocEntry LastEntriesBuf[6]; // Track last 6 frames that had allocations

  DebugAllocInfo() { memset(this, 0, sizeof(*this)); }
};

struct MetricsConfig {
  bool ShowDebugLog = false;
  bool ShowIDStackTool = false;
  bool ShowWindowsRects = false;
  bool ShowWindowsBeginOrder = false;
  bool ShowTablesRects = false;
  bool ShowDrawCmdMesh = true;
  bool ShowDrawCmdBoundingBoxes = true;
  bool ShowAtlasTintedWithTextColor = false;
  int ShowWindowsRectsType = -1;
  int ShowTablesRectsType = -1;
};

struct StackLevelInfo {
  ID ID;
  S8 QueryFrameCount; // >= 1: Query in progress
  bool QuerySuccess;  // Obtained result from DebugHookIdInfo()
  DataType DataType : 8;
  char Desc[57]; // Arbitrarily sized buffer to hold a result (FIXME: could
                 // replace Results[] with a chunk stream?) FIXME: Now that we
                 // added CTRL+C this should be fixed.

  StackLevelInfo() { memset(this, 0, sizeof(*this)); }
};

// State for ID Stack tool queries
struct IDStackTool {
  int LastActiveFrame;
  int StackLevel; // -1: query stack and resize Results, >= 0: individual stack
                  // level
  ID QueryId;     // ID to query details for
  Vector<StackLevelInfo> Results;
  bool CopyToClipboardOnCtrlC;
  float CopyToClipboardLastTime;

  IDStackTool() {
    memset(this, 0, sizeof(*this));
    CopyToClipboardLastTime = -FLT_MAX;
  }
};

//-----------------------------------------------------------------------------
// [SECTION] Generic context hooks
//-----------------------------------------------------------------------------

typedef void (*ContextHookCallback)(Context *ctx, ContextHook *hook);
enum ContextHookType {
  ContextHookType_NewFramePre,
  ContextHookType_NewFramePost,
  ContextHookType_EndFramePre,
  ContextHookType_EndFramePost,
  ContextHookType_RenderPre,
  ContextHookType_RenderPost,
  ContextHookType_Shutdown,
  ContextHookType_PendingRemoval_
};

struct ContextHook {
  ID HookId; // A unique ID assigned by AddContextHook()
  ContextHookType Type;
  ID Owner;
  ContextHookCallback Callback;
  void *UserData;

  ContextHook() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Context (main Dear Gui context)
//-----------------------------------------------------------------------------

struct Context {
  bool Initialized;
  bool FontAtlasOwnedByContext; // IO.Fonts-> is owned by the Context and
                                // will be destructed along with it.
  IO IO;
  Style Style;
  Font *Font; // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
  float
      FontSize; // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale
                // == window->FontSize(). Text height for current window.
  float FontBaseSize; // (Shortcut) == IO.FontGlobalScale * Font->Scale *
                      // Font->FontSize. Base text height.
  DrawListSharedData DrawListSharedData;
  double Time;
  int FrameCount;
  int FrameCountEnded;
  int FrameCountRendered;
  bool WithinFrameScope; // Set by NewFrame(), cleared by EndFrame()
  bool WithinFrameScopeWithImplicitWindow; // Set by NewFrame(), cleared by
                                           // EndFrame() when the implicit debug
                                           // window has been pushed
  bool WithinEndChild;                     // Set within EndChild()
  bool GcCompactAll;                       // Request full GC
  bool TestEngineHookItems;                // Will call test engine hooks:
                                           // TestEngineHook_ItemAdd(),
                                           // TestEngineHook_ItemInfo(),
                                           // TestEngineHook_Log()
  void *TestEngine;                        // Test engine user data

  // Inputs
  Vector<InputEvent> InputEventsQueue; // Input events which will be
                                       // trickled/written into IO structure.
  Vector<InputEvent>
      InputEventsTrail; // Past input events processed in NewFrame(). This is to
                        // allow domain-specific application to access e.g
                        // mouse/pen trail.
  MouseSource InputEventsNextMouseSource;
  U32 InputEventsNextEventId;

  // Windows state
  Vector<Window *> Windows; // Windows, sorted in display order, back to front
  Vector<Window *>
      WindowsFocusOrder; // Root windows, sorted in focus order, back to front.
  Vector<Window *>
      WindowsTempSortBuffer; // Temporary buffer used in EndFrame() to reorder
                             // windows so parents are kept before their child
  Vector<WindowStackData> CurrentWindowStack;
  Storage WindowsById;      // Map window's ID to Window*
  int WindowsActiveCount;   // Number of unique windows submitted by frame
  Vec2 WindowsHoverPadding; // Padding around resizable windows for which
                            // hovering on counts as hovering the window ==
                            // Max(style.TouchExtraPadding,
                            // WINDOWS_HOVER_PADDING)
  Window *CurrentWindow;    // Window being drawn into
  Window *HoveredWindow;    // Window the mouse is hovering. Will typically
                            // catch mouse inputs.
  Window
      *HoveredWindowUnderMovingWindow; // Hovered window ignoring MovingWindow.
                                       // Only set if MovingWindow is set.
  Window *MovingWindow; // Track the window we clicked on (in order to
                        // preserve focus). The actual window that is moved
                        // is generally MovingWindow->RootWindow.
  Window
      *WheelingWindow; // Track the window we started mouse-wheeling on. Until a
                       // timer elapse or mouse has moved, generally keep
                       // scrolling the same window even if during the course of
                       // scrolling the mouse ends up hovering a child window.
  Vec2 WheelingWindowRefMousePos;
  int WheelingWindowStartFrame; // This may be set one frame before
                                // WheelingWindow is != NULL
  int WheelingWindowScrolledFrame;
  float WheelingWindowReleaseTimer;
  Vec2 WheelingWindowWheelRemainder;
  Vec2 WheelingAxisAvg;

  // Item/widgets state and tracking information
  ID DebugHookIdInfo; // Will call core hooks: DebugHookIdInfo() from GetID
                      // functions, used by ID Stack Tool [next
                      // HoveredId/ActiveId to not pull in an extra cache-line]
  ID HoveredId;       // Hovered widget, filled during the frame
  ID HoveredIdPreviousFrame;
  bool HoveredIdAllowOverlap;
  bool HoveredIdDisabled; // At least one widget passed the rect test, but has
                          // been discarded by disabled flag or popup inhibit.
                          // May be true even if HoveredId == 0.
  float HoveredIdTimer;   // Measure contiguous hovering time
  float HoveredIdNotActiveTimer; // Measure contiguous hovering time where the
                                 // item has not been active
  ID ActiveId;                   // Active widget
  ID ActiveIdIsAlive; // Active widget has been seen this frame (we can't use
                      // a bool as the ActiveId may change within the frame)
  float ActiveIdTimer;
  bool ActiveIdIsJustActivated; // Set at the time of activation for one frame
  bool ActiveIdAllowOverlap;    // Active widget allows another widget to steal
                                // active id (generally for overlapping widgets,
                                // but not always)
  bool ActiveIdNoClearOnFocusLoss; // Disable losing active id if the active id
                                   // window gets unfocused.
  bool ActiveIdHasBeenPressedBefore; // Track whether the active id led to a
                                     // press (this is to allow changing between
                                     // PressOnClick and PressOnRelease without
                                     // pressing twice). Used by range_select
                                     // branch.
  bool ActiveIdHasBeenEditedBefore;  // Was the value associated to the widget
                                     // Edited over the course of the Active
                                     // state.
  bool ActiveIdHasBeenEditedThisFrame;
  Vec2 ActiveIdClickOffset; // Clicked offset from upper-left corner, if
                            // applicable (currently only set by ButtonBehavior)
  Window *ActiveIdWindow;
  InputSource ActiveIdSource; // Activating source: InputSource_Mouse OR
                              // InputSource_Keyboard OR InputSource_Gamepad
  int ActiveIdMouseButton;
  ID ActiveIdPreviousFrame;
  bool ActiveIdPreviousFrameIsAlive;
  bool ActiveIdPreviousFrameHasBeenEditedBefore;
  Window *ActiveIdPreviousFrameWindow;
  ID LastActiveId; // Store the last non-zero ActiveId, useful for animation.
  float LastActiveIdTimer; // Store the last non-zero ActiveId timer since the
                           // beginning of activation, useful for animation.

  // [EXPERIMENTAL] Key/Input Ownership + Shortcut Routing system
  // - The idea is that instead of "eating" a given key, we can link to an
  // owner.
  // - Input query can then read input by specifying KeyOwner_Any (== 0),
  // KeyOwner_None (== -1) or a custom ID.
  // - Routing is requested ahead of time for a given chord (Key + Mods) and
  // granted in NewFrame().
  KeyOwnerData KeysOwnerData[Key_NamedKey_COUNT];
  KeyRoutingTable KeysRoutingTable;
  U32 ActiveIdUsingNavDirMask; // Active widget will want to read those nav
                               // move requests (e.g. can activate a button
                               // and move away from it)
  bool ActiveIdUsingAllKeyboardKeys; // Active widget will want to read all
                                     // keyboard keys inputs. (FIXME: This is a
                                     // shortcut for not taking ownership of
                                     // 100+ keys but perhaps best to not have
                                     // the inconsistency)
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  U32 ActiveIdUsingNavInputMask; // If you used this. Since (GUI_VERSION_NUM
                                 // >= 18804) : 'g.ActiveIdUsingNavInputMask
                                 // |= (1 << NavInput_Cancel);' becomes
                                 // 'SetKeyOwner(Key_Escape, g.ActiveId)
                                 // and/or
                                 // SetKeyOwner(Key_NavGamepadCancel,
                                 // g.ActiveId);'
#endif

  // Next window/item data
  ID CurrentFocusScopeId;     // == g.FocusScopeStack.back()
  ItemFlags CurrentItemFlags; // == g.ItemFlagsStack.back()
  ID DebugLocateId; // Storage for DebugLocateItemOnHover() feature: this is
                    // read by ItemAdd() so we keep it in a hot/cached location
  NextItemData NextItemData; // Storage for SetNextItem** functions
  LastItemData
      LastItemData; // Storage for last submitted item (setup by ItemAdd)
  NextWindowData NextWindowData; // Storage for SetNextWindow** functions
  bool DebugShowGroupRects;

  // Shared stacks
  Col DebugFlashStyleColorIdx; // (Keep close to ColorStack to share cache line)
  Vector<ColorMod> ColorStack; // Stack for PushStyleColor()/PopStyleColor()
                               // - inherited by Begin()
  Vector<StyleMod> StyleVarStack; // Stack for PushStyleVar()/PopStyleVar()
                                  // - inherited by Begin()
  Vector<::Font *>
      FontStack; // Stack for PushFont()/PopFont() - inherited by Begin()
  Vector<ID>
      FocusScopeStack; // Stack for PushFocusScope()/PopFocusScope() - inherited
                       // by BeginChild(), pushed into by Begin()
  Vector<ItemFlags> ItemFlagsStack;  // Stack for PushItemFlag()/PopItemFlag()
                                     // - inherited by Begin()
  Vector<GroupData> GroupStack;      // Stack for BeginGroup()/EndGroup() -
                                     // not inherited by Begin()
  Vector<PopupData> OpenPopupStack;  // Which popups are open (persistent)
  Vector<PopupData> BeginPopupStack; // Which level of BeginPopup() we
                                     // are in (reset every frame)
  Vector<NavTreeNodeData> NavTreeNodeStack; // Stack for TreeNode() when a
                                            // NavLeft requested is emitted.

  int BeginMenuCount;

  // Viewports
  Vector<ViewportP *>
      Viewports; // Active viewports (Size==1 in 'master' branch). Each
                 // viewports hold their copy of DrawData.

  // Gamepad/keyboard Navigation
  Window *NavWindow;    // Focused window for navigation. Could be called
                        // 'FocusedWindow'
  ID NavId;             // Focused item for navigation
  ID NavFocusScopeId;   // Identify a selection scope (selection code often
                        // wants to "clear other items" when landing on an
                        // item of the selection set)
  ID NavActivateId;     // ~~ (g.ActiveId == 0) && (IsKeyPressed(Key_Space) ||
                        // IsKeyDown(Key_Enter) ||
                        // IsKeyPressed(Key_NavGamepadActivate)) ? NavId : 0,
                        // also set when calling ActivateItem()
  ID NavActivateDownId; // ~~ IsKeyDown(Key_Space) ||
                        // IsKeyDown(Key_Enter) ||
                        // IsKeyDown(Key_NavGamepadActivate) ? NavId : 0
  ID NavActivatePressedId; // ~~ IsKeyPressed(Key_Space) ||
                           // IsKeyPressed(Key_Enter) ||
                           // IsKeyPressed(Key_NavGamepadActivate) ?
                           // NavId : 0 (no repeat)
  ActivateFlags NavActivateFlags;
  ID NavJustMovedToId;           // Just navigated to this id (result of a
                                 // successfully MoveRequest).
  ID NavJustMovedToFocusScopeId; // Just navigated to this focus scope id
                                 // (result of a successfully MoveRequest).
  KeyChord NavJustMovedToKeyMods;
  ID NavNextActivateId; // Set by ActivateItem(), queued until next frame.
  ActivateFlags NavNextActivateFlags;
  InputSource NavInputSource; // Keyboard or Gamepad mode? THIS CAN ONLY BE
                              // InputSource_Keyboard or InputSource_Mouse
  NavLayer NavLayer; // Layer we are navigating on. For now the system is
                     // hard-coded for 0=main contents and 1=menu/title
                     // bar, may expose layers later.
  SelectionUserData
      NavLastValidSelectionUserData; // Last valid data passed to
                                     // SetNextItemSelectionUser(), or -1. For
                                     // current window. Not reset when focusing
                                     // an item that doesn't have selection
                                     // data.
  bool NavIdIsAlive;     // Nav widget has been seen this frame ~~ NavRectRel is
                         // valid
  bool NavMousePosDirty; // When set we will update mouse position if
                         // (io.ConfigFlags &
                         // ConfigFlags_NavEnableSetMousePos) if set (NB:
                         // this not enabled by default)
  bool NavDisableHighlight; // When user starts using mouse, we hide
                            // gamepad/keyboard highlight (NB: but they are
                            // still available, which is why NavDisableHighlight
                            // isn't always != NavDisableMouseHover)
  bool NavDisableMouseHover; // When user starts using gamepad/keyboard, we hide
                             // mouse hovering highlight until mouse is touched
                             // again.

  // Navigation: Init & Move Requests
  bool NavAnyRequest;  // ~~ NavMoveRequest || NavInitRequest this is to perform
                       // early out in ItemAdd()
  bool NavInitRequest; // Init request for appearing window to select first item
  bool NavInitRequestFromMove;
  NavItemData
      NavInitResult; // Init request result (first item of the window, or one
                     // for which SetItemDefaultFocus() was called)
  bool NavMoveSubmitted; // Move request submitted, will process result on next
                         // NewFrame()
  bool NavMoveScoringItems; // Move request submitted, still scoring incoming
                            // items
  bool NavMoveForwardToNextFrame;
  NavMoveFlags NavMoveFlags;
  ScrollFlags NavMoveScrollFlags;
  KeyChord NavMoveKeyMods;
  Dir NavMoveDir; // Direction of the move request (left/right/up/down)
  Dir NavMoveDirForDebug;
  Dir NavMoveClipDir;  // FIXME-NAV: Describe the purpose of this better.
                       // Might want to rename?
  Rect NavScoringRect; // Rectangle used for scoring, in screen space. Based
                       // of window->NavRectRel[], modified for directional
                       // navigation scoring.
  Rect NavScoringNoClipRect; // Some nav operations (such as PageUp/PageDown)
                             // enforce a region which clipper will attempt to
                             // always keep submitted
  int NavScoringDebugCount;  // Metrics for debugging
  int NavTabbingDir;     // Generally -1 or +1, 0 when tabbing without a nav id
  int NavTabbingCounter; // >0 when counting items for tabbing
  NavItemData
      NavMoveResultLocal; // Best move request candidate within NavWindow
  NavItemData
      NavMoveResultLocalVisible; // Best move request candidate within NavWindow
                                 // that are mostly visible (when using
                                 // NavMoveFlags_AlsoScoreVisibleSet flag)
  NavItemData NavMoveResultOther;    // Best move request candidate within
                                     // NavWindow's flattened hierarchy (when
                                     // using WindowFlags_NavFlattened flag)
  NavItemData NavTabbingResultFirst; // First tabbing request candidate within
                                     // NavWindow and flattened hierarchy

  // Navigation: Windowing (CTRL+TAB for list, or Menu button + keys or
  // directional pads to move/resize)
  KeyChord ConfigNavWindowingKeyNext; // = Mod_Ctrl | Key_Tab,
                                      // for reconfiguration (see #4828)
  KeyChord ConfigNavWindowingKeyPrev; // = Mod_Ctrl | Mod_Shift |
                                      // Key_Tab
  Window *NavWindowingTarget; // Target window when doing CTRL+Tab (or Pad
                              // Menu + FocusPrev/Next), this window is
                              // temporarily displayed top-most!
  Window
      *NavWindowingTargetAnim; // Record of last valid NavWindowingTarget until
                               // DimBgRatio and NavWindowingHighlightAlpha
                               // becomes 0.0f, so the fade-out can stay on it.
  Window *NavWindowingListWindow; // Internal window actually listing the
                                  // CTRL+Tab contents
  float NavWindowingTimer;
  float NavWindowingHighlightAlpha;
  bool NavWindowingToggleLayer;
  Vec2 NavWindowingAccumDeltaPos;
  Vec2 NavWindowingAccumDeltaSize;

  // Render
  float DimBgRatio; // 0.0..1.0 animation when fading in a dimming background
                    // (for modal window and CTRL+TAB list)

  // Drag and Drop
  bool DragDropActive;
  bool
      DragDropWithinSource; // Set when within a BeginDragDropXXX/EndDragDropXXX
                            // block for a drag source.
  bool
      DragDropWithinTarget; // Set when within a BeginDragDropXXX/EndDragDropXXX
                            // block for a drag target.
  DragDropFlags DragDropSourceFlags;
  int DragDropSourceFrameCount;
  int DragDropMouseButton;
  Payload DragDropPayload;
  Rect DragDropTargetRect; // Store rectangle of current target candidate (we
                           // favor small targets when overlapping)
  Rect DragDropTargetClipRect; // Store ClipRect at the time of item's drawing
  ID DragDropTargetId;
  DragDropFlags DragDropAcceptFlags;
  float DragDropAcceptIdCurrRectSurface; // Target item surface (we resolve
                                         // overlapping targets by prioritizing
                                         // the smaller surface)
  ID DragDropAcceptIdCurr;      // Target item id (set at the time of accepting
                                // the payload)
  ID DragDropAcceptIdPrev;      // Target item id from previous frame (we need
                                // to store this to allow for overlapping drag
                                // and drop targets)
  int DragDropAcceptFrameCount; // Last time a target expressed a desire to
                                // accept the source
  ID DragDropHoldJustPressedId; // Set when holding a payload just made
                                // ButtonBehavior() return a press.
  Vector<unsigned char>
      DragDropPayloadBufHeap; // We don't expose the Vector<> directly,
                              // Payload only holds pointer+size
  unsigned char DragDropPayloadBufLocal[16]; // Local buffer for small payloads

  // Clipper
  int ClipperTempDataStacked;
  Vector<ListClipperData> ClipperTempData;

  // Tables
  Table *CurrentTable;
  int TablesTempDataStacked; // Temporary table data size (because we leave
                             // previous instances undestructed, we generally
                             // don't use TablesTempData.Size)
  Vector<TableTempData>
      TablesTempData; // Temporary table data (buffers reused/shared across
                      // instances, support nesting)
  Pool<Table> Tables; // Persistent table data
  Vector<float> TablesLastTimeActive; // Last used timestamp of each tables
                                      // (SOA, for efficient GC)
  Vector<DrawChannel> DrawChannelsTempMergeBuffer;

  // Tab bars
  TabBar *CurrentTabBar;
  Pool<TabBar> TabBars;
  Vector<PtrOrIndex> CurrentTabBarStack;
  Vector<ShrinkWidthItem> ShrinkWidthBuffer;

  // Hover Delay system
  ID HoverItemDelayId;
  ID HoverItemDelayIdPreviousFrame;
  float HoverItemDelayTimer; // Currently used by IsItemHovered()
  float
      HoverItemDelayClearTimer; // Currently used by IsItemHovered(): grace time
                                // before g.TooltipHoverTimer gets cleared.
  ID HoverItemUnlockedStationaryId;   // Mouse has once been stationary on
                                      // this item. Only reset after
                                      // departing the item.
  ID HoverWindowUnlockedStationaryId; // Mouse has once been stationary on
                                      // this window. Only reset after
                                      // departing the window.

  // Mouse state
  MouseCursor MouseCursor;
  float MouseStationaryTimer; // Time the mouse has been stationary (with some
                              // loose heuristic)
  Vec2 MouseLastValidPos;

  // Widget state
  InputTextState InputTextState;
  InputTextDeactivatedState InputTextDeactivatedState;
  ::Font InputTextPasswordFont;
  ID TempInputId; // Temporary text input when CTRL+clicking on a slider, etc.
  ColorEditFlags ColorEditOptions; // Store user options for color edit widgets
  ID ColorEditCurrentID;   // Set temporarily while inside of the parent-most
                           // ColorEdit4/ColorPicker4 (because they call each
                           // others).
  ID ColorEditSavedID;     // ID we are saving/restoring HS for
  float ColorEditSavedHue; // Backup of last Hue associated to LastColor, so we
                           // can restore Hue in lossy RGB<>HSV round trips
  float ColorEditSavedSat; // Backup of last Saturation associated to LastColor,
                           // so we can restore Saturation in lossy RGB<>HSV
                           // round trips
  U32 ColorEditSavedColor; // RGB value with alpha set to 0.
  Vec4 ColorPickerRef;     // Initial/reference color at the time of opening the
                           // color picker.
  ComboPreviewData ComboPreviewData;
  Rect WindowResizeBorderExpectedRect; // Expected border rect, switch to
                                       // relative edit if moving
  bool WindowResizeRelativeMode;
  float SliderGrabClickOffset;
  float SliderCurrentAccum; // Accumulated slider delta when using navigation
                            // controls.
  bool SliderCurrentAccumDirty; // Has the accumulated slider delta changed
                                // since last time we tried to apply it?
  bool DragCurrentAccumDirty;
  float DragCurrentAccum; // Accumulator for dragging modification. Always
                          // high-precision, not rounded by end-user precision
                          // settings
  float DragSpeedDefaultRatio;           // If speed == 0.0f, uses (max-min) *
                                         // DragSpeedDefaultRatio
  float ScrollbarClickDeltaToGrabCenter; // Distance between mouse and center of
                                         // grab box, normalized in parent
                                         // space. Use storage?
  float DisabledAlphaBackup; // Backup for style.Alpha for BeginDisabled()
  short DisabledStackSize;
  short LockMarkEdited;
  short TooltipOverrideCount;
  Vector<char>
      ClipboardHandlerData; // If no custom clipboard handler is defined
  Vector<ID> MenusIdSubmittedThisFrame; // A list of menu IDs that were
                                        // rendered at least once
  TypingSelectState TypingSelectState;  // State for GetTypingSelectRequest()

  // Platform support
  PlatformImeData PlatformImeData;       // Data updated by current frame
  ::PlatformImeData PlatformImeDataPrev; // Previous frame data (when changing
                                         // we will call io.SetPlatformImeDataFn

  // Settings
  bool SettingsLoaded;
  float
      SettingsDirtyTimer; // Save .ini Settings to memory when time reaches zero
  TextBuffer SettingsIniData;                  // In memory .ini settings
  Vector<SettingsHandler> SettingsHandlers;    // List of .ini settings handlers
  ChunkStream<WindowSettings> SettingsWindows; // Window .ini settings entries
  ChunkStream<TableSettings> SettingsTables;   // Table .ini settings entries
  Vector<ContextHook> Hooks; // Hooks for extensions (e.g. test engine)
  ID HookIdNext;             // Next available HookId

  // Localization
  const char *LocalizationTable[LocKey_COUNT];

  // Capture/Logging
  bool LogEnabled;      // Currently capturing
  LogType LogType;      // Capture target
  FileHandle LogFile;   // If != NULL log to stdout/ file
  TextBuffer LogBuffer; // Accumulation buffer when log to clipboard. This
                        // is pointer so our GGui static constructor
                        // doesn't call heap allocators.
  const char *LogNextPrefix;
  const char *LogNextSuffix;
  float LogLinePosY;
  bool LogLineFirstItem;
  int LogDepthRef;
  int LogDepthToExpand;
  int LogDepthToExpandDefault; // Default/stored value for LogDepthMaxExpand if
                               // not specified in the LogXXX function call.

  // Debug Tools
  DebugLogFlags DebugLogFlags;
  TextBuffer DebugLogBuf;
  TextIndex DebugLogIndex;
  U8 DebugLogClipperAutoDisableFrames;
  U8 DebugLocateFrames; // For DebugLocateItemOnHover(). This is used together
                        // with DebugLocateId which is in a hot/cached spot
                        // above.
  S8 DebugBeginReturnValueCullDepth; // Cycle between 0..9 then wrap around.
  bool DebugItemPickerActive;        // Item picker is active (started with
                                     // DebugStartItemPicker())
  U8 DebugItemPickerMouseButton;
  ID DebugItemPickerBreakId; // Will call GUI_DEBUG_BREAK() when
                             // encountering this ID
  float DebugFlashStyleColorTime;
  Vec4 DebugFlashStyleColorBackup;
  MetricsConfig DebugMetricsConfig;
  IDStackTool DebugIDStackTool;
  DebugAllocInfo DebugAllocInfo;

  // Misc
  float FramerateSecPerFrame[60]; // Calculate estimate of framerate for user
                                  // over the last 60 frames..
  int FramerateSecPerFrameIdx;
  int FramerateSecPerFrameCount;
  float FramerateSecPerFrameAccum;
  int WantCaptureMouseNextFrame; // Explicit capture override via
                                 // SetNextFrameWantCaptureMouse()/SetNextFrameWantCaptureKeyboard().
                                 // Default to -1.
  int WantCaptureKeyboardNextFrame; // "
  int WantTextInputNextFrame;
  Vector<char> TempBuffer; // Temporary text buffer

  Context(FontAtlas *shared_font_atlas) {
    IO.Ctx = this;
    InputTextState.Ctx = this;

    Initialized = false;
    FontAtlasOwnedByContext = shared_font_atlas ? false : true;
    Font = NULL;
    FontSize = FontBaseSize = 0.0f;
    IO.Fonts = shared_font_atlas ? shared_font_atlas : GUI_NEW(FontAtlas)();
    Time = 0.0f;
    FrameCount = 0;
    FrameCountEnded = FrameCountRendered = -1;
    WithinFrameScope = WithinFrameScopeWithImplicitWindow = WithinEndChild =
        false;
    GcCompactAll = false;
    TestEngineHookItems = false;
    TestEngine = NULL;

    InputEventsNextMouseSource = MouseSource_Mouse;
    InputEventsNextEventId = 1;

    WindowsActiveCount = 0;
    CurrentWindow = NULL;
    HoveredWindow = NULL;
    HoveredWindowUnderMovingWindow = NULL;
    MovingWindow = NULL;
    WheelingWindow = NULL;
    WheelingWindowStartFrame = WheelingWindowScrolledFrame = -1;
    WheelingWindowReleaseTimer = 0.0f;

    DebugHookIdInfo = 0;
    HoveredId = HoveredIdPreviousFrame = 0;
    HoveredIdAllowOverlap = false;
    HoveredIdDisabled = false;
    HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
    ActiveId = 0;
    ActiveIdIsAlive = 0;
    ActiveIdTimer = 0.0f;
    ActiveIdIsJustActivated = false;
    ActiveIdAllowOverlap = false;
    ActiveIdNoClearOnFocusLoss = false;
    ActiveIdHasBeenPressedBefore = false;
    ActiveIdHasBeenEditedBefore = false;
    ActiveIdHasBeenEditedThisFrame = false;
    ActiveIdClickOffset = Vec2(-1, -1);
    ActiveIdWindow = NULL;
    ActiveIdSource = InputSource_None;
    ActiveIdMouseButton = -1;
    ActiveIdPreviousFrame = 0;
    ActiveIdPreviousFrameIsAlive = false;
    ActiveIdPreviousFrameHasBeenEditedBefore = false;
    ActiveIdPreviousFrameWindow = NULL;
    LastActiveId = 0;
    LastActiveIdTimer = 0.0f;

    ActiveIdUsingNavDirMask = 0x00;
    ActiveIdUsingAllKeyboardKeys = false;
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
    ActiveIdUsingNavInputMask = 0x00;
#endif

    CurrentFocusScopeId = 0;
    CurrentItemFlags = ItemFlags_None;
    DebugShowGroupRects = false;
    BeginMenuCount = 0;

    NavWindow = NULL;
    NavId = NavFocusScopeId = NavActivateId = NavActivateDownId =
        NavActivatePressedId = 0;
    NavJustMovedToId = NavJustMovedToFocusScopeId = NavNextActivateId = 0;
    NavActivateFlags = NavNextActivateFlags = ActivateFlags_None;
    NavJustMovedToKeyMods = Mod_None;
    NavInputSource = InputSource_Keyboard;
    NavLayer = NavLayer_Main;
    NavLastValidSelectionUserData = SelectionUserData_Invalid;
    NavIdIsAlive = false;
    NavMousePosDirty = false;
    NavDisableHighlight = true;
    NavDisableMouseHover = false;
    NavAnyRequest = false;
    NavInitRequest = false;
    NavInitRequestFromMove = false;
    NavMoveSubmitted = false;
    NavMoveScoringItems = false;
    NavMoveForwardToNextFrame = false;
    NavMoveFlags = NavMoveFlags_None;
    NavMoveScrollFlags = ScrollFlags_None;
    NavMoveKeyMods = Mod_None;
    NavMoveDir = NavMoveDirForDebug = NavMoveClipDir = Dir_None;
    NavScoringDebugCount = 0;
    NavTabbingDir = 0;
    NavTabbingCounter = 0;

    ConfigNavWindowingKeyNext = Mod_Ctrl | Key_Tab;
    ConfigNavWindowingKeyPrev = Mod_Ctrl | Mod_Shift | Key_Tab;
    NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow = NULL;
    NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
    NavWindowingToggleLayer = false;

    DimBgRatio = 0.0f;

    DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;
    DragDropSourceFlags = DragDropFlags_None;
    DragDropSourceFrameCount = -1;
    DragDropMouseButton = -1;
    DragDropTargetId = 0;
    DragDropAcceptFlags = DragDropFlags_None;
    DragDropAcceptIdCurrRectSurface = 0.0f;
    DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
    DragDropAcceptFrameCount = -1;
    DragDropHoldJustPressedId = 0;
    memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));

    ClipperTempDataStacked = 0;

    CurrentTable = NULL;
    TablesTempDataStacked = 0;
    CurrentTabBar = NULL;

    HoverItemDelayId = HoverItemDelayIdPreviousFrame =
        HoverItemUnlockedStationaryId = HoverWindowUnlockedStationaryId = 0;
    HoverItemDelayTimer = HoverItemDelayClearTimer = 0.0f;

    MouseCursor = MouseCursor_Arrow;
    MouseStationaryTimer = 0.0f;

    TempInputId = 0;
    ColorEditOptions = ColorEditFlags_DefaultOptions_;
    ColorEditCurrentID = ColorEditSavedID = 0;
    ColorEditSavedHue = ColorEditSavedSat = 0.0f;
    ColorEditSavedColor = 0;
    WindowResizeRelativeMode = false;
    SliderGrabClickOffset = 0.0f;
    SliderCurrentAccum = 0.0f;
    SliderCurrentAccumDirty = false;
    DragCurrentAccumDirty = false;
    DragCurrentAccum = 0.0f;
    DragSpeedDefaultRatio = 1.0f / 100.0f;
    ScrollbarClickDeltaToGrabCenter = 0.0f;
    DisabledAlphaBackup = 0.0f;
    DisabledStackSize = 0;
    LockMarkEdited = 0;
    TooltipOverrideCount = 0;

    PlatformImeData.InputPos = Vec2(0.0f, 0.0f);
    PlatformImeDataPrev.InputPos =
        Vec2(-1.0f, -1.0f); // Different to ensure initial submission

    SettingsLoaded = false;
    SettingsDirtyTimer = 0.0f;
    HookIdNext = 0;

    memset(LocalizationTable, 0, sizeof(LocalizationTable));

    LogEnabled = false;
    LogType = LogType_None;
    LogNextPrefix = LogNextSuffix = NULL;
    LogFile = NULL;
    LogLinePosY = FLT_MAX;
    LogLineFirstItem = false;
    LogDepthRef = 0;
    LogDepthToExpand = LogDepthToExpandDefault = 2;

    DebugLogFlags = DebugLogFlags_OutputToTTY;
    DebugLocateId = 0;
    DebugLogClipperAutoDisableFrames = 0;
    DebugLocateFrames = 0;
    DebugBeginReturnValueCullDepth = -1;
    DebugItemPickerActive = false;
    DebugItemPickerMouseButton = MouseButton_Left;
    DebugItemPickerBreakId = 0;
    DebugFlashStyleColorTime = 0.0f;
    DebugFlashStyleColorIdx = Col_COUNT;

    memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
    FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;
    FramerateSecPerFrameAccum = 0.0f;
    WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame =
        WantTextInputNextFrame = -1;
  }
};

//-----------------------------------------------------------------------------
// [SECTION] WindowTempData, Window
//-----------------------------------------------------------------------------

// Transient per-window data, reset at the beginning of the frame. This used to
// be called DrawContext, hence the DC variable name in Window.
// (That's theory, in practice the delimitation between Window and
// WindowTempData is quite tenuous and could be reconsidered..) (This
// doesn't need a constructor because we zero-clear it as part of Window
// and all frame-temporary data are setup on Begin)
struct GUI_API WindowTempData {
  // Layout
  Vec2 CursorPos; // Current emitting position, in absolute coordinates.
  Vec2 CursorPosPrevLine;
  Vec2 CursorStartPos; // Initial position after Begin(), generally ~ window
                       // position + WindowPadding.
  Vec2 CursorMaxPos;   // Used to implicitly calculate ContentSize at the
                       // beginning of next frame, for scrolling range and
                       // auto-resize. Always growing during the frame.
  Vec2 IdealMaxPos;    // Used to implicitly calculate ContentSizeIdeal at the
                       // beginning of next frame, for auto-resize only. Always
                       // growing during the frame.
  Vec2 CurrLineSize;
  Vec2 PrevLineSize;
  float CurrLineTextBaseOffset; // Baseline offset (0.0f by default on a new
                                // line, generally == style.FramePadding.y when
                                // a framed item has been added).
  float PrevLineTextBaseOffset;
  bool IsSameLine;
  bool IsSetPos;
  Vec1 Indent; // Indentation / start position from left of window (increased
               // by TreePush/TreePop, etc.)
  Vec1
      ColumnsOffset; // Offset to the current column (if ColumnsCurrent > 0).
                     // FIXME: This and the above should be a stack to allow use
                     // cases like Tree->Column->Tree. Need revamp columns API.
  Vec1 GroupOffset;
  Vec2
      CursorStartPosLossyness; // Record the loss of precision of CursorStartPos
                               // due to really large scrolling amount. This is
                               // used by clipper to compensate and fix the most
                               // common use case of large scroll area.

  // Keyboard/Gamepad navigation
  NavLayer NavLayerCurrent; // Current layer, 0..31 (we currently only use 0..1)
  short NavLayersActiveMask; // Which layers have been written to (result from
                             // previous frame)
  short NavLayersActiveMaskNext; // Which layers have been written to
                                 // (accumulator for current frame)
  bool NavIsScrollPushableX; // Set when current work location may be scrolled
                             // horizontally when moving left / right. This is
                             // generally always true UNLESS within a column.
  bool NavHideHighlightOneFrame;
  bool NavWindowHasScrollY; // Set per window when scrolling can be used (==
                            // ScrollMax.y > 0.0f)

  // Miscellaneous
  bool MenuBarAppending; // FIXME: Remove this
  Vec2 MenuBarOffset;    // MenuBarOffset.x is sort of equivalent of a per-layer
                         // CursorPos.x, saved/restored as we switch to the menu
                         // bar. The only situation when MenuBarOffset.y is > 0
                         // if when (SafeAreaPadding.y > FramePadding.y), often
                         // used on TVs.
  MenuColumns
      MenuColumns; // Simplified columns storage for menu items measurement
  int TreeDepth;   // Current tree depth.
  U32 TreeJumpToParentOnPopMask; // Store a copy of !g.NavIdIsAlive for
                                 // TreeDepth 0..31.. Could be turned into a
                                 // U64 if necessary.
  Vector<Window *> ChildWindows;
  Storage *StateStorage;      // Current persistent per-window storage (store
                              // e.g. tree node open/close state)
  OldColumns *CurrentColumns; // Current columns set
  int CurrentTableIdx;        // Current table index (into g.Tables)
  ::LayoutType LayoutType;
  ::LayoutType
      ParentLayoutType; // Layout type of parent window at the time of Begin()

  // Local parameters stacks
  // We store the current settings outside of the vectors to increase memory
  // locality (reduce cache misses). The vectors are rarely modified. Also it
  // allows us to not heap allocate for short-lived windows which are not using
  // those settings.
  float ItemWidth; // Current item width (>0.0: width in pixels, <0.0: align xx
                   // pixels to the right of window).
  float TextWrapPos;              // Current text wrap pos.
  Vector<float> ItemWidthStack;   // Store item widths to restore (attention:
                                  // .back() is not == ItemWidth)
  Vector<float> TextWrapPosStack; // Store text wrap pos to restore (attention:
                                  // .back() is not == TextWrapPos)
};

// Storage for one window
struct GUI_API Window {
  Context *Ctx; // Parent UI context (needs to be set explicitly by parent).
  char *Name;   // Window name, owned by the window.
  ID ID;        // == HashStr(Name)
  WindowFlags Flags;     // See enum WindowFlags_
  ChildFlags ChildFlags; // Set when window is a child window. See enum
                         // ChildFlags_
  ViewportP *Viewport;   // Always set in Begin(). Inactive windows may have a
                         // NULL value here if their viewport was discarded.
  Vec2 Pos;              // Position (always rounded-up to nearest pixel)
  Vec2 Size;        // Current size (==SizeFull or collapsed title bar size)
  Vec2 SizeFull;    // Size when non collapsed
  Vec2 ContentSize; // Size of contents/scrollable client area (calculated from
                    // the extents reach of the cursor) from previous frame.
                    // Does not include window decoration or window padding.
  Vec2 ContentSizeIdeal;
  Vec2 ContentSizeExplicit; // Size of contents/scrollable client area
                            // explicitly request by the user via
                            // SetNextWindowContentSize().
  Vec2 WindowPadding;       // Window padding at the time of Begin().
  float WindowRounding;     // Window rounding at the time of Begin(). May be
                        // clamped lower to avoid rendering artifacts with title
                        // bar, menu bar etc.
  float WindowBorderSize; // Window border size at the time of Begin().
  float DecoOuterSizeX1,
      DecoOuterSizeY1; // Left/Up offsets. Sum of non-scrolling outer
                       // decorations (X1 generally == 0.0f. Y1 generally =
                       // TitleBarHeight + MenuBarHeight). Locked during
                       // Begin().
  float DecoOuterSizeX2,
      DecoOuterSizeY2; // Right/Down offsets (X2 generally == ScrollbarSize.x,
                       // Y2 == ScrollbarSizes.y).
  float DecoInnerSizeX1,
      DecoInnerSizeY1; // Applied AFTER/OVER InnerRect. Specialized for Tables
                       // as they use specialized form of clipping and frozen
                       // rows/columns are inside InnerRect (and not part of
                       // regular decoration sizes).
  int NameBufLen;      // Size of buffer storing Name. May be larger than
                       // strlen(Name)!
  ::ID MoveId;         // == window->GetID("#MOVE")
  ::ID ChildId; // ID of corresponding item in parent window (for navigation
                // to return from child window to parent window)
  Vec2 Scroll;
  Vec2 ScrollMax;
  Vec2 ScrollTarget; // target scroll position. stored as cursor position with
                     // scrolling canceled out, so the highest point is always
                     // 0.0f. (FLT_MAX for no change)
  Vec2 ScrollTargetCenterRatio;  // 0.0f = scroll so that target position is at
                                 // top, 0.5f = scroll so that target position
                                 // is centered
  Vec2 ScrollTargetEdgeSnapDist; // 0.0f = no snapping, >0.0f snapping threshold
  Vec2 ScrollbarSizes; // Size taken by each scrollbars on their smaller axis.
                       // Pay attention! ScrollbarSizes.x == width of the
                       // vertical scrollbar, ScrollbarSizes.y = height of the
                       // horizontal scrollbar.
  bool ScrollbarX, ScrollbarY; // Are scrollbars visible?
  bool Active;                 // Set to true on Begin(), unless Collapsed
  bool WasActive;
  bool WriteAccessed; // Set to true when any widget access the current window
  bool Collapsed;     // Set when collapsing window to become only title-bar
  bool WantCollapseToggle;
  bool SkipItems; // Set when items can safely be all clipped (e.g. window not
                  // visible or collapsed)
  bool Appearing; // Set during the frame where the window is appearing (or
                  // re-appearing)
  bool Hidden;    // Do not display (== HiddenFrames*** > 0)
  bool IsFallbackWindow; // Set on the "Debug##Default" window.
  bool IsExplicitChild;  // Set when passed _ChildWindow, left to false by
                         // BeginDocked()
  bool
      HasCloseButton; // Set when the window has a close button (p_open != NULL)
  signed char ResizeBorderHovered; // Current border being hovered for resize
                                   // (-1: none, otherwise 0-3)
  signed char ResizeBorderHeld;    // Current border being held for resize (-1:
                                   // none, otherwise 0-3)
  short BeginCount; // Number of Begin() during the current frame (generally 0
                    // or 1, 1+ if appending via multiple Begin/End pairs)
  short BeginCountPreviousFrame; // Number of Begin() during the previous frame
  short BeginOrderWithinParent; // Begin() order within immediate parent window,
                                // if we are a child window. Otherwise 0.
  short BeginOrderWithinContext; // Begin() order within entire gui context.
                                 // This is mostly used for debugging submission
                                 // order related issues.
  short FocusOrder; // Order within WindowsFocusOrder[], altered when windows
                    // are focused.
  ::ID PopupId;     // ID in the popup stack when this window is used as a
                    // popup/menu (because we use generic Name/ID for recycling)
  S8 AutoFitFramesX, AutoFitFramesY;
  bool AutoFitOnlyGrows;
  Dir AutoPosLastDirection;
  S8 HiddenFramesCanSkipItems;      // Hide the window for N frames
  S8 HiddenFramesCannotSkipItems;   // Hide the window for N frames while
                                    // allowing items to be submitted so we can
                                    // measure their size
  S8 HiddenFramesForRenderOnly;     // Hide the window until frame N at Render()
                                    // time only
  S8 DisableInputsFrames;           // Disable window interactions for N frames
  Cond SetWindowPosAllowFlags : 8;  // store acceptable condition flags for
                                    // SetNextWindowPos() use.
  Cond SetWindowSizeAllowFlags : 8; // store acceptable condition flags for
                                    // SetNextWindowSize() use.
  Cond SetWindowCollapsedAllowFlags : 8; // store acceptable condition flags
                                         // for SetNextWindowCollapsed() use.
  Vec2 SetWindowPosVal;   // store window position when using a non-zero Pivot
                          // (position set needs to be processed when we know
                          // the window size)
  Vec2 SetWindowPosPivot; // store window pivot for positioning. Vec2(0, 0)
                          // when positioning from top-left corner; Vec2(0.5f,
                          // 0.5f) for centering; Vec2(1, 1) for bottom right.

  Vector<::ID> IDStack; // ID stack. ID are hashes seeded with the value at
                        // the top of the stack. (In theory this should be
                        // in the TempData structure)
  WindowTempData DC;    // Temporary per-window data, reset at the beginning
                        // of the frame. This used to be called
                        // DrawContext, hence the "DC" variable name.

  // The best way to understand what those rectangles are is to use the
  // 'Metrics->Tools->Show Windows Rectangles' viewer. The main 'OuterRect',
  // omitted as a field, is window->Rect().
  Rect OuterRectClipped; // == Window->Rect() just after setup in Begin(). ==
                         // window->Rect() for root window.
  Rect InnerRect;     // Inner rectangle (omit title bar, menu bar, scroll bar)
  Rect InnerClipRect; // == InnerRect shrunk by WindowPadding*0.5f on each
                      // side, clipped within viewport or parent clip rect.
  Rect WorkRect;      // Initially covers the whole scrolling region. Reduced by
                      // containers e.g columns/tables when active. Shrunk by
  // WindowPadding*1.0f on each side. This is meant to replace
  // ContentRegionRect over time (from 1.71+ onward).
  Rect ParentWorkRect; // Backup of WorkRect before entering a container such
                       // as columns/tables. Used by e.g. SpanAllColumns
                       // functions to easily access. Stacked containers are
                       // responsible for maintaining this. // FIXME-WORKRECT:
                       // Could be a stack?
  Rect
      ClipRect; // Current clipping/scissoring rectangle, evolve as we are using
                // PushClipRect(), etc. == DrawList->clip_rect_stack.back().
  Rect ContentRegionRect; // FIXME: This is currently confusing/misleading. It
                          // is essentially WorkRect but not handling of
                          // scrolling. We currently rely on it as right/bottom
                          // aligned sizing operation need some size to rely on.
  Vec2ih HitTestHoleSize; // Define an optional rectangular hole where mouse
                          // will pass-through the window.
  Vec2ih HitTestHoleOffset;

  int LastFrameActive;  // Last frame number the window was Active.
  float LastTimeActive; // Last timestamp the window was Active (using float as
                        // we don't need high precision there)
  float ItemWidthDefault;
  Storage StateStorage;
  Vector<OldColumns> ColumnsStorage;
  float FontWindowScale; // User scale multiplier per-window, via
                         // SetWindowFontScale()
  int SettingsOffset; // Offset into SettingsWindows[] (offsets are always valid
                      // as we only grow the array from the back)

  DrawList
      *DrawList; // == &DrawListInst (for backward compatibility reason with
                 // code using gui_internal.hpp we keep this a pointer)
  ::DrawList DrawListInst;
  Window *ParentWindow; // If we are a child _or_ popup _or_ docked window,
                        // this is pointing to our parent. Otherwise NULL.
  Window *ParentWindowInBeginStack;
  Window *RootWindow; // Point to ourself or first ancestor that is not a child
                      // window. Doesn't cross through popups/dock nodes.
  Window
      *RootWindowPopupTree; // Point to ourself or first ancestor that is not a
                            // child window. Cross through popups parent<>child.
  Window *RootWindowForTitleBarHighlight; // Point to ourself or first ancestor
                                          // which will display TitleBgActive
                                          // color when this window is active.
  Window *RootWindowForNav; // Point to ourself or first ancestor which
                            // doesn't have the NavFlattened flag.

  Window
      *NavLastChildNavWindow; // When going to the menu bar, we remember the
                              // child window we came from. (This could probably
                              // be made implicit if we kept g.Windows sorted by
                              // last focused including child window.)
  ::ID NavLastIds[NavLayer_COUNT]; // Last known NavId for this window,
                                   // per layer (0/1)
  Rect NavRectRel[NavLayer_COUNT]; // Reference rectangle, in window
                                   // relative space
  Vec2 NavPreferredScoringPosRel
      [NavLayer_COUNT];     // Preferred X/Y position updated when moving on a
                            // given axis, reset to FLT_MAX.
  ::ID NavRootFocusScopeId; // Focus Scope ID at the time of Begin()

  int MemoryDrawListIdxCapacity; // Backup of last idx/vtx count, so when waking
                                 // up the window we can preallocate and avoid
                                 // iterative alloc/copy
  int MemoryDrawListVtxCapacity;
  bool MemoryCompacted; // Set when window extraneous data have been garbage
                        // collected

public:
  Window(Context *context, const char *name);
  ~Window();

  ::ID GetID(const char *str, const char *str_end = NULL);
  ::ID GetID(const void *ptr);
  ::ID GetID(int n);
  ::ID GetIDFromRectangle(const Rect &r_abs);

  // We don't use g.FontSize because the window may be != g.CurrentWindow.
  Rect Rect() const {
    return ::Rect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y);
  }
  float CalcFontSize() const {
    Context &g = *Ctx;
    float scale = g.FontBaseSize * FontWindowScale;
    if (ParentWindow)
      scale *= ParentWindow->FontWindowScale;
    return scale;
  }
  float TitleBarHeight() const {
    Context &g = *Ctx;
    return (Flags & WindowFlags_NoTitleBar)
               ? 0.0f
               : CalcFontSize() + g.Style.FramePadding.y * 2.0f;
  }
  ::Rect TitleBarRect() const {
    return ::Rect(Pos, Vec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight()));
  }
  float MenuBarHeight() const {
    Context &g = *Ctx;
    return (Flags & WindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() +
                                               g.Style.FramePadding.y * 2.0f
                                         : 0.0f;
  }
  ::Rect MenuBarRect() const {
    float y1 = Pos.y + TitleBarHeight();
    return ::Rect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight());
  }
};

//-----------------------------------------------------------------------------
// [SECTION] Tab bar, Tab item support
//-----------------------------------------------------------------------------

// Extend TabBarFlags_
enum TabBarFlagsPrivate_ {
  TabBarFlags_DockNode =
      1 << 20, // Part of a dock node [we don't use this in the master branch
               // but it facilitate branch syncing to keep this around]
  TabBarFlags_IsFocused = 1 << 21,
  TabBarFlags_SaveSettings =
      1
      << 22, // FIXME: Settings are handled by the docking system, this only
             // request the tab bar to mark settings dirty when reordering tabs
};

// Extend TabItemFlags_
enum TabItemFlagsPrivate_ {
  TabItemFlags_SectionMask_ = TabItemFlags_Leading | TabItemFlags_Trailing,
  TabItemFlags_NoCloseButton =
      1 << 20, // Track whether p_open was set or not (we'll need this info on
               // the next frame to recompute ContentWidth during layout)
  TabItemFlags_Button = 1 << 21, // Used by TabItemButton, change the tab
                                 // item behavior to mimic a button
};

// Storage for one active tab item (sizeof() 40 bytes)
struct TabItem {
  ID ID;
  TabItemFlags Flags;
  int LastFrameVisible;
  int LastFrameSelected; // This allows us to infer an ordered list of the last
                         // activated tabs with little maintenance
  float Offset;          // Position relative to beginning of tab
  float Width;           // Width currently displayed
  float ContentWidth;    // Width of label, stored during BeginTabItem() call
  float RequestedWidth; // Width optionally requested by caller, -1.0f is unused
  S32 NameOffset;       // When Window==NULL, offset to name within parent
                        // TabBar::TabsNames
  S16 BeginOrder;       // BeginTabItem() order, used to re-order tabs after
                        // toggling TabBarFlags_Reorderable
  S16 IndexDuringLayout; // Index only used during TabBarLayout(). Tabs gets
                         // reordered so 'Tabs[n].IndexDuringLayout == n' but
                         // may mismatch during additions.
  bool WantClose;        // Marked as closed by SetTabItemClosed()

  TabItem() {
    memset(this, 0, sizeof(*this));
    LastFrameVisible = LastFrameSelected = -1;
    RequestedWidth = -1.0f;
    NameOffset = -1;
    BeginOrder = IndexDuringLayout = -1;
  }
};

// Storage for a tab bar (sizeof() 152 bytes)
struct GUI_API TabBar {
  Vector<TabItem> Tabs;
  TabBarFlags Flags;
  ID ID;                  // Zero for tab-bars used by docking
  ::ID SelectedTabId;     // Selected tab/window
  ::ID NextSelectedTabId; // Next selected tab/window. Will also trigger a
                          // scrolling animation
  ::ID VisibleTabId;      // Can occasionally be != SelectedTabId (e.g. when
                          // previewing contents for CTRL+TAB preview)
  int CurrFrameVisible;
  int PrevFrameVisible;
  Rect BarRect;
  float CurrTabsContentsHeight;
  float PrevTabsContentsHeight; // Record the height of contents submitted below
                                // the tab bar
  float WidthAllTabs; // Actual width of all tabs (locked during layout)
  float
      WidthAllTabsIdeal; // Ideal width if all tabs were visible and not clipped
  float ScrollingAnim;
  float ScrollingTarget;
  float ScrollingTargetDistToVisibility;
  float ScrollingSpeed;
  float ScrollingRectMinX;
  float ScrollingRectMaxX;
  float SeparatorMinX;
  float SeparatorMaxX;
  ::ID ReorderRequestTabId;
  S16 ReorderRequestOffset;
  S8 BeginCount;
  bool WantLayout;
  bool VisibleTabWasSubmitted;
  bool TabsAddedNew; // Set to true when a new tab item or button has been added
                     // to the tab bar during last frame
  S16 TabsActiveCount; // Number of tabs submitted this frame.
  S16 LastTabItemIdx;  // Index of last BeginTabItem() tab for use by
                       // EndTabItem()
  float ItemSpacingY;
  Vec2 FramePadding; // style.FramePadding locked at the time of BeginTabBar()
  Vec2 BackupCursorPos;
  TextBuffer TabsNames; // For non-docking tab bar we re-append names in a
                        // contiguous buffer.

  TabBar();
};

//-----------------------------------------------------------------------------
// [SECTION] Table support
//-----------------------------------------------------------------------------

#define GUI_COL32_DISABLE                                                      \
  GUI_COL32(                                                                   \
      0, 0, 0,                                                                 \
      1) // Special sentinel code which cannot be used as a regular color.
#define GUI_TABLE_MAX_COLUMNS 512 // May be further lifted

// Our current column maximum is 64 but we may raise that in the future.
typedef S16 TableColumnIdx;
typedef U16 TableDrawChannelIdx;

// [Internal] sizeof() ~ 112
// We use the terminology "Enabled" to refer to a column that is not Hidden by
// user/api. We use the terminology "Clipped" to refer to a column that is out
// of sight because of scrolling/clipping. This is in contrast with some
// user-facing api such as IsItemVisible() / IsRectVisible() which use "Visible"
// to mean "not clipped".
struct TableColumn {
  TableColumnFlags Flags; // Flags after some patching (not directly same as
                          // provided by user). See TableColumnFlags_
  float WidthGiven; // Final/actual width visible == (MaxX - MinX), locked in
                    // TableUpdateLayout(). May be > WidthRequest to honor
                    // minimum width, may be < WidthRequest to honor shrinking
                    // columns down in tight space.
  float MinX;       // Absolute positions
  float MaxX;
  float WidthRequest;  // Master width absolute value when !(Flags &
                       // _WidthStretch). When Stretch this is derived every
                       // frame from StretchWeight in TableUpdateLayout()
  float WidthAuto;     // Automatic width
  float StretchWeight; // Master width weight when (Flags & _WidthStretch).
                       // Often around ~1.0f initially.
  float
      InitStretchWeightOrWidth; // Value passed to TableSetupColumn(). For Width
                                // it is a content width (_without padding_).
  Rect ClipRect;                // Clipping rectangle for the column
  ID UserID;                    // Optional, value passed to TableSetupColumn()
  float WorkMinX;  // Contents region min ~(MinX + CellPaddingX + CellSpacingX1)
                   // == cursor start position when entering column
  float WorkMaxX;  // Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)
  float ItemWidth; // Current item width for the column, preserved across rows
  float ContentMaxXFrozen; // Contents maximum position for frozen rows (apart
                           // from headers), from which we can infer content
                           // width.
  float ContentMaxXUnfrozen;
  float ContentMaxXHeadersUsed; // Contents maximum position for headers rows
                                // (regardless of freezing). TableHeader()
                                // automatically softclip itself + report ideal
                                // desired size, to avoid creating extraneous
                                // draw calls
  float ContentMaxXHeadersIdeal;
  S16 NameOffset;              // Offset into parent ColumnsNames[]
  TableColumnIdx DisplayOrder; // Index within Table's IndexToDisplayOrder[]
                               // (column may be reordered by users)
  TableColumnIdx IndexWithinEnabledSet; // Index within enabled/visible set
                                        // (<= IndexToDisplayOrder)
  TableColumnIdx
      PrevEnabledColumn; // Index of prev enabled/visible column within
                         // Columns[], -1 if first enabled/visible column
  TableColumnIdx
      NextEnabledColumn; // Index of next enabled/visible column within
                         // Columns[], -1 if last enabled/visible column
  TableColumnIdx
      SortOrder; // Index of this column within sort specs, -1 if not sorting on
                 // this column, 0 for single-sort, may be >0 on multi-sort
  TableDrawChannelIdx
      DrawChannelCurrent; // Index within DrawSplitter.Channels[]
  TableDrawChannelIdx
      DrawChannelFrozen; // Draw channels for frozen rows (often headers)
  TableDrawChannelIdx DrawChannelUnfrozen; // Draw channels for unfrozen rows
  bool IsEnabled;     // IsUserEnabled && (Flags & TableColumnFlags_Disabled)
                      // == 0
  bool IsUserEnabled; // Is the column not marked Hidden by the user? (unrelated
                      // to being off view, e.g. clipped by scrolling).
  bool IsUserEnabledNextFrame;
  bool IsVisibleX; // Is actually in view (e.g. overlapping the host window
                   // clipping rectangle, not scrolled).
  bool IsVisibleY;
  bool IsRequestOutput; // Return value for TableSetColumnIndex() /
                        // TableNextColumn(): whether we request user to output
                        // contents or not.
  bool IsSkipItems;     // Do we want item submissions to this column to be
                        // completely ignored (no layout will happen).
  bool IsPreserveWidthAuto;
  S8 NavLayerCurrent;      // NavLayer in 1 byte
  U8 AutoFitQueue;         // Queue of 8 values for the next 8 frames to request
                           // auto-fit
  U8 CannotSkipItemsQueue; // Queue of 8 values for the next 8 frames to
                           // disable Clipped/SkipItem
  U8 SortDirection : 2;    // SortDirection_Ascending or
                           // SortDirection_Descending
  U8 SortDirectionsAvailCount : 2; // Number of available sort directions (0
                                   // to 3)
  U8 SortDirectionsAvailMask : 4;  // Mask of available sort directions (1-bit
                                   // each)
  U8 SortDirectionsAvailList;      // Ordered list of available sort directions
                                   // (2-bits each, total 8-bits)

  TableColumn() {
    memset(this, 0, sizeof(*this));
    StretchWeight = WidthRequest = -1.0f;
    NameOffset = -1;
    DisplayOrder = IndexWithinEnabledSet = -1;
    PrevEnabledColumn = NextEnabledColumn = -1;
    SortOrder = -1;
    SortDirection = SortDirection_None;
    DrawChannelCurrent = DrawChannelFrozen = DrawChannelUnfrozen = (U8)-1;
  }
};

// Transient cell data stored per row.
// sizeof() ~ 6
struct TableCellData {
  U32 BgColor;           // Actual color
  TableColumnIdx Column; // Column number
};

// Per-instance data that needs preserving across frames (seemingly most others
// do not need to be preserved aside from debug needs. Does that means they
// could be moved to TableTempData?) sizeof() ~ 24 bytes
struct TableInstanceData {
  ID TableInstanceID;
  float LastOuterHeight;         // Outer height from last frame
  float LastTopHeadersRowHeight; // Height of first consecutive header rows from
                                 // last frame (FIXME: this is used assuming
                                 // consecutive headers are in same frozen set)
  float LastFrozenHeight;        // Height of frozen section from last frame
  int HoveredRowLast;            // Index of row which was hovered last frame.
  int HoveredRowNext; // Index of row hovered this frame, set after encountering
                      // it.

  TableInstanceData() {
    TableInstanceID = 0;
    LastOuterHeight = LastTopHeadersRowHeight = LastFrozenHeight = 0.0f;
    HoveredRowLast = HoveredRowNext = -1;
  }
};

// FIXME-TABLE: more transient data could be stored in a stacked
// TableTempData: e.g. SortSpecs, incoming RowData sizeof() ~ 580 bytes +
// heap allocs described in TableBeginInitMemory()
struct GUI_API Table {
  ID ID;
  TableFlags Flags;
  void *RawData; // Single allocation to hold Columns[], DisplayOrderToIndex[]
                 // and RowCellData[]
  TableTempData *TempData;   // Transient data while table is active. Point
                             // within g.CurrentTableStack[]
  Span<TableColumn> Columns; // Point within RawData[]
  Span<TableColumnIdx>
      DisplayOrderToIndex; // Point within RawData[]. Store display order of
                           // columns (when not reordered, the values are
                           // 0...Count-1)
  Span<TableCellData> RowCellData;       // Point within RawData[]. Store cells
                                         // background requests for current row.
  BitArrayPtr EnabledMaskByDisplayOrder; // Column DisplayOrder -> IsEnabled map
  BitArrayPtr
      EnabledMaskByIndex; // Column Index -> IsEnabled map (== not hidden by
                          // user/api) in a format adequate for iterating column
                          // without touching cold data
  BitArrayPtr VisibleMaskByIndex; // Column Index -> IsVisibleX|IsVisibleY map
                                  // (== not hidden by user/api && not hidden
                                  // by scrolling/cliprect)
  TableFlags
      SettingsLoadedFlags; // Which data were loaded from the .ini file (e.g.
                           // when order is not altered we won't save order)
  int SettingsOffset;      // Offset in g.SettingsTables
  int LastFrameActive;
  int ColumnsCount; // Number of columns declared in BeginTable()
  int CurrentRow;
  int CurrentColumn;
  S16 InstanceCurrent; // Count of BeginTable() calls with same ID in the same
                       // frame (generally 0). This is a little bit similar to
                       // BeginCount for a window, but multiple table with same
                       // ID look are multiple tables, they are just synched.
  S16 InstanceInteracted; // Mark which instance (generally 0) of the same ID
                          // is being interacted with
  float RowPosY1;
  float RowPosY2;
  float RowMinHeight;    // Height submitted to TableNextRow()
  float RowCellPaddingY; // Top and bottom padding. Reloaded during row change.
  float RowTextBaseline;
  float RowIndentOffsetX;
  TableRowFlags RowFlags : 16; // Current row flags, see TableRowFlags_
  TableRowFlags LastRowFlags : 16;
  int RowBgColorCounter; // Counter for alternating background colors (can be
                         // fast-forwarded by e.g clipper), not same as
                         // CurrentRow because header rows typically don't
                         // increase this.
  U32 RowBgColor[2];     // Background color override for current row.
  U32 BorderColorStrong;
  U32 BorderColorLight;
  float BorderX1;
  float BorderX2;
  float HostIndentX;
  float MinColumnWidth;
  float OuterPaddingX;
  float
      CellPaddingX; // Padding from each borders. Locked in BeginTable()/Layout.
  float CellSpacingX1; // Spacing between non-bordered cells. Locked in
                       // BeginTable()/Layout.
  float CellSpacingX2;
  float InnerWidth; // User value passed to BeginTable(), see comments at the
                    // top of BeginTable() for details.
  float ColumnsGivenWidth;   // Sum of current column width
  float ColumnsAutoFitWidth; // Sum of ideal column width in order nothing to be
                             // clipped, used for auto-fitting and content width
                             // submission in outer window
  float ColumnsStretchSumWeights; // Sum of weight of all enabled stretching
                                  // columns
  float ResizedColumnNextWidth;
  float ResizeLockMinContentsX2; // Lock minimum contents width while resizing
                                 // down in order to not create feedback loops.
                                 // But we allow growing the table.
  float RefScale; // Reference scale to be able to rescale columns on font/dpi
                  // changes.
  float AngledHeadersHeight; // Set by TableAngledHeadersRow(), used in
                             // TableUpdateLayout()
  float AngledHeadersSlope;  // Set by TableAngledHeadersRow(), used in
                             // TableUpdateLayout()
  Rect OuterRect; // Note: for non-scrolling table, OuterRect.Max.y is often
                  // FLT_MAX until EndTable(), unless a height has been
                  // specified in BeginTable().
  Rect InnerRect; // InnerRect but without decoration. As with OuterRect, for
                  // non-scrolling tables, InnerRect.Max.y is
  Rect WorkRect;
  Rect InnerClipRect;
  Rect BgClipRect; // We use this to cpu-clip cell background color fill, evolve
                   // during the frame as we cross frozen rows boundaries
  Rect Bg0ClipRectForDrawCmd; // Actual DrawCmd clip rect for BG0/1 channel.
                              // This tends to be == OuterWindow->ClipRect at
                              // BeginTable() because output in BG0/BG1 is
                              // cpu-clipped
  Rect Bg2ClipRectForDrawCmd; // Actual DrawCmd clip rect for BG2 channel.
                              // This tends to be a correct, tight-fit,
                              // because output to BG2 are done by widgets
                              // relying on regular ClipRect.
  Rect HostClipRect; // This is used to check if we can eventually merge our
                     // columns draw calls into the current draw call of the
                     // current window.
  Rect HostBackupInnerClipRect; // Backup of InnerWindow->ClipRect during
                                // PushTableBackground()/PopTableBackground()
  Window *OuterWindow;          // Parent window for the table
  Window *InnerWindow;     // Window holding the table data (== OuterWindow or
                           // a child window)
  TextBuffer ColumnsNames; // Contiguous buffer holding columns names
  DrawListSplitter *DrawSplitter; // Shortcut to TempData->DrawSplitter while in
                                  // table. Isolate draw commands per columns to
                                  // avoid switching clip rect constantly
  TableInstanceData InstanceDataFirst;
  Vector<TableInstanceData>
      InstanceDataExtra; // FIXME-OPT: Using a small-vector pattern would be
                         // good.
  TableColumnSortSpecs SortSpecsSingle;
  Vector<TableColumnSortSpecs>
      SortSpecsMulti; // FIXME-OPT: Using a small-vector pattern would be good.
  TableSortSpecs SortSpecs; // Public facing sorts specs, this is what we
                            // return in TableGetSortSpecs()
  TableColumnIdx SortSpecsCount;
  TableColumnIdx
      ColumnsEnabledCount; // Number of enabled columns (<= ColumnsCount)
  TableColumnIdx
      ColumnsEnabledFixedCount; // Number of enabled columns (<= ColumnsCount)
  TableColumnIdx DeclColumnsCount;   // Count calls to TableSetupColumn()
  TableColumnIdx AngledHeadersCount; // Count columns with angled headers
  TableColumnIdx
      HoveredColumnBody; // Index of column whose visible region is being
                         // hovered. Important: == ColumnsCount when hovering
                         // empty region after the right-most column!
  TableColumnIdx HoveredColumnBorder; // Index of column whose right-border
                                      // is being hovered (for resizing).
  TableColumnIdx
      HighlightColumnHeader; // Index of column which should be highlighted.
  TableColumnIdx
      AutoFitSingleColumn;      // Index of single column requesting auto-fit.
  TableColumnIdx ResizedColumn; // Index of column being resized. Reset
                                // when InstanceCurrent==0.
  TableColumnIdx
      LastResizedColumn; // Index of column being resized from previous frame.
  TableColumnIdx HeldHeaderColumn; // Index of column header being held.
  TableColumnIdx
      ReorderColumn; // Index of column being reordered. (not cleared)
  TableColumnIdx ReorderColumnDir;      // -1 or +1
  TableColumnIdx LeftMostEnabledColumn; // Index of left-most non-hidden column.
  TableColumnIdx
      RightMostEnabledColumn; // Index of right-most non-hidden column.
  TableColumnIdx
      LeftMostStretchedColumn; // Index of left-most stretched column.
  TableColumnIdx
      RightMostStretchedColumn; // Index of right-most stretched column.
  TableColumnIdx
      ContextPopupColumn; // Column right-clicked on, of -1 if opening context
                          // menu from a neutral/empty spot
  TableColumnIdx FreezeRowsRequest; // Requested frozen rows count
  TableColumnIdx
      FreezeRowsCount; // Actual frozen row count (== FreezeRowsRequest, or == 0
                       // when no scrolling offset)
  TableColumnIdx FreezeColumnsRequest; // Requested frozen columns count
  TableColumnIdx FreezeColumnsCount;   // Actual frozen columns count (==
                                       // FreezeColumnsRequest, or == 0 when
                                       // no scrolling offset)
  TableColumnIdx
      RowCellDataCurrent; // Index of current RowCellData[] entry in current row
  TableDrawChannelIdx DummyDrawChannel; // Redirect non-visible columns here.
  TableDrawChannelIdx
      Bg2DrawChannelCurrent; // For Selectable() and other widgets drawing
                             // across columns after the freezing line. Index
                             // within DrawSplitter.Channels[]
  TableDrawChannelIdx Bg2DrawChannelUnfrozen;
  bool IsLayoutLocked; // Set by TableUpdateLayout() which is called when
                       // beginning the first row.
  bool IsInsideRow;    // Set when inside TableBeginRow()/TableEndRow().
  bool IsInitializing;
  bool IsSortSpecsDirty;
  bool IsUsingHeaders;     // Set when the first row had the
                           // TableRowFlags_Headers flag.
  bool IsContextPopupOpen; // Set when default context menu is open (also see:
                           // ContextPopupColumn, InstanceInteracted).
  bool DisableDefaultContextMenu; // Disable default context menu contents. You
                                  // may submit your own using
                                  // TableBeginContextMenuPopup()/EndPopup()
  bool IsSettingsRequestLoad;
  bool IsSettingsDirty; // Set when table settings have changed and needs to be
                        // reported into TableSetttings data.
  bool IsDefaultDisplayOrder; // Set when display order is unchanged from
                              // default (DisplayOrder contains 0...Count-1)
  bool IsResetAllRequest;
  bool IsResetDisplayOrderRequest;
  bool IsUnfrozenRows;        // Set when we got past the frozen row.
  bool IsDefaultSizingPolicy; // Set if user didn't explicitly set a sizing
                              // policy in BeginTable()
  bool IsActiveIdAliveBeforeTable;
  bool IsActiveIdInTable;
  bool HasScrollbarYCurr; // Whether ANY instance of this table had a vertical
                          // scrollbar during the current frame.
  bool HasScrollbarYPrev; // Whether ANY instance of this table had a vertical
                          // scrollbar during the previous.
  bool MemoryCompacted;
  bool HostSkipItems; // Backup of InnerWindow->SkipItem at the end of
                      // BeginTable(), because we will overwrite
                      // InnerWindow->SkipItem on a per-column basis

  Table() {
    memset(this, 0, sizeof(*this));
    LastFrameActive = -1;
  }
  ~Table() { GUI_FREE(RawData); }
};

// Transient data that are only needed between BeginTable() and EndTable(),
// those buffers are shared (1 per level of stacked table).
// - Accessing those requires chasing an extra pointer so for very frequently
// used data we leave them in the main table structure.
// - We also leave out of this structure data that tend to be particularly
// useful for debugging/metrics. sizeof() ~ 120 bytes.
struct GUI_API TableTempData {
  int TableIndex;                // Index in g.Tables.Buf[] pool
  float LastTimeActive;          // Last timestamp this structure was used
  float AngledheadersExtraWidth; // Used in EndTable()

  Vec2 UserOuterSize; // outer_size.x passed to BeginTable()
  DrawListSplitter DrawSplitter;

  Rect HostBackupWorkRect; // Backup of InnerWindow->WorkRect at the end of
                           // BeginTable()
  Rect HostBackupParentWorkRect; // Backup of InnerWindow->ParentWorkRect at
                                 // the end of BeginTable()
  Vec2 HostBackupPrevLineSize;   // Backup of InnerWindow->DC.PrevLineSize at
                                 // the end of BeginTable()
  Vec2 HostBackupCurrLineSize;   // Backup of InnerWindow->DC.CurrLineSize at
                                 // the end of BeginTable()
  Vec2 HostBackupCursorMaxPos;   // Backup of InnerWindow->DC.CursorMaxPos at
                                 // the end of BeginTable()
  Vec1 HostBackupColumnsOffset;  // Backup of OuterWindow->DC.ColumnsOffset at
                                 // the end of BeginTable()
  float HostBackupItemWidth; // Backup of OuterWindow->DC.ItemWidth at the end
                             // of BeginTable()
  int HostBackupItemWidthStackSize; // Backup of
                                    // OuterWindow->DC.ItemWidthStack.Size at
                                    // the end of BeginTable()

  TableTempData() {
    memset(this, 0, sizeof(*this));
    LastTimeActive = -1.0f;
  }
};

// sizeof() ~ 12
struct TableColumnSettings {
  float WidthOrWeight;
  ID UserID;
  TableColumnIdx Index;
  TableColumnIdx DisplayOrder;
  TableColumnIdx SortOrder;
  U8 SortDirection : 2;
  U8 IsEnabled : 1; // "Visible" in ini file
  U8 IsStretch : 1;

  TableColumnSettings() {
    WidthOrWeight = 0.0f;
    UserID = 0;
    Index = -1;
    DisplayOrder = SortOrder = -1;
    SortDirection = SortDirection_None;
    IsEnabled = 1;
    IsStretch = 0;
  }
};

// This is designed to be stored in a single ChunkStream (1 header followed by
// N TableColumnSettings, etc.)
struct TableSettings {
  ID ID;                // Set to 0 to invalidate/delete the setting
  TableFlags SaveFlags; // Indicate data we want to save using the
                        // Resizable/Reorderable/Sortable/Hideable flags
                        // (could be using its own flags..)
  float RefScale; // Reference scale to be able to rescale columns on font/dpi
                  // changes.
  TableColumnIdx ColumnsCount;
  TableColumnIdx
      ColumnsCountMax; // Maximum number of columns this settings instance can
                       // store, we can recycle a settings instance with lower
                       // number of columns but not higher
  bool WantApply; // Set when loaded from .ini data (to enable merging/loading
                  // .ini data into an already running context)

  TableSettings() { memset(this, 0, sizeof(*this)); }
  TableColumnSettings *GetColumnSettings() {
    return (TableColumnSettings *)(this + 1);
  }
};

//-----------------------------------------------------------------------------
// [SECTION] Gui internal API
// No guarantee of forward compatibility here!
//-----------------------------------------------------------------------------

namespace Gui {
// Windows
// We should always have a CurrentWindow in the stack (there is an implicit
// "Debug" window) If this ever crash because g.CurrentWindow is NULL it means
// that either
// - Gui::NewFrame() has never been called, which is illegal.
// - You are calling Gui functions after Gui::EndFrame()/Gui::Render() and
// before the next Gui::NewFrame(), which is also illegal.
inline Window *GetCurrentWindowRead() {
  Context &g = *GGui;
  return g.CurrentWindow;
}
inline Window *GetCurrentWindow() {
  Context &g = *GGui;
  g.CurrentWindow->WriteAccessed = true;
  return g.CurrentWindow;
}
GUI_API inline Window *FindWindowByID(ID id) {
  Context &g = *GGui;
  return (Window *)g.WindowsById.GetVoidPtr(id);
}

GUI_API inline Window *FindWindowByName(const char *name) {
  ID id = HashStr(name);
  return FindWindowByID(id);
}

GUI_API void UpdateWindowParentAndRootLinks(Window *window, WindowFlags flags,
                                            Window *parent_window);
GUI_API Vec2 CalcWindowNextAutoFitSize(Window *window);
GUI_API bool IsWindowChildOf(Window *window, Window *potential_parent,
                             bool popup_hierarchy);
GUI_API inline bool IsWindowWithinBeginStackOf(Window *window,
                                               Window *potential_parent) {
  if (window->RootWindow == potential_parent)
    return true;
  while (window != NULL) {
    if (window == potential_parent)
      return true;
    window = window->ParentWindowInBeginStack;
  }
  return false;
}

GUI_API bool IsWindowAbove(Window *potential_above, Window *potential_below);
GUI_API inline bool IsWindowNavFocusable(Window *window) {
  return window->WasActive && window == window->RootWindow &&
         !(window->Flags & WindowFlags_NoNavFocus);
}

GUI_API void SetWindowPos(Window *window, const Vec2 &pos, Cond cond = 0);
GUI_API void SetWindowSize(Window *window, const Vec2 &size, Cond cond = 0);
GUI_API inline void SetWindowCollapsed(Window *window, bool collapsed,
                                       Cond cond = 0) {
  // Test condition (NB: bit 0 is always true) and clear flags for next time
  if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)
    return;
  window->SetWindowCollapsedAllowFlags &=
      ~(Cond_Once | Cond_FirstUseEver | Cond_Appearing);

  // Set
  window->Collapsed = collapsed;
}

GUI_API void SetWindowHitTestHole(Window *window, const Vec2 &pos,
                                  const Vec2 &size);
GUI_API inline void SetWindowHiddenAndSkipItemsForCurrentFrame(Window *window) {
  window->Hidden = window->SkipItems = true;
  window->HiddenFramesCanSkipItems = 1;
}

inline Rect WindowRectAbsToRel(Window *window, const Rect &r) {
  Vec2 off = window->DC.CursorStartPos;
  return Rect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x,
              r.Max.y - off.y);
}
inline Rect WindowRectRelToAbs(Window *window, const Rect &r) {
  Vec2 off = window->DC.CursorStartPos;
  return Rect(r.Min.x + off.x, r.Min.y + off.y, r.Max.x + off.x,
              r.Max.y + off.y);
}
inline Vec2 WindowPosRelToAbs(Window *window, const Vec2 &p) {
  Vec2 off = window->DC.CursorStartPos;
  return Vec2(p.x + off.x, p.y + off.y);
}

// Windows: Display Order and Focus Order
GUI_API void FocusWindow(Window *window, FocusRequestFlags flags = 0);
GUI_API void FocusTopMostWindowUnderOne(Window *under_this_window,
                                        Window *ignore_window,
                                        Viewport *filter_viewport,
                                        FocusRequestFlags flags);
GUI_API void BringWindowToFocusFront(Window *window);
GUI_API void BringWindowToDisplayFront(Window *window);
GUI_API void BringWindowToDisplayBack(Window *window);
GUI_API void BringWindowToDisplayBehind(Window *window, Window *above_window);
GUI_API inline int FindWindowDisplayIndex(Window *window) {
  Context &g = *GGui;
  return g.Windows.index_from_ptr(g.Windows.find(window));
}

GUI_API Window *FindBottomMostVisibleWindowWithinBeginStack(Window *window);

// Fonts, drawing
GUI_API void SetCurrentFont(Font *font);
inline Font *GetDefaultFont() {
  Context &g = *GGui;
  return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0];
}
inline DrawList *GetForegroundDrawList(Window *window) {
  GUI_UNUSED(window);
  return GetForegroundDrawList();
} // This seemingly unnecessary wrapper simplifies compatibility between the
  // 'master' and 'docking' branches.
GUI_API DrawList *GetBackgroundDrawList(
    Viewport
        *viewport); // get background draw list for the given viewport. this
                    // draw list will be the first rendering one. Useful to
                    // quickly draw shapes/text behind dear gui contents.
GUI_API DrawList *GetForegroundDrawList(
    Viewport *viewport); // get foreground draw list for the given viewport.
                         // this draw list will be the last rendered one. Useful
                         // to quickly draw shapes/text over dear gui contents.
GUI_API void AddDrawListToDrawDataEx(DrawData *draw_data,
                                     Vector<DrawList *> *out_list,
                                     DrawList *draw_list);

// Init
GUI_API void Initialize();
GUI_API void Shutdown(); // Since 1.60 this is a _private_ function. You can
                         // call DestroyContext() to destroy the context
                         // created by CreateContext().

// NewFrame
GUI_API void UpdateInputEvents(bool trickle_fast_inputs);
GUI_API void UpdateHoveredWindowAndCaptureFlags();
GUI_API void StartMouseMovingWindow(Window *window);
GUI_API void UpdateMouseMovingWindowNewFrame();
GUI_API void UpdateMouseMovingWindowEndFrame();

// Generic context hooks
GUI_API ID AddContextHook(Context *context, const ContextHook *hook);
GUI_API void RemoveContextHook(Context *context, ID hook_to_remove);
GUI_API inline void CallContextHooks(Context *ctx, ContextHookType hook_type) {
  Context &g = *ctx;
  for (ContextHook &hook : g.Hooks)
    if (hook.Type == hook_type)
      hook.Callback(&g, &hook);
}

// Viewports
GUI_API inline void SetWindowViewport(Window *window, ViewportP *viewport) {
  window->Viewport = viewport;
}

// Settings
GUI_API inline void MarkIniSettingsDirty() {
  Context &g = *GGui;
  if (g.SettingsDirtyTimer <= 0.0f)
    g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

GUI_API inline void MarkIniSettingsDirty(Window *window) {
  Context &g = *GGui;
  if (!(window->Flags & WindowFlags_NoSavedSettings))
    if (g.SettingsDirtyTimer <= 0.0f)
      g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

GUI_API inline void ClearIniSettings() {
  Context &g = *GGui;
  g.SettingsIniData.clear();
  for (SettingsHandler &handler : g.SettingsHandlers)
    if (handler.ClearAllFn != NULL)
      handler.ClearAllFn(&g, &handler);
}

GUI_API void AddSettingsHandler(const SettingsHandler *handler);
GUI_API void RemoveSettingsHandler(const char *type_name);
GUI_API inline SettingsHandler *FindSettingsHandler(const char *type_name) {
  Context &g = *GGui;
  const ID type_hash = HashStr(type_name);
  for (SettingsHandler &handler : g.SettingsHandlers)
    if (handler.TypeHash == type_hash)
      return &handler;
  return NULL;
}

// Settings - Windows
GUI_API WindowSettings *CreateNewWindowSettings(const char *name);
GUI_API inline WindowSettings *FindWindowSettingsByID(ID id) {
  Context &g = *GGui;
  for (WindowSettings *settings = g.SettingsWindows.begin(); settings != NULL;
       settings = g.SettingsWindows.next_chunk(settings))
    if (settings->ID == id && !settings->WantDelete)
      return settings;
  return NULL;
}

GUI_API inline WindowSettings *FindWindowSettingsByWindow(Window *window) {
  Context &g = *GGui;
  if (window->SettingsOffset != -1)
    return g.SettingsWindows.ptr_from_offset(window->SettingsOffset);
  return FindWindowSettingsByID(window->ID);
}

GUI_API void ClearWindowSettings(const char *name);

// Localization
GUI_API inline void LocalizeRegisterEntries(const LocEntry *entries,
                                            int count) {
  Context &g = *GGui;
  for (int n = 0; n < count; n++)
    g.LocalizationTable[entries[n].Key] = entries[n].Text;
}

inline const char *LocalizeGetMsg(LocKey key) {
  Context &g = *GGui;
  const char *msg = g.LocalizationTable[key];
  return msg ? msg : "*Missing Text*";
}

// Scrolling
GUI_API inline void SetScrollX(Window *window, float scroll_x) {
  window->ScrollTarget.x = scroll_x;
  window->ScrollTargetCenterRatio.x = 0.0f;
  window->ScrollTargetEdgeSnapDist.x = 0.0f;
}

GUI_API inline void SetScrollY(Window *window, float scroll_y) {
  window->ScrollTarget.y = scroll_y;
  window->ScrollTargetCenterRatio.y = 0.0f;
  window->ScrollTargetEdgeSnapDist.y = 0.0f;
}

GUI_API void SetScrollFromPosX(Window *window, float local_x,
                               float center_x_ratio);
GUI_API void SetScrollFromPosY(Window *window, float local_y,
                               float center_y_ratio);

// Early work-in-progress API (ScrollToItem() will become public)
GUI_API void ScrollToItem(ScrollFlags flags = 0);
GUI_API void ScrollToRect(Window *window, const Rect &rect,
                          ScrollFlags flags = 0);
GUI_API Vec2 ScrollToRectEx(Window *window, const Rect &rect,
                            ScrollFlags flags = 0);
// #ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
inline void ScrollToBringRectIntoView(Window *window, const Rect &rect) {
  ScrollToRect(window, rect, ScrollFlags_KeepVisibleEdgeY);
}
// #endif

// Basic Accessors
inline ItemStatusFlags GetItemStatusFlags() {
  Context &g = *GGui;
  return g.LastItemData.StatusFlags;
}
inline ItemFlags GetItemFlags() {
  Context &g = *GGui;
  return g.LastItemData.InFlags;
}
inline ID GetActiveID() {
  Context &g = *GGui;
  return g.ActiveId;
}
inline ID GetFocusID() {
  Context &g = *GGui;
  return g.NavId;
}
GUI_API void SetActiveID(ID id, Window *window);
GUI_API void SetFocusID(ID id, Window *window);
GUI_API inline void ClearActiveID() {
  SetActiveID(0, NULL); // g.ActiveId = 0;
}

GUI_API inline ID GetHoveredID() {
  Context &g = *GGui;
  return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
}

GUI_API inline void SetHoveredID(ID id) {
  Context &g = *GGui;
  g.HoveredId = id;
  g.HoveredIdAllowOverlap = false;
  if (id != 0 && g.HoveredIdPreviousFrame != id)
    g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
}

GUI_API inline void KeepAliveID(ID id) {
  Context &g = *GGui;
  if (g.ActiveId == id)
    g.ActiveIdIsAlive = id;
  if (g.ActiveIdPreviousFrame == id)
    g.ActiveIdPreviousFrameIsAlive = true;
}

GUI_API void
MarkItemEdited(ID id); // Mark data associated to given item as "edited",
                       // used by IsItemDeactivatedAfterEdit() function.
GUI_API void
PushOverrideID(ID id); // Push given value as-is at the top of the ID stack
                       // (whereas PushID combines old and new hashes)
GUI_API ID GetIDWithSeed(const char *str_id_begin, const char *str_id_end,
                         ID seed);
GUI_API ID GetIDWithSeed(int n, ID seed);

// Basic Helpers for widget code
GUI_API inline void ItemSize(const Vec2 &size, float text_baseline_y = -1.0f) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return;

  // We increase the height in this function to accommodate for baseline offset.
  // In theory we should be offsetting the starting position
  // (window->DC.CursorPos), that will be the topic of a larger refactor, but
  // since ItemSize() is not yet an API that moves the cursor (to handle e.g.
  // wrapping) enlarging the height has the same effect.
  const float offset_to_match_baseline_y =
      (text_baseline_y >= 0)
          ? Max(0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y)
          : 0.0f;

  const float line_y1 = window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y
                                              : window->DC.CursorPos.y;
  const float line_height =
      Max(window->DC.CurrLineSize.y, /*Max(*/ window->DC.CursorPos.y -
                                         line_y1 /*, 0.0f)*/ + size.y +
                                         offset_to_match_baseline_y);

  // Always align ourselves on pixel boundaries
  // if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos,
  // window->DC.CursorPos + Vec2(size.x, line_height),
  // GUI_COL32(255,0,0,200));
  // // [DEBUG]
  window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
  window->DC.CursorPosPrevLine.y = line_y1;
  window->DC.CursorPos.x = GUI_TRUNC(window->Pos.x + window->DC.Indent.x +
                                     window->DC.ColumnsOffset.x); // Next line
  window->DC.CursorPos.y =
      GUI_TRUNC(line_y1 + line_height + g.Style.ItemSpacing.y); // Next line
  window->DC.CursorMaxPos.x =
      Max(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
  window->DC.CursorMaxPos.y =
      Max(window->DC.CursorMaxPos.y,
          window->DC.CursorPos.y - g.Style.ItemSpacing.y);
  // if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f,
  // GUI_COL32(255,0,0,255), 4); // [DEBUG]

  window->DC.PrevLineSize.y = line_height;
  window->DC.CurrLineSize.y = 0.0f;
  window->DC.PrevLineTextBaseOffset =
      Max(window->DC.CurrLineTextBaseOffset, text_baseline_y);
  window->DC.CurrLineTextBaseOffset = 0.0f;
  window->DC.IsSameLine = window->DC.IsSetPos = false;

  // Horizontal layout mode
  if (window->DC.LayoutType == LayoutType_Horizontal)
    SameLine();
}

inline void ItemSize(const Rect &bb, float text_baseline_y = -1.0f) {
  ItemSize(bb.GetSize(), text_baseline_y);
} // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.
GUI_API bool ItemAdd(const Rect &bb, ID id, const Rect *nav_bb = NULL,
                     ItemFlags extra_flags = 0);
GUI_API bool ItemHoverable(const Rect &bb, ID id, ItemFlags item_flags);
GUI_API inline bool IsWindowContentHoverable(Window *window,
                                             HoveredFlags flags = 0) {
  // An active popup disable hovering on other windows (apart from its own
  // children)
  // FIXME-OPT: This could be cached/stored within the window.
  Context &g = *GGui;
  if (g.NavWindow)
    if (Window *focused_root_window = g.NavWindow->RootWindow)
      if (focused_root_window->WasActive &&
          focused_root_window != window->RootWindow) {
        // For the purpose of those flags we differentiate "standard popup" from
        // "modal popup" NB: The 'else' is important because Modal windows are
        // also Popups.
        bool want_inhibit = false;
        if (focused_root_window->Flags & WindowFlags_Modal)
          want_inhibit = true;
        else if ((focused_root_window->Flags & WindowFlags_Popup) &&
                 !(flags & HoveredFlags_AllowWhenBlockedByPopup))
          want_inhibit = true;

        // Inhibit hover unless the window is within the stack of our
        // modal/popup
        if (want_inhibit)
          if (!IsWindowWithinBeginStackOf(window->RootWindow,
                                          focused_root_window))
            return false;
      }
  return true;
}

GUI_API inline bool IsClippedEx(const Rect &bb, ID id) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (!bb.Overlaps(window->ClipRect))
    if (id == 0 || (id != g.ActiveId && id != g.NavId))
      if (!g.LogEnabled)
        return true;
  return false;
}

GUI_API inline void SetLastItemData(ID item_id, ItemFlags in_flags,
                                    ItemStatusFlags item_flags,
                                    const Rect &item_rect) {
  Context &g = *GGui;
  g.LastItemData.ID = item_id;
  g.LastItemData.InFlags = in_flags;
  g.LastItemData.StatusFlags = item_flags;
  g.LastItemData.Rect = g.LastItemData.NavRect = item_rect;
}

GUI_API Vec2 CalcItemSize(Vec2 size, float default_w, float default_h);
GUI_API inline float CalcWrapWidthForPos(const Vec2 &pos, float wrap_pos_x) {
  if (wrap_pos_x < 0.0f)
    return 0.0f;

  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (wrap_pos_x == 0.0f) {
    // We could decide to setup a default wrapping max point for auto-resizing
    // windows, or have auto-wrap (with unspecified wrapping pos) behave as a
    // ContentSize extending function?
    // if (window->Hidden && (window->Flags &
    // WindowFlags_AlwaysAutoResize))
    //    wrap_pos_x = Max(window->WorkRect.Min.x + g.FontSize * 10.0f,
    //    window->WorkRect.Max.x);
    // else
    wrap_pos_x = window->WorkRect.Max.x;
  } else if (wrap_pos_x > 0.0f) {
    wrap_pos_x +=
        window->Pos.x -
        window->Scroll.x; // wrap_pos_x is provided is window local space
  }

  return Max(wrap_pos_x - pos.x, 1.0f);
}

GUI_API void PushMultiItemsWidths(int components, float width_full);
GUI_API inline bool IsItemToggledSelection() {
  Context &g = *GGui;
  return (g.LastItemData.StatusFlags & ItemStatusFlags_ToggledSelection)
             ? true
             : false;
}
// Was the last item selection toggled?
// (after Selectable(), TreeNode() etc.
// We only returns toggle _event_ in
// order to handle clipping correctly)
GUI_API inline Vec2 GetContentRegionMaxAbs() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  Vec2 mx = (window->DC.CurrentColumns || g.CurrentTable)
                ? window->WorkRect.Max
                : window->ContentRegionRect.Max;
  return mx;
}

GUI_API void ShrinkWidths(ShrinkWidthItem *items, int count,
                          float width_excess);

// Parameter stacks (shared)
GUI_API void PushItemFlag(ItemFlags option, bool enabled);
GUI_API void PopItemFlag();
GUI_API const DataVarInfo *GetStyleVarInfo(StyleVar idx);

// Logging/Capture
GUI_API void LogBegin(
    LogType type,
    int auto_open_depth); // -> BeginCapture() when we design v2 api, for now
                          // stay under the radar by using the old name.
GUI_API inline void LogToBuffer(int auto_open_depth = -1) {
  Context &g = *GGui;
  if (g.LogEnabled)
    return;
  LogBegin(LogType_Buffer, auto_open_depth);
}
// Start logging/capturing to internal buffer
GUI_API void LogRenderedText(const Vec2 *ref_pos, const char *text,
                             const char *text_end = NULL);
GUI_API inline void LogSetNextTextDecoration(const char *prefix,
                                             const char *suffix) {
  Context &g = *GGui;
  g.LogNextPrefix = prefix;
  g.LogNextSuffix = suffix;
}

// Popups, Modals, Tooltips
GUI_API bool BeginChildEx(const char *name, ID id, const Vec2 &size_arg,
                          ChildFlags child_flags, WindowFlags window_flags);
GUI_API void OpenPopupEx(ID id, PopupFlags popup_flags = PopupFlags_None);
GUI_API void ClosePopupToLevel(int remaining,
                               bool restore_focus_to_window_under_popup);
GUI_API void ClosePopupsOverWindow(Window *ref_window,
                                   bool restore_focus_to_window_under_popup);
GUI_API inline void ClosePopupsExceptModals() {
  Context &g = *GGui;

  int popup_count_to_keep;
  for (popup_count_to_keep = g.OpenPopupStack.Size; popup_count_to_keep > 0;
       popup_count_to_keep--) {
    Window *window = g.OpenPopupStack[popup_count_to_keep - 1].Window;
    if (!window || (window->Flags & WindowFlags_Modal))
      break;
  }
  if (popup_count_to_keep <
      g.OpenPopupStack.Size) // This test is not required but it allows to set a
                             // convenient breakpoint on the statement below
    ClosePopupToLevel(popup_count_to_keep, true);
}

GUI_API bool IsPopupOpen(ID id, PopupFlags popup_flags);
GUI_API inline bool BeginPopupEx(ID id, WindowFlags flags) {
  Context &g = *GGui;
  if (!IsPopupOpen(id, PopupFlags_None)) {
    g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume
                                   // those values
    return false;
  }

  char name[20];
  if (flags & WindowFlags_ChildMenu)
    FormatString(name, GUI_ARRAYSIZE(name), "##Menu_%02d",
                 g.BeginMenuCount); // Recycle windows based on depth
  else
    FormatString(
        name, GUI_ARRAYSIZE(name), "##Popup_%08x",
        id); // Not recycling, so we can close/open during the same frame

  flags |= WindowFlags_Popup;
  bool is_open = Begin(name, NULL, flags);
  if (!is_open) // NB: Begin can return false when the popup is completely
                // clipped (e.g. zero size display)
    EndPopup();

  return is_open;
}

GUI_API bool BeginTooltipEx(TooltipFlags tooltip_flags,
                            WindowFlags extra_window_flags);
GUI_API inline bool BeginTooltipHidden() {
  Context &g = *GGui;
  bool ret = Begin("##Tooltip_Hidden", NULL,
                   WindowFlags_Tooltip | WindowFlags_NoInputs |
                       WindowFlags_NoTitleBar | WindowFlags_NoMove |
                       WindowFlags_NoResize | WindowFlags_NoSavedSettings |
                       WindowFlags_AlwaysAutoResize);
  SetWindowHiddenAndSkipItemsForCurrentFrame(g.CurrentWindow);
  return ret;
}

GUI_API inline Rect GetPopupAllowedExtentRect(Window *window) {
  Context &g = *GGui;
  GUI_UNUSED(window);
  Rect r_screen = ((ViewportP *)(void *)GetMainViewport())->GetMainRect();
  Vec2 padding = g.Style.DisplaySafeAreaPadding;
  r_screen.Expand(
      Vec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f,
           (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));
  return r_screen;
}

GUI_API inline Window *GetTopMostPopupModal() {
  Context &g = *GGui;
  for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
    if (Window *popup = g.OpenPopupStack.Data[n].Window)
      if (popup->Flags & WindowFlags_Modal)
        return popup;
  return NULL;
}

GUI_API Window *GetTopMostAndVisiblePopupModal();
GUI_API inline Window *FindBlockingModal(Window *window) {
  Context &g = *GGui;
  if (g.OpenPopupStack.Size <= 0)
    return NULL;

  // Find a modal that has common parent with specified window. Specified window
  // should be positioned behind that modal.
  for (PopupData &popup_data : g.OpenPopupStack) {
    Window *popup_window = popup_data.Window;
    if (popup_window == NULL || !(popup_window->Flags & WindowFlags_Modal))
      continue;
    if (!popup_window->Active &&
        !popup_window
             ->WasActive) // Check WasActive, because this code may run before
                          // popup renders on current frame, also check Active
                          // to handle newly created windows.
      continue;
    if (window == NULL) // FindBlockingModal(NULL) test for if FocusWindow(NULL)
                        // is naturally possible via a mouse click.
      return popup_window;
    if (IsWindowWithinBeginStackOf(window,
                                   popup_window)) // Window may be over modal
      continue;
    return popup_window; // Place window right below first block modal
  }
  return NULL;
}

GUI_API Vec2 FindBestWindowPosForPopup(Window *window);
GUI_API Vec2 FindBestWindowPosForPopupEx(const Vec2 &ref_pos, const Vec2 &size,
                                         Dir *last_dir, const Rect &r_outer,
                                         const Rect &r_avoid,
                                         PopupPositionPolicy policy);

// Menus
GUI_API bool BeginViewportSideBar(const char *name, Viewport *viewport, Dir dir,
                                  float size, WindowFlags window_flags);
GUI_API bool BeginMenuEx(const char *label, const char *icon,
                         bool enabled = true);
GUI_API bool MenuItemEx(const char *label, const char *icon,
                        const char *shortcut = NULL, bool selected = false,
                        bool enabled = true);

// Combos
GUI_API bool BeginComboPopup(ID popup_id, const Rect &bb, ComboFlags flags);
GUI_API bool BeginComboPreview();
GUI_API inline void EndComboPreview() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  ComboPreviewData *preview_data = &g.ComboPreviewData;

  // FIXME: Using CursorMaxPos approximation instead of correct AABB which we
  // will store in DrawCmd in the future
  DrawList *draw_list = window->DrawList;
  if (window->DC.CursorMaxPos.x < preview_data->PreviewRect.Max.x &&
      window->DC.CursorMaxPos.y < preview_data->PreviewRect.Max.y)
    if (draw_list->CmdBuffer.Size >
        1) // Unlikely case that the PushClipRect() didn't create a command
    {
      draw_list->_CmdHeader.ClipRect =
          draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ClipRect =
              draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 2].ClipRect;
      draw_list->_TryMergeDrawCmds();
    }
  PopClipRect();
  window->DC.CursorPos = preview_data->BackupCursorPos;
  window->DC.CursorMaxPos =
      Max(window->DC.CursorMaxPos, preview_data->BackupCursorMaxPos);
  window->DC.CursorPosPrevLine = preview_data->BackupCursorPosPrevLine;
  window->DC.PrevLineTextBaseOffset =
      preview_data->BackupPrevLineTextBaseOffset;
  window->DC.LayoutType = preview_data->BackupLayout;
  window->DC.IsSameLine = false;
  preview_data->PreviewRect = Rect();
}

// Gamepad/Keyboard Navigation
GUI_API void NavInitWindow(Window *window, bool force_reinit);
GUI_API void NavInitRequestApplyResult();
GUI_API inline bool NavMoveRequestButNoResultYet() {
  Context &g = *GGui;
  return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 &&
         g.NavMoveResultOther.ID == 0;
}

GUI_API void NavMoveRequestSubmit(Dir move_dir, Dir clip_dir,
                                  NavMoveFlags move_flags,
                                  ScrollFlags scroll_flags);
GUI_API void NavMoveRequestForward(Dir move_dir, Dir clip_dir,
                                   NavMoveFlags move_flags,
                                   ScrollFlags scroll_flags);
GUI_API void NavMoveRequestResolveWithLastItem(NavItemData *result);
GUI_API void
NavMoveRequestResolveWithPastTreeNode(NavItemData *result,
                                      NavTreeNodeData *tree_node_data);
GUI_API void NavMoveRequestCancel();
GUI_API void NavMoveRequestApplyResult();
GUI_API void NavMoveRequestTryWrapping(Window *window, NavMoveFlags move_flags);
GUI_API inline void NavClearPreferredPosForAxis(Axis axis) {
  Context &g = *GGui;
  g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer][axis] =
      FLT_MAX;
}

GUI_API inline void NavRestoreHighlightAfterMove() {
  Context &g = *GGui;
  g.NavDisableHighlight = false;
  g.NavDisableMouseHover = g.NavMousePosDirty = true;
}

GUI_API inline void NavUpdateCurrentWindowIsScrollPushableX() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  window->DC.NavIsScrollPushableX =
      (g.CurrentTable == NULL && window->DC.CurrentColumns == NULL);
}

GUI_API void SetNavWindow(Window *window);
GUI_API void SetNavID(ID id, NavLayer nav_layer, ID focus_scope_id,
                      const Rect &rect_rel);

// Focus/Activation
// This should be part of a larger set of API: FocusItem(offset = -1),
// FocusItemByID(id), ActivateItem(offset = -1), ActivateItemByID(id) etc. which
// are much harder to design and implement than expected. I have a couple of
// private branches on this matter but it's not simple. For now implementing the
// easy ones.
GUI_API void FocusItem(); // Focus last item (no selection/activation).
GUI_API inline void ActivateItemByID(ID id) {
  Context &g = *GGui;
  g.NavNextActivateId = id;
  g.NavNextActivateFlags = ActivateFlags_None;
}
// Activate an item by ID (button, checkbox, tree node
// etc.). Activation is queued and processed on the
// next frame when the item is encountered again.

// Inputs
// FIXME: Eventually we should aim to move e.g. IsActiveIdUsingKey() into
// IsKeyXXX functions.
inline bool IsNamedKey(Key key) {
  return key >= Key_NamedKey_BEGIN && key < Key_NamedKey_END;
}
inline bool IsNamedKeyOrModKey(Key key) {
  return (key >= Key_NamedKey_BEGIN && key < Key_NamedKey_END) ||
         key == Mod_Ctrl || key == Mod_Shift || key == Mod_Alt ||
         key == Mod_Super || key == Mod_Shortcut;
}
inline bool IsLegacyKey(Key key) {
  return key >= Key_LegacyNativeKey_BEGIN && key < Key_LegacyNativeKey_END;
}
inline bool IsKeyboardKey(Key key) {
  return key >= Key_Keyboard_BEGIN && key < Key_Keyboard_END;
}
inline bool IsGamepadKey(Key key) {
  return key >= Key_Gamepad_BEGIN && key < Key_Gamepad_END;
}
inline bool IsMouseKey(Key key) {
  return key >= Key_Mouse_BEGIN && key < Key_Mouse_END;
}
inline bool IsAliasKey(Key key) {
  return key >= Key_Aliases_BEGIN && key < Key_Aliases_END;
}
inline KeyChord ConvertShortcutMod(KeyChord key_chord) {
  Context &g = *GGui;
  GUI_ASSERT_PARANOID(key_chord & Mod_Shortcut);
  return (key_chord & ~Mod_Shortcut) |
         (g.IO.ConfigMacOSXBehaviors ? Mod_Super : Mod_Ctrl);
}
inline Key ConvertSingleModFlagToKey(Context *ctx, Key key) {
  Context &g = *ctx;
  if (key == Mod_Ctrl)
    return Key_ReservedForModCtrl;
  if (key == Mod_Shift)
    return Key_ReservedForModShift;
  if (key == Mod_Alt)
    return Key_ReservedForModAlt;
  if (key == Mod_Super)
    return Key_ReservedForModSuper;
  if (key == Mod_Shortcut)
    return (g.IO.ConfigMacOSXBehaviors ? Key_ReservedForModSuper
                                       : Key_ReservedForModCtrl);
  return key;
}

GUI_API KeyData *GetKeyData(Context *ctx, Key key);
inline KeyData *GetKeyData(Key key) {
  Context &g = *GGui;
  return GetKeyData(&g, key);
}
GUI_API void GetKeyChordName(KeyChord key_chord, char *out_buf,
                             int out_buf_size);
inline Key MouseButtonToKey(MouseButton button) {
  GUI_ASSERT(button >= 0 && button < MouseButton_COUNT);
  return (Key)(Key_MouseLeft + button);
}
GUI_API bool IsMouseDragPastThreshold(MouseButton button,
                                      float lock_threshold = -1.0f);
GUI_API inline Vec2 GetKeyMagnitude2d(Key key_left, Key key_right, Key key_up,
                                      Key key_down) {
  return Vec2(
      GetKeyData(key_right)->AnalogValue - GetKeyData(key_left)->AnalogValue,
      GetKeyData(key_down)->AnalogValue - GetKeyData(key_up)->AnalogValue);
}

GUI_API float GetNavTweakPressedAmount(Axis axis);
GUI_API inline int CalcTypematicRepeatAmount(float t0, float t1,
                                             float repeat_delay,
                                             float repeat_rate) {
  if (t1 == 0.0f)
    return 1;
  if (t0 >= t1)
    return 0;
  if (repeat_rate <= 0.0f)
    return (t0 < repeat_delay) && (t1 >= repeat_delay);
  const int count_t0 =
      (t0 < repeat_delay) ? -1 : (int)((t0 - repeat_delay) / repeat_rate);
  const int count_t1 =
      (t1 < repeat_delay) ? -1 : (int)((t1 - repeat_delay) / repeat_rate);
  const int count = count_t1 - count_t0;
  return count;
}

GUI_API inline void GetTypematicRepeatRate(InputFlags flags,
                                           float *repeat_delay,
                                           float *repeat_rate) {
  Context &g = *GGui;
  switch (flags & InputFlags_RepeatRateMask_) {
  case InputFlags_RepeatRateNavMove:
    *repeat_delay = g.IO.KeyRepeatDelay * 0.72f;
    *repeat_rate = g.IO.KeyRepeatRate * 0.80f;
    return;
  case InputFlags_RepeatRateNavTweak:
    *repeat_delay = g.IO.KeyRepeatDelay * 0.72f;
    *repeat_rate = g.IO.KeyRepeatRate * 0.30f;
    return;
  case InputFlags_RepeatRateDefault:
  default:
    *repeat_delay = g.IO.KeyRepeatDelay * 1.00f;
    *repeat_rate = g.IO.KeyRepeatRate * 1.00f;
    return;
  }
}

GUI_API inline void TeleportMousePos(const Vec2 &pos) {
  Context &g = *GGui;
  g.IO.MousePos = g.IO.MousePosPrev = pos;
  g.IO.MouseDelta = Vec2(0.0f, 0.0f);
  g.IO.WantSetMousePos = true;
  // GUI_DEBUG_LOG_IO("TeleportMousePos: (%.1f,%.1f)\n", io.MousePos.x,
  // io.MousePos.y);
}

GUI_API void SetActiveIdUsingAllKeyboardKeys();
inline bool IsActiveIdUsingNavDir(Dir dir) {
  Context &g = *GGui;
  return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0;
}

// [EXPERIMENTAL] Low-Level: Key/Input Ownership
// - The idea is that instead of "eating" a given input, we can link to an owner
// id.
// - Ownership is most often claimed as a result of reacting to a press/down
// event (but occasionally may be claimed ahead).
// - Input queries can then read input by specifying KeyOwner_Any (== 0),
// KeyOwner_None (== -1) or a custom ID.
// - Legacy input queries (without specifying an owner or _Any or _None) are
// equivalent to using KeyOwner_Any (== 0).
// - Input ownership is automatically released on the frame after a key is
// released. Therefore:
//   - for ownership registration happening as a result of a down/press event,
//   the SetKeyOwner() call may be done once (common case).
//   - for ownership registration happening ahead of a down/press event, the
//   SetKeyOwner() call needs to be made every frame (happens if e.g. claiming
//   ownership on hover).
// - SetItemKeyOwner() is a shortcut for common simple case. A custom widget
// will probably want to call SetKeyOwner() multiple times directly based on its
// interaction state.
// - This is marked experimental because not all widgets are fully honoring the
// Set/Test idioms. We will need to move forward step by step.
//   Please open a GitHub Issue to submit your usage scenario or if there's a
//   use case you need solved.
GUI_API ID GetKeyOwner(Key key);
GUI_API void SetKeyOwner(Key key, ID owner_id, InputFlags flags = 0);
GUI_API inline void SetKeyOwnersForKeyChord(KeyChord key_chord, ID owner_id,
                                            InputFlags flags = 0) {
  if (key_chord & Mod_Ctrl) {
    SetKeyOwner(Mod_Ctrl, owner_id, flags);
  }
  if (key_chord & Mod_Shift) {
    SetKeyOwner(Mod_Shift, owner_id, flags);
  }
  if (key_chord & Mod_Alt) {
    SetKeyOwner(Mod_Alt, owner_id, flags);
  }
  if (key_chord & Mod_Super) {
    SetKeyOwner(Mod_Super, owner_id, flags);
  }
  if (key_chord & Mod_Shortcut) {
    SetKeyOwner(Mod_Shortcut, owner_id, flags);
  }
  if (key_chord & ~Mod_Mask_) {
    SetKeyOwner((Key)(key_chord & ~Mod_Mask_), owner_id, flags);
  }
}

GUI_API void SetItemKeyOwner(
    Key key,
    InputFlags flags = 0); // Set key owner to last item if it is hovered or
                           // active. Equivalent to 'if (IsItemHovered() ||
                           // IsItemActive()) { SetKeyOwner(key, GetItemID());'.
GUI_API bool TestKeyOwner(Key key,
                          ID owner_id); // Test that key is either not owned,
                                        // either owned by 'owner_id'
inline KeyOwnerData *GetKeyOwnerData(Context *ctx, Key key) {
  if (key & Mod_Mask_)
    key = ConvertSingleModFlagToKey(ctx, key);
  GUI_ASSERT(IsNamedKey(key));
  return &ctx->KeysOwnerData[key - Key_NamedKey_BEGIN];
}

// [EXPERIMENTAL] High-Level: Input Access functions w/ support for Key/Input
// Ownership
// - Important: legacy IsKeyPressed(Key, bool repeat=true) _DEFAULTS_ to
// repeat, new IsKeyPressed() requires _EXPLICIT_ InputFlags_Repeat flag.
// - Expected to be later promoted to public API, the prototypes are designed to
// replace existing ones (since owner_id can default to Any == 0)
// - Specifying a value for 'ID owner' will test that EITHER the key is NOT
// owned (UNLESS locked), EITHER the key is owned by 'owner'.
//   Legacy functions use KeyOwner_Any meaning that they typically ignore
//   ownership, unless a call to SetKeyOwner() explicitly used
//   InputFlags_LockThisFrame or InputFlags_LockUntilRelease.
// - Binding generators may want to ignore those for now, or suffix them with
// Ex() until we decide if this gets moved into public API.
GUI_API inline bool IsKeyDown(Key key, ID owner_id) {
  const KeyData *key_data = GetKeyData(key);
  if (!key_data->Down)
    return false;
  if (!TestKeyOwner(key, owner_id))
    return false;
  return true;
}

GUI_API bool IsKeyPressed(
    Key key, ID owner_id,
    InputFlags flags =
        0); // Important: when transitioning from old to new IsKeyPressed(): old
            // API has "bool repeat = true", so would default to repeat. New API
            // requiress explicit InputFlags_Repeat.
GUI_API inline bool IsKeyReleased(Key key, ID owner_id) {
  const KeyData *key_data = GetKeyData(key);
  if (key_data->DownDurationPrev < 0.0f || key_data->Down)
    return false;
  if (!TestKeyOwner(key, owner_id))
    return false;
  return true;
}

GUI_API bool IsMouseDown(MouseButton button, ID owner_id);
GUI_API bool IsMouseClicked(MouseButton button, ID owner_id,
                            InputFlags flags = 0);
GUI_API bool IsMouseReleased(MouseButton button, ID owner_id);
GUI_API bool IsMouseDoubleClicked(MouseButton button, ID owner_id);

// [EXPERIMENTAL] Shortcut Routing
// - KeyChord = a Key optionally OR-red with
// Mod_Alt/Mod_Ctrl/Mod_Shift/Mod_Super.
//     Key_C                 (accepted by functions taking Key or
//     KeyChord) Key_C | Mod_Ctrl (accepted by functions taking
//     KeyChord)
//   ONLY Mod_XXX values are legal to 'OR' with an Key. You CANNOT
//   'OR' two Key values.
// - When using one of the routing flags (e.g. InputFlags_RouteFocused):
// routes requested ahead of time given a chord (key + modifiers) and a routing
// policy.
// - Routes are resolved during NewFrame(): if keyboard modifiers are matching
// current ones: SetKeyOwner() is called + route is granted for the frame.
// - Route is granted to a single owner. When multiple requests are made we have
// policies to select the winning route.
// - Multiple read sites may use the same owner id and will all get the granted
// route.
// - For routing: when owner_id is 0 we use the current Focus Scope ID as a
// default owner in order to identify our location.
// - TL;DR;
//   - IsKeyChordPressed() compares mods + call IsKeyPressed() -> function has
//   no side-effect.
//   - Shortcut() submits a route then if currently can be routed calls
//   IsKeyChordPressed() -> function has (desirable) side-effects.
GUI_API inline bool IsKeyChordPressed(KeyChord key_chord, ID owner_id,
                                      InputFlags flags = 0) {
  Context &g = *GGui;
  if (key_chord & Mod_Shortcut)
    key_chord = ConvertShortcutMod(key_chord);
  Key mods = (Key)(key_chord & Mod_Mask_);
  if (g.IO.KeyMods != mods)
    return false;

  // Special storage location for mods
  Key key = (Key)(key_chord & ~Mod_Mask_);
  if (key == Key_None)
    key = ConvertSingleModFlagToKey(&g, mods);
  if (!IsKeyPressed(key, owner_id,
                    (flags & (InputFlags_Repeat |
                              (InputFlags)InputFlags_RepeatRateMask_))))
    return false;
  return true;
}

GUI_API bool Shortcut(KeyChord key_chord, ID owner_id = 0,
                      InputFlags flags = 0);
GUI_API bool SetShortcutRouting(KeyChord key_chord, ID owner_id = 0,
                                InputFlags flags = 0);
GUI_API bool TestShortcutRouting(KeyChord key_chord, ID owner_id);
GUI_API KeyRoutingData *GetShortcutRoutingData(KeyChord key_chord);

// [EXPERIMENTAL] Focus Scope
// This is generally used to identify a unique input location (for e.g. a
// selection set) There is one per window (automatically set in Begin), but:
// - Selection patterns generally need to react (e.g. clear a selection) when
// landing on one item of the set.
//   So in order to identify a set multiple lists in same window may each need a
//   focus scope. If you imagine an hypothetical
//   BeginSelectionGroup()/EndSelectionGroup() api, it would likely call
//   PushFocusScope()/EndFocusScope()
// - Shortcut routing also use focus scope as a default location identifier if
// an owner is not provided. We don't use the ID Stack for this as it is common
// to want them separate.
GUI_API inline void PushFocusScope(ID id) {
  Context &g = *GGui;
  g.FocusScopeStack.push_back(id);
  g.CurrentFocusScopeId = id;
}

GUI_API void PopFocusScope();
inline ID GetCurrentFocusScope() {
  Context &g = *GGui;
  return g.CurrentFocusScopeId;
} // Focus scope we are outputting into, set by PushFocusScope()

// Drag and Drop
GUI_API inline bool IsDragDropActive() {
  Context &g = *GGui;
  return g.DragDropActive;
}

GUI_API bool BeginDragDropTargetCustom(const Rect &bb, ID id);
GUI_API void ClearDragDrop();
GUI_API inline bool IsDragDropPayloadBeingAccepted() {
  Context &g = *GGui;
  return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
}

GUI_API inline void RenderDragDropTargetRect(const Rect &bb,
                                             const Rect &item_clip_rect) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  Rect bb_display = bb;
  bb_display.ClipWith(
      item_clip_rect); // Clip THEN expand so we have a way to visualize that
                       // target is not entirely visible.
  bb_display.Expand(3.5f);
  bool push_clip_rect = !window->ClipRect.Contains(bb_display);
  if (push_clip_rect)
    window->DrawList->PushClipRectFullScreen();
  window->DrawList->AddRect(bb_display.Min, bb_display.Max,
                            GetColorU32(Col_DragDropTarget), 0.0f, 0, 2.0f);
  if (push_clip_rect)
    window->DrawList->PopClipRect();
}

// Typing-Select API
GUI_API TypingSelectRequest *
GetTypingSelectRequest(TypingSelectFlags flags = TypingSelectFlags_None);
GUI_API int TypingSelectFindMatch(TypingSelectRequest *req, int items_count,
                                  const char *(*get_item_name_func)(void *,
                                                                    int),
                                  void *user_data, int nav_item_idx);
GUI_API int TypingSelectFindNextSingleCharMatch(
    TypingSelectRequest *req, int items_count,
    const char *(*get_item_name_func)(void *, int), void *user_data,
    int nav_item_idx);
GUI_API int
TypingSelectFindBestLeadingMatch(TypingSelectRequest *req, int items_count,
                                 const char *(*get_item_name_func)(void *, int),
                                 void *user_data);

// Internal Columns API (this is not exposed because we will encourage
// transitioning to the Tables API)
GUI_API inline void SetWindowClipRectBeforeSetChannel(Window *window,
                                                      const Rect &clip_rect) {
  Vec4 clip_rect_vec4 = clip_rect.ToVec4();
  window->ClipRect = clip_rect;
  window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;
  window->DrawList->_ClipRectStack
      .Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;
}

GUI_API void BeginColumns(
    const char *str_id, int count,
    OldColumnFlags flags =
        0); // setup number of columns. use an identifier to distinguish
            // multiple column sets. close with EndColumns().
GUI_API void EndColumns(); // close columns
GUI_API inline void PushColumnClipRect(int column_index) {
  Window *window = GetCurrentWindowRead();
  OldColumns *columns = window->DC.CurrentColumns;
  if (column_index < 0)
    column_index = columns->Current;

  OldColumnData *column = &columns->Columns[column_index];
  PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);
}

GUI_API inline void PushColumnsBackground() {
  Window *window = GetCurrentWindowRead();
  OldColumns *columns = window->DC.CurrentColumns;
  if (columns->Count == 1)
    return;

  // Optimization: avoid SetCurrentChannel() + PushClipRect()
  columns->HostBackupClipRect = window->ClipRect;
  SetWindowClipRectBeforeSetChannel(window, columns->HostInitialClipRect);
  columns->Splitter.SetCurrentChannel(window->DrawList, 0);
}

GUI_API inline void PopColumnsBackground() {
  Window *window = GetCurrentWindowRead();
  OldColumns *columns = window->DC.CurrentColumns;
  if (columns->Count == 1)
    return;

  // Optimization: avoid PopClipRect() + SetCurrentChannel()
  SetWindowClipRectBeforeSetChannel(window, columns->HostBackupClipRect);
  columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);
}

GUI_API inline ID GetColumnsID(const char *str_id, int columns_count) {
  Window *window = GetCurrentWindow();

  // Differentiate column ID with an arbitrary prefix for cases where users name
  // their columns set the same as another widget. In addition, when an
  // identifier isn't explicitly provided we include the number of columns in
  // the hash to make it uniquer.
  PushID(0x11223347 + (str_id ? 0 : columns_count));
  ID id = window->GetID(str_id ? str_id : "columns");
  PopID();

  return id;
}

GUI_API inline OldColumns *FindOrCreateColumns(Window *window, ID id) {
  // We have few columns per window so for now we don't need bother much with
  // turning this into a faster lookup.
  for (int n = 0; n < window->ColumnsStorage.Size; n++)
    if (window->ColumnsStorage[n].ID == id)
      return &window->ColumnsStorage[n];

  window->ColumnsStorage.push_back(OldColumns());
  OldColumns *columns = &window->ColumnsStorage.back();
  columns->ID = id;
  return columns;
}

GUI_API inline float GetColumnOffsetFromNorm(const OldColumns *columns,
                                             float offset_norm) {
  return offset_norm * (columns->OffMaxX - columns->OffMinX);
}

GUI_API inline float GetColumnNormFromOffset(const OldColumns *columns,
                                             float offset) {
  return offset / (columns->OffMaxX - columns->OffMinX);
}

// Tables: Candidates for public API
GUI_API void TableOpenContextMenu(int column_n = -1);
GUI_API void TableSetColumnWidth(int column_n, float width);
GUI_API void TableSetColumnSortDirection(int column_n,
                                         SortDirection sort_direction,
                                         bool append_to_sort_specs);
GUI_API inline int TableGetHoveredColumn() {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  if (!table)
    return -1;
  return (int)table->HoveredColumnBody;
}
// May use (TableGetColumnFlags() &
// TableColumnFlags_IsHovered) instead. Return
// hovered column. return -1 when table is not hovered.
// return columns_count if the unused space at the
// right of visible columns is hovered.
GUI_API int TableGetHoveredRow(); // Retrieve *PREVIOUS FRAME* hovered row. This
                                  // difference with TableGetHoveredColumn() is
                                  // the reason why this is not public yet.
GUI_API float TableGetHeaderRowHeight();
GUI_API float TableGetHeaderAngledMaxLabelWidth();
GUI_API inline void TablePushBackgroundChannel() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  Table *table = g.CurrentTable;

  // Optimization: avoid SetCurrentChannel() + PushClipRect()
  table->HostBackupInnerClipRect = window->ClipRect;
  SetWindowClipRectBeforeSetChannel(window, table->Bg2ClipRectForDrawCmd);
  table->DrawSplitter->SetCurrentChannel(window->DrawList,
                                         table->Bg2DrawChannelCurrent);
}

GUI_API inline void TablePopBackgroundChannel() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  Table *table = g.CurrentTable;
  TableColumn *column = &table->Columns[table->CurrentColumn];

  // Optimization: avoid PopClipRect() + SetCurrentChannel()
  SetWindowClipRectBeforeSetChannel(window, table->HostBackupInnerClipRect);
  table->DrawSplitter->SetCurrentChannel(window->DrawList,
                                         column->DrawChannelCurrent);
}

GUI_API void TableAngledHeadersRowEx(float angle, float label_width = 0.0f);

// Tables: Internals
inline Table *GetCurrentTable() {
  Context &g = *GGui;
  return g.CurrentTable;
}
GUI_API inline Table *TableFindByID(ID id) {
  Context &g = *GGui;
  return g.Tables.GetByKey(id);
}

GUI_API bool BeginTableEx(const char *name, ID id, int columns_count,
                          TableFlags flags = 0,
                          const Vec2 &outer_size = Vec2(0, 0),
                          float inner_width = 0.0f);
GUI_API void TableBeginInitMemory(Table *table, int columns_count);
GUI_API void TableBeginApplyRequests(Table *table);
GUI_API void TableSetupDrawChannels(Table *table);
GUI_API void TableUpdateLayout(Table *table);
GUI_API void TableUpdateBorders(Table *table);
GUI_API void TableUpdateColumnsWeightFromWidth(Table *table);
GUI_API void TableDrawBorders(Table *table);
GUI_API void
TableDrawDefaultContextMenu(Table *table,
                            TableFlags flags_for_section_to_display);
GUI_API inline bool TableBeginContextMenuPopup(Table *table) {
  if (!table->IsContextPopupOpen ||
      table->InstanceCurrent != table->InstanceInteracted)
    return false;
  const ID context_menu_id = HashStr("##ContextMenu", 0, table->ID);
  if (BeginPopupEx(context_menu_id, WindowFlags_AlwaysAutoResize |
                                        WindowFlags_NoTitleBar |
                                        WindowFlags_NoSavedSettings))
    return true;
  table->IsContextPopupOpen = false;
  return false;
}

GUI_API void TableMergeDrawChannels(Table *table);
inline TableInstanceData *TableGetInstanceData(Table *table, int instance_no) {
  if (instance_no == 0)
    return &table->InstanceDataFirst;
  return &table->InstanceDataExtra[instance_no - 1];
}
inline ID TableGetInstanceID(Table *table, int instance_no) {
  return TableGetInstanceData(table, instance_no)->TableInstanceID;
}
GUI_API void TableSortSpecsSanitize(Table *table);
GUI_API void TableSortSpecsBuild(Table *table);
GUI_API SortDirection TableGetColumnNextSortDirection(TableColumn *column);
GUI_API void TableFixColumnSortDirection(Table *table, TableColumn *column);
GUI_API inline float TableGetColumnWidthAuto(Table *table,
                                             TableColumn *column) {
  const float content_width_body =
      Max(column->ContentMaxXFrozen, column->ContentMaxXUnfrozen) -
      column->WorkMinX;
  const float content_width_headers =
      column->ContentMaxXHeadersIdeal - column->WorkMinX;
  float width_auto = content_width_body;
  if (!(column->Flags & TableColumnFlags_NoHeaderWidth))
    width_auto = Max(width_auto, content_width_headers);

  // Non-resizable fixed columns preserve their requested width
  if ((column->Flags & TableColumnFlags_WidthFixed) &&
      column->InitStretchWeightOrWidth > 0.0f)
    if (!(table->Flags & TableFlags_Resizable) ||
        (column->Flags & TableColumnFlags_NoResize))
      width_auto = column->InitStretchWeightOrWidth;

  return Max(width_auto, table->MinColumnWidth);
}

GUI_API void TableBeginRow(Table *table);
GUI_API void TableEndRow(Table *table);
GUI_API void TableBeginCell(Table *table, int column_n);
GUI_API void TableEndCell(Table *table);
GUI_API inline Rect TableGetCellBgRect(const Table *table, int column_n) {
  const TableColumn *column = &table->Columns[column_n];
  float x1 = column->MinX;
  float x2 = column->MaxX;
  // if (column->PrevEnabledColumn == -1)
  //     x1 -= table->OuterPaddingX;
  // if (column->NextEnabledColumn == -1)
  //     x2 += table->OuterPaddingX;
  x1 = Max(x1, table->WorkRect.Min.x);
  x2 = Min(x2, table->WorkRect.Max.x);
  return Rect(x1, table->RowPosY1, x2, table->RowPosY2);
}

GUI_API inline const char *TableGetColumnName(const Table *table,
                                              int column_n) {
  if (table->IsLayoutLocked == false && column_n >= table->DeclColumnsCount)
    return ""; // NameOffset is invalid at this point
  const TableColumn *column = &table->Columns[column_n];
  if (column->NameOffset == -1)
    return "";
  return &table->ColumnsNames.Buf[column->NameOffset];
}

GUI_API ID TableGetColumnResizeID(Table *table, int column_n,
                                  int instance_no = 0);
GUI_API inline float TableGetMaxColumnWidth(const Table *table, int column_n) {
  const TableColumn *column = &table->Columns[column_n];
  float max_width = FLT_MAX;
  const float min_column_distance = table->MinColumnWidth +
                                    table->CellPaddingX * 2.0f +
                                    table->CellSpacingX1 + table->CellSpacingX2;
  if (table->Flags & TableFlags_ScrollX) {
    // Frozen columns can't reach beyond visible width else scrolling will
    // naturally break. (we use DisplayOrder as within a set of multiple frozen
    // column reordering is possible)
    if (column->DisplayOrder < table->FreezeColumnsRequest) {
      max_width = (table->InnerClipRect.Max.x -
                   (table->FreezeColumnsRequest - column->DisplayOrder) *
                       min_column_distance) -
                  column->MinX;
      max_width = max_width - table->OuterPaddingX - table->CellPaddingX -
                  table->CellSpacingX2;
    }
  } else if ((table->Flags & TableFlags_NoKeepColumnsVisible) == 0) {
    // If horizontal scrolling if disabled, we apply a final lossless shrinking
    // of columns in order to make sure they are all visible. Because of this we
    // also know that all of the columns will always fit in table->WorkRect and
    // therefore in table->InnerRect (because ScrollX is off)
    // FIXME-TABLE: This is solved incorrectly but also quite a difficult
    // problem to fix as we also want ClipRect width to match. See
    // "table_width_distrib" and "table_width_keep_visible" tests
    max_width =
        table->WorkRect.Max.x -
        (table->ColumnsEnabledCount - column->IndexWithinEnabledSet - 1) *
            min_column_distance -
        column->MinX;
    // max_width -= table->CellSpacingX1;
    max_width -= table->CellSpacingX2;
    max_width -= table->CellPaddingX * 2.0f;
    max_width -= table->OuterPaddingX;
  }
  return max_width;
}

GUI_API inline void TableSetColumnWidthAutoSingle(Table *table, int column_n) {
  // Single auto width uses auto-fit
  TableColumn *column = &table->Columns[column_n];
  if (!column->IsEnabled)
    return;
  column->CannotSkipItemsQueue = (1 << 0);
  table->AutoFitSingleColumn = (TableColumnIdx)column_n;
}

GUI_API inline void TableSetColumnWidthAutoAll(Table *table) {
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
    TableColumn *column = &table->Columns[column_n];
    if (!column->IsEnabled &&
        !(column->Flags &
          TableColumnFlags_WidthStretch)) // Cannot reset weight of hidden
                                          // stretch column
      continue;
    column->CannotSkipItemsQueue = (1 << 0);
    column->AutoFitQueue = (1 << 1);
  }
}

GUI_API inline void TableRemove(Table *table) {
  // GUI_DEBUG_PRINT("TableRemove() id=0x%08X\n", table->ID);
  Context &g = *GGui;
  int table_idx = g.Tables.GetIndex(table);
  // memset(table->RawData.Data, 0, table->RawData.size_in_bytes());
  // memset(table, 0, sizeof(Table));
  g.Tables.Remove(table->ID, table);
  g.TablesLastTimeActive[table_idx] = -1.0f;
}

GUI_API void TableGcCompactTransientBuffers(Table *table);
GUI_API inline void TableGcCompactTransientBuffers(TableTempData *temp_data) {
  temp_data->DrawSplitter.ClearFreeMemory();
  temp_data->LastTimeActive = -1.0f;
}

GUI_API void TableGcCompactSettings();

// Tables: Settings
GUI_API void TableLoadSettings(Table *table);
GUI_API void TableSaveSettings(Table *table);
GUI_API inline void TableResetSettings(Table *table) {
  table->IsInitializing = table->IsSettingsDirty = true;
  table->IsResetAllRequest = false;
  table->IsSettingsRequestLoad = false; // Don't reload from ini
  table->SettingsLoadedFlags =
      TableFlags_None; // Mark as nothing loaded so our initialized data
                       // becomes authoritative
}

GUI_API TableSettings *TableGetBoundSettings(Table *table);
GUI_API void TableSettingsAddSettingsHandler();
GUI_API TableSettings *TableSettingsCreate(ID id, int columns_count);
GUI_API inline TableSettings *TableSettingsFindByID(ID id) {
  // FIXME-OPT: Might want to store a lookup map for this?
  Context &g = *GGui;
  for (TableSettings *settings = g.SettingsTables.begin(); settings != NULL;
       settings = g.SettingsTables.next_chunk(settings))
    if (settings->ID == id)
      return settings;
  return NULL;
}

// Tab Bars
inline TabBar *GetCurrentTabBar() {
  Context &g = *GGui;
  return g.CurrentTabBar;
}
GUI_API bool BeginTabBarEx(TabBar *tab_bar, const Rect &bb, TabBarFlags flags);
GUI_API inline TabItem *TabBarFindTabByID(TabBar *tab_bar, ID tab_id) {
  if (tab_id != 0)
    for (int n = 0; n < tab_bar->Tabs.Size; n++)
      if (tab_bar->Tabs[n].ID == tab_id)
        return &tab_bar->Tabs[n];
  return NULL;
}

GUI_API inline TabItem *TabBarFindTabByOrder(TabBar *tab_bar, int order) {
  if (order < 0 || order >= tab_bar->Tabs.Size)
    return NULL;
  return &tab_bar->Tabs[order];
}

GUI_API inline TabItem *TabBarGetCurrentTab(TabBar *tab_bar) {
  if (tab_bar->LastTabItemIdx <= 0 ||
      tab_bar->LastTabItemIdx >= tab_bar->Tabs.Size)
    return NULL;
  return &tab_bar->Tabs[tab_bar->LastTabItemIdx];
}

inline int TabBarGetTabOrder(TabBar *tab_bar, TabItem *tab) {
  return tab_bar->Tabs.index_from_ptr(tab);
}
GUI_API const char *TabBarGetTabName(TabBar *tab_bar, TabItem *tab);
GUI_API inline void TabBarRemoveTab(TabBar *tab_bar, ID tab_id) {
  if (TabItem *tab = TabBarFindTabByID(tab_bar, tab_id))
    tab_bar->Tabs.erase(tab);
  if (tab_bar->VisibleTabId == tab_id) {
    tab_bar->VisibleTabId = 0;
  }
  if (tab_bar->SelectedTabId == tab_id) {
    tab_bar->SelectedTabId = 0;
  }
  if (tab_bar->NextSelectedTabId == tab_id) {
    tab_bar->NextSelectedTabId = 0;
  }
}

GUI_API void TabBarCloseTab(TabBar *tab_bar, TabItem *tab);
GUI_API inline void TabBarQueueFocus(TabBar *tab_bar, TabItem *tab) {
  tab_bar->NextSelectedTabId = tab->ID;
}

GUI_API void TabBarQueueReorder(TabBar *tab_bar, TabItem *tab, int offset);
GUI_API void TabBarQueueReorderFromMousePos(TabBar *tab_bar, TabItem *tab,
                                            Vec2 mouse_pos);
GUI_API bool TabBarProcessReorder(TabBar *tab_bar);
GUI_API bool TabItemEx(TabBar *tab_bar, const char *label, bool *p_open,
                       TabItemFlags flags, Window *docked_window);
GUI_API Vec2 TabItemCalcSize(const char *label,
                             bool has_close_button_or_unsaved_marker);
GUI_API Vec2 TabItemCalcSize(Window *window);
GUI_API void TabItemBackground(DrawList *draw_list, const Rect &bb,
                               TabItemFlags flags, U32 col);
GUI_API void TabItemLabelAndCloseButton(
    DrawList *draw_list, const Rect &bb, TabItemFlags flags, Vec2 frame_padding,
    const char *label, ID tab_id, ID close_button_id, bool is_contents_visible,
    bool *out_just_closed, bool *out_text_clipped);

// Render helpers
// AVOID USING OUTSIDE OF GUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS
// ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE
// REFACTORED INTO SOMETHING DECENT. NB: All position are in absolute pixels
// coordinates (we are never using window coordinates internally)
GUI_API void RenderText(Vec2 pos, const char *text, const char *text_end = NULL,
                        bool hide_text_after_hash = true);
GUI_API void RenderTextWrapped(Vec2 pos, const char *text, const char *text_end,
                               float wrap_width);
GUI_API void RenderTextClipped(const Vec2 &pos_min, const Vec2 &pos_max,
                               const char *text, const char *text_end,
                               const Vec2 *text_size_if_known,
                               const Vec2 &align = Vec2(0, 0),
                               const Rect *clip_rect = NULL);
GUI_API inline void RenderTextClippedEx(DrawList *draw_list,
                                        const Vec2 &pos_min,
                                        const Vec2 &pos_max, const char *text,
                                        const char *text_display_end,
                                        const Vec2 *text_size_if_known,
                                        const Vec2 &align = Vec2(0, 0),
                                        const Rect *clip_rect = NULL) {
  // Perform CPU side clipping for single clipped element to avoid using scissor
  // state
  Vec2 pos = pos_min;
  const Vec2 text_size =
      text_size_if_known ? *text_size_if_known
                         : CalcTextSize(text, text_display_end, false, 0.0f);

  const Vec2 *clip_min = clip_rect ? &clip_rect->Min : &pos_min;
  const Vec2 *clip_max = clip_rect ? &clip_rect->Max : &pos_max;
  bool need_clipping = (pos.x + text_size.x >= clip_max->x) ||
                       (pos.y + text_size.y >= clip_max->y);
  if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
    need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);

  // Align whole block. We should defer that to the better rendering function
  // when we'll have support for individual line alignment.
  if (align.x > 0.0f)
    pos.x = Max(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
  if (align.y > 0.0f)
    pos.y = Max(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

  // Render
  if (need_clipping) {
    Vec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
    draw_list->AddText(NULL, 0.0f, pos, GetColorU32(Col_Text), text,
                       text_display_end, 0.0f, &fine_clip_rect);
  } else {
    draw_list->AddText(NULL, 0.0f, pos, GetColorU32(Col_Text), text,
                       text_display_end, 0.0f, NULL);
  }
}

GUI_API void RenderTextEllipsis(DrawList *draw_list, const Vec2 &pos_min,
                                const Vec2 &pos_max, float clip_max_x,
                                float ellipsis_max_x, const char *text,
                                const char *text_end,
                                const Vec2 *text_size_if_known);
GUI_API void RenderFrame(Vec2 p_min, Vec2 p_max, U32 fill_col,
                         bool border = true, float rounding = 0.0f);
GUI_API void RenderFrameBorder(Vec2 p_min, Vec2 p_max, float rounding = 0.0f);
GUI_API inline void RenderColorRectWithAlphaCheckerboard(
    DrawList *draw_list, Vec2 p_min, Vec2 p_max, U32 col, float grid_step,
    Vec2 grid_off, float rounding = 0.0f, DrawFlags flags = 0) {
  if ((flags & DrawFlags_RoundCornersMask_) == 0)
    flags = DrawFlags_RoundCornersDefault_;
  if (((col & GUI_COL32_A_MASK) >> GUI_COL32_A_SHIFT) < 0xFF) {
    U32 col_bg1 =
        GetColorU32(AlphaBlendColors(GUI_COL32(204, 204, 204, 255), col));
    U32 col_bg2 =
        GetColorU32(AlphaBlendColors(GUI_COL32(128, 128, 128, 255), col));
    draw_list->AddRectFilled(p_min, p_max, col_bg1, rounding, flags);

    int yi = 0;
    for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++) {
      float y1 = Clamp(y, p_min.y, p_max.y), y2 = Min(y + grid_step, p_max.y);
      if (y2 <= y1)
        continue;
      for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x;
           x += grid_step * 2.0f) {
        float x1 = Clamp(x, p_min.x, p_max.x), x2 = Min(x + grid_step, p_max.x);
        if (x2 <= x1)
          continue;
        DrawFlags cell_flags = DrawFlags_RoundCornersNone;
        if (y1 <= p_min.y) {
          if (x1 <= p_min.x)
            cell_flags |= DrawFlags_RoundCornersTopLeft;
          if (x2 >= p_max.x)
            cell_flags |= DrawFlags_RoundCornersTopRight;
        }
        if (y2 >= p_max.y) {
          if (x1 <= p_min.x)
            cell_flags |= DrawFlags_RoundCornersBottomLeft;
          if (x2 >= p_max.x)
            cell_flags |= DrawFlags_RoundCornersBottomRight;
        }

        // Combine flags
        cell_flags = (flags == DrawFlags_RoundCornersNone ||
                      cell_flags == DrawFlags_RoundCornersNone)
                         ? DrawFlags_RoundCornersNone
                         : (cell_flags & flags);
        draw_list->AddRectFilled(Vec2(x1, y1), Vec2(x2, y2), col_bg2, rounding,
                                 cell_flags);
      }
    }
  } else {
    draw_list->AddRectFilled(p_min, p_max, col, rounding, flags);
  }
}

GUI_API void
RenderNavHighlight(const Rect &bb, ID id,
                   NavHighlightFlags flags =
                       NavHighlightFlags_TypeDefault); // Navigation highlight
GUI_API inline const char *FindRenderedTextEnd(const char *text,
                                               const char *text_end = NULL) {
  const char *text_display_end = text;
  if (!text_end)
    text_end = (const char *)-1;

  while (text_display_end < text_end && *text_display_end != '\0' &&
         (text_display_end[0] != '#' || text_display_end[1] != '#'))
    text_display_end++;
  return text_display_end;
}
// Find the optional ## from which we stop displaying text.
GUI_API void RenderMouseCursor(Vec2 pos, float scale, MouseCursor mouse_cursor,
                               U32 col_fill, U32 col_border, U32 col_shadow);

// Render helpers (those functions don't access any Gui state!)
GUI_API void RenderArrow(DrawList *draw_list, Vec2 pos, U32 col, Dir dir,
                         float scale = 1.0f);
GUI_API inline void RenderBullet(DrawList *draw_list, Vec2 pos, U32 col) {
  // FIXME-OPT: This should be baked in font.
  draw_list->AddCircleFilled(pos, draw_list->_Data->FontSize * 0.20f, col, 8);
}

GUI_API void RenderCheckMark(DrawList *draw_list, Vec2 pos, U32 col, float sz);
GUI_API inline void RenderArrowPointingAt(DrawList *draw_list, Vec2 pos,
                                          Vec2 half_sz, Dir direction,
                                          U32 col) {
  switch (direction) {
  case Dir_Left:
    draw_list->AddTriangleFilled(Vec2(pos.x + half_sz.x, pos.y - half_sz.y),
                                 Vec2(pos.x + half_sz.x, pos.y + half_sz.y),
                                 pos, col);
    return;
  case Dir_Right:
    draw_list->AddTriangleFilled(Vec2(pos.x - half_sz.x, pos.y + half_sz.y),
                                 Vec2(pos.x - half_sz.x, pos.y - half_sz.y),
                                 pos, col);
    return;
  case Dir_Up:
    draw_list->AddTriangleFilled(Vec2(pos.x + half_sz.x, pos.y + half_sz.y),
                                 Vec2(pos.x - half_sz.x, pos.y + half_sz.y),
                                 pos, col);
    return;
  case Dir_Down:
    draw_list->AddTriangleFilled(Vec2(pos.x - half_sz.x, pos.y - half_sz.y),
                                 Vec2(pos.x + half_sz.x, pos.y - half_sz.y),
                                 pos, col);
    return;
  case Dir_None:
  case Dir_COUNT:
    break; // Fix warnings
  }
}

GUI_API void RenderRectFilledRangeH(DrawList *draw_list, const Rect &rect,
                                    U32 col, float x_start_norm,
                                    float x_end_norm, float rounding);
GUI_API inline void RenderRectFilledWithHole(DrawList *draw_list,
                                             const Rect &outer,
                                             const Rect &inner, U32 col,
                                             float rounding) {
  const bool fill_L = (inner.Min.x > outer.Min.x);
  const bool fill_R = (inner.Max.x < outer.Max.x);
  const bool fill_U = (inner.Min.y > outer.Min.y);
  const bool fill_D = (inner.Max.y < outer.Max.y);
  if (fill_L)
    draw_list->AddRectFilled(
        Vec2(outer.Min.x, inner.Min.y), Vec2(inner.Min.x, inner.Max.y), col,
        rounding,
        DrawFlags_RoundCornersNone |
            (fill_U ? 0 : DrawFlags_RoundCornersTopLeft) |
            (fill_D ? 0 : DrawFlags_RoundCornersBottomLeft));
  if (fill_R)
    draw_list->AddRectFilled(
        Vec2(inner.Max.x, inner.Min.y), Vec2(outer.Max.x, inner.Max.y), col,
        rounding,
        DrawFlags_RoundCornersNone |
            (fill_U ? 0 : DrawFlags_RoundCornersTopRight) |
            (fill_D ? 0 : DrawFlags_RoundCornersBottomRight));
  if (fill_U)
    draw_list->AddRectFilled(Vec2(inner.Min.x, outer.Min.y),
                             Vec2(inner.Max.x, inner.Min.y), col, rounding,
                             DrawFlags_RoundCornersNone |
                                 (fill_L ? 0 : DrawFlags_RoundCornersTopLeft) |
                                 (fill_R ? 0 : DrawFlags_RoundCornersTopRight));
  if (fill_D)
    draw_list->AddRectFilled(
        Vec2(inner.Min.x, inner.Max.y), Vec2(inner.Max.x, outer.Max.y), col,
        rounding,
        DrawFlags_RoundCornersNone |
            (fill_L ? 0 : DrawFlags_RoundCornersBottomLeft) |
            (fill_R ? 0 : DrawFlags_RoundCornersBottomRight));
  if (fill_L && fill_U)
    draw_list->AddRectFilled(Vec2(outer.Min.x, outer.Min.y),
                             Vec2(inner.Min.x, inner.Min.y), col, rounding,
                             DrawFlags_RoundCornersTopLeft);
  if (fill_R && fill_U)
    draw_list->AddRectFilled(Vec2(inner.Max.x, outer.Min.y),
                             Vec2(outer.Max.x, inner.Min.y), col, rounding,
                             DrawFlags_RoundCornersTopRight);
  if (fill_L && fill_D)
    draw_list->AddRectFilled(Vec2(outer.Min.x, inner.Max.y),
                             Vec2(inner.Min.x, outer.Max.y), col, rounding,
                             DrawFlags_RoundCornersBottomLeft);
  if (fill_R && fill_D)
    draw_list->AddRectFilled(Vec2(inner.Max.x, inner.Max.y),
                             Vec2(outer.Max.x, outer.Max.y), col, rounding,
                             DrawFlags_RoundCornersBottomRight);
}

// Widgets
GUI_API void TextEx(const char *text, const char *text_end = NULL,
                    TextFlags flags = 0);
GUI_API bool ButtonEx(const char *label, const Vec2 &size_arg = Vec2(0, 0),
                      ButtonFlags flags = 0);
GUI_API bool ArrowButtonEx(const char *str_id, Dir dir, Vec2 size_arg,
                           ButtonFlags flags = 0);
GUI_API bool ImageButtonEx(ID id, TextureID texture_id, const Vec2 &image_size,
                           const Vec2 &uv0, const Vec2 &uv1, const Vec4 &bg_col,
                           const Vec4 &tint_col, ButtonFlags flags = 0);
GUI_API void SeparatorEx(SeparatorFlags flags, float thickness = 1.0f);
GUI_API inline void SeparatorTextEx(ID id, const char *label,
                                    const char *label_end, float extra_w) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  Style &style = g.Style;

  const Vec2 label_size = CalcTextSize(label, label_end, false);
  const Vec2 pos = window->DC.CursorPos;
  const Vec2 padding = style.SeparatorTextPadding;

  const float separator_thickness = style.SeparatorTextBorderSize;
  const Vec2 min_size(
      label_size.x + extra_w + padding.x * 2.0f,
      Max(label_size.y + padding.y * 2.0f, separator_thickness));
  const Rect bb(pos, Vec2(window->WorkRect.Max.x, pos.y + min_size.y));
  const float text_baseline_y =
      Trunc((bb.GetHeight() - label_size.y) * style.SeparatorTextAlign.y +
            0.99999f); // Max(padding.y, Floor((style.SeparatorTextSize -
                       // label_size.y) * 0.5f));
  ItemSize(min_size, text_baseline_y);
  if (!ItemAdd(bb, id))
    return;

  const float sep1_x1 = pos.x;
  const float sep2_x2 = bb.Max.x;
  const float seps_y = Trunc((bb.Min.y + bb.Max.y) * 0.5f + 0.99999f);

  const float label_avail_w = Max(0.0f, sep2_x2 - sep1_x1 - padding.x * 2.0f);
  const Vec2 label_pos(pos.x + padding.x +
                           Max(0.0f, (label_avail_w - label_size.x - extra_w) *
                                         style.SeparatorTextAlign.x),
                       pos.y + text_baseline_y); // FIXME-ALIGN

  // This allows using SameLine() to position something in the 'extra_w'
  window->DC.CursorPosPrevLine.x = label_pos.x + label_size.x;

  const U32 separator_col = GetColorU32(Col_Separator);
  if (label_size.x > 0.0f) {
    const float sep1_x2 = label_pos.x - style.ItemSpacing.x;
    const float sep2_x1 =
        label_pos.x + label_size.x + extra_w + style.ItemSpacing.x;
    if (sep1_x2 > sep1_x1 && separator_thickness > 0.0f)
      window->DrawList->AddLine(Vec2(sep1_x1, seps_y), Vec2(sep1_x2, seps_y),
                                separator_col, separator_thickness);
    if (sep2_x2 > sep2_x1 && separator_thickness > 0.0f)
      window->DrawList->AddLine(Vec2(sep2_x1, seps_y), Vec2(sep2_x2, seps_y),
                                separator_col, separator_thickness);
    if (g.LogEnabled)
      LogSetNextTextDecoration("---", NULL);
    RenderTextEllipsis(window->DrawList, label_pos,
                       Vec2(bb.Max.x, bb.Max.y + style.ItemSpacing.y), bb.Max.x,
                       bb.Max.x, label, label_end, &label_size);
  } else {
    if (g.LogEnabled)
      LogText("---");
    if (separator_thickness > 0.0f)
      window->DrawList->AddLine(Vec2(sep1_x1, seps_y), Vec2(sep2_x2, seps_y),
                                separator_col, separator_thickness);
  }
}

GUI_API bool CheckboxFlags(const char *label, S64 *flags, S64 flags_value);
GUI_API bool CheckboxFlags(const char *label, U64 *flags, U64 flags_value);

// Widgets: Window Decorations
GUI_API bool CloseButton(ID id, const Vec2 &pos);
GUI_API bool CollapseButton(ID id, const Vec2 &pos);
GUI_API void Scrollbar(Axis axis);
GUI_API bool ScrollbarEx(const Rect &bb, ID id, Axis axis, S64 *p_scroll_v,
                         S64 avail_v, S64 contents_v, DrawFlags flags);
GUI_API Rect GetWindowScrollbarRect(Window *window, Axis axis);
GUI_API inline ID GetWindowScrollbarID(Window *window, Axis axis) {
  return window->GetID(axis == Axis_X ? "#SCROLLX" : "#SCROLLY");
}

GUI_API ID GetWindowResizeCornerID(Window *window,
                                   int n); // 0..3: corners
GUI_API ID GetWindowResizeBorderID(Window *window, Dir dir);

// Widgets low-level behaviors
GUI_API bool ButtonBehavior(const Rect &bb, ID id, bool *out_hovered,
                            bool *out_held, ButtonFlags flags = 0);
GUI_API bool DragBehavior(ID id, DataType data_type, void *p_v, float v_speed,
                          const void *p_min, const void *p_max,
                          const char *format, SliderFlags flags);
GUI_API bool SliderBehavior(const Rect &bb, ID id, DataType data_type,
                            void *p_v, const void *p_min, const void *p_max,
                            const char *format, SliderFlags flags,
                            Rect *out_grab_bb);
GUI_API bool SplitterBehavior(const Rect &bb, ID id, Axis axis, float *size1,
                              float *size2, float min_size1, float min_size2,
                              float hover_extend = 0.0f,
                              float hover_visibility_delay = 0.0f,
                              U32 bg_col = 0);
GUI_API bool TreeNodeBehavior(ID id, TreeNodeFlags flags, const char *label,
                              const char *label_end = NULL);
GUI_API inline void TreePushOverrideID(ID id) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  Indent();
  window->DC.TreeDepth++;
  PushOverrideID(id);
}

GUI_API inline void TreeNodeSetOpen(ID id, bool open) {
  Context &g = *GGui;
  Storage *storage = g.CurrentWindow->DC.StateStorage;
  storage->SetInt(id, open ? 1 : 0);
}

GUI_API inline bool TreeNodeUpdateNextOpen(ID id, TreeNodeFlags flags) {
  if (flags & TreeNodeFlags_Leaf)
    return true;

  // We only write to the tree storage if the user clicks (or explicitly use the
  // SetNextItemOpen function)
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  Storage *storage = window->DC.StateStorage;

  bool is_open;
  if (g.NextItemData.Flags & NextItemDataFlags_HasOpen) {
    if (g.NextItemData.OpenCond & Cond_Always) {
      is_open = g.NextItemData.OpenVal;
      TreeNodeSetOpen(id, is_open);
    } else {
      // We treat Cond_Once and Cond_FirstUseEver the same because
      // tree node state are not saved persistently.
      const int stored_value = storage->GetInt(id, -1);
      if (stored_value == -1) {
        is_open = g.NextItemData.OpenVal;
        TreeNodeSetOpen(id, is_open);
      } else {
        is_open = stored_value != 0;
      }
    }
  } else {
    is_open =
        storage->GetInt(id, (flags & TreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;
  }

  // When logging is enabled, we automatically expand tree nodes (but *NOT*
  // collapsing headers.. seems like sensible behavior). NB- If we are above max
  // depth we still allow manually opened nodes to be logged.
  if (g.LogEnabled && !(flags & TreeNodeFlags_NoAutoOpenOnLog) &&
      (window->DC.TreeDepth - g.LogDepthRef) < g.LogDepthToExpand)
    is_open = true;

  return is_open;
}
// Return open state. Consume previous SetNextItemOpen() data,
// if any. May return true when logging.
GUI_API inline void
SetNextItemSelectionUserData(SelectionUserData selection_user_data) {
  // Note that flags will be cleared by ItemAdd(), so it's only useful for
  // Navigation code! This designed so widgets can also cheaply set this before
  // calling ItemAdd(), so we are not tied to MultiSelect api.
  Context &g = *GGui;
  g.NextItemData.ItemFlags |= ItemFlags_HasSelectionUserData;
  g.NextItemData.SelectionUserData = selection_user_data;
}

// Template functions are instantiated in gui_widgets.hpp for a finite number
// of types. To use them externally (for custom widget) you may need an "extern
// template" statement in your code in order to link to existing instances and
// silence Clang warnings (see #2036). e.g. " extern template GUI_API float
// RoundScalarWithFormatT<float, float>(const char* format, DataType
// data_type, float v); "
template <typename T, typename SIGNED_T, typename FLOAT_T>
GUI_API float ScaleRatioFromValueT(DataType data_type, T v, T v_min, T v_max,
                                   bool is_logarithmic,
                                   float logarithmic_zero_epsilon,
                                   float zero_deadzone_size);
template <typename T, typename SIGNED_T, typename FLOAT_T>
GUI_API T ScaleValueFromRatioT(DataType data_type, float t, T v_min, T v_max,
                               bool is_logarithmic,
                               float logarithmic_zero_epsilon,
                               float zero_deadzone_size);
template <typename T, typename SIGNED_T, typename FLOAT_T>
GUI_API bool DragBehaviorT(DataType data_type, T *v, float v_speed, T v_min,
                           T v_max, const char *format, SliderFlags flags);
template <typename T, typename SIGNED_T, typename FLOAT_T>
GUI_API bool SliderBehaviorT(const Rect &bb, ID id, DataType data_type, T *v,
                             T v_min, T v_max, const char *format,
                             SliderFlags flags, Rect *out_grab_bb);
template <typename T>
GUI_API T RoundScalarWithFormatT(const char *format, DataType data_type, T v);
template <typename T>
GUI_API bool CheckboxFlagsT(const char *label, T *flags, T flags_value);

// Data type helpers
GUI_API const DataTypeInfo *DataTypeGetInfo(DataType data_type);
GUI_API int DataTypeFormatString(char *buf, int buf_size, DataType data_type,
                                 const void *p_data, const char *format);
GUI_API void DataTypeApplyOp(DataType data_type, int op, void *output,
                             const void *arg_1, const void *arg_2);
GUI_API bool DataTypeApplyFromText(const char *buf, DataType data_type,
                                   void *p_data, const char *format);
GUI_API int DataTypeCompare(DataType data_type, const void *arg_1,
                            const void *arg_2);
GUI_API bool DataTypeClamp(DataType data_type, void *p_data, const void *p_min,
                           const void *p_max);

// InputText
GUI_API bool InputTextEx(const char *label, const char *hint, char *buf,
                         int buf_size, const Vec2 &size_arg,
                         InputTextFlags flags,
                         ::InputTextCallback callback = NULL,
                         void *user_data = NULL);
GUI_API void InputTextDeactivateHook(ID id);
GUI_API bool TempInputText(const Rect &bb, ID id, const char *label, char *buf,
                           int buf_size, InputTextFlags flags);
GUI_API bool TempInputScalar(const Rect &bb, ID id, const char *label,
                             DataType data_type, void *p_data,
                             const char *format, const void *p_clamp_min = NULL,
                             const void *p_clamp_max = NULL);
inline bool TempInputIsActive(ID id) {
  Context &g = *GGui;
  return (g.ActiveId == id && g.TempInputId == id);
}
inline InputTextState *GetInputTextState(ID id) {
  Context &g = *GGui;
  return (id != 0 && g.InputTextState.ID == id) ? &g.InputTextState : NULL;
} // Get input text state if active

// Color
GUI_API inline void ColorTooltip(const char *text, const float *col,
                                 ColorEditFlags flags) {
  Context &g = *GGui;

  if (!BeginTooltipEx(TooltipFlags_OverridePrevious, WindowFlags_None))
    return;
  const char *text_end = text ? FindRenderedTextEnd(text, NULL) : text;
  if (text_end > text) {
    TextEx(text, text_end);
    Separator();
  }

  Vec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2,
          g.FontSize * 3 + g.Style.FramePadding.y * 2);
  Vec4 cf(col[0], col[1], col[2],
          (flags & ColorEditFlags_NoAlpha) ? 1.0f : col[3]);
  int cr = GUI_F32_TO_INT8_SAT(col[0]), cg = GUI_F32_TO_INT8_SAT(col[1]),
      cb = GUI_F32_TO_INT8_SAT(col[2]),
      ca = (flags & ColorEditFlags_NoAlpha) ? 255 : GUI_F32_TO_INT8_SAT(col[3]);
  ColorButton("##preview", cf,
              (flags & (ColorEditFlags_InputMask_ | ColorEditFlags_NoAlpha |
                        ColorEditFlags_AlphaPreview |
                        ColorEditFlags_AlphaPreviewHalf)) |
                  ColorEditFlags_NoTooltip,
              sz);
  SameLine();
  if ((flags & ColorEditFlags_InputRGB) ||
      !(flags & ColorEditFlags_InputMask_)) {
    if (flags & ColorEditFlags_NoAlpha)
      Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb,
           cr, cg, cb, col[0], col[1], col[2]);
    else
      Text(
          "#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)",
          cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);
  } else if (flags & ColorEditFlags_InputHSV) {
    if (flags & ColorEditFlags_NoAlpha)
      Text("H: %.3f, S: %.3f, V: %.3f", col[0], col[1], col[2]);
    else
      Text("H: %.3f, S: %.3f, V: %.3f, A: %.3f", col[0], col[1], col[2],
           col[3]);
  }
  EndTooltip();
}

GUI_API inline void ColorEditOptionsPopup(const float *col,
                                          ColorEditFlags flags) {
  bool allow_opt_inputs = !(flags & ColorEditFlags_DisplayMask_);
  bool allow_opt_datatype = !(flags & ColorEditFlags_DataTypeMask_);
  if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))
    return;
  Context &g = *GGui;
  g.LockMarkEdited++;
  ColorEditFlags opts = g.ColorEditOptions;
  if (allow_opt_inputs) {
    if (RadioButton("RGB", (opts & ColorEditFlags_DisplayRGB) != 0))
      opts = (opts & ~ColorEditFlags_DisplayMask_) | ColorEditFlags_DisplayRGB;
    if (RadioButton("HSV", (opts & ColorEditFlags_DisplayHSV) != 0))
      opts = (opts & ~ColorEditFlags_DisplayMask_) | ColorEditFlags_DisplayHSV;
    if (RadioButton("Hex", (opts & ColorEditFlags_DisplayHex) != 0))
      opts = (opts & ~ColorEditFlags_DisplayMask_) | ColorEditFlags_DisplayHex;
  }
  if (allow_opt_datatype) {
    if (allow_opt_inputs)
      Separator();
    if (RadioButton("0..255", (opts & ColorEditFlags_Uint8) != 0))
      opts = (opts & ~ColorEditFlags_DataTypeMask_) | ColorEditFlags_Uint8;
    if (RadioButton("0.00..1.00", (opts & ColorEditFlags_Float) != 0))
      opts = (opts & ~ColorEditFlags_DataTypeMask_) | ColorEditFlags_Float;
  }

  if (allow_opt_inputs || allow_opt_datatype)
    Separator();
  if (Button("Copy as..", Vec2(-1, 0)))
    OpenPopup("Copy");
  if (BeginPopup("Copy")) {
    int cr = GUI_F32_TO_INT8_SAT(col[0]), cg = GUI_F32_TO_INT8_SAT(col[1]),
        cb = GUI_F32_TO_INT8_SAT(col[2]),
        ca = (flags & ColorEditFlags_NoAlpha) ? 255
                                              : GUI_F32_TO_INT8_SAT(col[3]);
    char buf[64];
    FormatString(buf, GUI_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)",
                 col[0], col[1], col[2],
                 (flags & ColorEditFlags_NoAlpha) ? 1.0f : col[3]);
    if (Selectable(buf))
      SetClipboardText(buf);
    FormatString(buf, GUI_ARRAYSIZE(buf), "(%d,%d,%d,%d)", cr, cg, cb, ca);
    if (Selectable(buf))
      SetClipboardText(buf);
    FormatString(buf, GUI_ARRAYSIZE(buf), "#%02X%02X%02X", cr, cg, cb);
    if (Selectable(buf))
      SetClipboardText(buf);
    if (!(flags & ColorEditFlags_NoAlpha)) {
      FormatString(buf, GUI_ARRAYSIZE(buf), "#%02X%02X%02X%02X", cr, cg, cb,
                   ca);
      if (Selectable(buf))
        SetClipboardText(buf);
    }
    EndPopup();
  }

  g.ColorEditOptions = opts;
  EndPopup();
  g.LockMarkEdited--;
}

GUI_API void ColorPickerOptionsPopup(const float *ref_col,
                                     ColorEditFlags flags);

// Plot
GUI_API int PlotEx(PlotType plot_type, const char *label,
                   float (*values_getter)(void *data, int idx), void *data,
                   int values_count, int values_offset,
                   const char *overlay_text, float scale_min, float scale_max,
                   const Vec2 &size_arg);

// Shade functions (write over already created vertices)
GUI_API void
ShadeVertsLinearColorGradientKeepAlpha(DrawList *draw_list, int vert_start_idx,
                                       int vert_end_idx, Vec2 gradient_p0,
                                       Vec2 gradient_p1, U32 col0, U32 col1);
GUI_API void ShadeVertsLinearUV(DrawList *draw_list, int vert_start_idx,
                                int vert_end_idx, const Vec2 &a, const Vec2 &b,
                                const Vec2 &uv_a, const Vec2 &uv_b, bool clamp);
GUI_API void ShadeVertsTransformPos(DrawList *draw_list, int vert_start_idx,
                                    int vert_end_idx, const Vec2 &pivot_in,
                                    float cos_a, float sin_a,
                                    const Vec2 &pivot_out);

// Garbage collection
GUI_API inline void GcCompactTransientMiscBuffers() {
  Context &g = *GGui;
  g.ItemFlagsStack.clear();
  g.GroupStack.clear();
  TableGcCompactSettings();
}

GUI_API inline void GcCompactTransientWindowBuffers(Window *window) {
  window->MemoryCompacted = true;
  window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
  window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
  window->IDStack.clear();
  window->DrawList->_ClearFreeMemory();
  window->DC.ChildWindows.clear();
  window->DC.ItemWidthStack.clear();
  window->DC.TextWrapPosStack.clear();
}

GUI_API inline void GcAwakeTransientWindowBuffers(Window *window) {
  // We stored capacity of the DrawList buffer to reduce growth-caused
  // allocation/copy when awakening. The other buffers tends to amortize much
  // faster.
  window->MemoryCompacted = false;
  window->DrawList->IdxBuffer.reserve(window->MemoryDrawListIdxCapacity);
  window->DrawList->VtxBuffer.reserve(window->MemoryDrawListVtxCapacity);
  window->MemoryDrawListIdxCapacity = window->MemoryDrawListVtxCapacity = 0;
}

// Debug Log
GUI_API void DebugLog(const char *fmt, ...) GUI_FMTARGS(1);
GUI_API void DebugLogV(const char *fmt, va_list args) GUI_FMTLIST(1);
GUI_API void DebugAllocHook(DebugAllocInfo *info, int frame_count, void *ptr,
                            size_t size); // size >= 0 : alloc, size = -1 : free

// Debug Tools
GUI_API void ErrorCheckEndFrameRecover(ErrorLogCallback log_callback,
                                       void *user_data = NULL);
GUI_API void ErrorCheckEndWindowRecover(ErrorLogCallback log_callback,
                                        void *user_data = NULL);
GUI_API void ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
GUI_API inline void DebugDrawCursorPos(U32 col = GUI_COL32(255, 0, 0, 255)) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  Vec2 pos = window->DC.CursorPos;
  window->DrawList->AddLine(Vec2(pos.x, pos.y - 3.0f),
                            Vec2(pos.x, pos.y + 4.0f), col, 1.0f);
  window->DrawList->AddLine(Vec2(pos.x - 3.0f, pos.y),
                            Vec2(pos.x + 4.0f, pos.y), col, 1.0f);
}

GUI_API void DebugDrawLineExtents(U32 col = GUI_COL32(255, 0, 0, 255));
GUI_API inline void DebugDrawItemRect(U32 col = GUI_COL32(255, 0, 0, 255)) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GetForegroundDrawList(window)->AddRect(g.LastItemData.Rect.Min,
                                         g.LastItemData.Rect.Max, col);
}

GUI_API inline void DebugLocateItem(ID target_id) {
  Context &g = *GGui;
  g.DebugLocateId = target_id;
  g.DebugLocateFrames = 2;
}
// Call sparingly: only 1 at the same time!
GUI_API void
DebugLocateItemOnHover(ID target_id); // Only call on reaction to a mouse Hover:
                                      // because only 1 at the same time!
GUI_API void DebugLocateItemResolveWithLastItem();
inline void DebugStartItemPicker() {
  Context &g = *GGui;
  g.DebugItemPickerActive = true;
}
GUI_API void ShowFontAtlas(FontAtlas *atlas);
GUI_API void DebugHookIdInfo(ID id, DataType data_type, const void *data_id,
                             const void *data_id_end);
GUI_API void DebugNodeColumns(OldColumns *columns);
GUI_API void DebugNodeDrawList(Window *window, ViewportP *viewport,
                               const DrawList *draw_list, const char *label);
GUI_API void DebugNodeDrawCmdShowMeshAndBoundingBox(DrawList *out_draw_list,
                                                    const DrawList *draw_list,
                                                    const DrawCmd *draw_cmd,
                                                    bool show_mesh,
                                                    bool show_aabb);
GUI_API void DebugNodeFont(Font *font);
GUI_API inline void DebugNodeFontGlyph(Font *, const FontGlyph *glyph) {
  Text("Codepoint: U+%04X", glyph->Codepoint);
  Separator();
  Text("Visible: %d", glyph->Visible);
  Text("AdvanceX: %.1f", glyph->AdvanceX);
  Text("Pos: (%.2f,%.2f)->(%.2f,%.2f)", glyph->X0, glyph->Y0, glyph->X1,
       glyph->Y1);
  Text("UV: (%.3f,%.3f)->(%.3f,%.3f)", glyph->U0, glyph->V0, glyph->U1,
       glyph->V1);
}

GUI_API inline void DebugNodeStorage(Storage *storage, const char *label) {
  if (!TreeNode(label, "%s: %d entries, %d bytes", label, storage->Data.Size,
                storage->Data.size_in_bytes()))
    return;
  for (const Storage::StoragePair &p : storage->Data)
    BulletText("Key 0x%08X Value { i: %d }", p.key,
               p.val_i); // Important: we currently don't store a type, real
                         // value may not be integer.
  TreePop();
}

GUI_API inline void DebugNodeTabBar(TabBar *tab_bar, const char *label) {
  // Standalone tab bars (not associated to docking/windows functionality)
  // currently hold no discernible strings.
  char buf[256];
  char *p = buf;
  const char *buf_end = buf + GUI_ARRAYSIZE(buf);
  const bool is_active = (tab_bar->PrevFrameVisible >= GetFrameCount() - 2);
  p += FormatString(p, buf_end - p, "%s 0x%08X (%d tabs)%s  {", label,
                    tab_bar->ID, tab_bar->Tabs.Size,
                    is_active ? "" : " *Inactive*");
  for (int tab_n = 0; tab_n < Min(tab_bar->Tabs.Size, 3); tab_n++) {
    TabItem *tab = &tab_bar->Tabs[tab_n];
    p += FormatString(p, buf_end - p, "%s'%s'", tab_n > 0 ? ", " : "",
                      TabBarGetTabName(tab_bar, tab));
  }
  p +=
      FormatString(p, buf_end - p, (tab_bar->Tabs.Size > 3) ? " ... }" : " } ");
  if (!is_active) {
    PushStyleColor(Col_Text, GetStyleColorVec4(Col_TextDisabled));
  }
  bool open = TreeNode(label, "%s", buf);
  if (!is_active) {
    PopStyleColor();
  }
  if (is_active && IsItemHovered()) {
    DrawList *draw_list = GetForegroundDrawList();
    draw_list->AddRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max,
                       GUI_COL32(255, 255, 0, 255));
    draw_list->AddLine(Vec2(tab_bar->ScrollingRectMinX, tab_bar->BarRect.Min.y),
                       Vec2(tab_bar->ScrollingRectMinX, tab_bar->BarRect.Max.y),
                       GUI_COL32(0, 255, 0, 255));
    draw_list->AddLine(Vec2(tab_bar->ScrollingRectMaxX, tab_bar->BarRect.Min.y),
                       Vec2(tab_bar->ScrollingRectMaxX, tab_bar->BarRect.Max.y),
                       GUI_COL32(0, 255, 0, 255));
  }
  if (open) {
    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++) {
      TabItem *tab = &tab_bar->Tabs[tab_n];
      PushID(tab);
      if (SmallButton("<")) {
        TabBarQueueReorder(tab_bar, tab, -1);
      }
      SameLine(0, 2);
      if (SmallButton(">")) {
        TabBarQueueReorder(tab_bar, tab, +1);
      }
      SameLine();
      Text("%02d%c Tab 0x%08X '%s' Offset: %.2f, Width: %.2f/%.2f", tab_n,
           (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID,
           TabBarGetTabName(tab_bar, tab), tab->Offset, tab->Width,
           tab->ContentWidth);
      PopID();
    }
    TreePop();
  }
}

GUI_API void DebugNodeTable(Table *table);
GUI_API void DebugNodeTableSettings(TableSettings *settings);
GUI_API void DebugNodeInputTextState(InputTextState *state);
GUI_API inline void DebugNodeTypingSelectState(TypingSelectState *data) {
#ifndef GUI_DISABLE_DEBUG_TOOLS
  Text("SearchBuffer = \"%s\"", data->SearchBuffer);
  Text("SingleCharMode = %d, Size = %d, Lock = %d",
       data->Request.SingleCharMode, data->Request.SingleCharSize,
       data->SingleCharModeLock);
  Text("LastRequest = time: %.2f, frame: %d", data->LastRequestTime,
       data->LastRequestFrame);
#else
  GUI_UNUSED(data);
#endif
}

GUI_API void DebugNodeWindow(Window *window, const char *label);
GUI_API inline void DebugNodeWindowSettings(WindowSettings *settings) {
  if (settings->WantDelete)
    BeginDisabled();
  Text("0x%08X \"%s\" Pos (%d,%d) Size (%d,%d) Collapsed=%d", settings->ID,
       settings->GetName(), settings->Pos.x, settings->Pos.y, settings->Size.x,
       settings->Size.y, settings->Collapsed);
  if (settings->WantDelete)
    EndDisabled();
}

GUI_API inline void DebugNodeWindowsList(Vector<Window *> *windows,
                                         const char *label) {
  if (!TreeNode(label, "%s (%d)", label, windows->Size))
    return;
  for (int i = windows->Size - 1; i >= 0; i--) // Iterate front to back
  {
    PushID((*windows)[i]);
    DebugNodeWindow((*windows)[i], "Window");
    PopID();
  }
  TreePop();
}

GUI_API inline void
DebugNodeWindowsListByBeginStackParent(Window **windows, int windows_size,
                                       Window *parent_in_begin_stack) {
  for (int i = 0; i < windows_size; i++) {
    Window *window = windows[i];
    if (window->ParentWindowInBeginStack != parent_in_begin_stack)
      continue;
    char buf[20];
    FormatString(buf, GUI_ARRAYSIZE(buf), "[%04d] Window",
                 window->BeginOrderWithinContext);
    // BulletText("[%04d] Window '%s'", window->BeginOrderWithinContext,
    // window->Name);
    DebugNodeWindow(window, buf);
    Indent();
    DebugNodeWindowsListByBeginStackParent(windows + i + 1,
                                           windows_size - i - 1, window);
    Unindent();
  }
}

GUI_API inline void DebugNodeViewport(ViewportP *viewport) {
  SetNextItemOpen(true, Cond_Once);
  if (TreeNode("viewport0", "Viewport #%d", 0)) {
    WindowFlags flags = viewport->Flags;
    BulletText("Main Pos: (%.0f,%.0f), Size: (%.0f,%.0f)\nWorkArea Offset "
               "Left: %.0f Top: %.0f, Right: %.0f, Bottom: %.0f",
               viewport->Pos.x, viewport->Pos.y, viewport->Size.x,
               viewport->Size.y, viewport->WorkOffsetMin.x,
               viewport->WorkOffsetMin.y, viewport->WorkOffsetMax.x,
               viewport->WorkOffsetMax.y);
    BulletText(
        "Flags: 0x%04X =%s%s%s", viewport->Flags,
        (flags & ViewportFlags_IsPlatformWindow) ? " IsPlatformWindow" : "",
        (flags & ViewportFlags_IsPlatformMonitor) ? " IsPlatformMonitor" : "",
        (flags & ViewportFlags_OwnedByApp) ? " OwnedByApp" : "");
    for (DrawList *draw_list : viewport->DrawDataP.CmdLists)
      DebugNodeDrawList(NULL, viewport, draw_list, "DrawList");
    TreePop();
  }
}

GUI_API void DebugRenderKeyboardPreview(DrawList *draw_list);
GUI_API void DebugRenderViewportThumbnail(DrawList *draw_list,
                                          ViewportP *viewport, const Rect &bb);

// Obsolete functions
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
inline void SetItemUsingMouseWheel() {
  SetItemKeyOwner(Key_MouseWheelY);
} // Changed in 1.89
inline bool TreeNodeBehaviorIsOpen(ID id, TreeNodeFlags flags = 0) {
  return TreeNodeUpdateNextOpen(id, flags);
} // Renamed in 1.89

// Refactored focus/nav/tabbing system in 1.82 and 1.84. If you have old/custom
// copy-and-pasted widgets that used FocusableItemRegister():
//  (Old) GUI_VERSION_NUM  < 18209: using 'ItemAdd(....)' and 'bool
//  tab_focused = FocusableItemRegister(...)' (Old) GUI_VERSION_NUM >= 18209:
//  using 'ItemAdd(..., ItemAddFlags_Focusable)'  and 'bool tab_focused =
//  (GetItemStatusFlags() & ItemStatusFlags_Focused) != 0' (New)
//  GUI_VERSION_NUM >= 18413: using 'ItemAdd(..., ItemFlags_Inputable)'
//  and 'bool tab_focused = (GetItemStatusFlags() &
//  ItemStatusFlags_FocusedTabbing) != 0 || (g.NavActivateId == id &&
//  (g.NavActivateFlags & ActivateFlags_PreferInput))' (WIP)
// Widget code are simplified as there's no need to call
// FocusableItemUnregister() while managing the transition from regular widget
// to TempInputText()
inline bool FocusableItemRegister(Window *window, ID id) {
  GUI_ASSERT(0);
  GUI_UNUSED(window);
  GUI_UNUSED(id);
  return false;
} // -> pass ItemAddFlags_Inputable flag to ItemAdd()
inline void FocusableItemUnregister(Window *window) {
  GUI_ASSERT(0);
  GUI_UNUSED(window);
} // -> unnecessary: TempInputText() uses InputTextFlags_MergedItem
#endif
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
inline bool IsKeyPressedMap(Key key, bool repeat = true) {
  GUI_ASSERT(IsNamedKey(key));
  return IsKeyPressed(key, repeat);
} // Removed in 1.87: Mapping from named key is always identity!
#endif

} // namespace Gui

//-----------------------------------------------------------------------------
// [SECTION] FontAtlas internal API
//-----------------------------------------------------------------------------

// This structure is likely to evolve as we add support for incremental atlas
// updates
struct FontBuilderIO {
  bool (*FontBuilder_Build)(FontAtlas *atlas);
};

// Helper for font builder
#ifdef GUI_ENABLE_STB_TRUETYPE
GUI_API const FontBuilderIO *FontAtlasGetBuilderForStbTruetype();
#endif
GUI_API inline void FontAtlasUpdateConfigDataPointers(FontAtlas *atlas) {
  for (FontConfig &font_cfg : atlas->ConfigData) {
    Font *font = font_cfg.DstFont;
    if (!font_cfg.MergeMode) {
      font->ConfigData = &font_cfg;
      font->ConfigDataCount = 0;
    }
    font->ConfigDataCount++;
  }
}

GUI_API void FontAtlasBuildInit(FontAtlas *atlas);
GUI_API void FontAtlasBuildSetupFont(FontAtlas *atlas, Font *font,
                                     FontConfig *font_config, float ascent,
                                     float descent);
GUI_API void FontAtlasBuildPackCustomRects(FontAtlas *atlas,
                                           void *stbrp_context_opaque);
GUI_API void FontAtlasBuildFinish(FontAtlas *atlas);
GUI_API void FontAtlasBuildRender8bppRectFromString(
    FontAtlas *atlas, int x, int y, int w, int h, const char *in_str,
    char in_marker_char, unsigned char in_marker_pixel_value);
GUI_API void FontAtlasBuildRender32bppRectFromString(
    FontAtlas *atlas, int x, int y, int w, int h, const char *in_str,
    char in_marker_char, unsigned int in_marker_pixel_value);
GUI_API inline void
FontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256],
                                      float in_brighten_factor) {
  for (unsigned int i = 0; i < 256; i++) {
    unsigned int value = (unsigned int)(i * in_brighten_factor);
    out_table[i] = value > 255 ? 255 : (value & 0xFF);
  }
}

GUI_API inline void
FontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256],
                                 unsigned char *pixels, int x, int y, int w,
                                 int h, int stride) {
  GUI_ASSERT_PARANOID(w <= stride);
  unsigned char *data = pixels + x + y * stride;
  for (int j = h; j > 0; j--, data += stride - w)
    for (int i = w; i > 0; i--, data++)
      *data = table[*data];
}

//-----------------------------------------------------------------------------
// [SECTION] Test Engine specific hooks (gui_test_engine)
//-----------------------------------------------------------------------------

#ifdef GUI_ENABLE_TEST_ENGINE
extern void
TestEngineHook_ItemAdd(Context *ctx, ID id, const Rect &bb,
                       const LastItemData *item_data); // item_data may be NULL
extern void TestEngineHook_ItemInfo(Context *ctx, ID id, const char *label,
                                    ItemStatusFlags flags);
extern void TestEngineHook_Log(Context *ctx, const char *fmt, ...);
extern const char *TestEngine_FindItemDebugLabel(Context *ctx, ID id);

// In GUI_VERSION_NUM >= 18934: changed GUI_TEST_ENGINE_ITEM_ADD(bb,id) to
// GUI_TEST_ENGINE_ITEM_ADD(id,bb,item_data);
#define GUI_TEST_ENGINE_ITEM_ADD(_ID, _BB, _ITEM_DATA)                         \
  if (g.TestEngineHookItems)                                                   \
  TestEngineHook_ItemAdd(&g, _ID, _BB, _ITEM_DATA) // Register item bounding box
#define GUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS)                         \
  if (g.TestEngineHookItems)                                                   \
  TestEngineHook_ItemInfo(                                                     \
      &g, _ID, _LABEL,                                                         \
      _FLAGS) // Register item label and status flags (optional)
#define GUI_TEST_ENGINE_LOG(_FMT, ...)                                         \
  if (g.TestEngineHookItems)                                                   \
  TestEngineHook_Log(                                                          \
      &g, _FMT, __VA_ARGS__) // Custom log entry from user land into test log
#else
#define GUI_TEST_ENGINE_ITEM_ADD(_BB, _ID) ((void)0)
#define GUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS) ((void)g)
#endif

//-----------------------------------------------------------------------------

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#endif // #ifndef GUI_DISABLE

// dear gui, v1.90.1 WIP
// (main code and documentation)

// Help:
// - See links below.
// - Call and read Gui::ShowDemoWindow() in gui_demo.cpp. All applications in
// examples/ are doing that.
// - Read top of gui.cpp for more details, links and comments.

// Resources:
// - FAQ                   https://dearimgui.com/faq
// - Getting Started       https://dearimgui.com/getting-started
// - Homepage              https://github.com/ocornut/imgui
// - Releases & changelog  https://github.com/ocornut/imgui/releases
// - Gallery               https://github.com/ocornut/imgui/issues/6897 (please
// post your screenshots/video there!)
// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good
// stuff there)
// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary
// - Issues & support      https://github.com/ocornut/imgui/issues
// - Tests & Automation    https://github.com/ocornut/gui_test_engine

// For first-time users having issues compiling/linking/running/loading fonts:
// please post in https://github.com/ocornut/imgui/discussions if you cannot
// find a solution in resources above. Everything else should be asked in
// 'Issues'! We are building a database of cross-linked knowledge there.

// Copyright (c) 2014-2023 Omar Cornut
// Developed by Omar Cornut and every direct or indirect contributors to the
// GitHub. See LICENSE.txt for copyright and licensing details (standard MIT
// License). This library is free but needs your support to sustain development
// and maintenance. Businesses: you can support continued development via B2B
// invoiced technical support, maintenance and sponsoring contracts. PLEASE
// reach out at omar AT dearimgui DOT com. See
// https://github.com/ocornut/imgui/wiki/Sponsors Businesses: you can also
// purchase licenses for the Dear Gui Automation/Test Engine.

// It is recommended that you don't modify gui.cpp! It will become difficult
// for you to update the library. Note that 'Gui::' being a namespace, you can
// add functions into the namespace from your own source files, without
// modifying gui.hpp or gui.cpp. You may include gui_internal.hpp to access
// internal data structures, but it doesn't come with any guarantee of forward
// compatibility. Discussing your changes on the GitHub Issue Tracker may lead
// you to a better solution or official support for them.

/*

Index of this file:

DOCUMENTATION

- MISSION STATEMENT
- CONTROLS GUIDE
- PROGRAMMER GUIDE
  - READ FIRST
  - HOW TO UPDATE TO A NEWER VERSION OF DEAR GUI
  - GETTING STARTED WITH INTEGRATING DEAR GUI IN YOUR CODE/ENGINE
  - HOW A SIMPLE APPLICATION MAY LOOK LIKE
  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
- API BREAKING CHANGES (read me when you update!)
- FREQUENTLY ASKED QUESTIONS (FAQ)
  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md
(with a Markdown viewer)

CODE
(search for "[SECTION]" in the code to find them)

// [SECTION] INCLUDES
// [SECTION] FORWARD DECLARATIONS
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
// [SECTION] USER FACING STRUCTURES (Style, IO)
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
// [SECTION] MISC HELPERS/UTILITIES (File functions)
// [SECTION] MISC HELPERS/UTILITIES (Text* functions)
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// [SECTION] Storage
// [SECTION] TextFilter
// [SECTION] TextBuffer, TextIndex
// [SECTION] ListClipper
// [SECTION] STYLING
// [SECTION] RENDER HELPERS
// [SECTION] INITIALIZATION, SHUTDOWN
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
// [SECTION] INPUTS
// [SECTION] ERROR CHECKING
// [SECTION] LAYOUT
// [SECTION] SCROLLING
// [SECTION] TOOLTIPS
// [SECTION] POPUPS
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
// [SECTION] DRAG AND DROP
// [SECTION] LOGGING/CAPTURING
// [SECTION] SETTINGS
// [SECTION] LOCALIZATION
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
// [SECTION] PLATFORM DEPENDENT HELPERS
// [SECTION] METRICS/DEBUGGER WINDOW
// [SECTION] DEBUG LOG WINDOW
// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)

*/

//-----------------------------------------------------------------------------
// DOCUMENTATION
//-----------------------------------------------------------------------------

/*

 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools.
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate
 tools.
 - Easy to hack and improve.
 - Minimize setup and maintenance.
 - Minimize state storage on user side.
 - Minimize state synchronization.
 - Portable, minimize dependencies, run on target (consoles, phones, etc.).
 - Efficient runtime and memory consumption.

 Designed primarily for developers and content-creators, not the typical
 end-user! Some of the current weaknesses (which we aim to address in the
 future) includes:

 - Doesn't look fancy.
 - Limited layout features, intricate layouts are typically crafted in code.


 CONTROLS GUIDE
 ==============

 - MOUSE CONTROLS
   - Mouse wheel:                   Scroll vertically.
   - SHIFT+Mouse wheel:             Scroll horizontally.
   - Click [X]:                     Close a window, available when 'bool*
 p_open' is passed to Gui::Begin().
   - Click ^, Double-Click title:   Collapse window.
   - Drag on corner/border:         Resize window (double-click to auto fit
 window to its contents).
   - Drag on any empty space:       Move window (unless
 io.ConfigWindowsMoveFromTitleBarOnly = true).
   - Left-click outside popup:      Close popup stack (right-click over
 underlying popup: Partially close popup stack).

 - TEXT EDITOR
   - Hold SHIFT or Drag Mouse:      Select text.
   - CTRL+Left/Right:               Word jump.
   - CTRL+Shift+Left/Right:         Select words.
   - CTRL+A or Double-Click:        Select All.
   - CTRL+X, CTRL+C, CTRL+V:        Use OS clipboard.
   - CTRL+Z, CTRL+Y:                Undo, Redo.
   - ESCAPE:                        Revert text to its original value.
   - On OSX, controls are automatically adjusted to match standard OSX text
 editing shortcuts and behaviors.

 - KEYBOARD CONTROLS
   - Basic:
     - Tab, SHIFT+Tab               Cycle through text editable fields.
     - CTRL+Tab, CTRL+Shift+Tab     Cycle through windows.
     - CTRL+Click                   Input text into a Slider or Drag widget.
   - Extended features with `io.ConfigFlags |=
 ConfigFlags_NavEnableKeyboard`:
     - Tab, SHIFT+Tab:              Cycle through every items.
     - Arrow keys                   Move through items using directional
 navigation. Tweak value.
     - Arrow keys + Alt, Shift      Tweak slower, tweak faster (when using arrow
 keys).
     - Enter                        Activate item (prefer text input when
 possible).
     - Space                        Activate item (prefer tweaking with arrows
 when possible).
     - Escape                       Deactivate item, leave child window, close
 popup.
     - Page Up, Page Down           Previous page, next page.
     - Home, End                    Scroll to top, scroll to bottom.
     - Alt                          Toggle between scrolling layer and menu
 layer.
     - CTRL+Tab then Ctrl+Arrows    Move window. Hold SHIFT to resize instead of
 moving.
   - Output when ConfigFlags_NavEnableKeyboard set,
     - io.WantCaptureKeyboard flag is set when keyboard is claimed.
     - io.NavActive: true when a window is focused and it doesn't have the
 WindowFlags_NoNavInputs flag set.
     - io.NavVisible: true when the navigation cursor is visible (usually goes
 to back false when mouse is used).

 - GAMEPAD CONTROLS
   - Enable with 'io.ConfigFlags |= ConfigFlags_NavEnableGamepad'.
   - Particularly useful to use Dear Gui on a console system (e.g.
 PlayStation, Switch, Xbox) without a mouse!
   - Download controller mapping PNG/PSD at http://dearimgui.com/controls_sheets
   - Backend support: backend needs to:
      - Set 'io.BackendFlags |= BackendFlags_HasGamepad' + call
 io.AddKeyEvent/AddKeyAnalogEvent() with Key_Gamepad_XXX keys.
      - For analog values (0.0f to 1.0f), backend is responsible to handling a
 dead-zone and rescaling inputs accordingly. Backend code will probably need to
 transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range
 to 0.0..1.0 gui range, etc.).
      - BEFORE 1.87, BACKENDS USED TO WRITE TO io.NavInputs[]. This is now
 obsolete. Please call io functions instead!
   - If you need to share inputs between your game and the Dear Gui interface,
 the easiest approach is to go all-or-nothing, with a buttons combo to toggle
 the target. Please reach out if you think the game vs navigation input sharing
 could be improved.

 - REMOTE INPUTS SHARING & MOUSE EMULATION
   - PS4/PS5 users: Consider emulating a mouse cursor with DualShock touch pad
 or a spare analog stick as a mouse-emulation fallback.
   - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your
 PC) + run examples/libs/synergy/uSynergy.c (on your console/tablet/phone app)
     in order to share your PC mouse/keyboard.
   - See https://github.com/ocornut/imgui/wiki/Useful-Extensions#remoting for
 other remoting solutions.
   - On a TV/console system where readability may be lower or mouse inputs may
 be awkward, you may want to set the ConfigFlags_NavEnableSetMousePos flag.
     Enabling ConfigFlags_NavEnableSetMousePos +
 BackendFlags_HasSetMousePos instructs Dear Gui to move your mouse cursor
 along with navigation movements. When enabled, the NewFrame() function may
 alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants
 the mouse cursor to be moved. When that happens your backend NEEDS to move the
 OS or underlying mouse cursor on the next frame. Some of the backends in
 examples/ do that. (If you set the NavEnableSetMousePos flag but don't honor
 'io.WantSetMousePos' properly, Dear Gui will misbehave as it will see your
 mouse moving back & forth!) (In a setup when you may not have easy control over
 the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor,
 you may want to set a boolean to ignore your other external mouse positions
 until the external source is moved again.)


 PROGRAMMER GUIDE
 ================

 READ FIRST
 ----------
 - Remember to check the wonderful Wiki (https://github.com/ocornut/imgui/wiki)
 - Your code creates the UI every frame of your application loop, if your code
 doesn't run the UI is gone! The UI can be highly dynamic, there are no
 construction or destruction steps, less superfluous data retention on your
 side, less state duplication, less state synchronization, fewer bugs.
 - Call and read Gui::ShowDemoWindow() for demo code demonstrating most
 features. Or browse
 https://pthom.github.io/gui_manual_online/manual/gui_manual.html for
 interactive web version.
 - The library is designed to be built from sources. Avoid pre-compiled binaries
 and packaged versions. See config.hpp to configure your build.
 - Dear Gui is an implementation of the GUI paradigm (immediate-mode
 graphical user interface, a term coined by Casey Muratori). You can learn about
 GUI principles at http://www.johno.se/book/gui.hpptml,
 http://mollyrocket.com/861 & more links in Wiki.
 - Dear Gui is a "single pass" rasterizing implementation of the GUI
 paradigm, aimed at ease of use and high-performances. For every application
 frame, your UI code will be called only once. This is in contrast to e.g.
 Unity's implementation of an GUI, where the UI code is called multiple times
 ("multiple passes") from a single entry point. There are pros and cons to both
 approaches.
 - Our origin is on the top-left. In axis aligned bounding boxes, Min =
 top-left, Max = bottom-right.
 - Please make sure you have asserts enabled (GUI_ASSERT redirects to assert()
 by default, but can be redirected). If you get an assert, read the messages and
 comments around the assert.
 - This codebase aims to be highly optimized:
   - A typical idle frame should never call malloc/free.
   - We rely on a maximum of constant-time or O(N) algorithms. Limiting
 searches/scans as much as possible.
   - We put particular energy in making sure performances are decent with
 typical "Debug" build settings as well. Which mean we tend to avoid
 over-relying on "zero-cost abstraction" as they aren't zero-cost at all.
 - This codebase aims to be both highly opinionated and highly flexible:
   - This code works because of the things it choose to solve or not solve.
   - C++: this is a pragmatic C-ish codebase: we don't use fancy C++ features,
 we don't include C++ headers, and Gui:: is a namespace. We rarely use member
 functions (and when we did, I am mostly regretting it now). This is to increase
 compatibility, increase maintainability and facilitate use from other
 languages.
   - C++: Vec2/Vec4 do not expose math operators by default, because it is
 expected that you use your own math types. See FAQ "How can I use my own math
 types instead of Vec2/Vec4?" for details about setting up config.hpp for
 that. We can can optionally export math operators for Vec2/Vec4 using
 GUI_DEFINE_MATH_OPERATORS, which we use internally.
   - C++: pay attention that Vector<> manipulates plain-old-data and does not
 honor construction/destruction (so don't use Vector in your code or at our
 own risk!).
   - Building: We don't use nor mandate a build system for the main library.
     This is in an effort to ensure that it works in the real world aka with any
 esoteric build setup. This is also because providing a build system for the
 main library would be of little-value. The build problems are almost never
 coming from the main library but from specific backends.


 HOW TO UPDATE TO A NEWER VERSION OF DEAR GUI
 ----------------------------------------------
 - Update submodule or copy/overwrite every file.
 - About config.hpp:
   - You may modify your copy of config.hpp, in this case don't overwrite it.
   - or you may locally branch to modify config.hpp and merge/rebase latest.
   - or you may '#define GUI_USER_CONFIG "my_config_file.h"' globally from
 your build system to specify a custom path for your config.hpp file and instead
 not have to modify the default one.

 - Overwrite all the sources files except for config.hpp (if you have modified
 your copy of config.hpp)
 - Or maintain your own branch where you have config.hpp modified as a top-most
 commit which you can regularly rebase over "master".
 - You can also use '#define GUI_USER_CONFIG "my_config_file.h" to redirect
 configuration to your own file.
 - Read the "API BREAKING CHANGES" section (below). This is where we list
 occasional API breaking changes. If a function/type has been renamed / or
 marked obsolete, try to fix the name in your code before it is permanently
 removed from the public API. If you have a problem with a missing
 function/symbols, search for its name in the code, there will likely be a
 comment about it. Please report any issue to the GitHub page!
 - To find out usage of old API, you can add '#define
 GUI_DISABLE_OBSOLETE_FUNCTIONS' in your configuration file.
 - Try to keep your copy of Dear Gui reasonably up to date!


 GETTING STARTED WITH INTEGRATING DEAR GUI IN YOUR CODE/ENGINE
 ---------------------------------------------------------------
 - See https://github.com/ocornut/imgui/wiki/Getting-Started.
 - Run and study the examples and demo in gui_demo.cpp to get acquainted with
 the library.
 - In the majority of cases you should be able to use unmodified backends files
 available in the backends/ folder.
 - Add the Dear Gui source files + selected backend source files to your
 projects or using your preferred build system. It is recommended you build and
 statically link the .cpp files as part of your project and NOT as a shared
 library (DLL).
 - You can later customize the config.hpp file to tweak some compile-time
 behavior, such as integrating Dear Gui types with your own maths types.
 - When using Dear Gui, your programming IDE is your friend: follow the
 declaration of variables, functions and types to find comments about them.
 - Dear Gui never touches or knows about your GPU state. The only function
 that knows about GPU is the draw function that you provide. Effectively it
 means you can create widgets at any time in your code, regardless of
 considerations of being in "update" vs "render" phases of your own application.
 All rendering information is stored into command-lists that you will retrieve
 after calling Gui::Render().
 - Refer to the backends and demo applications in the examples/ folder for
 instruction on how to setup your code.
 - If you are running over a standard OS with a common graphics API, you should
 be able to use unmodified gui_impl_*** files from the examples/ folder.


 HOW A SIMPLE APPLICATION MAY LOOK LIKE
 --------------------------------------
 EXHIBIT 1: USING THE EXAMPLE BACKENDS (= gui_impl_XXX.cpp files from the
 backends/ folder). The sub-folders in examples/ contain examples applications
 following this structure.

     // Application init: create a dear gui context, setup some options, load
 fonts Gui::CreateContext(); IO& io = Gui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |=
 ConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Initialize helper Platform and Renderer backends (here we are using
 gui_impl_win32.cpp and gui_impl_dx11.cpp) Gui_ImplWin32_Init(hwnd);
     Gui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

     // Application main loop
     while (true)
     {
         // Feed inputs to dear gui, start new frame
         Gui_ImplDX11_NewFrame();
         Gui_ImplWin32_NewFrame();
         Gui::NewFrame();

         // Any application code here
         Gui::Text("Hello, world!");

         // Render dear gui into screen
         Gui::Render();
         Gui_ImplDX11_RenderDrawData(Gui::GetDrawData());
         g_pSwapChain->Present(1, 0);
     }

     // Shutdown
     Gui_ImplDX11_Shutdown();
     Gui_ImplWin32_Shutdown();
     Gui::DestroyContext();

 EXHIBIT 2: IMPLEMENTING CUSTOM BACKEND / CUSTOM ENGINE

     // Application init: create a dear gui context, setup some options, load
 fonts Gui::CreateContext(); IO& io = Gui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |=
 ConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Build and load the texture atlas into a texture
     // (In the examples/ app this is usually done within the
 Gui_ImplXXX_Init() function from one of the demo Renderer) int width, height;
     unsigned char* pixels = nullptr;
     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

     // At this point you've got the texture data and you need to upload that to
 your graphic system:
     // After we have created the texture, store its pointer/identifier (_in
 whichever format your engine uses_) in 'io.Fonts->TexID'.
     // This will be passed back to your via the renderer. Basically TextureID
 == void*. Read FAQ for details about TextureID. Texture* texture =
 Engine::CreateTextureFromMemoryPixels(pixels, width, height,
 TEXTURE_TYPE_RGBA32) io.Fonts->SetTexID((void*)texture);

     // Application main loop
     while (true)
     {
        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or
 write to those fields from your Windows message handlers, etc.
        // (In the examples/ app this is usually done within the
 Gui_ImplXXX_NewFrame() function from one of the demo Platform Backends)
        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since
 the previous frame (in seconds) io.DisplaySize.x = 1920.0f;             // set
 the current display width io.DisplaySize.y = 1280.0f;             // set the
 current display height here io.AddMousePosEvent(mouse_x, mouse_y);  // update
 mouse position io.AddMouseButtonEvent(0, mouse_b[0]);  // update mouse button
 states io.AddMouseButtonEvent(1, mouse_b[1]);  // update mouse button states

        // Call NewFrame(), after this point you can use Gui::* functions
 anytime
        // (So you want to try calling NewFrame() as early as you can in your
 main loop to be able to use Dear Gui everywhere) Gui::NewFrame();

        // Most of your application code here
        Gui::Text("Hello, world!");
        GameUpdate(); // may use any Dear Gui functions, e.g. Gui::Begin("My
 window"); Gui::Text("Hello, world!"); Gui::End(); GameRender(); // may use
 any Dear Gui functions as well!

        // Render dear gui, swap buffers
        // (You want to try calling EndFrame/Render as late as you can, to be
 able to use Dear Gui in your own game rendering code) Gui::EndFrame();
        Gui::Render();
        DrawData* draw_data = Gui::GetDrawData();
        RenderFunction(draw_data);
        SwapBuffers();
     }

     // Shutdown
     Gui::DestroyContext();

 To decide whether to dispatch mouse/keyboard inputs to Dear Gui to the rest
 of your application, you should read the 'io.WantCaptureMouse',
 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags! Please read the FAQ
 entry "How can I tell whether to dispatch mouse/keyboard to Dear Gui or my
 application?" about this.


 HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
 ---------------------------------------------
 The backends in impl_impl_XXX.cpp files contain many working implementations of
 a rendering function.

    void RenderFunction(DrawData* draw_data)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no
 depth testing, scissor enabled
       // TODO: Setup texture sampling state: sample with bilinear filtering
 (NOT point/nearest filtering). Use 'io.Fonts->Flags |=
 FontAtlasFlags_NoBakedLines;' to allow point/nearest filtering.
       // TODO: Setup viewport covering draw_data->DisplayPos to
 draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos
 to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color },
 fragment shader sample color from 1 texture, multiply by vertex color. Vec2
 clip_off = draw_data->DisplayPos; for (int n = 0; n < draw_data->CmdListsCount;
 n++)
       {
          const DrawList* cmd_list = draw_data->CmdLists[n];
          const DrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex
 buffer generated by Dear Gui const DrawIdx* idx_buffer =
 cmd_list->IdxBuffer.Data;   // index buffer generated by Dear Gui for (int
 cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
          {
             const DrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
             if (pcmd->UserCallback)
             {
                 pcmd->UserCallback(cmd_list, pcmd);
             }
             else
             {
                 // Project scissor/clipping rectangles into framebuffer space
                 Vec2 clip_min(pcmd->ClipRect.x - clip_off.x, pcmd->ClipRect.y
 - clip_off.y); Vec2 clip_max(pcmd->ClipRect.z - clip_off.x, pcmd->ClipRect.w
 - clip_off.y); if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
                     continue;

                 // We are using scissoring to clip some objects. All low-level
 graphics API should support it.
                 // - If your engine doesn't support scissoring yet, you may
 ignore this at first. You will get some small glitches
                 //   (some elements visible outside their bounds) but you can
 fix that once everything else works!
                 // - Clipping coordinates are provided in gui coordinates
 space:
                 //   - For a given viewport, draw_data->DisplayPos ==
 viewport->Pos and draw_data->DisplaySize == viewport->Size
                 //   - In a single viewport application, draw_data->DisplayPos
 == (0,0) and draw_data->DisplaySize == io.DisplaySize, but always use
 GetMainViewport()->Pos/Size instead of hardcoding those values.
                 //   - In the interest of supporting multi-viewport
 applications (see 'docking' branch on github),
                 //     always subtract draw_data->DisplayPos from clipping
 bounds to convert them to your viewport space.
                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some
 graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
                 EngineSetScissor(clip_min.x, clip_min.y, clip_max.x,
 clip_max.y);

                 // The texture for the draw call is specified by
 pcmd->GetTexID().
                 // The vast majority of draw calls will use the Dear Gui
 texture atlas, which value you have set yourself during initialization.
                 EngineBindTexture((Texture*)pcmd->GetTexID());

                 // Render 'pcmd->ElemCount/3' indexed triangles.
                 // By default the indices DrawIdx are 16-bit, you can change
 them to 32-bit in config.hpp if your engine doesn't support 16-bit indices.
                 EngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(DrawIdx)
 == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer + pcmd->IdxOffset,
 vtx_buffer, pcmd->VtxOffset);
             }
          }
       }
    }


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the
 breakage minor and easy to fix. Below is a change-log of API breaking changes
 only. If you are using one of the functions listed, expect to have to fix some
 code. When you are not sure about an old symbol or function name, try using the
 Search/Find function of your IDE to look for comments or references in all
 gui files. You can read releases logs
 https://github.com/ocornut/imgui/releases for more details.

 - 2023/12/19 (1.90.1) - commented out obsolete Key_KeyPadEnter redirection
 to Key_KeypadEnter.
 - 2023/11/06 (1.90.1) - removed CalcListClipping() marked obsolete in 1.86.
 Prefer using ListClipper which can return non-contiguous ranges.
 - 2023/11/05 (1.90.1) - gui_freetype: commented out
 FreeType::BuildFontAtlas() obsoleted in 1.81. prefer using #define
 GUI_ENABLE_FREETYPE or see commented code for manual calls.
 - 2023/11/05 (1.90.1) - internals,columns: commented out legacy
 ColumnsFlags_XXX symbols redirecting to OldColumnsFlags_XXX,
 obsoleted from gui_internal.hpp in 1.80.
 - 2023/11/09 (1.90.0) - removed GUI_OFFSETOF() macro in favor of using
 offsetof() available in C++11. Kept redirection define (will obsolete).
 - 2023/11/07 (1.90.0) - removed BeginChildFrame()/EndChildFrame() in favor of
 using BeginChild() with the ChildFlags_FrameStyle flag. kept inline
 redirection function (will obsolete). those functions were merely
 PushStyle/PopStyle helpers, the removal isn't so much motivated by needing to
 add the feature in BeginChild(), but by the necessity to avoid
 BeginChildFrame() signature mismatching BeginChild() signature and features.
 - 2023/11/02 (1.90.0) - BeginChild: upgraded 'bool border = true' parameter to
 'ChildFlags flags' type, added ChildFlags_Border equivalent. As with
 our prior "bool-to-flags" API updates, the ChildFlags_Border value is
 guaranteed to be == true forever to ensure a smoother transition, meaning all
 existing calls will still work.
                           - old: BeginChild("Name", size, true)
                           - new: BeginChild("Name", size,
 ChildFlags_Border)
                           - old: BeginChild("Name", size, false)
                           - new: BeginChild("Name", size) or BeginChild("Name",
 0) or BeginChild("Name", size, ChildFlags_None)
 - 2023/11/02 (1.90.0) - BeginChild: added child-flag
 ChildFlags_AlwaysUseWindowPadding as a replacement for the window-flag
 WindowFlags_AlwaysUseWindowPadding: the feature only ever made sense for
 BeginChild() anyhow.
                           - old: BeginChild("Name", size, 0,
 WindowFlags_AlwaysUseWindowPadding);
                           - new: BeginChild("Name", size,
 ChildFlags_AlwaysUseWindowPadding, 0);
 - 2023/09/27 (1.90.0) - io: removed io.MetricsActiveAllocations introduced
 in 1.63. Same as 'g.DebugMemAllocCount - g.DebugMemFreeCount' (still displayed
 in Metrics, unlikely to be accessed by end-user).
 - 2023/09/26 (1.90.0) - debug tools: Renamed ShowStackToolWindow() ("Stack
 Tool") to ShowIDStackToolWindow() ("ID Stack Tool"), as earlier name was
 misleading. Kept inline redirection function. (#4631)
 - 2023/09/15 (1.90.0) - ListBox, Combo: changed signature of "name getter"
 callback in old one-liner ListBox()/Combo() apis. kept inline redirection
 function (will obsolete).
                           - old: bool Combo(const char* label, int*
 current_item, bool (*getter)(void* user_data, int idx, const char** out_text),
 ...)
                           - new: bool Combo(const char* label, int*
 current_item, const char* (*getter)(void* user_data, int idx), ...);
                           - old: bool ListBox(const char* label, int*
 current_item, bool (*getting)(void* user_data, int idx, const char** out_text),
 ...);
                           - new: bool ListBox(const char* label, int*
 current_item, const char* (*getter)(void* user_data, int idx), ...);
 - 2023/09/08 (1.90.0) - commented out obsolete redirecting functions:
                           - GetWindowContentRegionWidth()  -> use
 GetWindowContentRegionMax().x - GetWindowContentRegionMin().x. Consider that
 generally 'GetContentRegionAvail().x' is more useful.
                           - DrawCornerFlags_XXX          -> use
 DrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details + grep
 commented names in sources.
                       - commented out runtime support for hardcoded ~0 or
 0x01..0x0F rounding flags values for
 AddRect()/AddRectFilled()/PathRect()/AddImageRounded() -> use
 DrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details
 - 2023/08/25 (1.89.9) - clipper: Renamed IncludeRangeByIndices() (also called
 ForceDisplayRangeByIndices() before 1.89.6) to IncludeItemsByIndex(). Kept
 inline redirection function. Sorry!
 - 2023/07/12 (1.89.8) - DrawData: CmdLists now owned, changed from
 DrawList** to Vector<DrawList*>. Majority of users shouldn't be affected,
 but you cannot compare to NULL nor reassign manually anymore. Instead use
 AddDrawList(). (#6406, #4879, #1878)
 - 2023/06/28 (1.89.7) - overlapping items: obsoleted 'SetItemAllowOverlap()'
 (called after item) in favor of calling 'SetNextItemAllowOverlap()' (called
 before item). 'SetItemAllowOverlap()' didn't and couldn't work reliably
 since 1.89 (2022-11-15).
 - 2023/06/28 (1.89.7) - overlapping items: renamed
 'TreeNodeFlags_AllowItemOverlap' to 'TreeNodeFlags_AllowOverlap',
 'SelectableFlags_AllowItemOverlap' to 'SelectableFlags_AllowOverlap'.
 Kept redirecting enums (will obsolete).
 - 2023/06/28 (1.89.7) - overlapping items: IsItemHovered() now by default
 return false when querying an item using AllowOverlap mode which is being
 overlapped. Use HoveredFlags_AllowWhenOverlappedByItem to revert to old
 behavior.
 - 2023/06/28 (1.89.7) - overlapping items: Selectable and TreeNode don't allow
 overlap when active so overlapping widgets won't appear as hovered. While this
 fixes a common small visual issue, it also means that calling IsItemHovered()
 after a non-reactive elements - e.g. Text() - overlapping an active one may
 fail if you don't use
 IsItemHovered(HoveredFlags_AllowWhenBlockedByActiveItem). (#6610)
 - 2023/06/20 (1.89.7) - moved io.HoverDelayShort/io.HoverDelayNormal to
 style.HoverDelayShort/style.HoverDelayNormal. As the fields were added in 1.89
 and expected to be left unchanged by most users, or only tweaked once during
 app initialization, we are exceptionally accepting the breakage.
 - 2023/05/30 (1.89.6) - backends: renamed "gui_impl_sdlrenderer.cpp" to
 "gui_impl_sdlrenderer2.cpp" and "gui_impl_sdlrenderer.h" to
 "gui_impl_sdlrenderer2.hpp". This is in prevision for the future release of
 SDL3.
 - 2023/05/22 (1.89.6) - listbox: commented out obsolete/redirecting functions
 that were marked obsolete more than two years ago:
                           - ListBoxHeader()  -> use BeginListBox() (note how
 two variants of ListBoxHeader() existed. Check commented versions in gui.hpp
 for reference)
                           - ListBoxFooter()  -> use EndListBox()
 - 2023/05/15 (1.89.6) - clipper: commented out obsolete redirection constructor
 'ListClipper(int items_count, float items_height = -1.0f)' that was marked
 obsolete in 1.79. Use default constructor + clipper.Begin().
 - 2023/05/15 (1.89.6) - clipper: renamed
 ListClipper::ForceDisplayRangeByIndices() to
 ListClipper::IncludeRangeByIndices().
 - 2023/03/14 (1.89.4) - commented out redirecting enums/functions names that
 were marked obsolete two years ago:
                           - SliderFlags_ClampOnInput        -> use
 SliderFlags_AlwaysClamp
                           - InputTextFlags_AlwaysInsertMode -> use
 InputTextFlags_AlwaysOverwrite
                           - DrawList::AddBezierCurve()         -> use
 DrawList::AddBezierCubic()
                           - DrawList::PathBezierCurveTo()      -> use
 DrawList::PathBezierCubicCurveTo()
 - 2023/03/09 (1.89.4) - renamed
 PushAllowKeyboardFocus()/PopAllowKeyboardFocus() to PushTabStop()/PopTabStop().
 Kept inline redirection functions (will obsolete).
 - 2023/03/09 (1.89.4) - tooltips: Added 'bool' return value to BeginTooltip()
 for API consistency. Please only submit contents and call EndTooltip() if
 BeginTooltip() returns true. In reality the function will _currently_ always
 return true, but further changes down the line may change this, best to clarify
 API sooner.
 - 2023/02/15 (1.89.4) - moved the optional "courtesy maths operators"
 implementation from gui_internal.hpp in gui.hpp. Even though we encourage using
 your own maths types and operators by setting up GUI_VEC2_CLASS_EXTRA, it has
 been frequently requested by people to use our own. We had an opt-in define
 which was previously fulfilled in gui_internal.hpp. It is now fulfilled in
 gui.hpp. (#6164)
                           - OK:     #define GUI_DEFINE_MATH_OPERATORS /
 #include "gui.hpp" / #include "gui_internal.hpp"
                           - Error:  #include "gui.hpp" / #define
 GUI_DEFINE_MATH_OPERATORS / #include "gui_internal.hpp"
 - 2023/02/07 (1.89.3) - backends: renamed "gui_impl_sdl.cpp" to
 "gui_impl_sdl2.cpp" and "gui_impl_sdl.h" to "gui_impl_sdl2.hpp". (#6146)
 This is in prevision for the future release of SDL3.
 - 2022/10/26 (1.89)   - commented out redirecting OpenPopupContextItem() which
 was briefly the name of OpenPopupOnItemClick() from 1.77 to 1.79.
 - 2022/10/12 (1.89)   - removed runtime patching of invalid "%f"/"%0.f" format
 strings for DragInt()/SliderInt(). This was obsoleted in 1.61 (May 2018).
 See 1.61 changelog for details.
 - 2022/09/26 (1.89)   - renamed and merged keyboard modifiers key enums and
 flags into a same set. Kept inline redirection enums (will obsolete).
                           - Key_ModCtrl  and ModFlags_Ctrl  ->
 Mod_Ctrl
                           - Key_ModShift and ModFlags_Shift ->
 Mod_Shift
                           - Key_ModAlt   and ModFlags_Alt   ->
 Mod_Alt
                           - Key_ModSuper and ModFlags_Super ->
 Mod_Super the Key_ModXXX were introduced in 1.87 and mostly used by
 backends. the ModFlags_XXX have been exposed in gui.hpp but not really
 used by any public api only by third-party extensions. exceptionally commenting
 out the older KeyModFlags_XXX names ahead of obsolescence schedule to
 reduce confusion and because they were not meant to be used anyway.
 - 2022/09/20 (1.89)   - Key is now a typed enum, allowing Key_XXX
 symbols to be named in debuggers. this will require uses of legacy
 backend-dependent indices to be casted, e.g.
                            - with gui_impl_glfw:  IsKeyPressed(GLFW_KEY_A) ->
 IsKeyPressed((Key)GLFW_KEY_A);
                            - with gui_impl_win32: IsKeyPressed('A')        ->
 IsKeyPressed((Key)'A')
                            - etc. However if you are upgrading code you might
 well use the better, backend-agnostic IsKeyPressed(Key_A) now!
 - 2022/09/12 (1.89) - removed the bizarre legacy default argument for
 'TreePush(const void* ptr = NULL)', always pass a pointer value explicitly.
 NULL/nullptr is ok but require cast, e.g. TreePush((void*)nullptr);
 - 2022/09/05 (1.89) - commented out redirecting functions/enums names that were
 marked obsolete in 1.77 and 1.78 (June 2020):
                         - DragScalar(), DragScalarN(), DragFloat(),
 DragFloat2(), DragFloat3(), DragFloat4(): For old signatures ending with (...,
 const char* format, float power = 1.0f) -> use (..., format
 SliderFlags_Logarithmic) if power != 1.0f.
                         - SliderScalar(), SliderScalarN(), SliderFloat(),
 SliderFloat2(), SliderFloat3(), SliderFloat4(): For old signatures ending with
 (..., const char* format, float power = 1.0f) -> use (..., format
 SliderFlags_Logarithmic) if power != 1.0f.
                         - BeginPopupContextWindow(const char*,
 MouseButton, bool) -> use BeginPopupContextWindow(const char*,
 PopupFlags)
 - 2022/09/02 (1.89) - obsoleted using SetCursorPos()/SetCursorScreenPos() to
 extend parent window/cell boundaries. this relates to when moving the cursor
 position beyond current boundaries WITHOUT submitting an item.
                         - previously this would make the window content size
 ~200x200: Begin(...) + SetCursorScreenPos(GetCursorScreenPos() +
 Vec2(200,200)) + End();
                         - instead, please submit an item:
                              Begin(...) +
 SetCursorScreenPos(GetCursorScreenPos() + Vec2(200,200)) + Dummy(Vec2(0,0))
 + End();
                         - alternative:
                              Begin(...) + Dummy(Vec2(200,200)) + End();
                         - content size is now only extended when submitting an
 item!
                         - with '#define GUI_DISABLE_OBSOLETE_FUNCTIONS' this
 will now be detected and assert.
                         - without '#define GUI_DISABLE_OBSOLETE_FUNCTIONS'
 this will silently be fixed until we obsolete it.
 - 2022/08/03 (1.89) - changed signature of ImageButton() function. Kept
 redirection function (will obsolete).
                        - added 'const char* str_id' parameter + removed 'int
 frame_padding = -1' parameter.
                        - old signature: bool ImageButton(TextureID tex_id,
 Vec2 size, Vec2 uv0 = Vec2(0,0), Vec2 uv1 = Vec2(1,1), int
 frame_padding = -1, Vec4 bg_col = Vec4(0,0,0,0), Vec4 tint_col =
 Vec4(1,1,1,1));
                          - used the TextureID value to create an ID. This was
 inconsistent with other functions, led to ID conflicts, and caused problems
 with engines using transient TextureID values.
                          - had a FramePadding override which was inconsistent
 with other functions and made the already-long signature even longer.
                        - new signature: bool ImageButton(const char* str_id,
 TextureID tex_id, Vec2 size, Vec2 uv0 = Vec2(0,0), Vec2 uv1 =
 Vec2(1,1), Vec4 bg_col = Vec4(0,0,0,0), Vec4 tint_col =
 Vec4(1,1,1,1));
                          - requires an explicit identifier. You may still use
 e.g. PushID() calls and then pass an empty identifier.
                          - always uses style.FramePadding for padding, to be
 consistent with other buttons. You may use PushStyleVar() to alter this.
 - 2022/07/08 (1.89) - inputs: removed io.NavInputs[] and NavInput enum
 (following 1.87 changes).
                        - Official backends from 1.87+                  -> no
 issue.
                        - Official backends from 1.60 to 1.86           -> will
 build and convert gamepad inputs, unless GUI_DISABLE_OBSOLETE_KEYIO is
 defined. Need updating!
                        - Custom backends not writing to io.NavInputs[] -> no
 issue.
                        - Custom backends writing to io.NavInputs[]     -> will
 build and convert gamepad inputs, unless GUI_DISABLE_OBSOLETE_KEYIO is
 defined. Need fixing!
                        - TL;DR: Backends should call
 io.AddKeyEvent()/io.AddKeyAnalogEvent() with Key_GamepadXXX values instead
 of filling io.NavInput[].
 - 2022/06/15 (1.88) - renamed GUI_DISABLE_METRICS_WINDOW to
 GUI_DISABLE_DEBUG_TOOLS for correctness. kept support for old define (will
 obsolete).
 - 2022/05/03 (1.88) - backends: osx: removed Gui_ImplOSX_HandleEvent() from
 backend API in favor of backend automatically handling event capture. All
 Gui_ImplOSX_HandleEvent() calls should be removed as they are now
 unnecessary.
 - 2022/04/05 (1.88) - inputs: renamed KeyModFlags to ModFlags. Kept
 inline redirection enums (will obsolete). This was never used in public API
 functions but technically present in gui.hpp and IO.
 - 2022/01/20 (1.87) - inputs: reworded gamepad IO.
                        - Backend writing to io.NavInputs[]            ->
 backend should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with
 Key_GamepadXXX values.
 - 2022/01/19 (1.87) - sliders, drags: removed support for legacy arithmetic
 operators (+,+-,*,/) when inputing text. This doesn't break any api/code but a
 feature that used to be accessible by end-users (which seemingly no one used).
 - 2022/01/17 (1.87) - inputs: reworked mouse IO.
                        - Backend writing to io.MousePos               ->
 backend should call io.AddMousePosEvent()
                        - Backend writing to io.MouseDown[]            ->
 backend should call io.AddMouseButtonEvent()
                        - Backend writing to io.MouseWheel             ->
 backend should call io.AddMouseWheelEvent()
                        - Backend writing to io.MouseHoveredViewport   ->
 backend should call io.AddMouseViewportEvent() [Docking branch w/
 multi-viewports only] note: for all calls to IO new functions, the Dear Gui
 context should be bound/current. read
 https://github.com/ocornut/imgui/issues/4921 for details.
 - 2022/01/10 (1.87) - inputs: reworked keyboard IO. Removed io.KeyMap[],
 io.KeysDown[] in favor of calling io.AddKeyEvent(). Removed GetKeyIndex(), now
 unecessary. All IsKeyXXX() functions now take Key values. All features are
 still functional until GUI_DISABLE_OBSOLETE_KEYIO is defined. Read Changelog
 and Release Notes for details.
                        - IsKeyPressed(MY_NATIVE_KEY_XXX)              -> use
 IsKeyPressed(Key_XXX)
                        - IsKeyPressed(GetKeyIndex(Key_XXX))      -> use
 IsKeyPressed(Key_XXX)
                        - Backend writing to io.KeyMap[],io.KeysDown[] ->
 backend should call io.AddKeyEvent() (+ call io.SetKeyEventNativeData() if you
 want legacy user code to stil function with legacy key codes).
                        - Backend writing to io.KeyCtrl, io.KeyShift.. ->
 backend should call io.AddKeyEvent() with Mod_XXX values. *IF YOU PULLED
 CODE BETWEEN 2021/01/10 and 2021/01/27: We used to have a io.AddKeyModsEvent()
 function which was now replaced by io.AddKeyEvent() with Mod_XXX values.*
                     - one case won't work with backward compatibility: if your
 custom backend used Key as mock native indices (e.g.
 "io.KeyMap[Key_A] = Key_A") because those values are now larger than
 the legacy KeyDown[] array. Will assert.
                     - inputs: added
 Key_ModCtrl/Key_ModShift/Key_ModAlt/Key_ModSuper values to
 submit keyboard modifiers using io.AddKeyEvent(), instead of writing directly
 to io.KeyCtrl, io.KeyShift, io.KeyAlt, io.KeySuper.
 - 2022/01/05 (1.87) - inputs: renamed Key_KeyPadEnter to
 Key_KeypadEnter to align with new symbols. Kept redirection enum.
 - 2022/01/05 (1.87) - removed io.ImeSetInputScreenPosFn() in favor of more
 flexible io.SetPlatformImeDataFn(). Removed 'void* io.ImeWindowHandle' in favor
 of writing to 'void* Viewport::PlatformHandleRaw'.
 - 2022/01/01 (1.87) - commented out redirecting functions/enums names that were
 marked obsolete in 1.69, 1.70, 1.71, 1.72 (March-July 2019)
                        - Gui::SetNextTreeNodeOpen()        -> use
 Gui::SetNextItemOpen()
                        - Gui::GetContentRegionAvailWidth() -> use
 Gui::GetContentRegionAvail().x
                        - Gui::TreeAdvanceToLabelPos()      -> use
 Gui::SetCursorPosX(Gui::GetCursorPosX() + Gui::GetTreeNodeToLabelSpacing());
                        - FontAtlas::CustomRect             -> use
 FontAtlasCustomRect
                        - ColorEditFlags_RGB/HSV/HEX     -> use
 ColorEditFlags_DisplayRGB/HSV/Hex
 - 2021/12/20 (1.86) - backends: removed obsolete Marmalade backend
 (gui_impl_marmalade.cpp) + example. Find last supported version at
 https://github.com/ocornut/imgui/wiki/Bindings
 - 2021/11/04 (1.86) - removed CalcListClipping() function. Prefer using
 ListClipper which can return non-contiguous ranges. Please open an issue
 if you think you really need this function.
 - 2021/08/23 (1.85) - removed GetWindowContentRegionWidth() function. keep
 inline redirection helper. can use 'GetWindowContentRegionMax().x -
 GetWindowContentRegionMin().x' instead for generally
 'GetContentRegionAvail().x' is more useful.
 - 2021/07/26 (1.84) - commented out redirecting functions/enums names that were
 marked obsolete in 1.67 and 1.69 (March 2019):
                        - Gui::GetOverlayDrawList() -> use
 Gui::GetForegroundDrawList()
                        - Font::GlyphRangesBuilder  -> use
 FontGlyphRangesBuilder
 - 2021/05/19 (1.83) - backends: obsoleted direct access to DrawCmd::TextureId
 in favor of calling DrawCmd::GetTexID().
                        - if you are using official backends from the source
 tree: you have nothing to do.
                        - if you have copied old backend code or using your own:
 change access to draw_cmd->TextureId to draw_cmd->GetTexID().
 - 2021/03/12 (1.82) - upgraded DrawList::AddRect(), AddRectFilled(),
 PathRect() to use DrawFlags instead of DrawCornersFlags.
                        - DrawCornerFlags_TopLeft  -> use
 DrawFlags_RoundCornersTopLeft
                        - DrawCornerFlags_BotRight -> use
 DrawFlags_RoundCornersBottomRight
                        - DrawCornerFlags_None     -> use
 DrawFlags_RoundCornersNone etc. flags now sanely defaults to 0 instead of
 0x0F, consistent with all other flags in the API. breaking: the default with
 rounding > 0.0f is now "round all corners" vs old implicit "round no corners":
                        - rounding == 0.0f + flags == 0 --> meant no rounding
 --> unchanged (common use)
                        - rounding  > 0.0f + flags != 0 --> meant rounding -->
 unchanged (common use)
                        - rounding == 0.0f + flags != 0 --> meant no rounding
 --> unchanged (unlikely use)
                        - rounding  > 0.0f + flags == 0 --> meant no rounding
 --> BREAKING (unlikely use): will now round all corners --> use
 DrawFlags_RoundCornersNone or rounding == 0.0f. this ONLY matters for hard
 coded use of 0 + rounding > 0.0f. Use of named DrawFlags_RoundCornersNone
 (new) or DrawCornerFlags_None (old) are ok. the old DrawCornersFlags used
 awkward default values of ~0 or 0xF (4 lower bits set) to signify "round all
 corners" and we sometimes encouraged using them as shortcuts. legacy path still
 support use of hard coded ~0 or any value from 0x1 or 0xF. They will behave the
 same with legacy paths enabled (will assert otherwise).
 - 2021/03/11 (1.82) - removed redirecting functions/enums names that were
 marked obsolete in 1.66 (September 2018):
                        - Gui::SetScrollHere()              -> use
 Gui::SetScrollHereY()
 - 2021/03/11 (1.82) - clarified that DrawList::PathArcTo(),
 DrawList::PathArcToFast() won't render with radius < 0.0f. Previously it
 sorts of accidentally worked but would generally lead to counter-clockwise
 paths and have an effect on anti-aliasing.
 - 2021/03/10 (1.82) - upgraded DrawList::AddPolyline() and PathStroke() "bool
 closed" parameter to "DrawFlags flags". The matching DrawFlags_Closed value
 is guaranteed to always stay == 1 in the future.
 - 2021/02/22 (1.82) - (*undone in 1.84*) win32+mingw: Re-enabled IME functions
 by default even under MinGW. In July 2016, issue #738 had me incorrectly
 disable those default functions for MinGW. MinGW users should: either link with
 -limm32, either set their imconfig file  with '#define
 GUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS'.
 - 2021/02/17 (1.82) - renamed rarely used style.CircleSegmentMaxError (old
 default = 1.60f) to style.CircleTessellationMaxError (new default = 0.30f) as
 the meaning of the value changed.
 - 2021/02/03 (1.81) - renamed ListBoxHeader(const char* label, Vec2 size) to
 BeginListBox(). Kept inline redirection function (will obsolete).
                     - removed ListBoxHeader(const char* label, int items_count,
 int height_in_items = -1) in favor of specifying size. Kept inline redirection
 function (will obsolete).
                     - renamed ListBoxFooter() to EndListBox(). Kept inline
 redirection function (will obsolete).
 - 2021/01/26 (1.81) - removed FreeType::BuildFontAtlas(). Kept inline
 redirection function. Prefer using '#define GUI_ENABLE_FREETYPE', but there's
 a runtime selection path available too. The shared extra flags parameters (very
 rarely used) are now stored in FontAtlas::FontBuilderFlags.
                     - renamed FontConfig::RasterizerFlags (used by FreeType)
 to FontConfig::FontBuilderFlags.
                     - renamed FreeType::XXX flags to
 FreeTypeBuilderFlags_XXX for consistency with other API.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked
 obsolete in 1.63 (August 2018):
                        - Gui::IsItemDeactivatedAfterChange() -> use
 Gui::IsItemDeactivatedAfterEdit().
                        - Col_ModalWindowDarkening       -> use
 Col_ModalWindowDimBg
                        - InputTextCallback              -> use
 TextEditCallback
                        - InputTextCallbackData          -> use
 TextEditCallbackData
 - 2020/12/21 (1.80) - renamed DrawList::AddBezierCurve() to AddBezierCubic(),
 and PathBezierCurveTo() to PathBezierCubicCurveTo(). Kept inline redirection
 function (will obsolete).
 - 2020/12/04 (1.80) - added gui_tables.hpp file! Manually constructed project
 files will need the new file added!
 - 2020/11/18 (1.80) - renamed undocumented/internals ColumnsFlags_* to
 OldColumnFlags_* in prevision of incoming Tables API.
 - 2020/11/03 (1.80) - renamed io.ConfigWindowsMemoryCompactTimer to
 io.ConfigMemoryCompactTimer as the feature will apply to other data structures
 - 2020/10/14 (1.80) - backends: moved all backends files (gui_impl_XXXX.cpp,
 gui_impl_XXXX.h) from examples/ to backends/.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked
 obsolete in 1.60 (April 2018):
                        - io.RenderDrawListsFn pointer        -> use
 Gui::GetDrawData() value and call the render function of your backend
                        - Gui::IsAnyWindowFocused()         -> use
 Gui::IsWindowFocused(FocusedFlags_AnyWindow)
                        - Gui::IsAnyWindowHovered()         -> use
 Gui::IsWindowHovered(HoveredFlags_AnyWindow)
                        - StyleVar_Count_                -> use
 StyleVar_COUNT
                        - MouseCursor_Count_             -> use
 MouseCursor_COUNT
                      - removed redirecting functions names that were marked
 obsolete in 1.61 (May 2018):
                        - InputFloat (... int decimal_precision ...) -> use
 InputFloat (... const char* format ...) with format = "%.Xf" where X is your
 value for decimal_precision.
                        - same for InputFloat2()/InputFloat3()/InputFloat4()
 variants taking a `int decimal_precision` parameter.
 - 2020/10/05 (1.79) - removed ListClipper: Renamed constructor parameters
 which created an ambiguous alternative to using the ListClipper::Begin()
 function, with misleading edge cases (note: gui_memory_editor <0.40 from
 gui_club/ used this old clipper API. Update your copy if needed).
 - 2020/09/25 (1.79) - renamed SliderFlags_ClampOnInput to
 SliderFlags_AlwaysClamp. Kept redirection enum (will obsolete sooner
 because previous name was added recently).
 - 2020/09/25 (1.79) - renamed style.TabMinWidthForUnselectedCloseButton to
 style.TabMinWidthForCloseButton.
 - 2020/09/21 (1.79) - renamed OpenPopupContextItem() back to
 OpenPopupOnItemClick(), reverting the change from 1.77. For varieties of reason
 this is more self-explanatory.
 - 2020/09/21 (1.79) - removed return value from OpenPopupOnItemClick() -
 returned true on mouse release on an item - because it is inconsistent with
 other popup APIs and makes others misleading. It's also and unnecessary: you
 can use IsWindowAppearing() after BeginPopup() for a similar result.
 - 2020/09/17 (1.79) - removed Font::DisplayOffset in favor of
 FontConfig::GlyphOffset. DisplayOffset was applied after scaling and not very
 meaningful/useful outside of being needed by the default ProggyClean font. If
 you scaled this value after calling AddFontDefault(), this is now done
 automatically. It was also getting in the way of better font scaling, so let's
 get rid of it now!
 - 2020/08/17 (1.78) - obsoleted use of the trailing 'float power=1.0f'
 parameter for DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(),
 DragFloatRange2(), DragScalar(), DragScalarN(), SliderFloat(), SliderFloat2(),
 SliderFloat3(), SliderFloat4(), SliderScalar(), SliderScalarN(), VSliderFloat()
 and VSliderScalar(). replaced the 'float power=1.0f' argument with
 integer-based flags defaulting to 0 (as with all our flags). worked out a
 backward-compatibility scheme so hopefully most C++ codebase should not be
 affected. in short, when calling those functions:
                       - if you omitted the 'power' parameter (likely!), you are
 not affected.
                       - if you set the 'power' parameter to 1.0f (same as
 previous default value): 1/ your compiler may warn on float>int conversion, 2/
 everything else will work. 3/ you can replace the 1.0f value with 0 to fix the
 warning, and be technically correct.
                       - if you set the 'power' parameter to >1.0f (to enable
 non-linear editing): 1/ your compiler may warn on float>int conversion, 2/ code
 will assert at runtime, 3/ in case asserts are disabled, the code will not
 crash and enable the _Logarithmic flag. 4/ you can replace the >1.0f value with
 SliderFlags_Logarithmic to fix the warning/assert and get a _similar_
 effect as previous uses of power >1.0f. see
 https://github.com/ocornut/imgui/issues/3361 for all details. kept inline
 redirection functions (will obsolete) apart for: DragFloatRange2(),
 VSliderFloat(), VSliderScalar(). For those three the 'float power=1.0f' version
 was removed directly as they were most unlikely ever used. for shared code, you
 can version check at compile-time with `#if GUI_VERSION_NUM >= 17704`.
                     - obsoleted use of v_min > v_max in DragInt, DragFloat,
 DragScalar to lock edits (introduced in 1.73, was not demoed nor documented
 very), will be replaced by a more generic ReadOnly feature. You may use the
 SliderFlags_ReadOnly internal flag in the meantime.
 - 2020/06/23 (1.77) - removed BeginPopupContextWindow(const char*, int
 mouse_button, bool also_over_items) in favor of BeginPopupContextWindow(const
 char*, PopupFlags flags) with PopupFlags_NoOverItems.
 - 2020/06/15 (1.77) - renamed OpenPopupOnItemClick() to OpenPopupContextItem().
 Kept inline redirection function (will obsolete). [NOTE: THIS WAS REVERTED
 IN 1.79]
 - 2020/06/15 (1.77) - removed CalcItemRectClosestPoint() entry point which was
 made obsolete and asserting in December 2017.
 - 2020/04/23 (1.77) - removed unnecessary ID (first arg) of
 FontAtlas::AddCustomRectRegular().
 - 2020/01/22 (1.75) - DrawList::AddCircle()/AddCircleFilled() functions don't
 accept negative radius any more.
 - 2019/12/17 (1.75) - [undid this change in 1.76] made Columns() limited to 64
 columns by asserting above that limit. While the current code technically
 supports it, future code may not so we're putting the restriction ahead.
 - 2019/12/13 (1.75) - [gui_internal.hpp] changed Rect() default constructor
 initializes all fields to 0.0f instead of (FLT_MAX,FLT_MAX,-FLT_MAX,-FLT_MAX).
 If you used Rect::Add() to create bounding boxes by adding multiple points
 into it, you may need to fix your initial value.
 - 2019/12/08 (1.75) - removed redirecting functions/enums that were marked
 obsolete in 1.53 (December 2017):
                       - ShowTestWindow()                    -> use
 ShowDemoWindow()
                       - IsRootWindowFocused()               -> use
 IsWindowFocused(FocusedFlags_RootWindow)
                       - IsRootWindowOrAnyChildFocused()     -> use
 IsWindowFocused(FocusedFlags_RootAndChildWindows)
                       - SetNextWindowContentWidth(w)        -> use
 SetNextWindowContentSize(Vec2(w, 0.0f)
                       - GetItemsLineHeightWithSpacing()     -> use
 GetFrameHeightWithSpacing()
                       - Col_ChildWindowBg              -> use
 Col_ChildBg
                       - StyleVar_ChildWindowRounding   -> use
 StyleVar_ChildRounding
                       - TreeNodeFlags_AllowOverlapMode -> use
 TreeNodeFlags_AllowItemOverlap
                       - GUI_DISABLE_TEST_WINDOWS          -> use
 GUI_DISABLE_DEMO_WINDOWS
 - 2019/12/08 (1.75) - obsoleted calling DrawList::PrimReserve() with a
 negative count (which was vaguely documented and rarely if ever used). Instead,
 we added an explicit PrimUnreserve() API.
 - 2019/12/06 (1.75) - removed implicit default parameter to IsMouseDragging(int
 button = 0) to be consistent with other mouse functions (none of the other
 functions have it).
 - 2019/11/21 (1.74) - FontAtlas::AddCustomRectRegular() now requires an ID
 larger than 0x110000 (instead of 0x10000) to conform with supporting Unicode
 planes 1-16 in a future update. ID below 0x110000 will now assert.
 - 2019/11/19 (1.74) - renamed GUI_DISABLE_FORMAT_STRING_FUNCTIONS to
 GUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS for consistency.
 - 2019/11/19 (1.74) - renamed GUI_DISABLE_MATH_FUNCTIONS to
 GUI_DISABLE_DEFAULT_MATH_FUNCTIONS for consistency.
 - 2019/10/22 (1.74) - removed redirecting functions/enums that were marked
 obsolete in 1.52 (October 2017):
                       - Begin() [old 5 args version]        -> use Begin() [3
 args], use SetNextWindowSize() SetNextWindowBgAlpha() if needed
                       - IsRootWindowOrAnyChildHovered()     -> use
 IsWindowHovered(HoveredFlags_RootAndChildWindows)
                       - AlignFirstTextHeightToWidgets()     -> use
 AlignTextToFramePadding()
                       - SetNextWindowPosCenter()            -> use
 SetNextWindowPos() with a pivot of (0.5f, 0.5f)
                       - Font::Glyph                       -> use FontGlyph
 - 2019/10/14 (1.74) - inputs: Fixed a miscalculation in the keyboard/mouse
 "typematic" repeat delay/rate calculation, used by keys and e.g. repeating
 mouse buttons as well as the GetKeyPressedAmount() function. if you were using
 a non-default value for io.KeyRepeatRate (previous default was 0.250), you can
 add +io.KeyRepeatDelay to it to compensate for the fix. The function was
 triggering on: 0.0 and (delay+rate*N) where (N>=1). Fixed formula responds to
 (N>=0). Effectively it made io.KeyRepeatRate behave like it was set to
 (io.KeyRepeatRate + io.KeyRepeatDelay). If you never altered io.KeyRepeatRate
 nor used GetKeyPressedAmount() this won't affect you.
 - 2019/07/15 (1.72) - removed TreeAdvanceToLabelPos() which is rarely used and
 only does SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()). Kept
 redirection function (will obsolete).
 - 2019/07/12 (1.72) - renamed FontAtlas::CustomRect to FontAtlasCustomRect.
 Kept redirection typedef (will obsolete).
 - 2019/06/14 (1.72) - removed redirecting functions/enums names that were
 marked obsolete in 1.51 (June 2017): Col_Column*, SetCond_*,
 IsItemHoveredRect(), IsPosHoveringAnyWindow(), IsMouseHoveringAnyWindow(),
 IsMouseHoveringWindow(), GUI_ONCE_UPON_A_FRAME. Grep this log for details and
 new names, or see how they were implemented until 1.71.
 - 2019/06/07 (1.71) - rendering of child window outer decorations (bg color,
 border, scrollbars) is now performed as part of the parent window. If you have
                       overlapping child windows in a same parent, and relied on
 their relative z-order to be mapped to their submission order, this will affect
 your rendering. This optimization is disabled if the parent window has no
 visual output, because it appears to be the most common situation leading to
 the creation of overlapping child windows. Please reach out if you are
 affected.
 - 2019/05/13 (1.71) - renamed SetNextTreeNodeOpen() to SetNextItemOpen(). Kept
 inline redirection function (will obsolete).
 - 2019/05/11 (1.71) - changed io.AddInputCharacter(unsigned short c) signature
 to io.AddInputCharacter(unsigned int c).
 - 2019/04/29 (1.70) - improved DrawList thick strokes (>1.0f) preserving
 correct thickness up to 90 degrees angles (e.g. rectangles). If you have custom
 rendering using thick lines, they will appear thicker now.
 - 2019/04/29 (1.70) - removed GetContentRegionAvailWidth(), use
 GetContentRegionAvail().x instead. Kept inline redirection function (will
 obsolete).
 - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList().
 Kept redirection function (will obsolete).
 - 2019/02/26 (1.69) - renamed
 ColorEditFlags_RGB/ColorEditFlags_HSV/ColorEditFlags_HEX to
 ColorEditFlags_DisplayRGB/ColorEditFlags_DisplayHSV/ColorEditFlags_DisplayHex.
 Kept redirection enums (will obsolete).
 - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with
 an exception for the first frame). If for some reason your time step
 calculation gives you a zero value, replace it with an arbitrarily small value!
 - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which
 were marked obsolete and removed from viewport/docking branch already).
 - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was
 always intended. Please don't access directly, and use AddInputCharacter()
 instead!
 - 2019/01/06 (1.67) - renamed FontAtlas::GlyphRangesBuilder to
 FontGlyphRangesBuilder. Kept redirection typedef (will obsolete).
 - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string.
 This somehow half-worked before but had various undesirable side-effects.
 - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to
 io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration
 flags.
 - 2018/10/12 (1.66) - renamed misc/stl/gui_stl.* to misc/cpp/gui_stdlib.*
 in prevision for other C++ helper files.
 - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept
 redirection function (will obsolete).
 - 2018/09/06 (1.65) - renamed stb_truetype.h to truetype.hpp,
 textedit.hpp to textedit.hpppp, and stb_rect_pack.h to rectpack.hpp. If
 you were conveniently using the gui copy of those STB headers in your project
 you will have to update your include paths.
 - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to
 io.ConfigInputTextCursorBlink. (#1427)
 - 2018/08/31 (1.64) - added gui_widgets.hpp file, extracted and moved widgets
 code out of gui.cpp into gui_widgets.hpp. Re-ordered some of the code
 remaining in gui.cpp. NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS
 SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED. Because of
 this, any local modifications to gui.cpp will likely conflict when you
 update. Read docs/CHANGELOG.txt for suggestions.
 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to
 IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept
 redirection function (will obsolete soonish as IsItemDeactivatedAfterChange()
 is very recent).
 - 2018/08/21 (1.63) - renamed TextEditCallback to InputTextCallback,
 TextEditCallbackData to InputTextCallbackData for consistency. Kept
 redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed InputTextCallbackData::ReadOnly since it is
 a duplication of (InputTextCallbackData::Flags &
 InputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window WindowFlags_ResizeFromAnySide
 beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67
 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [->
 io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to
 ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed Gui::GetTime() return value from float to double
 to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed Col_ModalWindowDarkening to
 Col_ModalWindowDimBg for consistency with other features. Kept redirection
 enum (will obsolete).
 - 2018/06/08 (1.62) - examples: the gui_impl_XXX files have been split to
 separate platform (Win32, GLFW, SDL2, etc.) from renderer (DX11, OpenGL,
 Vulkan,  etc.). old backends will still work as is, however prefer using the
 separated backends as they will be updated to support multi-viewports. when
 adopting new backends follow the main.cpp code of your preferred examples/
 folder to know which functions to call. in particular, note that old backends
 called Gui::NewFrame() at the end of their Gui_ImplXXXX_NewFrame() function.
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to
 GetGlyphRangesChineseFull() to distinguish other variants and discourage using
 the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the
 TreeNodeFlags_CollapsingHeader helper now include the
 TreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has
 been changed from "%.0f" to "%d", as we are not using integers internally any
 more. If you used DragInt() with custom format strings, make sure you change
 them to use %d or an integer-compatible format. To honor
 backward-compatibility, the DragInt() code will currently parse and modify
 format strings to replace %*f with %d, giving time to users to upgrade their
 code. If you have GUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will
 instead assert! You may run a reg-exp search on your codebase for e.g.
 "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int
 decimal_precision" in favor of an equivalent and more flexible "const char*
 format", consistent with other functions. Kept redirection functions (will
 obsolete).
 - 2018/04/09 (1.61) - GUI_DELETE() helper function added in 1.60 doesn't clear
 the input _pointer_ reference, more consistent with expectation and allows
 passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for
 consistency and ease of understanding (was added in 1.52, _not_ used by core
 and only honored by some backend ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed Col_CloseButton, Col_CloseButtonActive,
 Col_CloseButtonHovered as the closing cross uses regular button colors
 now.
 - 2018/03/08 (1.60) - changed Font::DisplayOffset.y to default to 0 instead
 of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were
 adding or subtracting to Font::DisplayOffset check if your fonts are
 correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed StyleVar_Count_ to StyleVar_COUNT and
 MouseCursor_Count_ to MouseCursor_COUNT for consistency with other
 public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional
 mouse_button=0 parameter because it is not really usable in many situations at
 the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call
 your graphics engine render function after Gui::Render(). Use
 Gui::GetDrawData() to retrieve the DrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
                       - YOU NOW NEED TO CALL Gui::CreateContext() AT THE
 BEGINNING OF YOUR APP, AND CALL Gui::DestroyContext() AT THE END.
                       - removed Shutdown() function, as DestroyContext() serve
 this purpose.
                       - you may pass a FontAtlas* pointer to CreateContext()
 to share a font atlas between contexts. Otherwise CreateContext() will create
 its own font atlas instance.
                       - removed allocator parameters from CreateContext(), they
 are now setup with SetAllocatorFunctions(), and shared by all contexts.
                       - removed the default global context and font atlas
 instance, which were confusing for users of DLL reloading and users of multiple
 contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/.
 If you loaded files directly from the gui repo you may need to update your
 paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of
 IsWindowHovered(HoveredFlags_AnyWindow). Kept redirection function (will
 obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of
 IsWindowFocused(FocusedFlags_AnyWindow). Kept redirection function (will
 obsolete).
 - 2018/01/03 (1.60) - renamed SizeConstraintCallback to SizeCallback,
 SizeConstraintCallbackData to SizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and
 not really used by anyone except demo code. If you need it it's easy to
 replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to
 ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - DrawList: renamed style.AntiAliasedShapes to
 style.AntiAliasedFill for consistency and as a way to explicitly break code
 that manipulate those flag at runtime. You can now manipulate DrawList::Flags
 - 2017/12/21 (1.53) - DrawList: removed 'bool anti_aliased = true' final
 parameter of DrawList::AddPolyline() and DrawList::AddConvexPolyFilled().
 Prefer manipulating DrawList::Flags if you need to toggle them during the
 frame.
 - 2017/12/14 (1.53) - using the WindowFlags_NoScrollWithMouse flag on a
 child window forwards the mouse wheel event to the parent window, unless either
 WindowFlags_NoInputs or WindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to
 GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using
 IsWindowFocused(FocusedFlags_RootWindow). Kept redirection function (will
 obsolete).
                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of
 using IsWindowFocused(FocusedFlags_RootAndChildWindows). Kept redirection
 function (will obsolete).
 - 2017/12/12 (1.53) - renamed TreeNodeFlags_AllowOverlapMode to
 TreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using
 SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed TextBuffer::append() helper to appendf(),
 appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses
 appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed WindowFlags_ShowBorders window
 flag. Borders are now fully set up in the Style structure (see e.g.
 style.FrameBorderSize, style.WindowBorderSize). Use Gui::ShowStyleEditor() to
 look them up. Please note that the style system will keep evolving (hopefully
 stabilizing in Q1 2018), and so custom styles will probably subtly break over
 time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(),
 StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed Col_ComboBg in favor of combo boxes
 using Col_PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed Col_ChildWindowBg to
 Col_ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to
 style.ChildRounding, StyleVar_ChildWindowRounding to
 StyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of
 using IsWindowHovered(HoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed
 GUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/GUI_DISABLE_WIN32_DEFAULT_IME_FUNCS
 to
 GUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/GUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
 for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to
 return false if an item is active in another window (e.g. click-dragging item
 from another window to this window). You can use the newly introduced
 IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as
 obsolete, in favor of using the newly introduced flags for IsItemHovered() and
 IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for
 details. removed the IsItemRectHovered()/IsWindowRectHovered() names introduced
 in 1.51 since they were merely more consistent names for the two functions we
 are now obsoleting. IsItemHoveredRect()        -->
 IsItemHovered(HoveredFlags_RectOnly) IsMouseHoveringAnyWindow() -->
 IsWindowHovered(HoveredFlags_AnyWindow) IsMouseHoveringWindow()    -->
 IsWindowHovered(HoveredFlags_AllowWhenBlockedByPopup |
 HoveredFlags_AllowWhenBlockedByActiveItem) [weird, old behavior]
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as
 obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to
 AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/26 (1.52) - renamed Font::Glyph to FontGlyph. Kept redirection
 typedef (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because
 SetNextWindowPos() now has the optional pivot information to do the same and
 more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to Vec2(-FLT_MAX,-FLT_MAX)
 when mouse is unavailable/missing. Previously Vec2(-1,-1) was enough but we
 now accept negative mouse coordinates. In your backend if you need to support
 unavailable mouse, make sure to replace "io.MousePos = Vec2(-1,-1)" with
 "io.MousePos = Vec2(-FLT_MAX,-FLT_MAX)".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept
 inline redirection function (will obsolete). -> (1.52) use
 IsItemHovered(HoveredFlags_RectOnly)!
                     - renamed IsMouseHoveringAnyWindow() to
 IsAnyWindowHovered() for consistency. Kept inline redirection function (will
 obsolete).
                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered()
 for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for
 consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(Col idx,U32 col) overload,
 which _might_ cause an "ambiguous call" compilation error if you are using
 Color() with implicit cast. Cast toU32 or Vec4 explicily to fix.
 - 2017/08/15 (1.51) - marked the weird GUI_ONCE_UPON_A_FRAME helper macro as
 obsolete. prefer using the more explicit OnceUponAFrame type.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow()
 from (const char*,int buttons,bool also_over_items) to (const char*,int
 buttons,bool also_over_items). Note that most calls relied on default
 parameters completely.
 - 2017/08/13 (1.51) - renamed Col_Column to Col_Separator,
 Col_ColumnHovered to Col_SeparatorHovered, Col_ColumnActive to
 Col_SeparatorActive. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed SetCond_Always to Cond_Always,
 SetCond_Once to Cond_Once, SetCond_FirstUseEver to
 Cond_FirstUseEver, SetCond_Appearing to Cond_Appearing. Kept
 redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to
 calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and ColorEditMode in favor
 of ColorEditFlags and parameters to the various Color*() functions. The
 SetColorEditOptions() allows to initialize default but the user can still
 change them with right-click context menu.
                     - changed prototype of 'ColorEdit4(const char* label, float
 col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float
 col[4], ColorEditFlags flags = 0)', where passing flags = 0x01 is a safe
 no-op (hello dodgy backward compatibility!). - check and run the demo window,
 under "Color/Picker Widgets", to understand the various new options.
                     - changed prototype of rarely used 'ColorButton(Vec4 col,
 bool small_height = false, bool outline_border = true)' to 'ColorButton(const
 char* desc_id, Vec4 col, ColorEditFlags flags = 0, Vec2 size =
 Vec2(0, 0))'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(Vec2), which was partly
 broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed FontConfig::MergeGlyphCenterV in favor of a
 more multipurpose FontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed DrawList::PathFill() (rarely used directly) to
 DrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the
 provided label, consistently with other functions as it should always have
 been. It shouldn't affect you unless (extremely unlikely) you were appending
 multiple times to a same child from different locations of the stack id. If
 that's the case, generate an id with GetID() and use it instead of passing
 string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to
 io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass
 io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a Vec2 (Align enum
 was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f)
 for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of
 column/group if any, and not always to left of window. This was sort of always
 the intent and hopefully, breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using Col_TitleBg/Col_TitleBgActive
 colors) isn't rendered over a window background (Col_WindowBg color)
 anymore. If your TitleBg/TitleBgActive alpha was 1.0f or you are using the
 default theme it will not affect you, otherwise if <1.0f you need to tweak your
 custom theme to readjust for the fact that we don't draw a WindowBg background
 behind the title bar. This helper function will convert an old
 TitleBg/TitleBgActive color into a new one with the same visual output, given
 the OLD color and the OLD WindowBg color: Vec4 ConvertTitleBgCol(const
 Vec4& win_bg_col, const Vec4& title_bg_col) { float new_a = 1.0f - ((1.0f -
 win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a; return
 Vec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y *
 win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w +
 title_bg_col.z) * k, new_a); } If this is confusing, pick the RGB value from
 title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or
 you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(),
 GetInternalStateSize(), SetInternalState() functions. Now using
 CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(),
 no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char*
 label, const char* str_id = NULL, bool display_frame = true, bool default_open
 = false) as extra parameters were badly designed and rarely used. You can
 replace the "default_open = true" flag in new API with CollapsingHeader(label,
 TreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed DrawList::PushClipRect(Vec4 rect) to
 DrawList::PushClipRect(Imvec2 min,Vec2 max,bool
 intersect_with_current_clip_rect=false). Note that higher-level
 Gui::PushClipRect() is preferable because it will clip at logic/widget level,
 whereas DrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was
 redundant. Bake default BG alpha inside style.Colors[Col_WindowBg] and all
 other Bg color values. (ref GitHub issue #337).
 - 2016/04/03 (1.48) - renamed Col_TooltipBg to Col_PopupBg, used by
 popups/menus and tooltips. popups/menus were previously using
 Col_WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize()
 to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you
 modify the text buffer manually (without using DeleteChars()/InsertChars()
 helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(),
 previously it would add extra FramePadding.x*2 over that width. if you had
 manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed DrawList::AddRect() which used to render a
 rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously
 named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various
 fixes to inconsistencies with dealing with cursor position.
                       GetCursorPos()/SetCursorPos() functions now include the
 scrolled amount. It shouldn't affect the majority of users, but take note that
 SetCursorPosX(100.0f) puts you at +100 from the starting x position which may
 include scrolling, not at +100 from the window left side.
                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax()
 functions allow include the scrolled amount. Typically those were used in cases
 where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split gui.cpp into extra files: gui_demo.cpp
 gui_draw.hpp gui_internal.hpp that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in DrawList::PathArcTo(), PathArcToFast()
 (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new FontAtlas::AddFont() API. For the old
 AddFont***, moved the 'font_no' parameter of FontAtlas::AddFont** functions
 to the FontConfig structure. you need to render your textured triangles with
 bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is
 saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a
 marginal cost. this necessary change will break your rendering function! the
 fix should be very easy. sorry for that :(
                     - if you are using a vanilla copy of one of the
 gui_impl_XXX.cpp provided in the example, you just need to update your copy
 and you can ignore the rest.
                     - the signature of the io.RenderDrawListsFn handler has
 changed! old: Gui_XXXX_RenderDrawLists(DrawList** const cmd_lists, int
 cmd_lists_count) new: Gui_XXXX_RenderDrawLists(DrawData* draw_data).
                         parameters: 'cmd_lists' becomes 'draw_data->CmdLists',
 'cmd_lists_count' becomes 'draw_data->CmdListsCount' DrawList: 'commands'
 becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
                         DrawCmd:  'vtx_count' becomes 'ElemCount',
 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback',
 'texture_id' becomes 'TextureId'.
                     - each DrawList now contains both a vertex buffer and an
 index buffer. For each command, render ElemCount/3 triangles using indices from
 the index buffer.
                     - if you REALLY cannot render indexed primitives, you can
 call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is
 slow and a waste of CPU/GPU. Prefer using indexed rendering!
                     - refer to code in the examples/ folder or ask on the
 GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos().
 Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to
 reduce confusion along with other scrolling functions, because positions (e.g.
 cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from
 (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture
 have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to
 (label, selected, flags, size). Size override should have been rarely used.
 Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for
 consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for
 consistency. Note that return value is opposite! Kept inline redirection
 function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from
 Button() - sorry! it was rarely used and inconsistent. Use
 PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier
 instead of a bool. Gui needs to manage the open/closed state of popups. Call
 OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns
 true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding
 makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline
 redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed DrawList::AddArc() to DrawList::AddArcFast()
 for compatibility with future API
 - 2015/04/03 (1.38) - removed Col_CheckHovered, Col_CheckActive,
 replaced with the more general Col_FrameBgHovered, Col_FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the
 range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed
 GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to
 GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline
 redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing,
 StyleVar_TreeNodeSpacing to StyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept
 inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth
 (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool,
 SetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed SetCondition_*** to SetCond_***, and
 _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback TextEditCallback return
 type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its
 evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to
 GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed Storage::GetIntPtr()/GetFloatPtr() to
 GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage
 functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for
 multiple fonts. no need for a PNG loader.
 - 2015/01/11 (1.30) - removed GetDefaultFontData(). uses
 io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
                       - old:  const void* png_data; unsigned int png_size;
 Gui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); [..Upload texture to
 GPU..];
                       - new:  unsigned char* pixels; int width, height;
 io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); [..Upload texture to
 GPU..]; io.Fonts->SetTexID(YourTexIdentifier); you now have more flexibility to
 load multiple TTF fonts and manage the texture buffer for internal needs. It is
 now recommended that you sample the font texture with bilinear interpolation.
 - 2015/01/11 (1.30) - added texture identifier in DrawCmd passed to your
 render function (we can now render images). make sure to call
 io.Fonts->SetTexID()
 - 2015/01/11 (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled
 in user projection matrix)
 - 2015/01/11 (1.30) - removed Gui::IsItemFocused() in favor of
 Gui::IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic
 API SetNextWindowPos(pos, SetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font->
 structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of GUI_ONCE_UPON_A_FRAME helper macro
 to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed GUI_INCLUDE_GUI_USER_CPP to
 GUI_INCLUDE_GUI_USER_INL and gui_user.cpp to gui_user.inl (more IDE
 friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn
 (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved GUI_MALLOC/GUI_REALLOC/GUI_FREE preprocessor
 defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved GUI_FONT_TEX_UV_FOR_WHITE preprocessor define to
 IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following
 various rendering fixes


 FREQUENTLY ASKED QUESTIONS (FAQ)
 ================================

 Read all answers online:
   https://www.dearimgui.com/faq or
 https://github.com/ocornut/imgui/blob/master/docs/FAQ.md (same url) Read all
 answers locally (with a text editor or ideally a Markdown viewer): docs/FAQ.md
 Some answers are copied down here to facilitate searching in code.

 Q&A: Basics
 ===========

 Q: Where is the documentation?
 A: This library is poorly documented at the moment and expects the user to be
 acquainted with C/C++.
    - Run the examples/ applications and explore them.
    - Read Getting Started
 (https://github.com/ocornut/imgui/wiki/Getting-Started) guide.
    - See demo code in gui_demo.cpp and particularly the Gui::ShowDemoWindow()
 function.
    - The demo covers most features of Dear Gui, so you can read the code and
 see its output.
    - See documentation and comments at the top of gui.cpp + effectively
 gui.hpp.
    - 20+ standalone example applications using e.g. OpenGL/DirectX are provided
 in the examples/ folder to explain how to integrate Dear Gui with your own
 engine/application.
    - The Wiki (https://github.com/ocornut/imgui/wiki) has many resources and
 links.
    - The Glossary (https://github.com/ocornut/imgui/wiki/Glossary) page also
 may be useful.
    - Your programming IDE is your friend, find the type or function declaration
 to find comments associated with it.

 Q: What is this library called?
 Q: Which version should I get?
 >> This library is called "Dear Gui", please don't call it "Gui" :)
 >> See https://www.dearimgui.com/faq for details.

 Q&A: Integration
 ================

 Q: How to get started?
 A: Read https://github.com/ocornut/imgui/wiki/Getting-Started. Read 'PROGRAMMER
 GUIDE' above. Read examples/README.txt.

 Q: How can I tell whether to dispatch mouse/keyboard to Dear Gui or my
 application? A: You should read the 'io.WantCaptureMouse',
 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 >> See https://www.dearimgui.com/faq for a fully detailed answer. You really
 want to read this.

 Q. How can I enable keyboard or gamepad controls?
 Q: How can I use this on a machine without mouse, keyboard or screen? (input
 share, remote display) Q: I integrated Dear Gui in my engine and little
 squares are showing instead of text... Q: I integrated Dear Gui in my engine
 and some elements are clipping or disappearing when I move windows around... Q:
 I integrated Dear Gui in my engine and some elements are displaying outside
 their expected windows boundaries...
 >> See https://www.dearimgui.com/faq

 Q&A: Usage
 ----------

 Q: About the ID Stack system..
   - Why is my widget not reacting when I click on it?
   - How can I have widgets with an empty label?
   - How can I have multiple widgets with the same label?
   - How can I have multiple windows with the same label?
 Q: How can I display an image? What is TextureID, how does it work?
 Q: How can I use my own math types instead of Vec2?
 Q: How can I interact with standard C++ types (such as std::string and
 std::vector)? Q: How can I display custom shapes? (using low-level DrawList
 API)
 >> See https://www.dearimgui.com/faq

 Q&A: Fonts, Text
 ================

 Q: How should I handle DPI in my application?
 Q: How can I load a different font than the default?
 Q: How can I easily use icons in my application?
 Q: How can I load multiple fonts?
 Q: How can I display and input non-Latin characters such as Chinese, Japanese,
 Korean, Cyrillic?
 >> See https://www.dearimgui.com/faq and
 https://github.com/ocornut/imgui/edit/master/docs/FONTS.md

 Q&A: Concerns
 =============

 Q: Who uses Dear Gui?
 Q: Can you create elaborate/serious tools with Dear Gui?
 Q: Can you reskin the look of Dear Gui?
 Q: Why using C++ (as opposed to C)?
 >> See https://www.dearimgui.com/faq

 Q&A: Community
 ==============

 Q: How can I help?
 A: - Businesses: please reach out to "omar AT dearimgui DOT com" if you work in
 a place using Dear Gui! We can discuss ways for your company to fund
 development via invoiced technical support, maintenance or sponsoring contacts.
      This is among the most useful thing you can do for Dear Gui. With
 increased funding, we sustain and grow work on this project. Also see
 https://github.com/ocornut/imgui/wiki/Sponsors
    - Businesses: you can also purchase licenses for the Dear Gui
 Automation/Test Engine.
    - If you are experienced with Dear Gui and C++, look at the GitHub issues,
 look at the Wiki, and see how you want to help and can help!
    - Disclose your usage of Dear Gui via a dev blog post, a tweet, a
 screenshot, a mention somewhere etc. You may post screenshot or links in the
 gallery threads. Visuals are ideal as they inspire other programmers. But even
 without visuals, disclosing your use of dear gui helps the library grow
 credibility, and help other teams and programmers with taking decisions.
    - If you have issues or if you need to hack into the library, even if you
 don't expect any support it is useful that you share your issues (on GitHub or
 privately).

*/

//-------------------------------------------------------------------------
// [SECTION] INCLUDES
//-------------------------------------------------------------------------

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef GUI_DEFINE_MATH_OPERATORS
#define GUI_DEFINE_MATH_OPERATORS
#endif

#ifndef GUI_DISABLE

// System includes

// [Windows] On non-Visual Studio compilers, we default to
// GUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS unless explicitly enabled
#if defined(_WIN32) && !defined(_MSC_VER) &&                                   \
    !defined(GUI_ENABLE_WIN32_DEFAULT_IME_FUNCTIONS) &&                        \
    !defined(GUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)
#define GUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
#endif

// [Windows] OS specific includes (optional)
#if defined(_WIN32) && defined(GUI_DISABLE_DEFAULT_FILE_FUNCTIONS) &&          \
    defined(GUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) &&                  \
    defined(GUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS) &&                        \
    !defined(GUI_DISABLE_WIN32_FUNCTIONS)
#define GUI_DISABLE_WIN32_FUNCTIONS
#endif
#if defined(_WIN32) && !defined(GUI_DISABLE_WIN32_FUNCTIONS)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef __MINGW32__
#include <Windows.h> // _wfopen, OpenClipboard
#else
#include <windows.h>
#endif
#if defined(WINAPI_FAMILY) &&                                                  \
    (WINAPI_FAMILY ==                                                          \
     WINAPI_FAMILY_APP) // UWP doesn't have all Win32 functions
#define GUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS
#define GUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
#endif
#endif

// [Apple] OS specific includes
#if defined(__APPLE__)
#include <TargetConditionals.h>
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning(disable : 4127) // condition expression is constant
#pragma warning(                                                               \
    disable : 4996) // 'This function or variable may be unsafe': strcpy,
                    // strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning(disable : 5054) // operator '|': deprecated between enumerations
                                // of different types
#endif
#pragma warning(                                                               \
    disable : 26451) // [Static Analyzer] Arithmetic overflow : Using operator
                     // 'xxx' on a 4 byte value and then casting the result to
                     // an 8 byte value. Cast the value to the wider type before
                     // calling operator 'xxx' to avoid overflow(io.2).
#pragma warning(                                                               \
    disable : 26495) // [Static Analyzer] Variable 'XXX' is uninitialized.
                     // Always initialize a member variable (type.6).
#pragma warning(                                                               \
    disable : 26812) // [Static Analyzer] The enum type 'xxx' is unscoped.
                     // Prefer 'enum class' over 'enum' (Enum.3).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored                                               \
    "-Wunknown-warning-option" // warning: unknown warning group 'xxx' // not
                               // all warnings are known by all Clang versions
                               // and they tend to be rename-happy.. so ignoring
                               // warnings triggers new warnings on some
                               // configuration. Great!
#endif
#pragma clang diagnostic ignored                                               \
    "-Wunknown-pragmas" // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored                                               \
    "-Wold-style-cast" // warning: use of old-style cast // yes, they are more
                       // terse.
#pragma clang diagnostic ignored                                               \
    "-Wfloat-equal" // warning: comparing floating point with == or != is unsafe
                    // // storing and comparing against same constants
                    // (typically 0.0f) is ok.
#pragma clang diagnostic ignored                                               \
    "-Wformat-nonliteral" // warning: format string is not a string literal //
                          // passing non-literal to vsnformat(). yes, user
                          // passing incorrect format strings can crash the
                          // code.
#pragma clang diagnostic ignored                                               \
    "-Wexit-time-destructors" // warning: declaration requires an exit-time
                              // destructor     // exit-time destruction order
                              // is undefined. if MemFree() leads to users code
                              // that has been disabled before exit it might
                              // cause problems. Gui coding style welcomes
                              // static/globals.
#pragma clang diagnostic ignored                                               \
    "-Wglobal-constructors" // warning: declaration requires a global destructor
                            // // similar to above, not sure what the exact
                            // difference is.
#pragma clang diagnostic ignored                                               \
    "-Wsign-conversion" // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored                                               \
    "-Wformat-pedantic" // warning: format specifies type 'void *' but the
                        // argument has type 'xxxx *' // unreasonable, would
                        // lead to casting every %p arg to void*. probably
                        // enabled by -pedantic.
#pragma clang diagnostic ignored                                               \
    "-Wint-to-void-pointer-cast" // warning: cast to 'void *' from smaller
                                 // integer type 'int'
#pragma clang diagnostic ignored                                               \
    "-Wzero-as-null-pointer-constant" // warning: zero as null pointer constant
                                      // // some standard header variations use
                                      // #define NULL 0
#pragma clang diagnostic ignored                                               \
    "-Wdouble-promotion" // warning: implicit conversion from 'float' to
                         // 'double' when passing argument to function  // using
                         // printf() is a misery with this as C++ va_arg
                         // ellipsis changes float to double.
#pragma clang diagnostic ignored                                               \
    "-Wimplicit-int-float-conversion" // warning: implicit conversion from 'xxx'
                                      // to 'float' may lose precision
#elif defined(__GNUC__)
// We disable -Wpragmas because GCC doesn't provide a has_warning equivalent and
// some forks/patches may not follow the warning/version association.
#pragma GCC diagnostic ignored                                                 \
    "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored                                                 \
    "-Wunused-function" // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored                                                 \
    "-Wint-to-pointer-cast" // warning: cast to pointer from integer of
                            // different size
#pragma GCC diagnostic ignored                                                 \
    "-Wformat" // warning: format '%p' expects argument of type 'void*', but
               // argument 6 has type 'Window*'
#pragma GCC diagnostic ignored                                                 \
    "-Wdouble-promotion" // warning: implicit conversion from 'float' to
                         // 'double' when passing argument to function
#pragma GCC diagnostic ignored                                                 \
    "-Wconversion" // warning: conversion to 'xxxx' from 'xxxx' may alter its
                   // value
#pragma GCC diagnostic ignored                                                 \
    "-Wformat-nonliteral" // warning: format not a string literal, format string
                          // not checked
#pragma GCC diagnostic ignored                                                 \
    "-Wstrict-overflow" // warning: assuming signed overflow does not occur when
                        // assuming that (X - c) > X is always false
#pragma GCC diagnostic ignored                                                 \
    "-Wclass-memaccess" // [__GNUC__ >= 8] warning: 'memset/memcpy'
                        // clearing/writing an object of type 'xxxx' with no
                        // trivial copy-assignment; use assignment or
                        // value-initialization instead
#endif

// Debug options
#define GUI_DEBUG_NAV_SCORING                                                  \
  0 // Display navigation scoring preview when hovering items. Display last
    // moving direction matches when holding CTRL
#define GUI_DEBUG_NAV_RECTS                                                    \
  0 // Display the reference navigation rectangle for each window

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in
// order to reduce visual noise doing a fast switch.
static const float NAV_WINDOWING_HIGHLIGHT_DELAY =
    0.20f; // Time before the highlight and screen dimming starts fading in
static const float NAV_WINDOWING_LIST_APPEAR_DELAY =
    0.15f; // Time before the window list starts to appear

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and
// BackendFlags_HasMouseCursors is set in io.BackendFlags by backend)
static const float WINDOWS_HOVER_PADDING =
    4.0f; // Extend outside window for hovering/resizing (maxxed with
          // TouchPadding) and inside windows for borders. Affect
          // FindHoveredWindow().
static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER =
    0.04f; // Reduce visual noise by only highlighting the border after a
           // certain time.
static const float WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER =
    0.70f; // Lock scrolled window (so it doesn't pick child windows that are
           // scrolling through) for a certain time, unless mouse moved.

// Tooltip offset
static const Vec2 TOOLTIP_DEFAULT_OFFSET =
    Vec2(16, 10); // Multiplied by g.Style.MouseCursorScale

//-------------------------------------------------------------------------
// [SECTION] FORWARD DECLARATIONS
//-------------------------------------------------------------------------

static void SetCurrentWindow(Window *window);
static void FindHoveredWindow();
static Window *CreateNewWindow(const char *name, WindowFlags flags);
static Vec2 CalcNextScrollFromScrollTargetAndClamp(Window *window);

static void AddWindowToSortBuffer(Vector<Window *> *out_sorted_windows,
                                  Window *window);

// Settings
static void WindowSettingsHandler_ClearAll(Context *, SettingsHandler *);
static void *WindowSettingsHandler_ReadOpen(Context *, SettingsHandler *,
                                            const char *name);
static void WindowSettingsHandler_ReadLine(Context *, SettingsHandler *,
                                           void *entry, const char *line);
static void WindowSettingsHandler_ApplyAll(Context *, SettingsHandler *);
static void WindowSettingsHandler_WriteAll(Context *, SettingsHandler *,
                                           TextBuffer *buf);

// Platform Dependents default implementation for IO functions
static const char *GetClipboardTextFn_DefaultImpl(void *user_data_ctx);
static void SetClipboardTextFn_DefaultImpl(void *user_data_ctx,
                                           const char *text);
static void SetPlatformImeDataFn_DefaultImpl(Viewport *viewport,
                                             PlatformImeData *data);

namespace Gui {
// Navigation
static void NavUpdate();
static void NavUpdateWindowing();
static void NavUpdateWindowingOverlay();
static void NavUpdateCancelRequest();
static void NavUpdateCreateMoveRequest();
static void NavUpdateCreateTabbingRequest();
static float NavUpdatePageUpPageDown();
static inline void NavUpdateAnyRequestFlag();
static void NavUpdateCreateWrappingRequest();
static void NavEndFrame();
static bool NavScoreItem(NavItemData *result);
static void NavApplyItemToResult(NavItemData *result);
static void NavProcessItem();
static void NavProcessItemForTabbingRequest(ID id, ItemFlags item_flags,
                                            NavMoveFlags move_flags);
static Vec2 NavCalcPreferredRefPos();
static void NavSaveLastChildNavWindowIntoParent(Window *nav_window);
static Window *NavRestoreLastChildNavWindow(Window *window);
static void NavRestoreLayer(NavLayer layer);
static int FindWindowFocusIndex(Window *window);

// Error Checking and Debug Tools
static void ErrorCheckNewFrameSanityChecks();
static void ErrorCheckEndFrameSanityChecks();
static void UpdateDebugToolItemPicker();
static void UpdateDebugToolStackQueries();
static void UpdateDebugToolFlashStyleColor();

// Inputs
static void UpdateKeyboardInputs();
static void UpdateMouseInputs();
static void UpdateMouseWheel();
static void UpdateKeyRoutingTable(KeyRoutingTable *rt);

// Misc
static void UpdateSettings();
static int UpdateWindowManualResize(Window *window, const Vec2 &size_auto_fit,
                                    int *border_hovered, int *border_held,
                                    int resize_grip_count,
                                    U32 resize_grip_col[4],
                                    const Rect &visibility_rect);
static void RenderWindowOuterBorders(Window *window);
static void RenderWindowDecorations(Window *window, const Rect &title_bar_rect,
                                    bool title_bar_is_highlight,
                                    bool handle_borders_and_resize_grips,
                                    int resize_grip_count,
                                    const U32 resize_grip_col[4],
                                    float resize_grip_draw_size);
static void RenderWindowTitleBarContents(Window *window,
                                         const Rect &title_bar_rect,
                                         const char *name, bool *p_open);
static void RenderDimmedBackgroundBehindWindow(Window *window, U32 col);
static void RenderDimmedBackgrounds();

// Viewports
static void UpdateViewportsNewFrame();

} // namespace Gui

//-----------------------------------------------------------------------------
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
//-----------------------------------------------------------------------------

// DLL users:
// - Heaps and globals are not shared across DLL boundaries!
// - You will need to call SetCurrentContext() + SetAllocatorFunctions() for
// each static/DLL boundary you are calling from.
// - Same applies for hot-reloading mechanisms that are reliant on reloading DLL
// (note that many hot-reloading mechanisms work without DLL).
// - Using Dear Gui via a shared library is not recommended, because of
// function call overhead and because we don't guarantee backward nor forward
// ABI compatibility.
// - Confused? In a debugger: add GGui to your watch window and notice how its
// value changes depending on your current location (which DLL boundary you are
// in).

// Current context pointer. Implicitly used by all Dear Gui functions. Always
// assumed to be != NULL.
// - Gui::CreateContext() will automatically set this pointer if it is NULL.
//   Change to a different context by calling Gui::SetCurrentContext().
// - Important: Dear Gui functions are not thread-safe because of this
// pointer.
//   If you want thread-safety to allow N threads to access N different
//   contexts:
//   - Change this variable to use thread local storage so each thread can refer
//   to a different context, in your config.hpp:
//         struct Context;
//         extern thread_local Context* TLS;
//         #define GGui TLS
//     And then define TLS in one of your cpp files. Note that
//     thread_local is a C++11 keyword, earlier C++ uses compiler-specific
//     keyword.
//   - Future development aims to make this context pointer explicit to all
//   calls. Also read https://github.com/ocornut/imgui/issues/586
//   - If you need a finite number of contexts, you may compile and use multiple
//   instances of the Gui code from a different namespace.
// - DLL users: read comments above.
#ifndef GGui
Context *GGui = NULL;
#endif

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// - You probably don't want to modify that mid-program, and if you use
// global/static e.g. Vector<> instances you may need to keep them accessible
// during program destruction.
// - DLL users: read comments above.
#ifndef GUI_DISABLE_DEFAULT_ALLOCATORS
static void *MallocWrapper(size_t size, void *user_data) {
  GUI_UNUSED(user_data);
  return malloc(size);
}
static void FreeWrapper(void *ptr, void *user_data) {
  GUI_UNUSED(user_data);
  free(ptr);
}
#else
static void *MallocWrapper(size_t size, void *user_data) {
  GUI_UNUSED(user_data);
  GUI_UNUSED(size);
  GUI_ASSERT(0);
  return NULL;
}
static void FreeWrapper(void *ptr, void *user_data) {
  GUI_UNUSED(user_data);
  GUI_UNUSED(ptr);
  GUI_ASSERT(0);
}
#endif
static MemAllocFunc GAllocatorAllocFunc = MallocWrapper;
static MemFreeFunc GAllocatorFreeFunc = FreeWrapper;
static void *GAllocatorUserData = NULL;

//-----------------------------------------------------------------------------
// [SECTION] USER FACING STRUCTURES (Style, IO)
//-----------------------------------------------------------------------------

inline Style::Style() {
  Alpha = 1.0f; // Global alpha applies to everything in Dear Gui.
  DisabledAlpha =
      0.60f; // Additional alpha multiplier applied by BeginDisabled(). Multiply
             // over current value of Alpha.
  WindowPadding = Vec2(8, 8); // Padding within a window
  WindowRounding = 0.0f; // Radius of window corners rounding. Set to 0.0f to
                         // have rectangular windows. Large values tend to lead
                         // to variety of artifacts and are not recommended.
  WindowBorderSize = 1.0f; // Thickness of border around windows. Generally set
                           // to 0.0f or 1.0f. Other values not well tested.
  WindowMinSize = Vec2(32, 32);        // Minimum window size
  WindowTitleAlign = Vec2(0.0f, 0.5f); // Alignment for title bar text
  WindowMenuButtonPosition =
      Dir_Left; // Position of the collapsing/docking button in the title
                // bar (left/right). Defaults to Dir_Left.
  ChildRounding = 0.0f; // Radius of child window corners rounding. Set to 0.0f
                        // to have rectangular child windows
  ChildBorderSize = 1.0f; // Thickness of border around child windows. Generally
                          // set to 0.0f or 1.0f. Other values not well tested.
  PopupRounding = 0.0f; // Radius of popup window corners rounding. Set to 0.0f
                        // to have rectangular child windows
  PopupBorderSize =
      1.0f; // Thickness of border around popup or tooltip windows. Generally
            // set to 0.0f or 1.0f. Other values not well tested.
  FramePadding =
      Vec2(4, 3); // Padding within a framed rectangle (used by most widgets)
  FrameRounding = 0.0f; // Radius of frame corners rounding. Set to 0.0f to have
                        // rectangular frames (used by most widgets).
  FrameBorderSize = 0.0f; // Thickness of border around frames. Generally set to
                          // 0.0f or 1.0f. Other values not well tested.
  ItemSpacing =
      Vec2(8, 4); // Horizontal and vertical spacing between widgets/lines
  ItemInnerSpacing =
      Vec2(4, 4); // Horizontal and vertical spacing between within elements
                  // of a composed widget (e.g. a slider and its label)
  CellPadding = Vec2(4, 2); // Padding within a table cell. CellPadding.y may
                            // be altered between different rows.
  TouchExtraPadding =
      Vec2(0, 0); // Expand reactive bounding box for touch-based system where
                  // touch position is not accurate enough. Unfortunately we
                  // don't sort widgets so priority on overlap will always be
                  // given to the first widget. So don't grow this too much!
  IndentSpacing = 21.0f; // Horizontal spacing when e.g. entering a tree node.
                         // Generally == (FontSize + FramePadding.x*2).
  ColumnsMinSpacing = 6.0f; // Minimum horizontal spacing between two columns.
                            // Preferably > (FramePadding.x + 1).
  ScrollbarSize = 14.0f;    // Width of the vertical scrollbar, Height of the
                            // horizontal scrollbar
  ScrollbarRounding = 9.0f; // Radius of grab corners rounding for scrollbar
  GrabMinSize =
      12.0f; // Minimum width/height of a grab box for slider/scrollbar
  GrabRounding = 0.0f; // Radius of grabs corners rounding. Set to 0.0f to have
                       // rectangular slider grabs.
  LogSliderDeadzone = 4.0f; // The size in pixels of the dead-zone around zero
                            // on logarithmic sliders that cross zero.
  TabRounding = 4.0f;   // Radius of upper corners of a tab. Set to 0.0f to have
                        // rectangular tabs.
  TabBorderSize = 0.0f; // Thickness of border around tabs.
  TabMinWidthForCloseButton =
      0.0f; // Minimum width for close button to appear on an unselected tab
            // when hovered. Set to 0.0f to always show when hovering, set to
            // FLT_MAX to never show close button unless selected.
  TabBarBorderSize = 1.0f; // Thickness of tab-bar separator, which takes on the
                           // tab active color to denote focus.
  TableAngledHeadersAngle =
      35.0f * (GUI_PI / 180.0f); // Angle of angled headers (supported values
                                 // range from -50 degrees to +50 degrees).
  ColorButtonPosition =
      Dir_Right; // Side of the color button in the ColorEdit4 widget
                 // (left/right). Defaults to Dir_Right.
  ButtonTextAlign = Vec2(
      0.5f, 0.5f); // Alignment of button text when button is larger than text.
  SelectableTextAlign = Vec2(
      0.0f,
      0.0f); // Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left
             // aligned). It's generally important to keep this left-aligned if
             // you want to lay multiple items on a same line.
  SeparatorTextBorderSize = 3.0f; // Thickkness of border in SeparatorText()
  SeparatorTextAlign =
      Vec2(0.0f, 0.5f); // Alignment of text within the separator. Defaults to
                        // (0.0f, 0.5f) (left aligned, center).
  SeparatorTextPadding =
      Vec2(20.0f, 3.f); // Horizontal offset of text from each edge of the
                        // separator + spacing on other axis. Generally small
                        // values. .y is recommended to be == FramePadding.y.
  DisplayWindowPadding =
      Vec2(19, 19); // Window position are clamped to be visible within the
                    // display area or monitors by at least this amount. Only
                    // applies to regular windows.
  DisplaySafeAreaPadding =
      Vec2(3, 3); // If you cannot see the edge of your screen (e.g. on a TV)
                  // increase the safe area padding. Covers popups/tooltips as
                  // well regular windows.
  MouseCursorScale =
      1.0f; // Scale software rendered mouse cursor (when io.MouseDrawCursor is
            // enabled). May be removed later.
  AntiAliasedLines = true; // Enable anti-aliased lines/borders. Disable if you
                           // are really tight on CPU/GPU.
  AntiAliasedLinesUseTex =
      true; // Enable anti-aliased lines/borders using textures where possible.
            // Require backend to render with bilinear filtering (NOT
            // point/nearest filtering).
  AntiAliasedFill = true; // Enable anti-aliased filled shapes (rounded
                          // rectangles, circles, etc.).
  CurveTessellationTol =
      1.25f; // Tessellation tolerance when using PathBezierCurveTo() without a
             // specific number of segments. Decrease for highly tessellated
             // curves (higher quality, more polygons), increase to reduce
             // quality.
  CircleTessellationMaxError =
      0.30f; // Maximum error (in pixels) allowed when using
             // AddCircle()/AddCircleFilled() or drawing rounded corner
             // rectangles with no explicit segment count specified. Decrease
             // for higher quality but more geometry.

  // Behaviors
  HoverStationaryDelay =
      0.15f; // Delay for IsItemHovered(HoveredFlags_Stationary). Time
             // required to consider mouse stationary.
  HoverDelayShort = 0.15f; // Delay for IsItemHovered(HoveredFlags_DelayShort).
                           // Usually used along with HoverStationaryDelay.
  HoverDelayNormal =
      0.40f; // Delay for IsItemHovered(HoveredFlags_DelayNormal). "
  HoverFlagsForTooltipMouse =
      HoveredFlags_Stationary | HoveredFlags_DelayShort |
      HoveredFlags_AllowWhenDisabled; // Default flags when using
                                      // IsItemHovered(HoveredFlags_ForTooltip)
                                      // or
                                      // BeginItemTooltip()/SetItemTooltip()
                                      // while using mouse.
  HoverFlagsForTooltipNav =
      HoveredFlags_NoSharedDelay | HoveredFlags_DelayNormal |
      HoveredFlags_AllowWhenDisabled; // Default flags when using
                                      // IsItemHovered(HoveredFlags_ForTooltip)
                                      // or
                                      // BeginItemTooltip()/SetItemTooltip()
                                      // while using keyboard/gamepad.

  // Default theme
  Gui::StyleColorsDark(this);
}

// To scale your entire UI (e.g. if you want your app to use High DPI or
// generally be DPI aware) you may use this helper function. Scaling the fonts
// is done separately and is up to you. Important: This operation is lossy
// because we round all sizes to integer. If you need to change your scale
// multiples, call this over a freshly initialized Style structure rather
// than scaling multiple times.
inline void Style::ScaleAllSizes(float scale_factor) {
  WindowPadding.x = Trunc(WindowPadding.x * scale_factor);
  WindowPadding.y = Trunc(WindowPadding.y * scale_factor);
  WindowRounding = Trunc(WindowRounding * scale_factor);
  WindowMinSize.x = Trunc(WindowMinSize.x * scale_factor);
  WindowMinSize.y = Trunc(WindowMinSize.y * scale_factor);
  ChildRounding = Trunc(ChildRounding * scale_factor);
  PopupRounding = Trunc(PopupRounding * scale_factor);
  FramePadding.x = Trunc(FramePadding.x * scale_factor);
  FramePadding.y = Trunc(FramePadding.y * scale_factor);
  FrameRounding = Trunc(FrameRounding * scale_factor);
  ItemSpacing.x = Trunc(ItemSpacing.x * scale_factor);
  ItemSpacing.y = Trunc(ItemSpacing.y * scale_factor);
  ItemInnerSpacing.x = Trunc(ItemInnerSpacing.x * scale_factor);
  ItemInnerSpacing.y = Trunc(ItemInnerSpacing.y * scale_factor);
  CellPadding.x = Trunc(CellPadding.x * scale_factor);
  CellPadding.y = Trunc(CellPadding.y * scale_factor);
  TouchExtraPadding.x = Trunc(TouchExtraPadding.x * scale_factor);
  TouchExtraPadding.y = Trunc(TouchExtraPadding.y * scale_factor);
  IndentSpacing = Trunc(IndentSpacing * scale_factor);
  ColumnsMinSpacing = Trunc(ColumnsMinSpacing * scale_factor);
  ScrollbarSize = Trunc(ScrollbarSize * scale_factor);
  ScrollbarRounding = Trunc(ScrollbarRounding * scale_factor);
  GrabMinSize = Trunc(GrabMinSize * scale_factor);
  GrabRounding = Trunc(GrabRounding * scale_factor);
  LogSliderDeadzone = Trunc(LogSliderDeadzone * scale_factor);
  TabRounding = Trunc(TabRounding * scale_factor);
  TabMinWidthForCloseButton =
      (TabMinWidthForCloseButton != FLT_MAX)
          ? Trunc(TabMinWidthForCloseButton * scale_factor)
          : FLT_MAX;
  SeparatorTextPadding.x = Trunc(SeparatorTextPadding.x * scale_factor);
  SeparatorTextPadding.y = Trunc(SeparatorTextPadding.y * scale_factor);
  DisplayWindowPadding.x = Trunc(DisplayWindowPadding.x * scale_factor);
  DisplayWindowPadding.y = Trunc(DisplayWindowPadding.y * scale_factor);
  DisplaySafeAreaPadding.x = Trunc(DisplaySafeAreaPadding.x * scale_factor);
  DisplaySafeAreaPadding.y = Trunc(DisplaySafeAreaPadding.y * scale_factor);
  MouseCursorScale = Trunc(MouseCursorScale * scale_factor);
}

inline IO::IO() {
  // Most fields are initialized with zero
  memset(this, 0, sizeof(*this));
  GUI_STATIC_ASSERT(GUI_ARRAYSIZE(IO::MouseDown) == MouseButton_COUNT &&
                    GUI_ARRAYSIZE(IO::MouseClicked) == MouseButton_COUNT);

  // Settings
  ConfigFlags = ConfigFlags_None;
  BackendFlags = BackendFlags_None;
  DisplaySize = Vec2(-1.0f, -1.0f);
  DeltaTime = 1.0f / 60.0f;
  IniSavingRate = 5.0f;
  IniFilename = "gui.ini"; // Important: "gui.ini" is relative to current
                           // working dir, most apps will want to lock this to
                           // an absolute path (e.g. same path as executables).
  LogFilename = "gui_log.txt";
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  for (int i = 0; i < Key_COUNT; i++)
    KeyMap[i] = -1;
#endif
  UserData = NULL;

  Fonts = NULL;
  FontGlobalScale = 1.0f;
  FontDefault = NULL;
  FontAllowUserScaling = false;
  DisplayFramebufferScale = Vec2(1.0f, 1.0f);

  MouseDoubleClickTime = 0.30f;
  MouseDoubleClickMaxDist = 6.0f;
  MouseDragThreshold = 6.0f;
  KeyRepeatDelay = 0.275f;
  KeyRepeatRate = 0.050f;

  // Miscellaneous options
  MouseDrawCursor = false;
#ifdef __APPLE__
  ConfigMacOSXBehaviors =
      true; // Set Mac OS X style defaults based on __APPLE__ compile time flag
#else
  ConfigMacOSXBehaviors = false;
#endif
  ConfigInputTrickleEventQueue = true;
  ConfigInputTextCursorBlink = true;
  ConfigInputTextEnterKeepActive = false;
  ConfigDragClickToInputText = false;
  ConfigWindowsResizeFromEdges = true;
  ConfigWindowsMoveFromTitleBarOnly = false;
  ConfigMemoryCompactTimer = 60.0f;
  ConfigDebugBeginReturnValueOnce = false;
  ConfigDebugBeginReturnValueLoop = false;

  // Platform Functions
  // Note: Initialize() will setup default clipboard/ime handlers.
  BackendPlatformName = BackendRendererName = NULL;
  BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData =
      NULL;
  PlatformLocaleDecimalPoint = '.';

  // Input (NB: we already have memset zero the entire structure!)
  MousePos = Vec2(-FLT_MAX, -FLT_MAX);
  MousePosPrev = Vec2(-FLT_MAX, -FLT_MAX);
  MouseSource = MouseSource_Mouse;
  for (int i = 0; i < GUI_ARRAYSIZE(MouseDownDuration); i++)
    MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
  for (int i = 0; i < GUI_ARRAYSIZE(KeysData); i++) {
    KeysData[i].DownDuration = KeysData[i].DownDurationPrev = -1.0f;
  }
  AppAcceptingEvents = true;
  BackendUsingLegacyKeyArrays = (S8)-1;
  BackendUsingLegacyNavInputArray =
      true; // assume using legacy array until proven wrong
}

// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the
// WM_CHAR message
// FIXME: Should in theory be called "AddCharacterEvent()" to be consistent with
// new API
inline void IO::AddInputCharacter(unsigned int c) {
  GUI_ASSERT(Ctx != NULL);
  Context &g = *Ctx;
  if (c == 0 || !AppAcceptingEvents)
    return;

  InputEvent e;
  e.Type = InputEventType_Text;
  e.Source = InputSource_Keyboard;
  e.EventId = g.InputEventsNextEventId++;
  e.Text.Char = c;
  g.InputEventsQueue.push_back(e);
}

// UTF16 strings use surrogate pairs to encode codepoints >= 0x10000, so
// we should save the high surrogate.
inline void IO::AddInputCharacterUTF16(Wchar16 c) {
  if ((c == 0 && InputQueueSurrogate == 0) || !AppAcceptingEvents)
    return;

  if ((c & 0xFC00) == 0xD800) // High surrogate, must save
  {
    if (InputQueueSurrogate != 0)
      AddInputCharacter(GUI_UNICODE_CODEPOINT_INVALID);
    InputQueueSurrogate = c;
    return;
  }

  Wchar cp = c;
  if (InputQueueSurrogate != 0) {
    if ((c & 0xFC00) != 0xDC00) // Invalid low surrogate
    {
      AddInputCharacter(GUI_UNICODE_CODEPOINT_INVALID);
    } else {
#if GUI_UNICODE_CODEPOINT_MAX == 0xFFFF
      cp = GUI_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in Wchar
#else
      cp = (Wchar)(((InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) +
                   0x10000);
#endif
    }

    InputQueueSurrogate = 0;
  }
  AddInputCharacter((unsigned)cp);
}

inline void IO::AddInputCharactersUTF8(const char *utf8_chars) {
  if (!AppAcceptingEvents)
    return;
  while (*utf8_chars != 0) {
    unsigned int c = 0;
    utf8_chars += TextCharFromUtf8(&c, utf8_chars, NULL);
    AddInputCharacter(c);
  }
}

// Clear all incoming events.
inline void IO::ClearEventsQueue() {
  GUI_ASSERT(Ctx != NULL);
  Context &g = *Ctx;
  g.InputEventsQueue.clear();
}

// Clear current keyboard/mouse/gamepad state + current frame text input buffer.
// Equivalent to releasing all keys/buttons.
inline void IO::ClearInputKeys() {
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  memset(KeysDown, 0, sizeof(KeysDown));
#endif
  for (int n = 0; n < GUI_ARRAYSIZE(KeysData); n++) {
    KeysData[n].Down = false;
    KeysData[n].DownDuration = -1.0f;
    KeysData[n].DownDurationPrev = -1.0f;
  }
  KeyCtrl = KeyShift = KeyAlt = KeySuper = false;
  KeyMods = Mod_None;
  MousePos = Vec2(-FLT_MAX, -FLT_MAX);
  for (int n = 0; n < GUI_ARRAYSIZE(MouseDown); n++) {
    MouseDown[n] = false;
    MouseDownDuration[n] = MouseDownDurationPrev[n] = -1.0f;
  }
  MouseWheel = MouseWheelH = 0.0f;
  InputQueueCharacters.resize(0); // Behavior of old ClearInputCharacters().
}

// Removed this as it is ambiguous/misleading and generally incorrect to use
// with the existence of a higher-level input queue. Current frame character
// buffer is now also cleared by ClearInputKeys().
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS

#endif

static InputEvent *FindLatestInputEvent(Context *ctx, InputEventType type,
                                        int arg = -1) {
  Context &g = *ctx;
  for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--) {
    InputEvent *e = &g.InputEventsQueue[n];
    if (e->Type != type)
      continue;
    if (type == InputEventType_Key && e->Key.Key != arg)
      continue;
    if (type == InputEventType_MouseButton && e->MouseButton.Button != arg)
      continue;
    return e;
  }
  return NULL;
}

// Queue a new key down/up event.
// - Key key:       Translated key (as in, generally Key_A matches the
// key end-user would use to emit an 'A' character)
// - bool down:          Is the key down? use false to signify a key release.
// - float analog_value: 0.0f..1.0f
// IMPORTANT: THIS FUNCTION AND OTHER "ADD" GRABS THE CONTEXT FROM OUR INSTANCE.
// WE NEED TO ENSURE THAT ALL FUNCTION CALLS ARE FULLFILLING THIS, WHICH IS WHY
// GetKeyData() HAS AN EXPLICIT CONTEXT.
inline void IO::AddKeyAnalogEvent(Key key, bool down, float analog_value) {
  // if (e->Down) { GUI_DEBUG_LOG_IO("AddKeyEvent() Key='%s' %d, NativeKeycode
  // = %d, NativeScancode = %d\n", Gui::GetKeyName(e->Key), e->Down,
  // e->NativeKeycode, e->NativeScancode); }
  GUI_ASSERT(Ctx != NULL);
  if (key == Key_None || !AppAcceptingEvents)
    return;
  Context &g = *Ctx;
  GUI_ASSERT(Gui::IsNamedKeyOrModKey(
      key)); // Backend needs to pass a valid Key_ constant. 0..511 values
             // are legacy native key codes which are not accepted by this API.
  GUI_ASSERT(Gui::IsAliasKey(key) ==
             false); // Backend cannot submit Key_MouseXXX values they are
                     // automatically inferred from AddMouseXXX() events.
  GUI_ASSERT(key != Mod_Shortcut); // We could easily support the translation
                                   // here but it seems saner to not accept it
                                   // (TestEngine perform a translation itself)

  // Verify that backend isn't mixing up using new io.AddKeyEvent() api and old
  // io.KeysDown[] + io.KeyMap[] data.
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  GUI_ASSERT(
      (BackendUsingLegacyKeyArrays == -1 || BackendUsingLegacyKeyArrays == 0) &&
      "Backend needs to either only use io.AddKeyEvent(), either only fill "
      "legacy io.KeysDown[] + io.KeyMap[]. Not both!");
  if (BackendUsingLegacyKeyArrays == -1)
    for (int n = Key_NamedKey_BEGIN; n < Key_NamedKey_END; n++)
      GUI_ASSERT(KeyMap[n] == -1 &&
                 "Backend needs to either only use io.AddKeyEvent(), either "
                 "only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
  BackendUsingLegacyKeyArrays = 0;
#endif
  if (Gui::IsGamepadKey(key))
    BackendUsingLegacyNavInputArray = false;

  // Filter duplicate (in particular: key mods and gamepad analog values are
  // commonly spammed)
  const InputEvent *latest_event =
      FindLatestInputEvent(&g, InputEventType_Key, (int)key);
  const KeyData *key_data = Gui::GetKeyData(&g, key);
  const bool latest_key_down =
      latest_event ? latest_event->Key.Down : key_data->Down;
  const float latest_key_analog =
      latest_event ? latest_event->Key.AnalogValue : key_data->AnalogValue;
  if (latest_key_down == down && latest_key_analog == analog_value)
    return;

  // Add event
  InputEvent e;
  e.Type = InputEventType_Key;
  e.Source =
      Gui::IsGamepadKey(key) ? InputSource_Gamepad : InputSource_Keyboard;
  e.EventId = g.InputEventsNextEventId++;
  e.Key.Key = key;
  e.Key.Down = down;
  e.Key.AnalogValue = analog_value;
  g.InputEventsQueue.push_back(e);
}

// [Optional] Call after AddKeyEvent().
// Specify native keycode, scancode + Specify index for legacy <1.87 IsKeyXXX()
// functions with native indices. If you are writing a backend in 2022 or don't
// use IsKeyXXX() with native values that are not Key values, you can avoid
// calling this.
inline void IO::SetKeyEventNativeData(Key key, int native_keycode,
                                      int native_scancode,
                                      int native_legacy_index) {
  if (key == Key_None)
    return;
  GUI_ASSERT(Gui::IsNamedKey(key)); // >= 512
  GUI_ASSERT(native_legacy_index == -1 ||
             Gui::IsLegacyKey((Key)native_legacy_index)); // >= 0 && <= 511
  GUI_UNUSED(native_keycode);                             // Yet unused
  GUI_UNUSED(native_scancode);                            // Yet unused

  // Build native->imgui map so old user code can still call key functions with
  // native 0..511 values.
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  const int legacy_key =
      (native_legacy_index != -1) ? native_legacy_index : native_keycode;
  if (!Gui::IsLegacyKey((Key)legacy_key))
    return;
  KeyMap[legacy_key] = key;
  KeyMap[key] = legacy_key;
#else
  GUI_UNUSED(key);
  GUI_UNUSED(native_legacy_index);
#endif
}

// Set master flag for accepting key/mouse/text events (default to true). Useful
// if you have native dialog boxes that are interrupting your application
// loop/refresh, and you want to disable events being queued while your app is
// frozen.

// Queue a mouse move event
inline void IO::AddMousePosEvent(float x, float y) {
  GUI_ASSERT(Ctx != NULL);
  Context &g = *Ctx;
  if (!AppAcceptingEvents)
    return;

  // Apply same flooring as UpdateMouseInputs()
  Vec2 pos((x > -FLT_MAX) ? Floor(x) : x, (y > -FLT_MAX) ? Floor(y) : y);

  // Filter duplicate
  const InputEvent *latest_event =
      FindLatestInputEvent(&g, InputEventType_MousePos);
  const Vec2 latest_pos = latest_event ? Vec2(latest_event->MousePos.PosX,
                                              latest_event->MousePos.PosY)
                                       : g.IO.MousePos;
  if (latest_pos.x == pos.x && latest_pos.y == pos.y)
    return;

  InputEvent e;
  e.Type = InputEventType_MousePos;
  e.Source = InputSource_Mouse;
  e.EventId = g.InputEventsNextEventId++;
  e.MousePos.PosX = pos.x;
  e.MousePos.PosY = pos.y;
  e.MousePos.MouseSource = g.InputEventsNextMouseSource;
  g.InputEventsQueue.push_back(e);
}

inline void IO::AddMouseButtonEvent(int mouse_button, bool down) {
  GUI_ASSERT(Ctx != NULL);
  Context &g = *Ctx;
  GUI_ASSERT(mouse_button >= 0 && mouse_button < MouseButton_COUNT);
  if (!AppAcceptingEvents)
    return;

  // Filter duplicate
  const InputEvent *latest_event =
      FindLatestInputEvent(&g, InputEventType_MouseButton, (int)mouse_button);
  const bool latest_button_down = latest_event ? latest_event->MouseButton.Down
                                               : g.IO.MouseDown[mouse_button];
  if (latest_button_down == down)
    return;

  InputEvent e;
  e.Type = InputEventType_MouseButton;
  e.Source = InputSource_Mouse;
  e.EventId = g.InputEventsNextEventId++;
  e.MouseButton.Button = mouse_button;
  e.MouseButton.Down = down;
  e.MouseButton.MouseSource = g.InputEventsNextMouseSource;
  g.InputEventsQueue.push_back(e);
}

// Queue a mouse wheel event (some mouse/API may only have a Y component)
inline void IO::AddMouseWheelEvent(float wheel_x, float wheel_y) {
  GUI_ASSERT(Ctx != NULL);
  Context &g = *Ctx;

  // Filter duplicate (unlike most events, wheel values are relative and easy to
  // filter)
  if (!AppAcceptingEvents || (wheel_x == 0.0f && wheel_y == 0.0f))
    return;

  InputEvent e;
  e.Type = InputEventType_MouseWheel;
  e.Source = InputSource_Mouse;
  e.EventId = g.InputEventsNextEventId++;
  e.MouseWheel.WheelX = wheel_x;
  e.MouseWheel.WheelY = wheel_y;
  e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;
  g.InputEventsQueue.push_back(e);
}

// This is not a real event, the data is latched in order to be stored in actual
// Mouse events. This is so that duplicate events (e.g. Windows sending
// extraneous WM_MOUSEMOVE) gets filtered and are not leading to actual source
// changes.
inline void IO::AddMouseSourceEvent(::MouseSource source) {
  GUI_ASSERT(Ctx != NULL);
  Context &g = *Ctx;
  g.InputEventsNextMouseSource = source;
}

inline void IO::AddFocusEvent(bool focused) {
  GUI_ASSERT(Ctx != NULL);
  Context &g = *Ctx;

  // Filter duplicate
  const InputEvent *latest_event =
      FindLatestInputEvent(&g, InputEventType_Focus);
  const bool latest_focused =
      latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;
  if (latest_focused == focused || (ConfigDebugIgnoreFocusLoss && !focused))
    return;

  InputEvent e;
  e.Type = InputEventType_Focus;
  e.EventId = g.InputEventsNextEventId++;
  e.AppFocused.Focused = focused;
  g.InputEventsQueue.push_back(e);
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
//-----------------------------------------------------------------------------
inline Vec2 Subtract(const Vec2 &a, const Vec2 &b) {
  return Vec2(a.x - b.x, a.y - b.y);
}
inline Vec2 Subtract(const Vec2 &a, float b) { return Vec2(a.x - b, a.y - b); }
inline Vec2 Add(const Vec2 &a, const Vec2 &b) {
  return Vec2(a.x + b.x, a.y + b.y);
}
inline Vec2 Add(const Vec2 &a, float b) { return Vec2(a.x + b, a.y + b); }
inline Vec2 Multiply(const Vec2 &a, const Vec2 &b) {
  return Vec2(a.x * b.x, a.y * b.y);
}
inline Vec2 Multiply(const Vec2 &a, float b) { return Vec2(a.x * b, a.y * b); }
inline Vec2 Divide(const Vec2 &a, const Vec2 &b) {
  return Vec2(a.x / b.x, a.y / b.y);
}
inline Vec2 Divide(const Vec2 &a, float b) { return Vec2(a.x / b, a.y / b); }
inline Vec2 BezierCubicClosestPoint(const Vec2 &p1, const Vec2 &p2,
                                    const Vec2 &p3, const Vec2 &p4,
                                    const Vec2 &p, int num_segments) {
  GUI_ASSERT(num_segments > 0); // Use BezierCubicClosestPointCasteljau()
  Vec2 p_last = p1;
  Vec2 p_closest;
  float p_closest_dist2 = FLT_MAX;
  float t_step = 1.0f / (float)num_segments;
  for (int i_step = 1; i_step <= num_segments; i_step++) {
    Vec2 p_current = BezierCubicCalc(p1, p2, p3, p4, t_step * i_step);
    Vec2 p_line = LineClosestPoint(p_last, p_current, p);
    float dist2 = LengthSqr(Subtract(p, p_line));
    if (dist2 < p_closest_dist2) {
      p_closest = p_line;
      p_closest_dist2 = dist2;
    }
    p_last = p_current;
  }
  return p_closest;
}

// Closely mimics PathBezierToCasteljau() in gui_draw.hpp
static void BezierCubicClosestPointCasteljauStep(
    const Vec2 &p, Vec2 &p_closest, Vec2 &p_last, float &p_closest_dist2,
    float x1, float y1, float x2, float y2, float x3, float y3, float x4,
    float y4, float tess_tol, int level) {
  float dx = x4 - x1;
  float dy = y4 - y1;
  float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);
  float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);
  d2 = (d2 >= 0) ? d2 : -d2;
  d3 = (d3 >= 0) ? d3 : -d3;
  if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy)) {
    Vec2 p_current(x4, y4);
    Vec2 p_line = LineClosestPoint(p_last, p_current, p);
    float dist2 = LengthSqr(Subtract(p, p_line));
    if (dist2 < p_closest_dist2) {
      p_closest = p_line;
      p_closest_dist2 = dist2;
    }
    p_last = p_current;
  } else if (level < 10) {
    float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;
    float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;
    float x34 = (x3 + x4) * 0.5f, y34 = (y3 + y4) * 0.5f;
    float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
    float x234 = (x23 + x34) * 0.5f, y234 = (y23 + y34) * 0.5f;
    float x1234 = (x123 + x234) * 0.5f, y1234 = (y123 + y234) * 0.5f;
    BezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2,
                                         x1, y1, x12, y12, x123, y123, x1234,
                                         y1234, tess_tol, level + 1);
    BezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2,
                                         x1234, y1234, x234, y234, x34, y34, x4,
                                         y4, tess_tol, level + 1);
  }
}

// tess_tol is generally the same value you would find in
// Gui::GetStyle().CurveTessellationTol Because those XXX functions are
// lower-level than Gui:: we cannot access this value automatically.
inline Vec2 BezierCubicClosestPointCasteljau(const Vec2 &p1, const Vec2 &p2,
                                             const Vec2 &p3, const Vec2 &p4,
                                             const Vec2 &p, float tess_tol) {
  GUI_ASSERT(tess_tol > 0.0f);
  Vec2 p_last = p1;
  Vec2 p_closest;
  float p_closest_dist2 = FLT_MAX;
  BezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2,
                                       p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x,
                                       p4.y, tess_tol, 0);
  return p_closest;
}

inline Vec2 LineClosestPoint(const Vec2 &a, const Vec2 &b, const Vec2 &p) {
  Vec2 ap = Subtract(p, a);
  Vec2 ab_dir = Subtract(b, a);
  float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
  if (dot < 0.0f)
    return a;
  float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
  if (dot > ab_len_sqr)
    return b;
  return Add(a, Divide(Multiply(ab_dir, dot), ab_len_sqr));
}

inline void TriangleBarycentricCoords(const Vec2 &a, const Vec2 &b,
                                      const Vec2 &c, const Vec2 &p,
                                      float &out_u, float &out_v,
                                      float &out_w) {
  Vec2 v0 = Subtract(b, a);
  Vec2 v1 = Subtract(c, a);
  Vec2 v2 = Subtract(p, a);
  const float denom = v0.x * v1.y - v1.x * v0.y;
  out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
  out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
  out_u = 1.0f - out_v - out_w;
}

inline Vec2 TriangleClosestPoint(const Vec2 &a, const Vec2 &b, const Vec2 &c,
                                 const Vec2 &p) {
  Vec2 proj_ab = LineClosestPoint(a, b, p);
  Vec2 proj_bc = LineClosestPoint(b, c, p);
  Vec2 proj_ca = LineClosestPoint(c, a, p);
  float dist2_ab = LengthSqr(Subtract(p, proj_ab));
  float dist2_bc = LengthSqr(Subtract(p, proj_bc));
  float dist2_ca = LengthSqr(Subtract(p, proj_ca));
  float m = Min(dist2_ab, Min(dist2_bc, dist2_ca));
  if (m == dist2_ab)
    return proj_ab;
  if (m == dist2_bc)
    return proj_bc;
  return proj_ca;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
//-----------------------------------------------------------------------------

// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We
// don't actually use eitherStricmp/Strnicmp in the codebase any more.
inline int Stricmp(const char *str1, const char *str2) {
  int d;
  while ((d = ToUpper(*str2) - ToUpper(*str1)) == 0 && *str1) {
    str1++;
    str2++;
  }
  return d;
}

inline int Strnicmp(const char *str1, const char *str2, size_t count) {
  int d = 0;
  while (count > 0 && (d = ToUpper(*str2) - ToUpper(*str1)) == 0 && *str1) {
    str1++;
    str2++;
    count--;
  }
  return d;
}

inline void Strncpy(char *dst, const char *src, size_t count) {
  if (count < 1)
    return;
  if (count > 1)
    strncpy(dst, src, count - 1);
  dst[count - 1] = 0;
}

inline char *Strdup(const char *str) {
  size_t len = strlen(str);
  void *buf = GUI_ALLOC(len + 1);
  return (char *)memcpy(buf, (const void *)str, len + 1);
}

inline char *Strdupcpy(char *dst, size_t *p_dst_size, const char *src) {
  size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;
  size_t src_size = strlen(src) + 1;
  if (dst_buf_size < src_size) {
    GUI_FREE(dst);
    dst = (char *)GUI_ALLOC(src_size);
    if (p_dst_size)
      *p_dst_size = src_size;
  }
  return (char *)memcpy(dst, (const void *)src, src_size);
}

inline const char *StrchrRange(const char *str, const char *str_end, char c) {
  const char *p = (const char *)memchr(str, (int)c, str_end - str);
  return p;
}

// Find end-of-line. Return pointer will point to either first \n, either
// str_end.
inline const char *StreolRange(const char *str, const char *str_end) {
  const char *p = (const char *)memchr(str, '\n', str_end - str);
  return p ? p : str_end;
}

inline const char *Stristr(const char *haystack, const char *haystack_end,
                           const char *needle, const char *needle_end) {
  if (!needle_end)
    needle_end = needle + strlen(needle);

  const char un0 = (char)ToUpper(*needle);
  while ((!haystack_end && *haystack) ||
         (haystack_end && haystack < haystack_end)) {
    if (ToUpper(*haystack) == un0) {
      const char *b = needle + 1;
      for (const char *a = haystack + 1; b < needle_end; a++, b++)
        if (ToUpper(*a) != ToUpper(*b))
          break;
      if (b == needle_end)
        return haystack;
    }
    haystack++;
  }
  return NULL;
}

// Trim str by offsetting contents when there's leading data + writing a \0 at
// the trailing position. We use this in situation where the cost is negligible.
inline void StrTrimBlanks(char *buf) {
  char *p = buf;
  while (p[0] == ' ' || p[0] == '\t') // Leading blanks
    p++;
  char *p_start = p;
  while (*p != 0) // Find end of string
    p++;
  while (p > p_start && (p[-1] == ' ' || p[-1] == '\t')) // Trailing blanks
    p--;
  if (p_start != buf) // Copy memory if we had leading blanks
    memmove(buf, p_start, p - p_start);
  buf[p - p_start] = 0; // Zero terminate
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to
// return total count (which may be >= buf_size). Ideally we would test for only
// one of those limits at runtime depending on the behavior the vsnprintf(), but
// trying to deduct it at compile time sounds like a pandora can of worm. B)
// When buf==NULL vsnprintf() will return the output size.
#ifndef GUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS

// We support stb_sprintf which is much faster (see:
// https://github.com/nothings/stb/blob/master/stb_sprintf.h) You may set
// GUI_USE_STB_SPRINTF to use our default wrapper, or set
// GUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS and setup the wrapper yourself.
// (FIXME-OPT: Some of our high-level operations such as
// TextBuffer::appendfv() are designed using two-passes worst case, which
// probably could be improved using the stbsp_vsprintfcb() function.)
#ifdef GUI_USE_STB_SPRINTF
#ifndef GUI_DISABLE_STB_SPRINTF_IMPLEMENTATION
#define STB_SPRINTF_IMPLEMENTATION
#endif
#ifdef GUI_STB_SPRINTF_FILENAME
#include GUI_STB_SPRINTF_FILENAME
#else
#include "stb_sprintf.h"
#endif
#endif // #ifdef GUI_USE_STB_SPRINTF

#if defined(_MSC_VER) && !defined(vsnprintf)
#define vsnprintf _vsnprintf
#endif

inline int FormatString(char *buf, size_t buf_size, const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
#ifdef GUI_USE_STB_SPRINTF
  int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
  int w = vsnprintf(buf, buf_size, fmt, args);
#endif
  va_end(args);
  if (buf == NULL)
    return w;
  if (w == -1 || w >= (int)buf_size)
    w = (int)buf_size - 1;
  buf[w] = 0;
  return w;
}

inline int FormatStringV(char *buf, size_t buf_size, const char *fmt,
                         va_list args) {
#ifdef GUI_USE_STB_SPRINTF
  int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
  int w = vsnprintf(buf, buf_size, fmt, args);
#endif
  if (buf == NULL)
    return w;
  if (w == -1 || w >= (int)buf_size)
    w = (int)buf_size - 1;
  buf[w] = 0;
  return w;
}
#endif // #ifdef GUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS

inline void FormatStringToTempBuffer(const char **out_buf,
                                     const char **out_buf_end, const char *fmt,
                                     ...) {
  va_list args;
  va_start(args, fmt);
  FormatStringToTempBufferV(out_buf, out_buf_end, fmt, args);
  va_end(args);
}

inline void FormatStringToTempBufferV(const char **out_buf,
                                      const char **out_buf_end, const char *fmt,
                                      va_list args) {
  Context &g = *GGui;
  if (fmt[0] == '%' && fmt[1] == 's' && fmt[2] == 0) {
    const char *buf =
        va_arg(args, const char *); // Skip formatting when using "%s"
    if (buf == NULL)
      buf = "(null)";
    *out_buf = buf;
    if (out_buf_end) {
      *out_buf_end = buf + strlen(buf);
    }
  } else if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '*' && fmt[3] == 's' &&
             fmt[4] == 0) {
    int buf_len = va_arg(args, int); // Skip formatting when using "%.*s"
    const char *buf = va_arg(args, const char *);
    if (buf == NULL) {
      buf = "(null)";
      buf_len = Min(buf_len, 6);
    }
    *out_buf = buf;
    *out_buf_end = buf + buf_len; // Disallow not passing 'out_buf_end' here.
                                  // User is expected to use it.
  } else {
    int buf_len =
        FormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args);
    *out_buf = g.TempBuffer.Data;
    if (out_buf_end) {
      *out_buf_end = g.TempBuffer.Data + buf_len;
    }
  }
}

// CRC32 needs a 1KB lookup table (not cache friendly)
// Although the code to generate the table is simple and shorter than the table
// itself, using a const table allows us to easily:
// - avoid an unnecessary branch/memory tap, - keep the HashXXX functions
// usable by static constructors, - make it thread-safe.
static const U32 GCrc32LookupTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
};

// Known size hash
// It is ok to call HashData on a string with known length but the ###
// operator won't be supported.
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access
// 1KB. Need to do proper measurements.
inline ID HashData(const void *data_p, size_t data_size, ID seed) {
  U32 crc = ~seed;
  const unsigned char *data = (const unsigned char *)data_p;
  const U32 *crc32_lut = GCrc32LookupTable;
  while (data_size-- != 0)
    crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
  return ~crc;
}

// Zero-terminated string hash, with support for ### to reset back to seed value
// We support a syntax of "label###id" where only "###id" is included in the
// hash, and only "label" gets displayed. Because this syntax is rarely used we
// are optimizing for the common case.
// - If we reach ### in the string we discard the hash so far and reset to the
// seed.
// - We don't do 'current += 2; continue;' after handling ### to keep the code
// smaller/faster (measured ~10% diff in Debug build)
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access
// 1KB. Need to do proper measurements.
inline ID HashStr(const char *data_p, size_t data_size, ID seed) {
  seed = ~seed;
  U32 crc = seed;
  const unsigned char *data = (const unsigned char *)data_p;
  const U32 *crc32_lut = GCrc32LookupTable;
  if (data_size != 0) {
    while (data_size-- != 0) {
      unsigned char c = *data++;
      if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
        crc = seed;
      crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
    }
  } else {
    while (unsigned char c = *data++) {
      if (c == '#' && data[0] == '#' && data[1] == '#')
        crc = seed;
      crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
    }
  }
  return ~crc;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (File functions)
//-----------------------------------------------------------------------------

// Default file functions
#ifndef GUI_DISABLE_DEFAULT_FILE_FUNCTIONS

inline FileHandle FileOpen(const char *filename, const char *mode) {
#if defined(_WIN32) && !defined(GUI_DISABLE_WIN32_FUNCTIONS) &&                \
    !defined(__CYGWIN__) && !defined(__GNUC__)
  // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8
  // filenames. Previously we used TextCountCharsFromUtf8/TextStrFromUtf8
  // here but we now need to support Wchar16 and Wchar32!
  const int filename_wsize =
      ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);
  const int mode_wsize = ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, NULL, 0);
  Context &g = *GGui;
  g.TempBuffer.reserve((filename_wsize + mode_wsize) * sizeof(wchar_t));
  wchar_t *buf = (wchar_t *)(void *)g.TempBuffer.Data;
  ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, (wchar_t *)&buf[0],
                        filename_wsize);
  ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, (wchar_t *)&buf[filename_wsize],
                        mode_wsize);
  return ::_wfopen((const wchar_t *)&buf[0],
                   (const wchar_t *)&buf[filename_wsize]);
#else
  return fopen(filename, mode);
#endif
}

// We should in theory be using fseeko()/ftello() with off_t and
// _fseeki64()/_ftelli64() with __int64, waiting for the PR that does that in a
// very portable pre-C++11 zero-warnings way.
inline bool FileClose(FileHandle f) { return fclose(f) == 0; }
inline U64 FileGetSize(FileHandle f) {
  long off = 0, sz = 0;
  return ((off = ftell(f)) != -1 && !fseek(f, 0, SEEK_END) &&
          (sz = ftell(f)) != -1 && !fseek(f, off, SEEK_SET))
             ? (U64)sz
             : (U64)-1;
}
inline U64 FileRead(void *data, U64 sz, U64 count, FileHandle f) {
  return fread(data, (size_t)sz, (size_t)count, f);
}
inline U64 FileWrite(const void *data, U64 sz, U64 count, FileHandle f) {
  return fwrite(data, (size_t)sz, (size_t)count, f);
}
#endif // #ifndef GUI_DISABLE_DEFAULT_FILE_FUNCTIONS

// Helper: Load file content into memory
// Memory allocated with GUI_ALLOC(), must be freed by user using GUI_FREE() ==
// Gui::MemFree() This can't really be used with "rt" because fseek size won't
// match read size.
inline void *FileLoadToMemory(const char *filename, const char *mode,
                              size_t *out_file_size, int padding_bytes) {
  GUI_ASSERT(filename && mode);
  if (out_file_size)
    *out_file_size = 0;

  FileHandle f;
  if ((f = FileOpen(filename, mode)) == NULL)
    return NULL;

  size_t file_size = (size_t)FileGetSize(f);
  if (file_size == (size_t)-1) {
    FileClose(f);
    return NULL;
  }

  void *file_data = GUI_ALLOC(file_size + padding_bytes);
  if (file_data == NULL) {
    FileClose(f);
    return NULL;
  }
  if (FileRead(file_data, 1, file_size, f) != file_size) {
    FileClose(f);
    GUI_FREE(file_data);
    return NULL;
  }
  if (padding_bytes > 0)
    memset((void *)(((char *)file_data) + file_size), 0, (size_t)padding_bytes);

  FileClose(f);
  if (out_file_size)
    *out_file_size = file_size;

  return file_data;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Text* functions)
//-----------------------------------------------------------------------------

GUI_MSVC_RUNTIME_CHECKS_OFF

// Convert UTF-8 to 32-bit character, process single character input.
// A nearly-branchless UTF-8 decoder, based on work of Christopher Wellons
// (https://github.com/skeeto/branchless-utf8). We handle UTF-8 decoding error
// by skipping forward.
inline int TextCharFromUtf8(unsigned int *out_char, const char *in_text,
                            const char *in_text_end) {
  static const char lengths[32] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                   1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                                   0, 0, 2, 2, 2, 2, 3, 3, 4, 0};
  static const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};
  static const uint32_t mins[] = {0x400000, 0, 0x80, 0x800, 0x10000};
  static const int shiftc[] = {0, 18, 12, 6, 0};
  static const int shifte[] = {0, 6, 4, 2, 0};
  int len = lengths[*(const unsigned char *)in_text >> 3];
  int wanted = len + (len ? 0 : 1);

  if (in_text_end == NULL)
    in_text_end =
        in_text + wanted; // Max length, nulls will be taken into account.

  // Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch
  // predictor does a good job here, so it is fast even with excessive
  // branching.
  unsigned char s[4];
  s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;
  s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;
  s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;
  s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;

  // Assume a four-byte character and load four bytes. Unused bits are shifted
  // out.
  *out_char = (uint32_t)(s[0] & masks[len]) << 18;
  *out_char |= (uint32_t)(s[1] & 0x3f) << 12;
  *out_char |= (uint32_t)(s[2] & 0x3f) << 6;
  *out_char |= (uint32_t)(s[3] & 0x3f) << 0;
  *out_char >>= shiftc[len];

  // Accumulate the various error conditions.
  int e = 0;
  e = (*out_char < mins[len]) << 6;                  // non-canonical encoding
  e |= ((*out_char >> 11) == 0x1b) << 7;             // surrogate half?
  e |= (*out_char > GUI_UNICODE_CODEPOINT_MAX) << 8; // out of range?
  e |= (s[1] & 0xc0) >> 2;
  e |= (s[2] & 0xc0) >> 4;
  e |= (s[3]) >> 6;
  e ^= 0x2a; // top two bits of each tail byte correct?
  e >>= shifte[len];

  if (e) {
    // No bytes are consumed when *in_text == 0 || in_text == in_text_end.
    // One byte is consumed in case of invalid first byte of in_text.
    // All available bytes (at most `len` bytes) are consumed on
    // incomplete/invalid second to last bytes. Invalid or incomplete input may
    // consume less bytes than wanted, therefore every byte has to be inspected
    // in s.
    wanted = Min(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);
    *out_char = GUI_UNICODE_CODEPOINT_INVALID;
  }

  return wanted;
}

// Based on stb_to_utf8() from github.com/nothings/stb/
static inline int TextCharToUtf8_inline(char *buf, int buf_size,
                                        unsigned int c) {
  if (c < 0x80) {
    buf[0] = (char)c;
    return 1;
  }
  if (c < 0x800) {
    if (buf_size < 2)
      return 0;
    buf[0] = (char)(0xc0 + (c >> 6));
    buf[1] = (char)(0x80 + (c & 0x3f));
    return 2;
  }
  if (c < 0x10000) {
    if (buf_size < 3)
      return 0;
    buf[0] = (char)(0xe0 + (c >> 12));
    buf[1] = (char)(0x80 + ((c >> 6) & 0x3f));
    buf[2] = (char)(0x80 + ((c) & 0x3f));
    return 3;
  }
  if (c <= 0x10FFFF) {
    if (buf_size < 4)
      return 0;
    buf[0] = (char)(0xf0 + (c >> 18));
    buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
    buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
    buf[3] = (char)(0x80 + ((c) & 0x3f));
    return 4;
  }
  // Invalid code point, the max unicode is 0x10FFFF
  return 0;
}

inline const char *TextCharToUtf8(char out_buf[5], unsigned int c) {
  int count = TextCharToUtf8_inline(out_buf, 5, c);
  out_buf[count] = 0;
  return out_buf;
}

// Not optimal but we very rarely use this function.

static inline int TextCountUtf8BytesFromChar(unsigned int c) {
  if (c < 0x80)
    return 1;
  if (c < 0x800)
    return 2;
  if (c < 0x10000)
    return 3;
  if (c <= 0x10FFFF)
    return 4;
  return 3;
}

inline int TextStrToUtf8(char *out_buf, int out_buf_size, const Wchar *in_text,
                         const Wchar *in_text_end) {
  char *buf_p = out_buf;
  const char *buf_end = out_buf + out_buf_size;
  while (buf_p < buf_end - 1 && (!in_text_end || in_text < in_text_end) &&
         *in_text) {
    unsigned int c = (unsigned int)(*in_text++);
    if (c < 0x80)
      *buf_p++ = (char)c;
    else
      buf_p += TextCharToUtf8_inline(buf_p, (int)(buf_end - buf_p - 1), c);
  }
  *buf_p = 0;
  return (int)(buf_p - out_buf);
}

inline int TextCountUtf8BytesFromStr(const Wchar *in_text,
                                     const Wchar *in_text_end) {
  int bytes_count = 0;
  while ((!in_text_end || in_text < in_text_end) && *in_text) {
    unsigned int c = (unsigned int)(*in_text++);
    if (c < 0x80)
      bytes_count++;
    else
      bytes_count += TextCountUtf8BytesFromChar(c);
  }
  return bytes_count;
}

GUI_MSVC_RUNTIME_CHECKS_RESTORE

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// Note: The Convert functions are early design which are not consistent with
// other API.
//-----------------------------------------------------------------------------

GUI_API inline U32 AlphaBlendColors(U32 col_a, U32 col_b) {
  float t = ((col_b >> GUI_COL32_A_SHIFT) & 0xFF) / 255.f;
  int r = Lerp((int)(col_a >> GUI_COL32_R_SHIFT) & 0xFF,
               (int)(col_b >> GUI_COL32_R_SHIFT) & 0xFF, t);
  int g = Lerp((int)(col_a >> GUI_COL32_G_SHIFT) & 0xFF,
               (int)(col_b >> GUI_COL32_G_SHIFT) & 0xFF, t);
  int b = Lerp((int)(col_a >> GUI_COL32_B_SHIFT) & 0xFF,
               (int)(col_b >> GUI_COL32_B_SHIFT) & 0xFF, t);
  return GUI_COL32(r, g, b, 0xFF);
}

inline Vec4 Gui::ColorConvertU32ToFloat4(U32 in) {
  float s = 1.0f / 255.0f;
  return Vec4(((in >> GUI_COL32_R_SHIFT) & 0xFF) * s,
              ((in >> GUI_COL32_G_SHIFT) & 0xFF) * s,
              ((in >> GUI_COL32_B_SHIFT) & 0xFF) * s,
              ((in >> GUI_COL32_A_SHIFT) & 0xFF) * s);
}

inline U32 Gui::ColorConvertFloat4ToU32(const Vec4 &in) {
  U32 out;
  out = ((U32)GUI_F32_TO_INT8_SAT(in.x)) << GUI_COL32_R_SHIFT;
  out |= ((U32)GUI_F32_TO_INT8_SAT(in.y)) << GUI_COL32_G_SHIFT;
  out |= ((U32)GUI_F32_TO_INT8_SAT(in.z)) << GUI_COL32_B_SHIFT;
  out |= ((U32)GUI_F32_TO_INT8_SAT(in.w)) << GUI_COL32_A_SHIFT;
  return out;
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]),
// from Foley & van Dam p592 Optimized
// http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
inline void Gui::ColorConvertRGBtoHSV(float r, float g, float b, float &out_h,
                                      float &out_s, float &out_v) {
  float K = 0.f;
  if (g < b) {
    Swap(g, b);
    K = -1.f;
  }
  if (r < g) {
    Swap(r, g);
    K = -2.f / 6.f - K;
  }

  const float chroma = r - (g < b ? g : b);
  out_h = Fabs(K + (g - b) / (6.f * chroma + 1e-20f));
  out_s = chroma / (r + 1e-20f);
  out_v = r;
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]),
// from Foley & van Dam p593 also http://en.wikipedia.org/wiki/HSL_and_HSV
inline void Gui::ColorConvertHSVtoRGB(float h, float s, float v, float &out_r,
                                      float &out_g, float &out_b) {
  if (s == 0.0f) {
    // gray
    out_r = out_g = out_b = v;
    return;
  }

  h = Fmod(h, 1.0f) / (60.0f / 360.0f);
  int i = (int)h;
  float f = h - (float)i;
  float p = v * (1.0f - s);
  float q = v * (1.0f - s * f);
  float t = v * (1.0f - s * (1.0f - f));

  switch (i) {
  case 0:
    out_r = v;
    out_g = t;
    out_b = p;
    break;
  case 1:
    out_r = q;
    out_g = v;
    out_b = p;
    break;
  case 2:
    out_r = p;
    out_g = v;
    out_b = t;
    break;
  case 3:
    out_r = p;
    out_g = q;
    out_b = v;
    break;
  case 4:
    out_r = t;
    out_g = p;
    out_b = v;
    break;
  case 5:
  default:
    out_r = v;
    out_g = p;
    out_b = q;
    break;
  }
}

//-----------------------------------------------------------------------------
// [SECTION] Storage
// Helper: Key->value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
static Storage::StoragePair *LowerBound(Vector<Storage::StoragePair> &data,
                                        ID key) {
  Storage::StoragePair *first = data.Data;
  Storage::StoragePair *last = data.Data + data.Size;
  size_t count = (size_t)(last - first);
  while (count > 0) {
    size_t count2 = count >> 1;
    Storage::StoragePair *mid = first + count2;
    if (mid->key < key) {
      first = ++mid;
      count -= count2 + 1;
    } else {
      count = count2;
    }
  }
  return first;
}

// For quicker full rebuild of a storage (instead of an incremental one), you
// may add all your contents and then sort once.
inline void Storage::BuildSortByKey() {
  struct StaticFunc {
    static int GUI_CDECL PairComparerByID(const void *lhs, const void *rhs) {
      // We can't just do a subtraction because qsort uses signed integers and
      // subtracting our ID doesn't play well with that.
      if (((const StoragePair *)lhs)->key > ((const StoragePair *)rhs)->key)
        return +1;
      if (((const StoragePair *)lhs)->key < ((const StoragePair *)rhs)->key)
        return -1;
      return 0;
    }
  };
  Qsort(Data.Data, (size_t)Data.Size, sizeof(StoragePair),
        StaticFunc::PairComparerByID);
}

inline int Storage::GetInt(ID key, int default_val) const {
  StoragePair *it = LowerBound(const_cast<Vector<StoragePair> &>(Data), key);
  if (it == Data.end() || it->key != key)
    return default_val;
  return it->val_i;
}

inline float Storage::GetFloat(ID key, float default_val) const {
  StoragePair *it = LowerBound(const_cast<Vector<StoragePair> &>(Data), key);
  if (it == Data.end() || it->key != key)
    return default_val;
  return it->val_f;
}

inline void *Storage::GetVoidPtr(ID key) const {
  StoragePair *it = LowerBound(const_cast<Vector<StoragePair> &>(Data), key);
  if (it == Data.end() || it->key != key)
    return NULL;
  return it->val_p;
}

// References are only valid until a new value is added to the storage. Calling
// a Set***() function or a Get***Ref() function invalidates the pointer.
inline int *Storage::GetIntRef(ID key, int default_val) {
  StoragePair *it = LowerBound(Data, key);
  if (it == Data.end() || it->key != key)
    it = Data.insert(it, StoragePair(key, default_val));
  return &it->val_i;
}

inline float *Storage::GetFloatRef(ID key, float default_val) {
  StoragePair *it = LowerBound(Data, key);
  if (it == Data.end() || it->key != key)
    it = Data.insert(it, StoragePair(key, default_val));
  return &it->val_f;
}

inline void **Storage::GetVoidPtrRef(ID key, void *default_val) {
  StoragePair *it = LowerBound(Data, key);
  if (it == Data.end() || it->key != key)
    it = Data.insert(it, StoragePair(key, default_val));
  return &it->val_p;
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing
// GetInt()/SetInt() - not too bad because it only happens on explicit
// interaction (maximum one a frame)
inline void Storage::SetInt(ID key, int val) {
  StoragePair *it = LowerBound(Data, key);
  if (it == Data.end() || it->key != key)
    Data.insert(it, StoragePair(key, val));
  else
    it->val_i = val;
}

inline void Storage::SetFloat(ID key, float val) {
  StoragePair *it = LowerBound(Data, key);
  if (it == Data.end() || it->key != key)
    Data.insert(it, StoragePair(key, val));
  else
    it->val_f = val;
}

inline void Storage::SetVoidPtr(ID key, void *val) {
  StoragePair *it = LowerBound(Data, key);
  if (it == Data.end() || it->key != key)
    Data.insert(it, StoragePair(key, val));
  else
    it->val_p = val;
}

//-----------------------------------------------------------------------------
// [SECTION] TextFilter
//-----------------------------------------------------------------------------
inline TextFilter::TextFilter(const char *default_filter) //-V1077
{
  InputBuf[0] = 0;
  CountGrep = 0;
  if (default_filter) {
    Strncpy(InputBuf, default_filter, GUI_ARRAYSIZE(InputBuf));
    Build();
  }
}

inline void TextFilter::Build() {
  Filters.resize(0);
  TextRange input_range(InputBuf, InputBuf + strlen(InputBuf));
  input_range.split(',', &Filters);

  CountGrep = 0;
  for (TextRange &f : Filters) {
    while (f.b < f.e && CharIsBlankA(f.b[0]))
      f.b++;
    while (f.e > f.b && CharIsBlankA(f.e[-1]))
      f.e--;
    if (f.empty())
      continue;
    if (f.b[0] != '-')
      CountGrep += 1;
  }
}

inline bool TextFilter::PassFilter(const char *text,
                                   const char *text_end) const {
  if (Filters.empty())
    return true;

  if (text == NULL)
    text = "";

  for (const TextRange &f : Filters) {
    if (f.empty())
      continue;
    if (f.b[0] == '-') {
      // Subtract
      if (Stristr(text, text_end, f.b + 1, f.e) != NULL)
        return false;
    } else {
      // Grep
      if (Stristr(text, text_end, f.b, f.e) != NULL)
        return true;
    }
  }

  // Implicit * grep
  if (CountGrep == 0)
    return true;

  return false;
}

//-----------------------------------------------------------------------------
// [SECTION] TextBuffer, TextIndex
//-----------------------------------------------------------------------------

// On some platform vsnprintf() takes va_list by reference and modifies it.
// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to
// 2013 doesn't have it.
#ifndef va_copy
#if defined(__GNUC__) || defined(__clang__)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#else
#define va_copy(dest, src) (dest = src)
#endif
#endif

char TextBuffer::EmptyString[1] = {0};

inline void TextBuffer::append(const char *str, const char *str_end) {
  int len = str_end ? (int)(str_end - str) : (int)strlen(str);

  // Add zero-terminator the first time
  const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
  const int needed_sz = write_off + len;
  if (write_off + len >= Buf.Capacity) {
    int new_capacity = Buf.Capacity * 2;
    Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
  }

  Buf.resize(needed_sz);
  memcpy(&Buf[write_off - 1], str, (size_t)len);
  Buf[write_off - 1 + len] = 0;
}

inline void TextBuffer::appendf(const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  appendfv(fmt, args);
  va_end(args);
}

// Helper: Text buffer for logging/accumulating text
inline void TextBuffer::appendfv(const char *fmt, va_list args) {
  va_list args_copy;
  va_copy(args_copy, args);

  int len = FormatStringV(NULL, 0, fmt,
                          args); // FIXME-OPT: could do a first pass write
                                 // attempt, likely successful on first pass.
  if (len <= 0) {
    va_end(args_copy);
    return;
  }

  // Add zero-terminator the first time
  const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
  const int needed_sz = write_off + len;
  if (write_off + len >= Buf.Capacity) {
    int new_capacity = Buf.Capacity * 2;
    Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
  }

  Buf.resize(needed_sz);
  FormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
  va_end(args_copy);
}

inline void TextIndex::append(const char *base, int old_size, int new_size) {
  GUI_ASSERT(old_size >= 0 && new_size >= old_size && new_size >= EndOffset);
  if (old_size == new_size)
    return;
  if (EndOffset == 0 || base[EndOffset - 1] == '\n')
    LineOffsets.push_back(EndOffset);
  const char *base_end = base + new_size;
  for (const char *p = base + old_size;
       (p = (const char *)memchr(p, '\n', base_end - p)) != 0;)
    if (++p < base_end) // Don't push a trailing offset on last \n
      LineOffsets.push_back((int)(intptr_t)(p - base));
  EndOffset = Max(EndOffset, new_size);
}

//-----------------------------------------------------------------------------
// [SECTION] ListClipper
//-----------------------------------------------------------------------------

// FIXME-TABLE: This prevents us from using ListClipper _inside_ a table
// cell. The problem we have is that without a Begin/End scheme for rows using
// the clipper is ambiguous.
static bool GetSkipItemForListClipping() {
  Context &g = *GGui;
  return (g.CurrentTable ? g.CurrentTable->HostSkipItems
                         : g.CurrentWindow->SkipItems);
}

static void ListClipper_SortAndFuseRanges(Vector<ListClipperRange> &ranges,
                                          int offset = 0) {
  if (ranges.Size - offset <= 1)
    return;

  // Helper to order ranges and fuse them together if possible (bubble sort is
  // fine as we are only sorting 2-3 entries)
  for (int sort_end = ranges.Size - offset - 1; sort_end > 0; --sort_end)
    for (int i = offset; i < sort_end + offset; ++i)
      if (ranges[i].Min > ranges[i + 1].Min)
        Swap(ranges[i], ranges[i + 1]);

  // Now fuse ranges together as much as possible.
  for (int i = 1 + offset; i < ranges.Size; i++) {
    GUI_ASSERT(!ranges[i].PosToIndexConvert &&
               !ranges[i - 1].PosToIndexConvert);
    if (ranges[i - 1].Max < ranges[i].Min)
      continue;
    ranges[i - 1].Min = Min(ranges[i - 1].Min, ranges[i].Min);
    ranges[i - 1].Max = Max(ranges[i - 1].Max, ranges[i].Max);
    ranges.erase(ranges.Data + i);
    i--;
  }
}

static void ListClipper_SeekCursorAndSetupPrevLine(float pos_y,
                                                   float line_height) {
  // Set cursor position and a few other things so that SetScrollHereY() and
  // Columns() can work when seeking cursor.
  // FIXME: It is problematic that we have to do that here, because
  // custom/equivalent end-user code would stumble on the same issue. The
  // clipper should probably have a final step to display the last item in a
  // regular manner, maybe with an opt-out flag for data sets which may have
  // costly seek?
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  float off_y = pos_y - window->DC.CursorPos.y;
  window->DC.CursorPos.y = pos_y;
  window->DC.CursorMaxPos.y =
      Max(window->DC.CursorMaxPos.y, pos_y - g.Style.ItemSpacing.y);
  window->DC.CursorPosPrevLine.y =
      window->DC.CursorPos.y -
      line_height; // Setting those fields so that SetScrollHereY() can properly
                   // function after the end of our clipper usage.
  window->DC.PrevLineSize.y =
      (line_height -
       g.Style.ItemSpacing
           .y); // If we end up needing more accurate data (to e.g. use
                // SameLine) we may as well make the clipper have a fourth step
                // to let user process and display the last item in their list.
  if (OldColumns *columns = window->DC.CurrentColumns)
    columns->LineMinY =
        window->DC.CursorPos
            .y; // Setting this so that cell Y position are set properly
  if (Table *table = g.CurrentTable) {
    if (table->IsInsideRow)
      Gui::TableEndRow(table);
    table->RowPosY2 = window->DC.CursorPos.y;
    const int row_increase = (int)((off_y / line_height) + 0.5f);
    // table->CurrentRow += row_increase; // Can't do without fixing
    // TableEndRow()
    table->RowBgColorCounter += row_increase;
  }
}

static void ListClipper_SeekCursorForItem(ListClipper *clipper, int item_n) {
  // StartPosY starts from ItemsFrozen hence the subtraction
  // Perform the add and multiply with double to allow seeking through larger
  // ranges
  ListClipperData *data = (ListClipperData *)clipper->TempData;
  float pos_y =
      (float)((double)clipper->StartPosY + data->LossynessOffset +
              (double)(item_n - data->ItemsFrozen) * clipper->ItemsHeight);
  ListClipper_SeekCursorAndSetupPrevLine(pos_y, clipper->ItemsHeight);
}

inline ListClipper::ListClipper() { memset(this, 0, sizeof(*this)); }

inline void ListClipper::Begin(int items_count, float items_height) {
  if (Ctx == NULL)
    Ctx = Gui::GetCurrentContext();

  Context &g = *Ctx;
  Window *window = g.CurrentWindow;
  GUI_DEBUG_LOG_CLIPPER("Clipper: Begin(%d,%.2f) in '%s'\n", items_count,
                        items_height, window->Name);

  if (Table *table = g.CurrentTable)
    if (table->IsInsideRow)
      Gui::TableEndRow(table);

  StartPosY = window->DC.CursorPos.y;
  ItemsHeight = items_height;
  ItemsCount = items_count;
  DisplayStart = -1;
  DisplayEnd = 0;

  // Acquire temporary buffer
  if (++g.ClipperTempDataStacked > g.ClipperTempData.Size)
    g.ClipperTempData.resize(g.ClipperTempDataStacked, ListClipperData());
  ListClipperData *data = &g.ClipperTempData[g.ClipperTempDataStacked - 1];
  data->Reset(this);
  data->LossynessOffset = window->DC.CursorStartPosLossyness.y;
  TempData = data;
}

inline void ListClipper::End() {
  if (ListClipperData *data = (ListClipperData *)TempData) {
    // In theory here we should assert that we are already at the right
    // position, but it seems saner to just seek at the end and not assert/crash
    // the user.
    Context &g = *Ctx;
    GUI_DEBUG_LOG_CLIPPER("Clipper: End() in '%s'\n", g.CurrentWindow->Name);
    if (ItemsCount >= 0 && ItemsCount < INT_MAX && DisplayStart >= 0)
      ListClipper_SeekCursorForItem(this, ItemsCount);

    // Restore temporary buffer and fix back pointers which may be invalidated
    // when nesting
    GUI_ASSERT(data->ListClipper == this);
    data->StepNo = data->Ranges.Size;
    if (--g.ClipperTempDataStacked > 0) {
      data = &g.ClipperTempData[g.ClipperTempDataStacked - 1];
      data->ListClipper->TempData = data;
    }
    TempData = NULL;
  }
  ItemsCount = -1;
}

inline void ListClipper::IncludeItemsByIndex(int item_begin, int item_end) {
  ListClipperData *data = (ListClipperData *)TempData;
  GUI_ASSERT(DisplayStart < 0); // Only allowed after Begin() and if there has
                                // not been a specified range yet.
  GUI_ASSERT(item_begin <= item_end);
  if (item_begin < item_end)
    data->Ranges.push_back(ListClipperRange::FromIndices(item_begin, item_end));
}

static bool ListClipper_StepInternal(ListClipper *clipper) {
  Context &g = *clipper->Ctx;
  Window *window = g.CurrentWindow;
  ListClipperData *data = (ListClipperData *)clipper->TempData;
  GUI_ASSERT(data != NULL && "Called ListClipper::Step() too many times, "
                             "or before ListClipper::Begin() ?");

  Table *table = g.CurrentTable;
  if (table && table->IsInsideRow)
    Gui::TableEndRow(table);

  // No items
  if (clipper->ItemsCount == 0 || GetSkipItemForListClipping())
    return false;

  // While we are in frozen row state, keep displaying items one by one,
  // unclipped
  // FIXME: Could be stored as a table-agnostic state.
  if (data->StepNo == 0 && table != NULL && !table->IsUnfrozenRows) {
    clipper->DisplayStart = data->ItemsFrozen;
    clipper->DisplayEnd = Min(data->ItemsFrozen + 1, clipper->ItemsCount);
    if (clipper->DisplayStart < clipper->DisplayEnd)
      data->ItemsFrozen++;
    return true;
  }

  // Step 0: Let you process the first element (regardless of it being visible
  // or not, so we can measure the element height)
  bool calc_clipping = false;
  if (data->StepNo == 0) {
    clipper->StartPosY = window->DC.CursorPos.y;
    if (clipper->ItemsHeight <= 0.0f) {
      // Submit the first item (or range) so we can measure its height
      // (generally the first range is 0..1)
      data->Ranges.push_front(ListClipperRange::FromIndices(
          data->ItemsFrozen, data->ItemsFrozen + 1));
      clipper->DisplayStart = Max(data->Ranges[0].Min, data->ItemsFrozen);
      clipper->DisplayEnd = Min(data->Ranges[0].Max, clipper->ItemsCount);
      data->StepNo = 1;
      return true;
    }
    calc_clipping = true; // If on the first step with known item height,
                          // calculate clipping.
  }

  // Step 1: Let the clipper infer height from first range
  if (clipper->ItemsHeight <= 0.0f) {
    GUI_ASSERT(data->StepNo == 1);
    if (table)
      GUI_ASSERT(table->RowPosY1 == clipper->StartPosY &&
                 table->RowPosY2 == window->DC.CursorPos.y);

    clipper->ItemsHeight = (window->DC.CursorPos.y - clipper->StartPosY) /
                           (float)(clipper->DisplayEnd - clipper->DisplayStart);
    bool affected_by_floating_point_precision =
        IsFloatAboveGuaranteedIntegerPrecision(clipper->StartPosY) ||
        IsFloatAboveGuaranteedIntegerPrecision(window->DC.CursorPos.y);
    if (affected_by_floating_point_precision)
      clipper->ItemsHeight =
          window->DC.PrevLineSize.y +
          g.Style.ItemSpacing
              .y; // FIXME: Technically wouldn't allow multi-line entries.

    GUI_ASSERT(clipper->ItemsHeight > 0.0f &&
               "Unable to calculate item height! First item hasn't moved the "
               "cursor vertically!");
    calc_clipping = true; // If item height had to be calculated, calculate
                          // clipping afterwards.
  }

  // Step 0 or 1: Calculate the actual ranges of visible elements.
  const int already_submitted = clipper->DisplayEnd;
  if (calc_clipping) {
    if (g.LogEnabled) {
      // If logging is active, do not perform any clipping
      data->Ranges.push_back(
          ListClipperRange::FromIndices(0, clipper->ItemsCount));
    } else {
      // Add range selected to be included for navigation
      const bool is_nav_request =
          (g.NavMoveScoringItems && g.NavWindow &&
           g.NavWindow->RootWindowForNav == window->RootWindowForNav);
      if (is_nav_request)
        data->Ranges.push_back(ListClipperRange::FromPositions(
            g.NavScoringNoClipRect.Min.y, g.NavScoringNoClipRect.Max.y, 0, 0));
      if (is_nav_request && (g.NavMoveFlags & NavMoveFlags_IsTabbing) &&
          g.NavTabbingDir == -1)
        data->Ranges.push_back(ListClipperRange::FromIndices(
            clipper->ItemsCount - 1, clipper->ItemsCount));

      // Add focused/active item
      Rect nav_rect_abs =
          Gui::WindowRectRelToAbs(window, window->NavRectRel[0]);
      if (g.NavId != 0 && window->NavLastIds[0] == g.NavId)
        data->Ranges.push_back(ListClipperRange::FromPositions(
            nav_rect_abs.Min.y, nav_rect_abs.Max.y, 0, 0));

      // Add visible range
      const int off_min =
          (is_nav_request && g.NavMoveClipDir == Dir_Up) ? -1 : 0;
      const int off_max =
          (is_nav_request && g.NavMoveClipDir == Dir_Down) ? 1 : 0;
      data->Ranges.push_back(ListClipperRange::FromPositions(
          window->ClipRect.Min.y, window->ClipRect.Max.y, off_min, off_max));
    }

    // Convert position ranges to item index ranges
    // - Very important: when a starting position is after our maximum item, we
    // set Min to (ItemsCount - 1). This allows us to handle most forms of
    // wrapping.
    // - Due to how Selectable extra padding they tend to be "unaligned" with
    // exact unit in the item list,
    //   which with the flooring/ceiling tend to lead to 2 items instead of one
    //   being submitted.
    for (ListClipperRange &range : data->Ranges)
      if (range.PosToIndexConvert) {
        int m1 = (int)(((double)range.Min - window->DC.CursorPos.y -
                        data->LossynessOffset) /
                       clipper->ItemsHeight);
        int m2 = (int)((((double)range.Max - window->DC.CursorPos.y -
                         data->LossynessOffset) /
                        clipper->ItemsHeight) +
                       0.999999f);
        range.Min = Clamp(already_submitted + m1 + range.PosToIndexOffsetMin,
                          already_submitted, clipper->ItemsCount - 1);
        range.Max = Clamp(already_submitted + m2 + range.PosToIndexOffsetMax,
                          range.Min + 1, clipper->ItemsCount);
        range.PosToIndexConvert = false;
      }
    ListClipper_SortAndFuseRanges(data->Ranges, data->StepNo);
  }

  // Step 0+ (if item height is given in advance) or 1+: Display the next range
  // in line.
  while (data->StepNo < data->Ranges.Size) {
    clipper->DisplayStart =
        Max(data->Ranges[data->StepNo].Min, already_submitted);
    clipper->DisplayEnd =
        Min(data->Ranges[data->StepNo].Max, clipper->ItemsCount);
    if (clipper->DisplayStart > already_submitted) //-V1051
      ListClipper_SeekCursorForItem(clipper, clipper->DisplayStart);
    data->StepNo++;
    if (clipper->DisplayStart == clipper->DisplayEnd &&
        data->StepNo < data->Ranges.Size)
      continue;
    return true;
  }

  // After the last step: Let the clipper validate that we have reached the
  // expected Y position (corresponding to element DisplayEnd), Advance the
  // cursor to the end of the list and then returns 'false' to end the loop.
  if (clipper->ItemsCount < INT_MAX)
    ListClipper_SeekCursorForItem(clipper, clipper->ItemsCount);

  return false;
}

inline bool ListClipper::Step() {
  Context &g = *Ctx;
  bool need_items_height = (ItemsHeight <= 0.0f);
  bool ret = ListClipper_StepInternal(this);
  if (ret && (DisplayStart == DisplayEnd))
    ret = false;
  if (g.CurrentTable && g.CurrentTable->IsUnfrozenRows == false)
    GUI_DEBUG_LOG_CLIPPER("Clipper: Step(): inside frozen table row.\n");
  if (need_items_height && ItemsHeight > 0.0f)
    GUI_DEBUG_LOG_CLIPPER("Clipper: Step(): computed ItemsHeight: %.2f.\n",
                          ItemsHeight);
  if (ret) {
    GUI_DEBUG_LOG_CLIPPER("Clipper: Step(): display %d to %d.\n", DisplayStart,
                          DisplayEnd);
  } else {
    GUI_DEBUG_LOG_CLIPPER("Clipper: Step(): End.\n");
    End();
  }
  return ret;
}

//-----------------------------------------------------------------------------
// [SECTION] STYLING
//-----------------------------------------------------------------------------

inline Style &Gui::GetStyle() {
  GUI_ASSERT(GGui != NULL &&
             "No current context. Did you call Gui::CreateContext() and "
             "Gui::SetCurrentContext() ?");
  return GGui->Style;
}

inline U32 Gui::GetColorU32(Col idx, float alpha_mul) {
  Style &style = GGui->Style;
  Vec4 c = style.Colors[idx];
  c.w *= style.Alpha * alpha_mul;
  return ColorConvertFloat4ToU32(c);
}

inline U32 Gui::GetColorU32(const Vec4 &col) {
  Style &style = GGui->Style;
  Vec4 c = col;
  c.w *= style.Alpha;
  return ColorConvertFloat4ToU32(c);
}

inline const Vec4 &Gui::GetStyleColorVec4(Col idx) {
  Style &style = GGui->Style;
  return style.Colors[idx];
}

inline U32 Gui::GetColorU32(U32 col) {
  Style &style = GGui->Style;
  if (style.Alpha >= 1.0f)
    return col;
  U32 a = (col & GUI_COL32_A_MASK) >> GUI_COL32_A_SHIFT;
  a = (U32)(a * style.Alpha); // We don't need to clamp 0..255 because
                              // Style.Alpha is in 0..1 range.
  return (col & ~GUI_COL32_A_MASK) | (a << GUI_COL32_A_SHIFT);
}

// FIXME: This may incur a round-trip (if the end user got their data from a
// float4) but eventually we aim to store the in-flight colors asU32
inline void Gui::PushStyleColor(Col idx, U32 col) {
  Context &g = *GGui;
  ColorMod backup;
  backup.Col = idx;
  backup.BackupValue = g.Style.Colors[idx];
  g.ColorStack.push_back(backup);
  if (g.DebugFlashStyleColorIdx != idx)
    g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
}

inline void Gui::PushStyleColor(Col idx, const Vec4 &col) {
  Context &g = *GGui;
  ColorMod backup;
  backup.Col = idx;
  backup.BackupValue = g.Style.Colors[idx];
  g.ColorStack.push_back(backup);
  if (g.DebugFlashStyleColorIdx != idx)
    g.Style.Colors[idx] = col;
}

inline void Gui::PopStyleColor(int count) {
  Context &g = *GGui;
  if (g.ColorStack.Size < count) {
    GUI_ASSERT_USER_ERROR(
        g.ColorStack.Size > count,
        "Calling PopStyleColor() too many times: stack underflow.");
    count = g.ColorStack.Size;
  }
  while (count > 0) {
    ColorMod &backup = g.ColorStack.back();
    g.Style.Colors[backup.Col] = backup.BackupValue;
    g.ColorStack.pop_back();
    count--;
  }
}

static const DataVarInfo GStyleVarInfo[] = {
    {DataType_Float, 1, (U32)offsetof(Style, Alpha)}, // StyleVar_Alpha
    {DataType_Float, 1,
     (U32)offsetof(Style, DisabledAlpha)}, // StyleVar_DisabledAlpha
    {DataType_Float, 2,
     (U32)offsetof(Style, WindowPadding)}, // StyleVar_WindowPadding
    {DataType_Float, 1,
     (U32)offsetof(Style, WindowRounding)}, // StyleVar_WindowRounding
    {DataType_Float, 1,
     (U32)offsetof(Style, WindowBorderSize)}, // StyleVar_WindowBorderSize
    {DataType_Float, 2,
     (U32)offsetof(Style, WindowMinSize)}, // StyleVar_WindowMinSize
    {DataType_Float, 2,
     (U32)offsetof(Style, WindowTitleAlign)}, // StyleVar_WindowTitleAlign
    {DataType_Float, 1,
     (U32)offsetof(Style, ChildRounding)}, // StyleVar_ChildRounding
    {DataType_Float, 1,
     (U32)offsetof(Style, ChildBorderSize)}, // StyleVar_ChildBorderSize
    {DataType_Float, 1,
     (U32)offsetof(Style, PopupRounding)}, // StyleVar_PopupRounding
    {DataType_Float, 1,
     (U32)offsetof(Style, PopupBorderSize)}, // StyleVar_PopupBorderSize
    {DataType_Float, 2,
     (U32)offsetof(Style, FramePadding)}, // StyleVar_FramePadding
    {DataType_Float, 1,
     (U32)offsetof(Style, FrameRounding)}, // StyleVar_FrameRounding
    {DataType_Float, 1,
     (U32)offsetof(Style, FrameBorderSize)}, // StyleVar_FrameBorderSize
    {DataType_Float, 2,
     (U32)offsetof(Style, ItemSpacing)}, // StyleVar_ItemSpacing
    {DataType_Float, 2,
     (U32)offsetof(Style, ItemInnerSpacing)}, // StyleVar_ItemInnerSpacing
    {DataType_Float, 1,
     (U32)offsetof(Style, IndentSpacing)}, // StyleVar_IndentSpacing
    {DataType_Float, 2,
     (U32)offsetof(Style, CellPadding)}, // StyleVar_CellPadding
    {DataType_Float, 1,
     (U32)offsetof(Style, ScrollbarSize)}, // StyleVar_ScrollbarSize
    {DataType_Float, 1,
     (U32)offsetof(Style, ScrollbarRounding)}, // StyleVar_ScrollbarRounding
    {DataType_Float, 1,
     (U32)offsetof(Style, GrabMinSize)}, // StyleVar_GrabMinSize
    {DataType_Float, 1,
     (U32)offsetof(Style, GrabRounding)}, // StyleVar_GrabRounding
    {DataType_Float, 1,
     (U32)offsetof(Style, TabRounding)}, // StyleVar_TabRounding
    {DataType_Float, 1,
     (U32)offsetof(Style, TabBarBorderSize)}, // StyleVar_TabBarBorderSize
    {DataType_Float, 2,
     (U32)offsetof(Style, ButtonTextAlign)}, // StyleVar_ButtonTextAlign
    {DataType_Float, 2,
     (U32)offsetof(Style, SelectableTextAlign)}, // StyleVar_SelectableTextAlign
    {DataType_Float, 1,
     (U32)offsetof(
         Style, SeparatorTextBorderSize)}, // StyleVar_SeparatorTextBorderSize
    {DataType_Float, 2,
     (U32)offsetof(Style, SeparatorTextAlign)}, // StyleVar_SeparatorTextAlign
    {DataType_Float, 2,
     (U32)offsetof(Style,
                   SeparatorTextPadding)}, // StyleVar_SeparatorTextPadding
};

inline const DataVarInfo *Gui::GetStyleVarInfo(StyleVar idx) {
  GUI_ASSERT(idx >= 0 && idx < StyleVar_COUNT);
  GUI_STATIC_ASSERT(GUI_ARRAYSIZE(GStyleVarInfo) == StyleVar_COUNT);
  return &GStyleVarInfo[idx];
}

inline void Gui::PushStyleVar(StyleVar idx, float val) {
  Context &g = *GGui;
  const DataVarInfo *var_info = GetStyleVarInfo(idx);
  if (var_info->Type == DataType_Float && var_info->Count == 1) {
    float *pvar = (float *)var_info->GetVarPtr(&g.Style);
    g.StyleVarStack.push_back(StyleMod(idx, *pvar));
    *pvar = val;
    return;
  }
  GUI_ASSERT_USER_ERROR(0, "Called PushStyleVar() variant with wrong type!");
}

inline void Gui::PushStyleVar(StyleVar idx, const Vec2 &val) {
  Context &g = *GGui;
  const DataVarInfo *var_info = GetStyleVarInfo(idx);
  if (var_info->Type == DataType_Float && var_info->Count == 2) {
    Vec2 *pvar = (Vec2 *)var_info->GetVarPtr(&g.Style);
    g.StyleVarStack.push_back(StyleMod(idx, *pvar));
    *pvar = val;
    return;
  }
  GUI_ASSERT_USER_ERROR(0, "Called PushStyleVar() variant with wrong type!");
}

inline void Gui::PopStyleVar(int count) {
  Context &g = *GGui;
  if (g.StyleVarStack.Size < count) {
    GUI_ASSERT_USER_ERROR(
        g.StyleVarStack.Size > count,
        "Calling PopStyleVar() too many times: stack underflow.");
    count = g.StyleVarStack.Size;
  }
  while (count > 0) {
    // We avoid a generic memcpy(data, &backup.Backup..,
    // GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not
    // worth it.
    StyleMod &backup = g.StyleVarStack.back();
    const DataVarInfo *info = GetStyleVarInfo(backup.VarIdx);
    void *data = info->GetVarPtr(&g.Style);
    if (info->Type == DataType_Float && info->Count == 1) {
      ((float *)data)[0] = backup.BackupFloat[0];
    } else if (info->Type == DataType_Float && info->Count == 2) {
      ((float *)data)[0] = backup.BackupFloat[0];
      ((float *)data)[1] = backup.BackupFloat[1];
    }
    g.StyleVarStack.pop_back();
    count--;
  }
}

inline const char *Gui::GetStyleColorName(Col idx) {
  // Create switch-case from enum with regexp: Col_{.*}, --> case
  // Col_\1: return "\1";
  switch (idx) {
  case Col_Text:
    return "Text";
  case Col_TextDisabled:
    return "TextDisabled";
  case Col_WindowBg:
    return "WindowBg";
  case Col_ChildBg:
    return "ChildBg";
  case Col_PopupBg:
    return "PopupBg";
  case Col_Border:
    return "Border";
  case Col_BorderShadow:
    return "BorderShadow";
  case Col_FrameBg:
    return "FrameBg";
  case Col_FrameBgHovered:
    return "FrameBgHovered";
  case Col_FrameBgActive:
    return "FrameBgActive";
  case Col_TitleBg:
    return "TitleBg";
  case Col_TitleBgActive:
    return "TitleBgActive";
  case Col_TitleBgCollapsed:
    return "TitleBgCollapsed";
  case Col_MenuBarBg:
    return "MenuBarBg";
  case Col_ScrollbarBg:
    return "ScrollbarBg";
  case Col_ScrollbarGrab:
    return "ScrollbarGrab";
  case Col_ScrollbarGrabHovered:
    return "ScrollbarGrabHovered";
  case Col_ScrollbarGrabActive:
    return "ScrollbarGrabActive";
  case Col_CheckMark:
    return "CheckMark";
  case Col_SliderGrab:
    return "SliderGrab";
  case Col_SliderGrabActive:
    return "SliderGrabActive";
  case Col_Button:
    return "Button";
  case Col_ButtonHovered:
    return "ButtonHovered";
  case Col_ButtonActive:
    return "ButtonActive";
  case Col_Header:
    return "Header";
  case Col_HeaderHovered:
    return "HeaderHovered";
  case Col_HeaderActive:
    return "HeaderActive";
  case Col_Separator:
    return "Separator";
  case Col_SeparatorHovered:
    return "SeparatorHovered";
  case Col_SeparatorActive:
    return "SeparatorActive";
  case Col_ResizeGrip:
    return "ResizeGrip";
  case Col_ResizeGripHovered:
    return "ResizeGripHovered";
  case Col_ResizeGripActive:
    return "ResizeGripActive";
  case Col_Tab:
    return "Tab";
  case Col_TabHovered:
    return "TabHovered";
  case Col_TabActive:
    return "TabActive";
  case Col_TabUnfocused:
    return "TabUnfocused";
  case Col_TabUnfocusedActive:
    return "TabUnfocusedActive";
  case Col_PlotLines:
    return "PlotLines";
  case Col_PlotLinesHovered:
    return "PlotLinesHovered";
  case Col_PlotHistogram:
    return "PlotHistogram";
  case Col_PlotHistogramHovered:
    return "PlotHistogramHovered";
  case Col_TableHeaderBg:
    return "TableHeaderBg";
  case Col_TableBorderStrong:
    return "TableBorderStrong";
  case Col_TableBorderLight:
    return "TableBorderLight";
  case Col_TableRowBg:
    return "TableRowBg";
  case Col_TableRowBgAlt:
    return "TableRowBgAlt";
  case Col_TextSelectedBg:
    return "TextSelectedBg";
  case Col_DragDropTarget:
    return "DragDropTarget";
  case Col_NavHighlight:
    return "NavHighlight";
  case Col_NavWindowingHighlight:
    return "NavWindowingHighlight";
  case Col_NavWindowingDimBg:
    return "NavWindowingDimBg";
  case Col_ModalWindowDimBg:
    return "ModalWindowDimBg";
  }
  GUI_ASSERT(0);
  return "Unknown";
}

//-----------------------------------------------------------------------------
// [SECTION] RENDER HELPERS
// Some of those (internal) functions are currently quite a legacy mess - their
// signature and behavior will change, we need a nicer separation between
// low-level functions and high-level functions relying on the Gui context.
// Also see gui_draw.hpp for some more which have been reworked to not rely on
// Gui:: context.
//-----------------------------------------------------------------------------

// Internal Gui functions to render text
// RenderText***() functions calls DrawList::AddText() calls
// BitmapFont::RenderText()
inline void Gui::RenderText(Vec2 pos, const char *text, const char *text_end,
                            bool hide_text_after_hash) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  // Hide anything after a '##' string
  const char *text_display_end;
  if (hide_text_after_hash) {
    text_display_end = FindRenderedTextEnd(text, text_end);
  } else {
    if (!text_end)
      text_end = text + strlen(text); // FIXME-OPT
    text_display_end = text_end;
  }

  if (text != text_display_end) {
    window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(Col_Text),
                              text, text_display_end);
    if (g.LogEnabled)
      LogRenderedText(&pos, text, text_display_end);
  }
}

inline void Gui::RenderTextWrapped(Vec2 pos, const char *text,
                                   const char *text_end, float wrap_width) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  if (!text_end)
    text_end = text + strlen(text); // FIXME-OPT

  if (text != text_end) {
    window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(Col_Text),
                              text, text_end, wrap_width);
    if (g.LogEnabled)
      LogRenderedText(&pos, text, text_end);
  }
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the
// triangles that are overlapping the clipping rectangle edges)
// FIXME-OPT: Since we have or calculate text_size we could coarse clip whole
// block immediately, especally for text above draw_list->DrawList. Effectively
// as this is called from widget doing their own coarse clipping it's not very
// valuable presently. Next time function will take better advantage of the
// render function taking size into account for coarse clipping.

inline void Gui::RenderTextClipped(const Vec2 &pos_min, const Vec2 &pos_max,
                                   const char *text, const char *text_end,
                                   const Vec2 *text_size_if_known,
                                   const Vec2 &align, const Rect *clip_rect) {
  // Hide anything after a '##' string
  const char *text_display_end = FindRenderedTextEnd(text, text_end);
  const int text_len = (int)(text_display_end - text);
  if (text_len == 0)
    return;

  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  RenderTextClippedEx(window->DrawList, pos_min, pos_max, text,
                      text_display_end, text_size_if_known, align, clip_rect);
  if (g.LogEnabled)
    LogRenderedText(&pos_min, text, text_display_end);
}

// Another overly complex function until we reorganize everything into a nice
// all-in-one helper. This is made more complex because we have dissociated the
// layout rectangle (pos_min..pos_max) which define _where_ the ellipsis is,
// from actual clipping of text and limit of the ellipsis display. This is
// because in the context of tabs we selectively hide part of the text when the
// Close Button appears, but we don't want the ellipsis to move.
inline void Gui::RenderTextEllipsis(DrawList *draw_list, const Vec2 &pos_min,
                                    const Vec2 &pos_max, float clip_max_x,
                                    float ellipsis_max_x, const char *text,
                                    const char *text_end_full,
                                    const Vec2 *text_size_if_known) {
  Context &g = *GGui;
  if (text_end_full == NULL)
    text_end_full = FindRenderedTextEnd(text);
  const Vec2 text_size = text_size_if_known
                             ? *text_size_if_known
                             : CalcTextSize(text, text_end_full, false, 0.0f);

  // draw_list->AddLine(Vec2(pos_max.x, pos_min.y - 4), Vec2(pos_max.x,
  // pos_max.y + 4), GUI_COL32(0, 0, 255, 255));
  // draw_list->AddLine(Vec2(ellipsis_max_x, pos_min.y-2),
  // Vec2(ellipsis_max_x, pos_max.y+2), GUI_COL32(0, 255, 0, 255));
  // draw_list->AddLine(Vec2(clip_max_x, pos_min.y), Vec2(clip_max_x,
  // pos_max.y), GUI_COL32(255, 0, 0, 255));
  //  FIXME: We could technically remove (last_glyph->AdvanceX - last_glyph->X1)
  //  from text_size.x here and save a few pixels.
  if (text_size.x > pos_max.x - pos_min.x) {
    // Hello wo...
    // |       |   |
    // min   max   ellipsis_max
    //          <-> this is generally some padding value

    const Font *font = draw_list->_Data->Font;
    const float font_size = draw_list->_Data->FontSize;
    const float font_scale = font_size / font->FontSize;
    const char *text_end_ellipsis = NULL;
    const float ellipsis_width = font->EllipsisWidth * font_scale;

    // We can now claim the space between pos_max.x and ellipsis_max.x
    const float text_avail_width = Max(
        (Max(pos_max.x, ellipsis_max_x) - ellipsis_width) - pos_min.x, 1.0f);
    float text_size_clipped_x =
        font->CalcTextSizeA(font_size, text_avail_width, 0.0f, text,
                            text_end_full, &text_end_ellipsis)
            .x;
    if (text == text_end_ellipsis && text_end_ellipsis < text_end_full) {
      // Always display at least 1 character if there's no room for character +
      // ellipsis
      text_end_ellipsis =
          text + TextCountUtf8BytesFromChar(text, text_end_full);
      text_size_clipped_x =
          font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, text, text_end_ellipsis)
              .x;
    }
    while (text_end_ellipsis > text && CharIsBlankA(text_end_ellipsis[-1])) {
      // Trim trailing space before ellipsis (FIXME: Supporting non-ascii blanks
      // would be nice, for this we need a function to backtrack in UTF-8 text)
      text_end_ellipsis--;
      text_size_clipped_x -=
          font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, text_end_ellipsis,
                              text_end_ellipsis + 1)
              .x; // Ascii blanks are always 1 byte
    }

    // Render text, render ellipsis
    RenderTextClippedEx(draw_list, pos_min, Vec2(clip_max_x, pos_max.y), text,
                        text_end_ellipsis, &text_size, Vec2(0.0f, 0.0f));
    Vec2 ellipsis_pos = Trunc(Vec2(pos_min.x + text_size_clipped_x, pos_min.y));
    if (ellipsis_pos.x + ellipsis_width <= ellipsis_max_x)
      for (int i = 0; i < font->EllipsisCharCount;
           i++, ellipsis_pos.x += font->EllipsisCharStep * font_scale)
        font->RenderChar(draw_list, font_size, ellipsis_pos,
                         GetColorU32(Col_Text), font->EllipsisChar);
  } else {
    RenderTextClippedEx(draw_list, pos_min, Vec2(clip_max_x, pos_max.y), text,
                        text_end_full, &text_size, Vec2(0.0f, 0.0f));
  }

  if (g.LogEnabled)
    LogRenderedText(&pos_min, text, text_end_full);
}

// Render a rectangle shaped with optional rounding and borders
inline void Gui::RenderFrame(Vec2 p_min, Vec2 p_max, U32 fill_col, bool border,
                             float rounding) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
  const float border_size = g.Style.FrameBorderSize;
  if (border && border_size > 0.0f) {
    window->DrawList->AddRect(Add(p_min, Vec2(1, 1)), Add(p_max, Vec2(1, 1)),
                              GetColorU32(Col_BorderShadow), rounding, 0,
                              border_size);
    window->DrawList->AddRect(p_min, p_max, GetColorU32(Col_Border), rounding,
                              0, border_size);
  }
}

inline void Gui::RenderFrameBorder(Vec2 p_min, Vec2 p_max, float rounding) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  const float border_size = g.Style.FrameBorderSize;
  if (border_size > 0.0f) {
    window->DrawList->AddRect(Add(p_min, Vec2(1, 1)), Add(p_max, Vec2(1, 1)),
                              GetColorU32(Col_BorderShadow), rounding, 0,
                              border_size);
    window->DrawList->AddRect(p_min, p_max, GetColorU32(Col_Border), rounding,
                              0, border_size);
  }
}

inline void Gui::RenderNavHighlight(const Rect &bb, ID id,
                                    NavHighlightFlags flags) {
  Context &g = *GGui;
  if (id != g.NavId)
    return;
  if (g.NavDisableHighlight && !(flags & NavHighlightFlags_AlwaysDraw))
    return;
  Window *window = g.CurrentWindow;
  if (window->DC.NavHideHighlightOneFrame)
    return;

  float rounding =
      (flags & NavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
  Rect display_rect = bb;
  display_rect.ClipWith(window->ClipRect);
  if (flags & NavHighlightFlags_TypeDefault) {
    const float THICKNESS = 2.0f;
    const float DISTANCE = 3.0f + THICKNESS * 0.5f;
    display_rect.Expand(Vec2(DISTANCE, DISTANCE));
    bool fully_visible = window->ClipRect.Contains(display_rect);
    if (!fully_visible)
      window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
    window->DrawList->AddRect(
        Add(display_rect.Min, Vec2(THICKNESS * 0.5f, THICKNESS * 0.5f)),
        Subtract(display_rect.Max, Vec2(THICKNESS * 0.5f, THICKNESS * 0.5f)),
        GetColorU32(Col_NavHighlight), rounding, 0, THICKNESS);
    if (!fully_visible)
      window->DrawList->PopClipRect();
  }
  if (flags & NavHighlightFlags_TypeThin) {
    window->DrawList->AddRect(display_rect.Min, display_rect.Max,
                              GetColorU32(Col_NavHighlight), rounding, 0, 1.0f);
  }
}

inline void Gui::RenderMouseCursor(Vec2 base_pos, float base_scale,
                                   MouseCursor mouse_cursor, U32 col_fill,
                                   U32 col_border, U32 col_shadow) {
  Context &g = *GGui;
  GUI_ASSERT(mouse_cursor > MouseCursor_None &&
             mouse_cursor < MouseCursor_COUNT);
  FontAtlas *font_atlas = g.DrawListSharedData.Font->ContainerAtlas;
  for (ViewportP *viewport : g.Viewports) {
    // We scale cursor with current viewport/monitor, however Windows 10 for its
    // own hardware cursor seems to be using a different scale factor.
    Vec2 offset, size, uv[4];
    if (!font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0],
                                           &uv[2]))
      continue;
    const Vec2 pos = Subtract(base_pos, offset);
    const float scale = base_scale;
    if (!viewport->GetMainRect().Overlaps(
            Rect(pos, Add(pos, Multiply(Vec2(size.x + 2, size.y + 2), scale)))))
      continue;
    DrawList *draw_list = GetForegroundDrawList(viewport);
    TextureID tex_id = font_atlas->TexID;
    draw_list->PushTextureID(tex_id);
    draw_list->AddImage(tex_id, Add(pos, Multiply(Vec2(1, 0), scale)),
                        Add(pos, Multiply(Add(Vec2(1, 0), size), scale)), uv[2],
                        uv[3], col_shadow);
    draw_list->AddImage(tex_id, Add(pos, Multiply(Vec2(2, 0), scale)),
                        Add(pos, Multiply(Add(Vec2(2, 0), size), scale)), uv[2],
                        uv[3], col_shadow);
    draw_list->AddImage(tex_id, pos, Add(pos, Multiply(size, scale)), uv[2],
                        uv[3], col_border);
    draw_list->AddImage(tex_id, pos, Add(pos, Multiply(size, scale)), uv[0],
                        uv[1], col_fill);
    draw_list->PopTextureID();
  }
}

//-----------------------------------------------------------------------------
// [SECTION] INITIALIZATION, SHUTDOWN
//-----------------------------------------------------------------------------

// Internal state access - if you want to share Dear Gui state between modules
// (e.g. DLL) or allocate it yourself Note that we still point to some static
// data and members (such as GFontAtlas), so the state instance you end up using
// will point to the static data within its module
inline Context *Gui::GetCurrentContext() { return GGui; }

inline void Gui::SetCurrentContext(Context *ctx) {
#ifdef GUI_SET_CURRENT_CONTEXT_FUNC
  GUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you
                                     // may want to have control over this.
#else
  GGui = ctx;
#endif
}

inline void Gui::SetAllocatorFunctions(MemAllocFunc alloc_func,
                                       MemFreeFunc free_func, void *user_data) {
  GAllocatorAllocFunc = alloc_func;
  GAllocatorFreeFunc = free_func;
  GAllocatorUserData = user_data;
}

// This is provided to facilitate copying allocators from one static/DLL
// boundary to another (e.g. retrieve default allocator of your executable
// address space)
inline void Gui::GetAllocatorFunctions(MemAllocFunc *p_alloc_func,
                                       MemFreeFunc *p_free_func,
                                       void **p_user_data) {
  *p_alloc_func = GAllocatorAllocFunc;
  *p_free_func = GAllocatorFreeFunc;
  *p_user_data = GAllocatorUserData;
}

inline Context *Gui::CreateContext(FontAtlas *shared_font_atlas) {
  Context *prev_ctx = GetCurrentContext();
  Context *ctx = GUI_NEW(Context)(shared_font_atlas);
  SetCurrentContext(ctx);
  Initialize();
  if (prev_ctx != NULL)
    SetCurrentContext(
        prev_ctx); // Restore previous context if any, else keep new one.
  return ctx;
}

inline void Gui::DestroyContext(Context *ctx) {
  Context *prev_ctx = GetCurrentContext();
  if (ctx == NULL) //-V1051
    ctx = prev_ctx;
  SetCurrentContext(ctx);
  Shutdown();
  SetCurrentContext((prev_ctx != ctx) ? prev_ctx : NULL);
  GUI_DELETE(ctx);
}

// IMPORTANT: ###xxx suffixes must be same in ALL languages
static const LocEntry GLocalizationEntriesEnUS[] = {
    {LocKey_VersionStr,
     "Dear Gui " GUI_VERSION " (" GUI_STRINGIFY(GUI_VERSION_NUM) ")"},
    {LocKey_TableSizeOne, "Size column to fit###SizeOne"},
    {LocKey_TableSizeAllFit, "Size all columns to fit###SizeAll"},
    {LocKey_TableSizeAllDefault, "Size all columns to default###SizeAll"},
    {LocKey_TableResetOrder, "Reset order###ResetOrder"},
    {LocKey_WindowingMainMenuBar, "(Main menu bar)"},
    {LocKey_WindowingPopup, "(Popup)"},
    {LocKey_WindowingUntitled, "(Untitled)"},
};

inline void Gui::Initialize() {
  Context &g = *GGui;
  GUI_ASSERT(!g.Initialized && !g.SettingsLoaded);

  // Add .ini handle for Window and Table types
  {
    SettingsHandler ini_handler;
    ini_handler.TypeName = "Window";
    ini_handler.TypeHash = HashStr("Window");
    ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
    ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
    ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
    ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
    ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
    AddSettingsHandler(&ini_handler);
  }
  TableSettingsAddSettingsHandler();

  // Setup default localization table
  LocalizeRegisterEntries(GLocalizationEntriesEnUS,
                          GUI_ARRAYSIZE(GLocalizationEntriesEnUS));

  // Setup default platform clipboard/IME handlers.
  g.IO.GetClipboardTextFn =
      GetClipboardTextFn_DefaultImpl; // Platform dependent default
                                      // implementations
  g.IO.SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
  g.IO.ClipboardUserData =
      (void *)&g; // Default implementation use the Context as user data
                  // (ideally those would be arguments to the function)
  g.IO.SetPlatformImeDataFn = SetPlatformImeDataFn_DefaultImpl;

  // Create default viewport
  ViewportP *viewport = GUI_NEW(ViewportP)();
  g.Viewports.push_back(viewport);
  g.TempBuffer.resize(1024 * 3 + 1, 0);

#ifdef GUI_HAS_DOCK
#endif

  g.Initialized = true;
}

// This function is merely here to free heap allocations.
inline void Gui::Shutdown() {
  // The fonts atlas can be used prior to calling NewFrame(), so we clear it
  // even if g.Initialized is FALSE (which would happen if we never called
  // NewFrame)
  Context &g = *GGui;
  if (g.IO.Fonts && g.FontAtlasOwnedByContext) {
    g.IO.Fonts->Locked = false;
    GUI_DELETE(g.IO.Fonts);
  }
  g.IO.Fonts = NULL;
  g.DrawListSharedData.TempBuffer.clear();

  // Cleanup of other data are conditional on actually having initialized Dear
  // Gui.
  if (!g.Initialized)
    return;

  // Save settings (unless we haven't attempted to load them:
  // CreateContext/DestroyContext without a call to NewFrame shouldn't save an
  // empty file)
  if (g.SettingsLoaded && g.IO.IniFilename != NULL)
    SaveIniSettingsToDisk(g.IO.IniFilename);

  CallContextHooks(&g, ContextHookType_Shutdown);

  // Clear everything else
  g.Windows.clear_delete();
  g.WindowsFocusOrder.clear();
  g.WindowsTempSortBuffer.clear();
  g.CurrentWindow = NULL;
  g.CurrentWindowStack.clear();
  g.WindowsById.Clear();
  g.NavWindow = NULL;
  g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;
  g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;
  g.MovingWindow = NULL;

  g.KeysRoutingTable.Clear();

  g.ColorStack.clear();
  g.StyleVarStack.clear();
  g.FontStack.clear();
  g.OpenPopupStack.clear();
  g.BeginPopupStack.clear();
  g.NavTreeNodeStack.clear();

  g.Viewports.clear_delete();

  g.TabBars.Clear();
  g.CurrentTabBarStack.clear();
  g.ShrinkWidthBuffer.clear();

  g.ClipperTempData.clear_destruct();

  g.Tables.Clear();
  g.TablesTempData.clear_destruct();
  g.DrawChannelsTempMergeBuffer.clear();

  g.ClipboardHandlerData.clear();
  g.MenusIdSubmittedThisFrame.clear();
  g.InputTextState.ClearFreeMemory();
  g.InputTextDeactivatedState.ClearFreeMemory();

  g.SettingsWindows.clear();
  g.SettingsHandlers.clear();

  if (g.LogFile) {
#ifndef GUI_DISABLE_TTY_FUNCTIONS
    if (g.LogFile != stdout)
#endif
      FileClose(g.LogFile);
    g.LogFile = NULL;
  }
  g.LogBuffer.clear();
  g.DebugLogBuf.clear();
  g.DebugLogIndex.clear();

  g.Initialized = false;
}

// No specific ordering/dependency support, will see as needed
inline ID Gui::AddContextHook(Context *ctx, const ContextHook *hook) {
  Context &g = *ctx;
  GUI_ASSERT(hook->Callback != NULL && hook->HookId == 0 &&
             hook->Type != ContextHookType_PendingRemoval_);
  g.Hooks.push_back(*hook);
  g.Hooks.back().HookId = ++g.HookIdNext;
  return g.HookIdNext;
}

// Deferred removal, avoiding issue with changing vector while iterating it
inline void Gui::RemoveContextHook(Context *ctx, ID hook_id) {
  Context &g = *ctx;
  GUI_ASSERT(hook_id != 0);
  for (ContextHook &hook : g.Hooks)
    if (hook.HookId == hook_id)
      hook.Type = ContextHookType_PendingRemoval_;
}

// Call context hooks (used by e.g. test engine)
// We assume a small number of hooks so all stored in same array

//-----------------------------------------------------------------------------
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
//-----------------------------------------------------------------------------

// Window is mostly a dumb struct. It merely has a constructor and a few
// helper methods
inline Window::Window(Context *ctx, const char *name) : DrawListInst(NULL) {
  memset(this, 0, sizeof(*this));
  Ctx = ctx;
  Name = Strdup(name);
  NameBufLen = (int)strlen(name) + 1;
  ID = HashStr(name);
  IDStack.push_back(ID);
  MoveId = GetID("#MOVE");
  ScrollTarget = Vec2(FLT_MAX, FLT_MAX);
  ScrollTargetCenterRatio = Vec2(0.5f, 0.5f);
  AutoFitFramesX = AutoFitFramesY = -1;
  AutoPosLastDirection = Dir_None;
  SetWindowPosAllowFlags = SetWindowSizeAllowFlags =
      SetWindowCollapsedAllowFlags = 0;
  SetWindowPosVal = SetWindowPosPivot = Vec2(FLT_MAX, FLT_MAX);
  LastFrameActive = -1;
  LastTimeActive = -1.0f;
  FontWindowScale = 1.0f;
  SettingsOffset = -1;
  DrawList = &DrawListInst;
  DrawList->_Data = &Ctx->DrawListSharedData;
  DrawList->_OwnerName = Name;
  NavPreferredScoringPosRel[0] = NavPreferredScoringPosRel[1] =
      Vec2(FLT_MAX, FLT_MAX);
}

inline Window::~Window() {
  GUI_ASSERT(DrawList == &DrawListInst);
  GUI_DELETE(Name);
  ColumnsStorage.clear_destruct();
}

inline ID Window::GetID(const char *str, const char *str_end) {
  ::ID seed = IDStack.back();
  ::ID id = HashStr(str, str_end ? (str_end - str) : 0, seed);
  Context &g = *Ctx;
  if (g.DebugHookIdInfo == id)
    Gui::DebugHookIdInfo(id, DataType_String, str, str_end);
  return id;
}

inline ID Window::GetID(const void *ptr) {
  ::ID seed = IDStack.back();
  ::ID id = HashData(&ptr, sizeof(void *), seed);
  Context &g = *Ctx;
  if (g.DebugHookIdInfo == id)
    Gui::DebugHookIdInfo(id, DataType_Pointer, ptr, NULL);
  return id;
}

inline ID Window::GetID(int n) {
  ::ID seed = IDStack.back();
  ::ID id = HashData(&n, sizeof(n), seed);
  Context &g = *Ctx;
  if (g.DebugHookIdInfo == id)
    Gui::DebugHookIdInfo(id, DataType_S32, (void *)(intptr_t)n, NULL);
  return id;
}

// This is only used in rare/specific situations to manufacture an ID out of
// nowhere.
inline ID Window::GetIDFromRectangle(const ::Rect &r_abs) {
  ::ID seed = IDStack.back();
  ::Rect r_rel = Gui::WindowRectAbsToRel(this, r_abs);
  ::ID id = HashData(&r_rel, sizeof(r_rel), seed);
  return id;
}

static void SetCurrentWindow(Window *window) {
  Context &g = *GGui;
  g.CurrentWindow = window;
  g.CurrentTable = window && window->DC.CurrentTableIdx != -1
                       ? g.Tables.GetByIndex(window->DC.CurrentTableIdx)
                       : NULL;
  if (window) {
    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
    Gui::NavUpdateCurrentWindowIsScrollPushableX();
  }
}

// Free up/compact internal window buffers, we can use this when a window
// becomes unused. Not freed:
// - Window, WindowSettings, Name, StateStorage, ColumnsStorage (may
// hold useful data) This should have no noticeable visual effect. When the
// window reappear however, expect new allocation/buffer growth/copy cost.

inline void Gui::SetActiveID(ID id, Window *window) {
  Context &g = *GGui;

  // Clear previous active id
  if (g.ActiveId != 0) {
    // While most behaved code would make an effort to not steal active id
    // during window move/drag operations, we at least need to be resilient to
    // it. Canceling the move is rather aggressive and users of 'master' branch
    // may prefer the weird ill-defined half working situation ('docking' did
    // assert), so may need to rework that.
    if (g.MovingWindow != NULL && g.ActiveId == g.MovingWindow->MoveId) {
      GUI_DEBUG_LOG_ACTIVEID("SetActiveID() cancel MovingWindow\n");
      g.MovingWindow = NULL;
    }

    // This could be written in a more general way (e.g associate a hook to
    // ActiveId), but since this is currently quite an exception we'll leave it
    // as is. One common scenario leading to this is: pressing Key
    // ->NavMoveRequestApplyResult() -> ClearActiveId()
    if (g.InputTextState.ID == g.ActiveId)
      InputTextDeactivateHook(g.ActiveId);
  }

  // Set active id
  g.ActiveIdIsJustActivated = (g.ActiveId != id);
  if (g.ActiveIdIsJustActivated) {
    GUI_DEBUG_LOG_ACTIVEID("SetActiveID() old:0x%08X (window \"%s\") -> "
                           "new:0x%08X (window \"%s\")\n",
                           g.ActiveId,
                           g.ActiveIdWindow ? g.ActiveIdWindow->Name : "", id,
                           window ? window->Name : "");
    g.ActiveIdTimer = 0.0f;
    g.ActiveIdHasBeenPressedBefore = false;
    g.ActiveIdHasBeenEditedBefore = false;
    g.ActiveIdMouseButton = -1;
    if (id != 0) {
      g.LastActiveId = id;
      g.LastActiveIdTimer = 0.0f;
    }
  }
  g.ActiveId = id;
  g.ActiveIdAllowOverlap = false;
  g.ActiveIdNoClearOnFocusLoss = false;
  g.ActiveIdWindow = window;
  g.ActiveIdHasBeenEditedThisFrame = false;
  if (id) {
    g.ActiveIdIsAlive = id;
    g.ActiveIdSource = (g.NavActivateId == id || g.NavJustMovedToId == id)
                           ? g.NavInputSource
                           : InputSource_Mouse;
    GUI_ASSERT(g.ActiveIdSource != InputSource_None);
  }

  // Clear declaration of inputs claimed by the widget
  // (Please note that this is WIP and not all keys/inputs are thoroughly
  // declared by all widgets yet)
  g.ActiveIdUsingNavDirMask = 0x00;
  g.ActiveIdUsingAllKeyboardKeys = false;
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  g.ActiveIdUsingNavInputMask = 0x00;
#endif
}

// This is called by ItemAdd().
// Code not using ItemAdd() may need to call this manually otherwise ActiveId
// will be cleared. In GUI_VERSION_NUM < 18717 this was called by GetID().

inline void Gui::MarkItemEdited(ID id) {
  // This marking is solely to be able to provide info for
  // IsItemDeactivatedAfterEdit(). ActiveId might have been released by the time
  // we call this (as in the typical press/release button behavior) but still
  // need to fill the data.
  Context &g = *GGui;
  if (g.LockMarkEdited > 0)
    return;
  if (g.ActiveId == id || g.ActiveId == 0) {
    g.ActiveIdHasBeenEditedThisFrame = true;
    g.ActiveIdHasBeenEditedBefore = true;
  }

  // We accept a MarkItemEdited() on drag and drop targets (see
  // https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343) We
  // accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit
  // after it has been taken ActiveId away (#4714)
  GUI_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 ||
             g.ActiveIdPreviousFrame == id);

  // GUI_ASSERT(g.CurrentWindow->DC.LastItemId == id);
  g.LastItemData.StatusFlags |= ItemStatusFlags_Edited;
}

static inline float CalcDelayFromHoveredFlags(HoveredFlags flags) {
  Context &g = *GGui;
  if (flags & HoveredFlags_DelayNormal)
    return g.Style.HoverDelayNormal;
  if (flags & HoveredFlags_DelayShort)
    return g.Style.HoverDelayShort;
  return 0.0f;
}

static HoveredFlags ApplyHoverFlagsForTooltip(HoveredFlags user_flags,
                                              HoveredFlags shared_flags) {
  // Allow instance flags to override shared flags
  if (user_flags & (HoveredFlags_DelayNone | HoveredFlags_DelayShort |
                    HoveredFlags_DelayNormal))
    shared_flags &= ~(HoveredFlags_DelayNone | HoveredFlags_DelayShort |
                      HoveredFlags_DelayNormal);
  return user_flags | shared_flags;
}

// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that
// clicking on non-interactive items such as a Text() item still returns true
// with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we
// cannot use LastItemId
inline bool Gui::IsItemHovered(HoveredFlags flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_ASSERT((flags & ~HoveredFlags_AllowedMaskForIsItemHovered) == 0 &&
             "Invalid flags for IsItemHovered()!");

  if (g.NavDisableMouseHover && !g.NavDisableHighlight &&
      !(flags & HoveredFlags_NoNavOverride)) {
    if ((g.LastItemData.InFlags & ItemFlags_Disabled) &&
        !(flags & HoveredFlags_AllowWhenDisabled))
      return false;
    if (!IsItemFocused())
      return false;

    if (flags & HoveredFlags_ForTooltip)
      flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipNav);
  } else {
    // Test for bounding box overlap, as updated as ItemAdd()
    ItemStatusFlags status_flags = g.LastItemData.StatusFlags;
    if (!(status_flags & ItemStatusFlags_HoveredRect))
      return false;

    if (flags & HoveredFlags_ForTooltip)
      flags =
          ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);

    GUI_ASSERT(
        (flags & (HoveredFlags_AnyWindow | HoveredFlags_RootWindow |
                  HoveredFlags_ChildWindows | HoveredFlags_NoPopupHierarchy)) ==
        0); // Flags not supported by this function

    // Done with rectangle culling so we can perform heavier checks now
    // Test if we are hovering the right window (our window could be behind
    // another window) [2021/03/02] Reworked / reverted the revert, finally.
    // Note we want e.g. BeginGroup/ItemAdd/EndGroup to work as well. (#3851)
    // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I
    // believe it is correct to NOT test for RootWindow but this leaves us
    // unable to use IsItemHovered() after EndChild() itself. Until a solution
    // is found I believe reverting to the test from 2017/09/27 is safe since
    // this was the test that has been running for a long while.
    if (g.HoveredWindow != window &&
        (status_flags & ItemStatusFlags_HoveredWindow) == 0)
      if ((flags & HoveredFlags_AllowWhenOverlappedByWindow) == 0)
        return false;

    // Test if another item is active (e.g. being dragged)
    const ID id = g.LastItemData.ID;
    if ((flags & HoveredFlags_AllowWhenBlockedByActiveItem) == 0)
      if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap &&
          g.ActiveId != window->MoveId)
        return false;

    // Test if interactions on this window are blocked by an active popup or
    // modal. The HoveredFlags_AllowWhenBlockedByPopup flag will be tested
    // here.
    if (!IsWindowContentHoverable(window, flags) &&
        !(g.LastItemData.InFlags & ItemFlags_NoWindowHoverableCheck))
      return false;

    // Test if the item is disabled
    if ((g.LastItemData.InFlags & ItemFlags_Disabled) &&
        !(flags & HoveredFlags_AllowWhenDisabled))
      return false;

    // Special handling for calling after Begin() which represent the title bar
    // or tab. When the window is skipped/collapsed (SkipItems==true) that last
    // item will never be overwritten so we need to detect the case.
    if (id == window->MoveId && window->WriteAccessed)
      return false;

    // Test if using AllowOverlap and overlapped
    if ((g.LastItemData.InFlags & ItemFlags_AllowOverlap) && id != 0)
      if ((flags & HoveredFlags_AllowWhenOverlappedByItem) == 0)
        if (g.HoveredIdPreviousFrame != g.LastItemData.ID)
          return false;
  }

  // Handle hover delay
  // (some ideas: https://www.nngroup.com/articles/timing-exposing-content)
  const float delay = CalcDelayFromHoveredFlags(flags);
  if (delay > 0.0f || (flags & HoveredFlags_Stationary)) {
    ID hover_delay_id = (g.LastItemData.ID != 0)
                            ? g.LastItemData.ID
                            : window->GetIDFromRectangle(g.LastItemData.Rect);
    if ((flags & HoveredFlags_NoSharedDelay) &&
        (g.HoverItemDelayIdPreviousFrame != hover_delay_id))
      g.HoverItemDelayTimer = 0.0f;
    g.HoverItemDelayId = hover_delay_id;

    // When changing hovered item we requires a bit of stationary delay before
    // activating hover timer, but once unlocked on a given item we also moving.
    // if (g.HoverDelayTimer >= delay && (g.HoverDelayTimer - g.IO.DeltaTime <
    // delay || g.MouseStationaryTimer - g.IO.DeltaTime <
    // g.Style.HoverStationaryDelay)) { GUI_DEBUG_LOG("HoverDelayTimer =
    // %f/%f, MouseStationaryTimer = %f\n", g.HoverDelayTimer, delay,
    // g.MouseStationaryTimer); }
    if ((flags & HoveredFlags_Stationary) != 0 &&
        g.HoverItemUnlockedStationaryId != hover_delay_id)
      return false;

    if (g.HoverItemDelayTimer < delay)
      return false;
  }

  return true;
}

// Internal facing ItemHoverable() used when submitting widgets. Differs
// slightly from IsItemHovered(). (this does not rely on LastItemData it can be
// called from a ButtonBehavior() call not following an ItemAdd() call)
// FIXME-LEGACY: the 'ItemFlags item_flags' parameter was added on
// 2023-06-28. If you used this in your legacy/custom widgets code:
// - Commonly: if your ItemHoverable() call comes after an ItemAdd() call: pass
// 'item_flags = g.LastItemData.InFlags'.
// - Rare: otherwise you may pass 'item_flags = 0' (ItemFlags_None) unless
// you want to benefit from special behavior handled by ItemHoverable.
inline bool Gui::ItemHoverable(const Rect &bb, ID id, ItemFlags item_flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (g.HoveredWindow != window)
    return false;
  if (!IsMouseHoveringRect(bb.Min, bb.Max))
    return false;

  if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
    return false;
  if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
    return false;

  // Done with rectangle culling so we can perform heavier checks now.
  if (!(item_flags & ItemFlags_NoWindowHoverableCheck) &&
      !IsWindowContentHoverable(window, HoveredFlags_None)) {
    g.HoveredIdDisabled = true;
    return false;
  }

  // We exceptionally allow this function to be called with id==0 to allow using
  // it for easy high-level hover test in widgets code. We could also decide to
  // split this function is two.
  if (id != 0) {
    // Drag source doesn't report as hovered
    if (g.DragDropActive && g.DragDropPayload.SourceId == id &&
        !(g.DragDropSourceFlags & DragDropFlags_SourceNoDisableHover))
      return false;

    SetHoveredID(id);

    // AllowOverlap mode (rarely used) requires previous frame HoveredId to be
    // null or to match. This allows using patterns where a later submitted
    // widget overlaps a previous one. Generally perceived as a front-to-back
    // hit-test.
    if (item_flags & ItemFlags_AllowOverlap) {
      g.HoveredIdAllowOverlap = true;
      if (g.HoveredIdPreviousFrame != id)
        return false;
    }
  }

  // When disabled we'll return false but still set HoveredId
  if (item_flags & ItemFlags_Disabled) {
    // Release active id if turning disabled
    if (g.ActiveId == id && id != 0)
      ClearActiveID();
    g.HoveredIdDisabled = true;
    return false;
  }

  if (id != 0) {
    // [DEBUG] Item Picker tool!
    // We perform the check here because SetHoveredID() is not frequently called
    // (1~ time a frame), making the cost of this tool near-zero. We can get
    // slightly better call-stack and support picking non-hovered items if we
    // performed the test in ItemAdd(), but that would incur a small runtime
    // cost.
    if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id)
      GetForegroundDrawList()->AddRect(bb.Min, bb.Max,
                                       GUI_COL32(255, 255, 0, 255));
    if (g.DebugItemPickerBreakId == id)
      GUI_DEBUG_BREAK();
  }

  if (g.NavDisableMouseHover)
    return false;

  return true;
}

// FIXME: This is inlined/duplicated in ItemAdd()

// This is also inlined in ItemAdd()
// Note: if ItemStatusFlags_HasDisplayRect is set, user needs to set
// g.LastItemData.DisplayRect.

// GUI_ALLOC() == Gui::MemAlloc()
inline void *Gui::MemAlloc(size_t size) {
  void *ptr = (*GAllocatorAllocFunc)(size, GAllocatorUserData);
#ifndef GUI_DISABLE_DEBUG_TOOLS
  if (Context *ctx = GGui)
    DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, size);
#endif
  return ptr;
}

// GUI_FREE() == Gui::MemFree()
inline void Gui::MemFree(void *ptr) {
#ifndef GUI_DISABLE_DEBUG_TOOLS
  if (ptr != NULL)
    if (Context *ctx = GGui)
      DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, (size_t)-1);
#endif
  return (*GAllocatorFreeFunc)(ptr, GAllocatorUserData);
}

// We record the number of allocation in recent frames, as a way to
// audit/sanitize our guiding principles of "no allocations on idle/repeating
// frames"
inline void Gui::DebugAllocHook(DebugAllocInfo *info, int frame_count,
                                void *ptr, size_t size) {
  DebugAllocEntry *entry = &info->LastEntriesBuf[info->LastEntriesIdx];
  GUI_UNUSED(ptr);
  if (entry->FrameCount != frame_count) {
    info->LastEntriesIdx =
        (info->LastEntriesIdx + 1) % GUI_ARRAYSIZE(info->LastEntriesBuf);
    entry = &info->LastEntriesBuf[info->LastEntriesIdx];
    entry->FrameCount = frame_count;
    entry->AllocCount = entry->FreeCount = 0;
  }
  if (size != (size_t)-1) {
    entry->AllocCount++;
    info->TotalAllocCount++;
    // printf("[%05d] MemAlloc(%d) -> 0x%p\n", frame_count, size, ptr);
  } else {
    entry->FreeCount++;
    info->TotalFreeCount++;
    // printf("[%05d] MemFree(0x%p)\n", frame_count, ptr);
  }
}

inline const char *Gui::GetClipboardText() {
  Context &g = *GGui;
  return g.IO.GetClipboardTextFn
             ? g.IO.GetClipboardTextFn(g.IO.ClipboardUserData)
             : "";
}

inline void Gui::SetClipboardText(const char *text) {
  Context &g = *GGui;
  if (g.IO.SetClipboardTextFn)
    g.IO.SetClipboardTextFn(g.IO.ClipboardUserData, text);
}

inline IO &Gui::GetIO() {
  GUI_ASSERT(GGui != NULL &&
             "No current context. Did you call Gui::CreateContext() and "
             "Gui::SetCurrentContext() ?");
  return GGui->IO;
}

// Pass this to your backend rendering function! Valid after Render() and until
// the next call to NewFrame()
inline DrawData *Gui::GetDrawData() {
  Context &g = *GGui;
  ViewportP *viewport = g.Viewports[0];
  return viewport->DrawDataP.Valid ? &viewport->DrawDataP : NULL;
}

inline double Gui::GetTime() { return GGui->Time; }

inline int Gui::GetFrameCount() { return GGui->FrameCount; }

static DrawList *GetViewportBgFgDrawList(ViewportP *viewport,
                                         size_t drawlist_no,
                                         const char *drawlist_name) {
  // Create the draw list on demand, because they are not frequently used for
  // all viewports
  Context &g = *GGui;
  GUI_ASSERT(drawlist_no < GUI_ARRAYSIZE(viewport->BgFgDrawLists));
  DrawList *draw_list = viewport->BgFgDrawLists[drawlist_no];
  if (draw_list == NULL) {
    draw_list = GUI_NEW(DrawList)(&g.DrawListSharedData);
    draw_list->_OwnerName = drawlist_name;
    viewport->BgFgDrawLists[drawlist_no] = draw_list;
  }

  // Our DrawList system requires that there is always a command
  if (viewport->BgFgDrawListsLastFrame[drawlist_no] != g.FrameCount) {
    draw_list->_ResetForNewFrame();
    draw_list->PushTextureID(g.IO.Fonts->TexID);
    draw_list->PushClipRect(viewport->Pos, Add(viewport->Pos, viewport->Size),
                            false);
    viewport->BgFgDrawListsLastFrame[drawlist_no] = g.FrameCount;
  }
  return draw_list;
}

inline DrawList *Gui::GetBackgroundDrawList(Viewport *viewport) {
  return GetViewportBgFgDrawList((ViewportP *)viewport, 0, "##Background");
}

inline DrawList *Gui::GetBackgroundDrawList() {
  Context &g = *GGui;
  return GetBackgroundDrawList(g.Viewports[0]);
}

inline DrawList *Gui::GetForegroundDrawList(Viewport *viewport) {
  return GetViewportBgFgDrawList((ViewportP *)viewport, 1, "##Foreground");
}

inline DrawList *Gui::GetForegroundDrawList() {
  Context &g = *GGui;
  return GetForegroundDrawList(g.Viewports[0]);
}

inline DrawListSharedData *Gui::GetDrawListSharedData() {
  return &GGui->DrawListSharedData;
}

inline void Gui::StartMouseMovingWindow(Window *window) {
  // Set ActiveId even if the _NoMove flag is set. Without it, dragging away
  // from a window with _NoMove would activate hover on other windows. We _also_
  // call this when clicking in a window empty space when
  // io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow
  // afterward. This is because we want ActiveId to be set even when the window
  // is not permitted to move.
  Context &g = *GGui;
  FocusWindow(window);
  SetActiveID(window->MoveId, window);
  g.NavDisableHighlight = true;
  g.ActiveIdClickOffset =
      Subtract(g.IO.MouseClickedPos[0], window->RootWindow->Pos);
  g.ActiveIdNoClearOnFocusLoss = true;
  SetActiveIdUsingAllKeyboardKeys();

  bool can_move_window = true;
  if ((window->Flags & WindowFlags_NoMove) ||
      (window->RootWindow->Flags & WindowFlags_NoMove))
    can_move_window = false;
  if (can_move_window)
    g.MovingWindow = window;
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB +
// Arrows) are processed in NavUpdateWindowing()
// FIXME: We don't have strong guarantee that g.MovingWindow stay synched with
// g.ActiveId == g.MovingWindow->MoveId. This is currently enforced by the fact
// that BeginDragDropSource() is setting all g.ActiveIdUsingXXXX flags to
// inhibit navigation inputs, but if we should more thoroughly test cases where
// g.ActiveId or g.MovingWindow gets changed and not the other.
inline void Gui::UpdateMouseMovingWindowNewFrame() {
  Context &g = *GGui;
  if (g.MovingWindow != NULL) {
    // We actually want to move the root window. g.MovingWindow == window we
    // clicked on (could be a child window). We track it to preserve Focus and
    // so that generally ActiveIdWindow == MovingWindow and ActiveId ==
    // MovingWindow->MoveId for consistency.
    KeepAliveID(g.ActiveId);
    GUI_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);
    Window *moving_window = g.MovingWindow->RootWindow;
    if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos)) {
      Vec2 pos = Subtract(g.IO.MousePos, g.ActiveIdClickOffset);
      SetWindowPos(moving_window, pos, Cond_Always);
      FocusWindow(g.MovingWindow);
    } else {
      g.MovingWindow = NULL;
      ClearActiveID();
    }
  } else {
    // When clicking/dragging from a window that has the _NoMove flag, we still
    // set the ActiveId in order to prevent hovering others.
    if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId) {
      KeepAliveID(g.ActiveId);
      if (!g.IO.MouseDown[0])
        ClearActiveID();
    }
  }
}

// Initiate moving window when clicking on empty space or title bar.
// Handle left-click and right-click focus.
inline void Gui::UpdateMouseMovingWindowEndFrame() {
  Context &g = *GGui;
  if (g.ActiveId != 0 || g.HoveredId != 0)
    return;

  // Unless we just made a window/popup appear
  if (g.NavWindow && g.NavWindow->Appearing)
    return;

  // Click on empty space to focus window and start moving
  // (after we're done with all our widgets)
  if (g.IO.MouseClicked[0]) {
    // Handle the edge case of a popup being closed while clicking in its empty
    // space. If we try to focus it, FocusWindow() > ClosePopupsOverWindow()
    // will accidentally close any parent popups because they are not linked
    // together any more.
    Window *root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;
    const bool is_closed_popup =
        root_window && (root_window->Flags & WindowFlags_Popup) &&
        !IsPopupOpen(root_window->PopupId, PopupFlags_AnyPopupLevel);

    if (root_window != NULL && !is_closed_popup) {
      StartMouseMovingWindow(g.HoveredWindow); //-V595

      // Cancel moving if clicked outside of title bar
      if (g.IO.ConfigWindowsMoveFromTitleBarOnly &&
          !(root_window->Flags & WindowFlags_NoTitleBar))
        if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
          g.MovingWindow = NULL;

      // Cancel moving if clicked over an item which was disabled or inhibited
      // by popups (note that we know HoveredId == 0 already)
      if (g.HoveredIdDisabled)
        g.MovingWindow = NULL;
    } else if (root_window == NULL && g.NavWindow != NULL) {
      // Clicking on void disable focus
      FocusWindow(NULL, FocusRequestFlags_UnlessBelowModal);
    }
  }

  // With right mouse button we close popups without changing focus based on
  // where the mouse is aimed Instead, focus will be restored to the window
  // under the bottom-most closed popup. (The left mouse button path calls
  // FocusWindow on the hovered window, which will lead
  // NewFrame->ClosePopupsOverWindow to trigger)
  if (g.IO.MouseClicked[1]) {
    // Find the top-most window between HoveredWindow and the top-most Modal
    // Window. This is where we can trim the popup stack.
    Window *modal = GetTopMostPopupModal();
    bool hovered_window_above_modal =
        g.HoveredWindow &&
        (modal == NULL || IsWindowAbove(g.HoveredWindow, modal));
    ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal,
                          true);
  }
}

static bool IsWindowActiveAndVisible(Window *window) {
  return (window->Active) && (!window->Hidden);
}

// The reason this is exposed in gui_internal.hpp is: on touch-based system that
// don't have hovering, we want to dispatch inputs to the right target (imgui vs
// gui+app)
inline void Gui::UpdateHoveredWindowAndCaptureFlags() {
  Context &g = *GGui;
  IO &io = g.IO;
  g.WindowsHoverPadding =
      Max(g.Style.TouchExtraPadding,
          Vec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));

  // Find the window hovered by mouse:
  // - Child windows can extend beyond the limit of their parent so we need to
  // derive HoveredRootWindow from HoveredWindow.
  // - When moving a window we can skip the search, which also conveniently
  // bypasses the fact that window->WindowRectClipped is lagging as this point
  // of the frame.
  // - We also support the moved window toggling the NoInputs flag after moving
  // has started in order to be able to detect windows below it, which is useful
  // for e.g. docking mechanisms.
  bool clear_hovered_windows = false;
  FindHoveredWindow();

  // Modal windows prevents mouse from hovering behind them.
  Window *modal_window = GetTopMostPopupModal();
  if (modal_window && g.HoveredWindow &&
      !IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, modal_window))
    clear_hovered_windows = true;

  // Disabled mouse?
  if (io.ConfigFlags & ConfigFlags_NoMouse)
    clear_hovered_windows = true;

  // We track click ownership. When clicked outside of a window the click is
  // owned by the application and won't report hovering nor request capture even
  // while dragging over our windows afterward.
  const bool has_open_popup = (g.OpenPopupStack.Size > 0);
  const bool has_open_modal = (modal_window != NULL);
  int mouse_earliest_down = -1;
  bool mouse_any_down = false;
  for (int i = 0; i < GUI_ARRAYSIZE(io.MouseDown); i++) {
    if (io.MouseClicked[i]) {
      io.MouseDownOwned[i] = (g.HoveredWindow != NULL) || has_open_popup;
      io.MouseDownOwnedUnlessPopupClose[i] =
          (g.HoveredWindow != NULL) || has_open_modal;
    }
    mouse_any_down |= io.MouseDown[i];
    if (io.MouseDown[i])
      if (mouse_earliest_down == -1 ||
          io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])
        mouse_earliest_down = i;
  }
  const bool mouse_avail =
      (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];
  const bool mouse_avail_unless_popup_close =
      (mouse_earliest_down == -1) ||
      io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];

  // If mouse was first clicked outside of Gui bounds we also cancel out
  // hovering.
  // FIXME: For patterns of drag and drop across OS windows, we may need to
  // rework/remove this test (first committed 311c0ca9 on 2015/02)
  const bool mouse_dragging_extern_payload =
      g.DragDropActive &&
      (g.DragDropSourceFlags & DragDropFlags_SourceExtern) != 0;
  if (!mouse_avail && !mouse_dragging_extern_payload)
    clear_hovered_windows = true;

  if (clear_hovered_windows)
    g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;

  // Update io.WantCaptureMouse for the user application (true = dispatch mouse
  // info to Dear Gui only, false = dispatch mouse to Dear Gui + underlying
  // app) Update io.WantCaptureMouseAllowPopupClose (experimental) to give a
  // chance for app to react to popup closure with a drag
  if (g.WantCaptureMouseNextFrame != -1) {
    io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose =
        (g.WantCaptureMouseNextFrame != 0);
  } else {
    io.WantCaptureMouse =
        (mouse_avail && (g.HoveredWindow != NULL || mouse_any_down)) ||
        has_open_popup;
    io.WantCaptureMouseUnlessPopupClose =
        (mouse_avail_unless_popup_close &&
         (g.HoveredWindow != NULL || mouse_any_down)) ||
        has_open_modal;
  }

  // Update io.WantCaptureKeyboard for the user application (true = dispatch
  // keyboard info to Dear Gui only, false = dispatch keyboard info to Dear
  // Gui + underlying app)
  io.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
  if (io.NavActive && (io.ConfigFlags & ConfigFlags_NavEnableKeyboard) &&
      !(io.ConfigFlags & ConfigFlags_NavNoCaptureKeyboard))
    io.WantCaptureKeyboard = true;
  if (g.WantCaptureKeyboardNextFrame != -1) // Manual override
    io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);

  // Update io.WantTextInput flag, this is to allow systems without a keyboard
  // (e.g. mobile, hand-held) to show a software keyboard if possible
  io.WantTextInput = (g.WantTextInputNextFrame != -1)
                         ? (g.WantTextInputNextFrame != 0)
                         : false;
}

inline void Gui::NewFrame() {
  GUI_ASSERT(GGui != NULL &&
             "No current context. Did you call Gui::CreateContext() and "
             "Gui::SetCurrentContext() ?");
  Context &g = *GGui;

  // Remove pending delete hooks before frame start.
  // This deferred removal avoid issues of removal while iterating the hook
  // vector
  for (int n = g.Hooks.Size - 1; n >= 0; n--)
    if (g.Hooks[n].Type == ContextHookType_PendingRemoval_)
      g.Hooks.erase(&g.Hooks[n]);

  CallContextHooks(&g, ContextHookType_NewFramePre);

  // Check and assert for various common IO and Configuration mistakes
  ErrorCheckNewFrameSanityChecks();

  // Load settings on first frame, save settings when modified (after a delay)
  UpdateSettings();

  g.Time += g.IO.DeltaTime;
  g.WithinFrameScope = true;
  g.FrameCount += 1;
  g.TooltipOverrideCount = 0;
  g.WindowsActiveCount = 0;
  g.MenusIdSubmittedThisFrame.resize(0);

  // Calculate frame-rate for the user, as a purely luxurious feature
  g.FramerateSecPerFrameAccum +=
      g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
  g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
  g.FramerateSecPerFrameIdx =
      (g.FramerateSecPerFrameIdx + 1) % GUI_ARRAYSIZE(g.FramerateSecPerFrame);
  g.FramerateSecPerFrameCount = Min(g.FramerateSecPerFrameCount + 1,
                                    GUI_ARRAYSIZE(g.FramerateSecPerFrame));
  g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f)
                       ? (1.0f / (g.FramerateSecPerFrameAccum /
                                  (float)g.FramerateSecPerFrameCount))
                       : FLT_MAX;

  // Process input queue (trickle as many events as possible), turn events into
  // writes to IO structure
  g.InputEventsTrail.resize(0);
  UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);

  // Update viewports (after processing input queue, so io.MouseHoveredViewport
  // is set)
  UpdateViewportsNewFrame();

  // Setup current font and draw list shared data
  g.IO.Fonts->Locked = true;
  SetCurrentFont(GetDefaultFont());
  GUI_ASSERT(g.Font->IsLoaded());
  Rect virtual_space(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
  for (ViewportP *viewport : g.Viewports)
    virtual_space.Add(viewport->GetMainRect());
  g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();
  g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
  g.DrawListSharedData.SetCircleTessellationMaxError(
      g.Style.CircleTessellationMaxError);
  g.DrawListSharedData.InitialFlags = DrawListFlags_None;
  if (g.Style.AntiAliasedLines)
    g.DrawListSharedData.InitialFlags |= DrawListFlags_AntiAliasedLines;
  if (g.Style.AntiAliasedLinesUseTex &&
      !(g.Font->ContainerAtlas->Flags & FontAtlasFlags_NoBakedLines))
    g.DrawListSharedData.InitialFlags |= DrawListFlags_AntiAliasedLinesUseTex;
  if (g.Style.AntiAliasedFill)
    g.DrawListSharedData.InitialFlags |= DrawListFlags_AntiAliasedFill;
  if (g.IO.BackendFlags & BackendFlags_RendererHasVtxOffset)
    g.DrawListSharedData.InitialFlags |= DrawListFlags_AllowVtxOffset;

  // Mark rendering data as invalid to prevent user who may have a handle on it
  // to use it.
  for (ViewportP *viewport : g.Viewports)
    viewport->DrawDataP.Valid = false;

  // Drag and drop keep the source ID alive so even if the source disappear our
  // state is consistent
  if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
    KeepAliveID(g.DragDropPayload.SourceId);

  // Update HoveredId data
  if (!g.HoveredIdPreviousFrame)
    g.HoveredIdTimer = 0.0f;
  if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
    g.HoveredIdNotActiveTimer = 0.0f;
  if (g.HoveredId)
    g.HoveredIdTimer += g.IO.DeltaTime;
  if (g.HoveredId && g.ActiveId != g.HoveredId)
    g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
  g.HoveredIdPreviousFrame = g.HoveredId;
  g.HoveredId = 0;
  g.HoveredIdAllowOverlap = false;
  g.HoveredIdDisabled = false;

  // Clear ActiveID if the item is not alive anymore.
  // In 1.87, the common most call to KeepAliveID() was moved from GetID() to
  // ItemAdd(). As a result, custom widget using ButtonBehavior() _without_
  // ItemAdd() need to call KeepAliveID() themselves.
  if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId &&
      g.ActiveIdPreviousFrame == g.ActiveId) {
    GUI_DEBUG_LOG_ACTIVEID(
        "NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n");
    ClearActiveID();
  }

  // Update ActiveId data (clear reference to active widget if the widget isn't
  // alive anymore)
  if (g.ActiveId)
    g.ActiveIdTimer += g.IO.DeltaTime;
  g.LastActiveIdTimer += g.IO.DeltaTime;
  g.ActiveIdPreviousFrame = g.ActiveId;
  g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
  g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
  g.ActiveIdIsAlive = 0;
  g.ActiveIdHasBeenEditedThisFrame = false;
  g.ActiveIdPreviousFrameIsAlive = false;
  g.ActiveIdIsJustActivated = false;
  if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)
    g.TempInputId = 0;
  if (g.ActiveId == 0) {
    g.ActiveIdUsingNavDirMask = 0x00;
    g.ActiveIdUsingAllKeyboardKeys = false;
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
    g.ActiveIdUsingNavInputMask = 0x00;
#endif
  }

#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  if (g.ActiveId == 0)
    g.ActiveIdUsingNavInputMask = 0;
  else if (g.ActiveIdUsingNavInputMask != 0) {
    // If your custom widget code used:                 {
    // g.ActiveIdUsingNavInputMask |= (1 << NavInput_Cancel); } Since
    // GUI_VERSION_NUM >= 18804 it should be:   { SetKeyOwner(Key_Escape,
    // g.ActiveId); SetKeyOwner(Key_NavGamepadCancel, g.ActiveId); }
    if (g.ActiveIdUsingNavInputMask & (1 << NavInput_Cancel))
      SetKeyOwner(Key_Escape, g.ActiveId);
    if (g.ActiveIdUsingNavInputMask & ~(1 << NavInput_Cancel))
      GUI_ASSERT(0); // Other values unsupported
  }
#endif

  // Record when we have been stationary as this state is preserved while over
  // same item.
  // FIXME: The way this is expressed means user cannot alter
  // HoverStationaryDelay during the frame to use varying values. To allow this
  // we should store HoverItemMaxStationaryTime+ID and perform the >= check in
  // IsItemHovered() function.
  if (g.HoverItemDelayId != 0 &&
      g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
    g.HoverItemUnlockedStationaryId = g.HoverItemDelayId;
  else if (g.HoverItemDelayId == 0)
    g.HoverItemUnlockedStationaryId = 0;
  if (g.HoveredWindow != NULL &&
      g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
    g.HoverWindowUnlockedStationaryId = g.HoveredWindow->ID;
  else if (g.HoveredWindow == NULL)
    g.HoverWindowUnlockedStationaryId = 0;

  // Update hover delay for IsItemHovered() with delays and tooltips
  g.HoverItemDelayIdPreviousFrame = g.HoverItemDelayId;
  if (g.HoverItemDelayId != 0) {
    g.HoverItemDelayTimer += g.IO.DeltaTime;
    g.HoverItemDelayClearTimer = 0.0f;
    g.HoverItemDelayId = 0;
  } else if (g.HoverItemDelayTimer > 0.0f) {
    // This gives a little bit of leeway before clearing the hover timer,
    // allowing mouse to cross gaps We could expose 0.25f as
    // style.HoverClearDelay but I am not sure of the logic yet, this is
    // particularly subtle.
    g.HoverItemDelayClearTimer += g.IO.DeltaTime;
    if (g.HoverItemDelayClearTimer >=
        Max(0.25f, g.IO.DeltaTime *
                       2.0f)) // ~7 frames at 30 Hz + allow for low framerate
      g.HoverItemDelayTimer = g.HoverItemDelayClearTimer =
          0.0f; // May want a decaying timer, in which case need to clamp at max
                // first, based on max of caller last requested timer.
  }

  // Drag and drop
  g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
  g.DragDropAcceptIdCurr = 0;
  g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
  g.DragDropWithinSource = false;
  g.DragDropWithinTarget = false;
  g.DragDropHoldJustPressedId = 0;

  // Close popups on focus lost (currently wip/opt-in)
  // if (g.IO.AppFocusLost)
  //    ClosePopupsExceptModals();

  // Update keyboard input state
  UpdateKeyboardInputs();

  // GUI_ASSERT(g.IO.KeyCtrl == IsKeyDown(Key_LeftCtrl) ||
  // IsKeyDown(Key_RightCtrl)); GUI_ASSERT(g.IO.KeyShift ==
  // IsKeyDown(Key_LeftShift) || IsKeyDown(Key_RightShift));
  // GUI_ASSERT(g.IO.KeyAlt == IsKeyDown(Key_LeftAlt) ||
  // IsKeyDown(Key_RightAlt)); GUI_ASSERT(g.IO.KeySuper ==
  // IsKeyDown(Key_LeftSuper) || IsKeyDown(Key_RightSuper));

  // Update gamepad/keyboard navigation
  NavUpdate();

  // Update mouse input state
  UpdateMouseInputs();

  // Find hovered window
  // (needs to be before UpdateMouseMovingWindowNewFrame so we fill
  // g.HoveredWindowUnderMovingWindow on the mouse release frame)
  UpdateHoveredWindowAndCaptureFlags();

  // Handle user moving window with mouse (at the beginning of the frame to
  // avoid input lag or sheering)
  UpdateMouseMovingWindowNewFrame();

  // Background darkening/whitening
  if (GetTopMostPopupModal() != NULL ||
      (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
    g.DimBgRatio = Min(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
  else
    g.DimBgRatio = Max(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);

  g.MouseCursor = MouseCursor_Arrow;
  g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame =
      g.WantTextInputNextFrame = -1;

  // Platform IME data: reset for the frame
  g.PlatformImeDataPrev = g.PlatformImeData;
  g.PlatformImeData.WantVisible = false;

  // Mouse wheel scrolling, scale
  UpdateMouseWheel();

  // Mark all windows as not visible and compact unused memory.
  GUI_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size);
  const float memory_compact_start_time =
      (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f)
          ? FLT_MAX
          : (float)g.Time - g.IO.ConfigMemoryCompactTimer;
  for (Window *window : g.Windows) {
    window->WasActive = window->Active;
    window->Active = false;
    window->WriteAccessed = false;
    window->BeginCountPreviousFrame = window->BeginCount;
    window->BeginCount = 0;

    // Garbage collect transient buffers of recently unused windows
    if (!window->WasActive && !window->MemoryCompacted &&
        window->LastTimeActive < memory_compact_start_time)
      GcCompactTransientWindowBuffers(window);
  }

  // Garbage collect transient buffers of recently unused tables
  for (int i = 0; i < g.TablesLastTimeActive.Size; i++)
    if (g.TablesLastTimeActive[i] >= 0.0f &&
        g.TablesLastTimeActive[i] < memory_compact_start_time)
      TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));
  for (TableTempData &table_temp_data : g.TablesTempData)
    if (table_temp_data.LastTimeActive >= 0.0f &&
        table_temp_data.LastTimeActive < memory_compact_start_time)
      TableGcCompactTransientBuffers(&table_temp_data);
  if (g.GcCompactAll)
    GcCompactTransientMiscBuffers();
  g.GcCompactAll = false;

  // Closing the focused window restore focus to the first active root window in
  // descending z-order
  if (g.NavWindow && !g.NavWindow->WasActive)
    FocusTopMostWindowUnderOne(NULL, NULL, NULL,
                               FocusRequestFlags_RestoreFocusedChild);

  // No window should be open at the beginning of the frame.
  // But in order to allow the user to call NewFrame() multiple times without
  // calling Render(), we are doing an explicit clear.
  g.CurrentWindowStack.resize(0);
  g.BeginPopupStack.resize(0);
  g.ItemFlagsStack.resize(0);
  g.ItemFlagsStack.push_back(ItemFlags_None);
  g.GroupStack.resize(0);

  // [DEBUG] Update debug features
  UpdateDebugToolItemPicker();
  UpdateDebugToolStackQueries();
  UpdateDebugToolFlashStyleColor();
  if (g.DebugLocateFrames > 0 && --g.DebugLocateFrames == 0)
    g.DebugLocateId = 0;
  if (g.DebugLogClipperAutoDisableFrames > 0 &&
      --g.DebugLogClipperAutoDisableFrames == 0) {
    DebugLog("(Debug Log: Auto-disabled DebugLogFlags_EventClipper after "
             "2 frames)\n");
    g.DebugLogFlags &= ~DebugLogFlags_EventClipper;
  }

  // Create implicit/fallback window - which we will only render it if the user
  // has added something to it. We don't use "Debug" to avoid colliding with
  // user trying to create a "Debug" window with custom flags. This fallback is
  // particularly important as it prevents Gui:: calls from crashing.
  g.WithinFrameScopeWithImplicitWindow = true;
  SetNextWindowSize(Vec2(400, 400), Cond_FirstUseEver);
  Begin("Debug##Default");
  GUI_ASSERT(g.CurrentWindow->IsFallbackWindow == true);

  // [DEBUG] When io.ConfigDebugBeginReturnValue is set, we make
  // Begin()/BeginChild() return false at different level of the window-stack,
  // allowing to validate correct Begin/End behavior in user code.
  if (g.IO.ConfigDebugBeginReturnValueLoop)
    g.DebugBeginReturnValueCullDepth =
        (g.DebugBeginReturnValueCullDepth == -1)
            ? 0
            : ((g.DebugBeginReturnValueCullDepth +
                ((g.FrameCount % 4) == 0 ? 1 : 0)) %
               10);
  else
    g.DebugBeginReturnValueCullDepth = -1;

  CallContextHooks(&g, ContextHookType_NewFramePost);
}

// FIXME: Add a more explicit sort order in the window structure.
static int GUI_CDECL ChildWindowComparer(const void *lhs, const void *rhs) {
  const Window *const a = *(const Window *const *)lhs;
  const Window *const b = *(const Window *const *)rhs;
  if (int d = (a->Flags & WindowFlags_Popup) - (b->Flags & WindowFlags_Popup))
    return d;
  if (int d =
          (a->Flags & WindowFlags_Tooltip) - (b->Flags & WindowFlags_Tooltip))
    return d;
  return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
}

static void AddWindowToSortBuffer(Vector<Window *> *out_sorted_windows,
                                  Window *window) {
  out_sorted_windows->push_back(window);
  if (window->Active) {
    int count = window->DC.ChildWindows.Size;
    Qsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(Window *),
          ChildWindowComparer);
    for (int i = 0; i < count; i++) {
      Window *child = window->DC.ChildWindows[i];
      if (child->Active)
        AddWindowToSortBuffer(out_sorted_windows, child);
    }
  }
}

static void AddWindowToDrawData(Window *window, int layer) {
  Context &g = *GGui;
  ViewportP *viewport = g.Viewports[0];
  g.IO.MetricsRenderWindows++;
  if (window->DrawList->_Splitter._Count > 1)
    window->DrawList->ChannelsMerge(); // Merge if user forgot to merge back.
                                       // Also required in Docking branch for
                                       // WindowFlags_DockNodeHost windows.
  Gui::AddDrawListToDrawDataEx(&viewport->DrawDataP,
                               viewport->DrawDataBuilder.Layers[layer],
                               window->DrawList);
  for (Window *child : window->DC.ChildWindows)
    if (IsWindowActiveAndVisible(
            child)) // Clipped children may have been marked not active
      AddWindowToDrawData(child, layer);
}

static inline int GetWindowDisplayLayer(Window *window) {
  return (window->Flags & WindowFlags_Tooltip) ? 1 : 0;
}

// Layer is locked for the root window, however child windows may use a
// different viewport (e.g. extruding menu)
static inline void AddRootWindowToDrawData(Window *window) {
  AddWindowToDrawData(window, GetWindowDisplayLayer(window));
}

static void FlattenDrawDataIntoSingleLayer(DrawDataBuilder *builder) {
  int n = builder->Layers[0]->Size;
  int full_size = n;
  for (int i = 1; i < GUI_ARRAYSIZE(builder->Layers); i++)
    full_size += builder->Layers[i]->Size;
  builder->Layers[0]->resize(full_size);
  for (int layer_n = 1; layer_n < GUI_ARRAYSIZE(builder->Layers); layer_n++) {
    Vector<DrawList *> *layer = builder->Layers[layer_n];
    if (layer->empty())
      continue;
    memcpy(builder->Layers[0]->Data + n, layer->Data,
           layer->Size * sizeof(DrawList *));
    n += layer->Size;
    layer->resize(0);
  }
}

static void InitViewportDrawData(ViewportP *viewport) {
  IO &io = Gui::GetIO();
  DrawData *draw_data = &viewport->DrawDataP;

  viewport->DrawDataBuilder.Layers[0] = &draw_data->CmdLists;
  viewport->DrawDataBuilder.Layers[1] = &viewport->DrawDataBuilder.LayerData1;
  viewport->DrawDataBuilder.Layers[0]->resize(0);
  viewport->DrawDataBuilder.Layers[1]->resize(0);

  draw_data->Valid = true;
  draw_data->CmdListsCount = 0;
  draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
  draw_data->DisplayPos = viewport->Pos;
  draw_data->DisplaySize = viewport->Size;
  draw_data->FramebufferScale = io.DisplayFramebufferScale;
  draw_data->OwnerViewport = viewport;
}

// Push a clipping rectangle for both Gui logic (hit-testing etc.) and
// low-level DrawList rendering.
// - When using this function it is sane to ensure that float are perfectly
// rounded to integer values,
//   so that e.g. (int)(max.x-min.x) in user's render produce correct result.
// - If the code here changes, may need to update code of functions like
// NextColumn() and PushColumnClipRect():
//   some frequently called functions which to modify both channels and clipping
//   simultaneously tend to use the more specialized
//   SetWindowClipRectBeforeSetChannel() to avoid extraneous updates of
//   underlying DrawCmds.
inline void Gui::PushClipRect(const Vec2 &clip_rect_min,
                              const Vec2 &clip_rect_max,
                              bool intersect_with_current_clip_rect) {
  Window *window = GetCurrentWindow();
  window->DrawList->PushClipRect(clip_rect_min, clip_rect_max,
                                 intersect_with_current_clip_rect);
  window->ClipRect = window->DrawList->_ClipRectStack.back();
}

inline void Gui::PopClipRect() {
  Window *window = GetCurrentWindow();
  window->DrawList->PopClipRect();
  window->ClipRect = window->DrawList->_ClipRectStack.back();
}

static void Gui::RenderDimmedBackgroundBehindWindow(Window *window, U32 col) {
  if ((col & GUI_COL32_A_MASK) == 0)
    return;

  ViewportP *viewport = (ViewportP *)GetMainViewport();
  Rect viewport_rect = viewport->GetMainRect();

  // Draw behind window by moving the draw command at the FRONT of the draw list
  {
    // We've already called AddWindowToDrawData() which called
    // DrawList->ChannelsMerge() on DockNodeHost windows, and draw list have
    // been trimmed already, hence the explicit recreation of a draw command if
    // missing.
    // FIXME: This is creating complication, might be simpler if we could inject
    // a drawlist in drawdata at a given position and not attempt to manipulate
    // DrawCmd order.
    DrawList *draw_list = window->RootWindow->DrawList;
    if (draw_list->CmdBuffer.Size == 0)
      draw_list->AddDrawCmd();
    draw_list->PushClipRect(
        Subtract(viewport_rect.Min, Vec2(1, 1)),
        Add(viewport_rect.Max, Vec2(1, 1)),
        false); // FIXME: Need to stricty ensure DrawCmd are not merged
                // (ElemCount==6 checks below will verify that)
    draw_list->AddRectFilled(viewport_rect.Min, viewport_rect.Max, col);
    DrawCmd cmd = draw_list->CmdBuffer.back();
    GUI_ASSERT(cmd.ElemCount == 6);
    draw_list->CmdBuffer.pop_back();
    draw_list->CmdBuffer.push_front(cmd);
    draw_list->AddDrawCmd(); // We need to create a command as
                             // CmdBuffer.back().IdxOffset won't be correct if
                             // we append to same command.
    draw_list->PopClipRect();
  }
}

inline Window *
Gui::FindBottomMostVisibleWindowWithinBeginStack(Window *parent_window) {
  Context &g = *GGui;
  Window *bottom_most_visible_window = parent_window;
  for (int i = FindWindowDisplayIndex(parent_window); i >= 0; i--) {
    Window *window = g.Windows[i];
    if (window->Flags & WindowFlags_ChildWindow)
      continue;
    if (!IsWindowWithinBeginStackOf(window, parent_window))
      break;
    if (IsWindowActiveAndVisible(window) &&
        GetWindowDisplayLayer(window) <= GetWindowDisplayLayer(parent_window))
      bottom_most_visible_window = window;
  }
  return bottom_most_visible_window;
}

static void Gui::RenderDimmedBackgrounds() {
  Context &g = *GGui;
  Window *modal_window = GetTopMostAndVisiblePopupModal();
  if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
    return;
  const bool dim_bg_for_modal = (modal_window != NULL);
  const bool dim_bg_for_window_list =
      (g.NavWindowingTargetAnim != NULL && g.NavWindowingTargetAnim->Active);
  if (!dim_bg_for_modal && !dim_bg_for_window_list)
    return;

  if (dim_bg_for_modal) {
    // Draw dimming behind modal or a begin stack child, whichever comes first
    // in draw order.
    Window *dim_behind_window =
        FindBottomMostVisibleWindowWithinBeginStack(modal_window);
    RenderDimmedBackgroundBehindWindow(
        dim_behind_window, GetColorU32(Col_ModalWindowDimBg, g.DimBgRatio));
  } else if (dim_bg_for_window_list) {
    // Draw dimming behind CTRL+Tab target window
    RenderDimmedBackgroundBehindWindow(
        g.NavWindowingTargetAnim,
        GetColorU32(Col_NavWindowingDimBg, g.DimBgRatio));

    // Draw border around CTRL+Tab target window
    Window *window = g.NavWindowingTargetAnim;
    Viewport *viewport = GetMainViewport();
    float distance = g.FontSize;
    Rect bb = window->Rect();
    bb.Expand(distance);
    if (bb.GetWidth() >= viewport->Size.x && bb.GetHeight() >= viewport->Size.y)
      bb.Expand(-distance - 1.0f); // If a window fits the entire viewport,
                                   // adjust its highlight inward
    if (window->DrawList->CmdBuffer.Size == 0)
      window->DrawList->AddDrawCmd();
    window->DrawList->PushClipRect(viewport->Pos,
                                   Add(viewport->Pos, viewport->Size));
    window->DrawList->AddRect(
        bb.Min, bb.Max,
        GetColorU32(Col_NavWindowingHighlight, g.NavWindowingHighlightAlpha),
        window->WindowRounding, 0, 3.0f);
    window->DrawList->PopClipRect();
  }
}

// This is normally called by Render(). You may want to call it directly if you
// want to avoid calling Render() but the gain will be very minimal.
inline void Gui::EndFrame() {
  Context &g = *GGui;
  GUI_ASSERT(g.Initialized);

  // Don't process EndFrame() multiple times.
  if (g.FrameCountEnded == g.FrameCount)
    return;
  GUI_ASSERT(g.WithinFrameScope && "Forgot to call Gui::NewFrame()?");

  CallContextHooks(&g, ContextHookType_EndFramePre);

  ErrorCheckEndFrameSanityChecks();

  // Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK
  // inputs using Microsoft IME)
  PlatformImeData *ime_data = &g.PlatformImeData;
  if (g.IO.SetPlatformImeDataFn &&
      memcmp(ime_data, &g.PlatformImeDataPrev, sizeof(PlatformImeData)) != 0) {
    GUI_DEBUG_LOG_IO("[io] Calling io.SetPlatformImeDataFn(): WantVisible: "
                     "%d, InputPos (%.2f,%.2f)\n",
                     ime_data->WantVisible, ime_data->InputPos.x,
                     ime_data->InputPos.y);
    Viewport *viewport = GetMainViewport();
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
    if (viewport->PlatformHandleRaw == NULL && g.IO.ImeWindowHandle != NULL) {
      viewport->PlatformHandleRaw = g.IO.ImeWindowHandle;
      g.IO.SetPlatformImeDataFn(viewport, ime_data);
      viewport->PlatformHandleRaw = NULL;
    } else
#endif
    {
      g.IO.SetPlatformImeDataFn(viewport, ime_data);
    }
  }

  // Hide implicit/fallback "Debug" window if it hasn't been used
  g.WithinFrameScopeWithImplicitWindow = false;
  if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
    g.CurrentWindow->Active = false;
  End();

  // Update navigation: CTRL+Tab, wrap-around requests
  NavEndFrame();

  // Drag and Drop: Elapse payload (if delivered, or if source stops being
  // submitted)
  if (g.DragDropActive) {
    bool is_delivered = g.DragDropPayload.Delivery;
    bool is_elapsed =
        (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) &&
        ((g.DragDropSourceFlags & DragDropFlags_SourceAutoExpirePayload) ||
         !IsMouseDown(g.DragDropMouseButton));
    if (is_delivered || is_elapsed)
      ClearDragDrop();
  }

  // Drag and Drop: Fallback for source tooltip. This is not ideal but better
  // than nothing.
  if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount &&
      !(g.DragDropSourceFlags & DragDropFlags_SourceNoPreviewTooltip)) {
    g.DragDropWithinSource = true;
    SetTooltip("...");
    g.DragDropWithinSource = false;
  }

  // End frame
  g.WithinFrameScope = false;
  g.FrameCountEnded = g.FrameCount;

  // Initiate moving window + handle left-click and right-click focus
  UpdateMouseMovingWindowEndFrame();

  // Sort the window list so that all child windows are after their parent
  // We cannot do that on FocusWindow() because children may not exist yet
  g.WindowsTempSortBuffer.resize(0);
  g.WindowsTempSortBuffer.reserve(g.Windows.Size);
  for (Window *window : g.Windows) {
    if (window->Active &&
        (window->Flags & WindowFlags_ChildWindow)) // if a child is active
                                                   // its parent will add it
      continue;
    AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
  }

  // This usually assert if there is a mismatch between the
  // WindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in
  // parents, aka we've done something wrong.
  GUI_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size);
  g.Windows.swap(g.WindowsTempSortBuffer);
  g.IO.MetricsActiveWindows = g.WindowsActiveCount;

  // Unlock font atlas
  g.IO.Fonts->Locked = false;

  // Clear Input data for next frame
  g.IO.MousePosPrev = g.IO.MousePos;
  g.IO.AppFocusLost = false;
  g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
  g.IO.InputQueueCharacters.resize(0);

  CallContextHooks(&g, ContextHookType_EndFramePost);
}

// Prepare the data for rendering so you can call GetDrawData()
// (As with anything within the Gui:: namspace this doesn't touch your GPU or
// graphics API at all: it is the role of the Gui_ImplXXXX_RenderDrawData()
// function provided by the renderer backend)
inline void Gui::Render() {
  Context &g = *GGui;
  GUI_ASSERT(g.Initialized);

  if (g.FrameCountEnded != g.FrameCount)
    EndFrame();
  if (g.FrameCountRendered == g.FrameCount)
    return;
  g.FrameCountRendered = g.FrameCount;

  g.IO.MetricsRenderWindows = 0;
  CallContextHooks(&g, ContextHookType_RenderPre);

  // Draw modal/window whitening backgrounds
  RenderDimmedBackgrounds();

  // Add background DrawList (for each active viewport)
  for (ViewportP *viewport : g.Viewports) {
    InitViewportDrawData(viewport);
    if (viewport->BgFgDrawLists[0] != NULL)
      AddDrawListToDrawDataEx(&viewport->DrawDataP,
                              viewport->DrawDataBuilder.Layers[0],
                              GetBackgroundDrawList(viewport));
  }

  // Add DrawList to render
  Window *windows_to_render_top_most[2];
  windows_to_render_top_most[0] =
      (g.NavWindowingTarget &&
       !(g.NavWindowingTarget->Flags & WindowFlags_NoBringToFrontOnFocus))
          ? g.NavWindowingTarget->RootWindow
          : NULL;
  windows_to_render_top_most[1] =
      (g.NavWindowingTarget ? g.NavWindowingListWindow : NULL);
  for (Window *window : g.Windows) {
    GUI_MSVC_WARNING_SUPPRESS(
        6011); // Static Analysis false positive "warning C6011: Dereferencing
               // NULL pointer 'window'"
    if (IsWindowActiveAndVisible(window) &&
        (window->Flags & WindowFlags_ChildWindow) == 0 &&
        window != windows_to_render_top_most[0] &&
        window != windows_to_render_top_most[1])
      AddRootWindowToDrawData(window);
  }
  for (int n = 0; n < GUI_ARRAYSIZE(windows_to_render_top_most); n++)
    if (windows_to_render_top_most[n] &&
        IsWindowActiveAndVisible(
            windows_to_render_top_most[n])) // NavWindowingTarget is always
                                            // temporarily displayed as the
                                            // top-most window
      AddRootWindowToDrawData(windows_to_render_top_most[n]);

  // Draw software mouse cursor if requested by io.MouseDrawCursor flag
  if (g.IO.MouseDrawCursor && g.MouseCursor != MouseCursor_None)
    RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor,
                      GUI_COL32_WHITE, GUI_COL32_BLACK, GUI_COL32(0, 0, 0, 48));

  // Setup DrawData structures for end-user
  g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;
  for (ViewportP *viewport : g.Viewports) {
    FlattenDrawDataIntoSingleLayer(&viewport->DrawDataBuilder);

    // Add foreground DrawList (for each active viewport)
    if (viewport->BgFgDrawLists[1] != NULL)
      AddDrawListToDrawDataEx(&viewport->DrawDataP,
                              viewport->DrawDataBuilder.Layers[0],
                              GetForegroundDrawList(viewport));

    // We call _PopUnusedDrawCmd() last thing, as RenderDimmedBackgrounds() rely
    // on a valid command being there (especially in docking branch).
    DrawData *draw_data = &viewport->DrawDataP;
    GUI_ASSERT(draw_data->CmdLists.Size == draw_data->CmdListsCount);
    for (DrawList *draw_list : draw_data->CmdLists)
      draw_list->_PopUnusedDrawCmd();

    g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;
    g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;
  }

  CallContextHooks(&g, ContextHookType_RenderPost);
}

// Calculate text size. Text can be multi-line. Optionally ignore text after a
// ## marker. CalcTextSize("") should return Vec2(0.0f, g.FontSize)
inline Vec2 Gui::CalcTextSize(const char *text, const char *text_end,
                              bool hide_text_after_double_hash,
                              float wrap_width) {
  Context &g = *GGui;

  const char *text_display_end;
  if (hide_text_after_double_hash)
    text_display_end = FindRenderedTextEnd(
        text, text_end); // Hide anything after a '##' string
  else
    text_display_end = text_end;

  Font *font = g.Font;
  const float font_size = g.FontSize;
  if (text == text_display_end)
    return Vec2(0.0f, font_size);
  Vec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text,
                                       text_display_end, NULL);

  // Round
  // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we
  // want this out.
  // FIXME: Investigate using ceilf or e.g.
  // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
  // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
  text_size.x = GUI_TRUNC(text_size.x + 0.99999f);

  return text_size;
}

// Find window given position, search front-to-back
// FIXME: Note that we have an inconsequential lag here: OuterRectClipped is
// updated in Begin(), so windows moved programmatically with SetWindowPos() and
// not SetNextWindowPos() will have that rectangle lagging by a frame at the
// time FindHoveredWindow() is called, aka before the next Begin(). Moving
// window isn't affected.
static void FindHoveredWindow() {
  Context &g = *GGui;

  Window *hovered_window = NULL;
  Window *hovered_window_ignoring_moving_window = NULL;
  if (g.MovingWindow && !(g.MovingWindow->Flags & WindowFlags_NoMouseInputs))
    hovered_window = g.MovingWindow;

  Vec2 padding_regular = g.Style.TouchExtraPadding;
  Vec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges
                                ? g.WindowsHoverPadding
                                : padding_regular;
  for (int i = g.Windows.Size - 1; i >= 0; i--) {
    Window *window = g.Windows[i];
    GUI_MSVC_WARNING_SUPPRESS(
        28182); // [Static Analyzer] Dereferencing NULL pointer.
    if (!window->Active || window->Hidden)
      continue;
    if (window->Flags & WindowFlags_NoMouseInputs)
      continue;

    // Using the clipped AABB, a child window will typically be clipped by its
    // parent (not always)
    Vec2 hit_padding =
        (window->Flags & (WindowFlags_NoResize | WindowFlags_AlwaysAutoResize))
            ? padding_regular
            : padding_for_resize;
    if (!window->OuterRectClipped.ContainsWithPad(g.IO.MousePos, hit_padding))
      continue;

    // Support for one rectangular hole in any given window
    // FIXME: Consider generalizing hit-testing override (with more generic
    // data, callback, etc.) (#1512)
    if (window->HitTestHoleSize.x != 0) {
      Vec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x,
                    window->Pos.y + (float)window->HitTestHoleOffset.y);
      Vec2 hole_size((float)window->HitTestHoleSize.x,
                     (float)window->HitTestHoleSize.y);
      if (Rect(hole_pos, Add(hole_pos, hole_size)).Contains(g.IO.MousePos))
        continue;
    }

    if (hovered_window == NULL)
      hovered_window = window;
    GUI_MSVC_WARNING_SUPPRESS(
        28182); // [Static Analyzer] Dereferencing NULL pointer.
    if (hovered_window_ignoring_moving_window == NULL &&
        (!g.MovingWindow || window->RootWindow != g.MovingWindow->RootWindow))
      hovered_window_ignoring_moving_window = window;
    if (hovered_window && hovered_window_ignoring_moving_window)
      break;
  }

  g.HoveredWindow = hovered_window;
  g.HoveredWindowUnderMovingWindow = hovered_window_ignoring_moving_window;
}

inline bool Gui::IsItemActive() {
  Context &g = *GGui;
  if (g.ActiveId)
    return g.ActiveId == g.LastItemData.ID;
  return false;
}

inline bool Gui::IsItemActivated() {
  Context &g = *GGui;
  if (g.ActiveId)
    if (g.ActiveId == g.LastItemData.ID &&
        g.ActiveIdPreviousFrame != g.LastItemData.ID)
      return true;
  return false;
}

inline bool Gui::IsItemDeactivated() {
  Context &g = *GGui;
  if (g.LastItemData.StatusFlags & ItemStatusFlags_HasDeactivated)
    return (g.LastItemData.StatusFlags & ItemStatusFlags_Deactivated) != 0;
  return (g.ActiveIdPreviousFrame == g.LastItemData.ID &&
          g.ActiveIdPreviousFrame != 0 && g.ActiveId != g.LastItemData.ID);
}

inline bool Gui::IsItemDeactivatedAfterEdit() {
  Context &g = *GGui;
  return IsItemDeactivated() &&
         (g.ActiveIdPreviousFrameHasBeenEditedBefore ||
          (g.ActiveId == 0 && g.ActiveIdHasBeenEditedBefore));
}

// == GetItemID() == GetFocusID()
inline bool Gui::IsItemFocused() {
  Context &g = *GGui;
  if (g.NavId != g.LastItemData.ID || g.NavId == 0)
    return false;
  return true;
}

// Important: this can be useful but it is NOT equivalent to the behavior of
// e.g.Button()! Most widgets have specific reactions based on mouse-up/down
// state, mouse position etc.
inline bool Gui::IsItemClicked(MouseButton mouse_button) {
  return IsMouseClicked(mouse_button) && IsItemHovered(HoveredFlags_None);
}

inline bool Gui::IsItemToggledOpen() {
  Context &g = *GGui;
  return (g.LastItemData.StatusFlags & ItemStatusFlags_ToggledOpen) ? true
                                                                    : false;
}

// IMPORTANT: If you are trying to check whether your mouse should be dispatched
// to Dear Gui or to your underlying app, you should not use this function!
// Use the 'io.WantCaptureMouse' boolean for that! Refer to FAQ entry "How can I
// tell whether to dispatch mouse/keyboard to Dear Gui or my application?" for
// details.
inline bool Gui::IsAnyItemHovered() {
  Context &g = *GGui;
  return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

inline bool Gui::IsAnyItemActive() {
  Context &g = *GGui;
  return g.ActiveId != 0;
}

inline bool Gui::IsAnyItemFocused() {
  Context &g = *GGui;
  return g.NavId != 0 && !g.NavDisableHighlight;
}

inline bool Gui::IsItemVisible() {
  Context &g = *GGui;
  return (g.LastItemData.StatusFlags & ItemStatusFlags_Visible) != 0;
}

inline bool Gui::IsItemEdited() {
  Context &g = *GGui;
  return (g.LastItemData.StatusFlags & ItemStatusFlags_Edited) != 0;
}

// Allow next item to be overlapped by subsequent items.
// This works by requiring HoveredId to match for two subsequent frames,
// so if a following items overwrite it our interactions will naturally be
// disabled.
inline void Gui::SetNextItemAllowOverlap() {
  Context &g = *GGui;
  g.NextItemData.ItemFlags |= ItemFlags_AllowOverlap;
}

#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
// Allow last item to be overlapped by a subsequent item. Both may be activated
// during the same frame before the later one takes priority.
// FIXME-LEGACY: Use SetNextItemAllowOverlap() *before* your item instead.
inline void Gui::SetItemAllowOverlap() {
  Context &g = *GGui;
  ID id = g.LastItemData.ID;
  if (g.HoveredId == id)
    g.HoveredIdAllowOverlap = true;
  if (g.ActiveId ==
      id) // Before we made this obsolete, most calls to SetItemAllowOverlap()
          // used to avoid this path by testing g.ActiveId != id.
    g.ActiveIdAllowOverlap = true;
}
#endif

// FIXME: It might be undesirable that this will likely disable KeyOwner-aware
// shortcuts systems. Consider a more fine-tuned version for the two users of
// this function.
inline void Gui::SetActiveIdUsingAllKeyboardKeys() {
  Context &g = *GGui;
  GUI_ASSERT(g.ActiveId != 0);
  g.ActiveIdUsingNavDirMask = (1 << Dir_COUNT) - 1;
  g.ActiveIdUsingAllKeyboardKeys = true;
  NavMoveRequestCancel();
}

inline ID Gui::GetItemID() {
  Context &g = *GGui;
  return g.LastItemData.ID;
}

inline Vec2 Gui::GetItemRectMin() {
  Context &g = *GGui;
  return g.LastItemData.Rect.Min;
}

inline Vec2 Gui::GetItemRectMax() {
  Context &g = *GGui;
  return g.LastItemData.Rect.Max;
}

inline Vec2 Gui::GetItemRectSize() {
  Context &g = *GGui;
  return g.LastItemData.Rect.GetSize();
}

// Prior to v1.90 2023/10/16, the BeginChild() function took a 'bool border =
// false' parameter instead of 'ChildFlags child_flags = 0'.
// ChildFlags_Border is defined as always == 1 in order to allow old code
// passing 'true'.
inline bool Gui::BeginChild(const char *str_id, const Vec2 &size_arg,
                            ChildFlags child_flags, WindowFlags window_flags) {
  ID id = GetCurrentWindow()->GetID(str_id);
  return BeginChildEx(str_id, id, size_arg, child_flags, window_flags);
}

inline bool Gui::BeginChild(ID id, const Vec2 &size_arg, ChildFlags child_flags,
                            WindowFlags window_flags) {
  return BeginChildEx(NULL, id, size_arg, child_flags, window_flags);
}

inline bool Gui::BeginChildEx(const char *name, ID id, const Vec2 &size_arg,
                              ChildFlags child_flags,
                              WindowFlags window_flags) {
  Context &g = *GGui;
  Window *parent_window = g.CurrentWindow;
  GUI_ASSERT(id != 0);

  // Sanity check as it is likely that some user will accidentally pass
  // WindowFlags into the ChildFlags argument.
  const ChildFlags ChildFlags_SupportedMask_ =
      ChildFlags_Border | ChildFlags_AlwaysUseWindowPadding |
      ChildFlags_ResizeX | ChildFlags_ResizeY | ChildFlags_AutoResizeX |
      ChildFlags_AutoResizeY | ChildFlags_AlwaysAutoResize |
      ChildFlags_FrameStyle;
  GUI_UNUSED(ChildFlags_SupportedMask_);
  GUI_ASSERT((child_flags & ~ChildFlags_SupportedMask_) == 0 &&
             "Illegal ChildFlags value. Did you pass WindowFlags "
             "values instead of ChildFlags?");
  GUI_ASSERT((window_flags & WindowFlags_AlwaysAutoResize) == 0 &&
             "Cannot specify WindowFlags_AlwaysAutoResize for "
             "BeginChild(). Use ChildFlags_AlwaysAutoResize!");
  if (child_flags & ChildFlags_AlwaysAutoResize) {
    GUI_ASSERT((child_flags & (ChildFlags_ResizeX | ChildFlags_ResizeY)) == 0 &&
               "Cannot use ChildFlags_ResizeX or ChildFlags_ResizeY "
               "with ChildFlags_AlwaysAutoResize!");
    GUI_ASSERT((child_flags &
                (ChildFlags_AutoResizeX | ChildFlags_AutoResizeY)) != 0 &&
               "Must use ChildFlags_AutoResizeX or ChildFlags_AutoResizeY "
               "with ChildFlags_AlwaysAutoResize!");
  }
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
  if (window_flags & WindowFlags_AlwaysUseWindowPadding)
    child_flags |= ChildFlags_AlwaysUseWindowPadding;
#endif
  if (child_flags & ChildFlags_AutoResizeX)
    child_flags &= ~ChildFlags_ResizeX;
  if (child_flags & ChildFlags_AutoResizeY)
    child_flags &= ~ChildFlags_ResizeY;

  // Set window flags
  window_flags |= WindowFlags_ChildWindow | WindowFlags_NoTitleBar;
  window_flags |=
      (parent_window->Flags & WindowFlags_NoMove); // Inherit the NoMove flag
  if (child_flags & (ChildFlags_AutoResizeX | ChildFlags_AutoResizeY |
                     ChildFlags_AlwaysAutoResize))
    window_flags |= WindowFlags_AlwaysAutoResize;
  if ((child_flags & (ChildFlags_ResizeX | ChildFlags_ResizeY)) == 0)
    window_flags |= WindowFlags_NoResize | WindowFlags_NoSavedSettings;

  // Special framed style
  if (child_flags & ChildFlags_FrameStyle) {
    PushStyleColor(Col_ChildBg, g.Style.Colors[Col_FrameBg]);
    PushStyleVar(StyleVar_ChildRounding, g.Style.FrameRounding);
    PushStyleVar(StyleVar_ChildBorderSize, g.Style.FrameBorderSize);
    PushStyleVar(StyleVar_WindowPadding, g.Style.FramePadding);
    child_flags |= ChildFlags_Border | ChildFlags_AlwaysUseWindowPadding;
    window_flags |= WindowFlags_NoMove;
  }

  // Forward child flags
  g.NextWindowData.Flags |= NextWindowDataFlags_HasChildFlags;
  g.NextWindowData.ChildFlags = child_flags;

  // Forward size
  // Important: Begin() has special processing to switch condition to
  // Cond_FirstUseEver for a given axis when ChildFlags_ResizeXXX is
  // set. (the alternative would to store conditional flags per axis, which is
  // possible but more code)
  const Vec2 size_avail = GetContentRegionAvail();
  const Vec2 size_default(
      (child_flags & ChildFlags_AutoResizeX) ? 0.0f : size_avail.x,
      (child_flags & ChildFlags_AutoResizeY) ? 0.0f : size_avail.y);
  const Vec2 size = CalcItemSize(size_arg, size_default.x, size_default.y);
  SetNextWindowSize(size);

  // Build up name. If you need to append to a same child from multiple location
  // in the ID stack, use BeginChild(ID id) with a stable value.
  // FIXME: 2023/11/14: commented out shorted version. We had an issue with
  // multiple ### in child window path names, which the trailing hash helped
  // workaround. e.g.
  // "ParentName###ParentIdentifier/ChildName###ChildIdentifier" would get
  // hashed incorrectly by HashStr(), trailing _%08X somehow fixes it.
  const char *temp_window_name;
  /*if (name && parent_window->IDStack.back() == parent_window->ID)
      FormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s",
  parent_window->Name, name); // May omit ID if in root of ID stack else*/
  if (name)
    FormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s_%08X",
                             parent_window->Name, name, id);
  else
    FormatStringToTempBuffer(&temp_window_name, NULL, "%s/%08X",
                             parent_window->Name, id);

  // Set style
  const float backup_border_size = g.Style.ChildBorderSize;
  if ((child_flags & ChildFlags_Border) == 0)
    g.Style.ChildBorderSize = 0.0f;

  // Begin into window
  const bool ret = Begin(temp_window_name, NULL, window_flags);

  // Restore style
  g.Style.ChildBorderSize = backup_border_size;
  if (child_flags & ChildFlags_FrameStyle) {
    PopStyleVar(3);
    PopStyleColor();
  }

  Window *child_window = g.CurrentWindow;
  child_window->ChildId = id;

  // Set the cursor to handle case where the user called
  // SetNextWindowPos()+BeginChild() manually. While this is not really
  // documented/defined, it seems that the expected thing to do.
  if (child_window->BeginCount == 1)
    parent_window->DC.CursorPos = child_window->Pos;

  // Process navigation-in immediately so NavInit can run on first frame
  // Can enter a child if (A) it has navigable items or (B) it can be scrolled.
  const ID temp_id_for_activation = HashStr("##Child", 0, id);
  if (g.ActiveId == temp_id_for_activation)
    ClearActiveID();
  if (g.NavActivateId == id && !(window_flags & WindowFlags_NavFlattened) &&
      (child_window->DC.NavLayersActiveMask != 0 ||
       child_window->DC.NavWindowHasScrollY)) {
    FocusWindow(child_window);
    NavInitWindow(child_window, false);
    SetActiveID(temp_id_for_activation,
                child_window); // Steal ActiveId with another arbitrary id so
                               // that key-press won't activate child item
    g.ActiveIdSource = g.NavInputSource;
  }
  return ret;
}

inline void Gui::EndChild() {
  Context &g = *GGui;
  Window *child_window = g.CurrentWindow;

  GUI_ASSERT(g.WithinEndChild == false);
  GUI_ASSERT(
      child_window->Flags &
      WindowFlags_ChildWindow); // Mismatched BeginChild()/EndChild() calls

  g.WithinEndChild = true;
  Vec2 child_size = child_window->Size;
  End();
  if (child_window->BeginCount == 1) {
    Window *parent_window = g.CurrentWindow;
    Rect bb(parent_window->DC.CursorPos,
            Add(parent_window->DC.CursorPos, child_size));
    ItemSize(child_size);
    if ((child_window->DC.NavLayersActiveMask != 0 ||
         child_window->DC.NavWindowHasScrollY) &&
        !(child_window->Flags & WindowFlags_NavFlattened)) {
      ItemAdd(bb, child_window->ChildId);
      RenderNavHighlight(bb, child_window->ChildId);

      // When browsing a window that has no activable items (scroll only) we
      // keep a highlight on the child (pass g.NavId to trick into always
      // displaying)
      if (child_window->DC.NavLayersActiveMask == 0 &&
          child_window == g.NavWindow)
        RenderNavHighlight(
            Rect(Subtract(bb.Min, Vec2(2, 2)), Add(bb.Max, Vec2(2, 2))),
            g.NavId, NavHighlightFlags_TypeThin);
    } else {
      // Not navigable into
      ItemAdd(bb, 0);

      // But when flattened we directly reach items, adjust active layer mask
      // accordingly
      if (child_window->Flags & WindowFlags_NavFlattened)
        parent_window->DC.NavLayersActiveMaskNext |=
            child_window->DC.NavLayersActiveMaskNext;
    }
    if (g.HoveredWindow == child_window)
      g.LastItemData.StatusFlags |= ItemStatusFlags_HoveredWindow;
  }
  g.WithinEndChild = false;
  g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
}

static void SetWindowConditionAllowFlags(Window *window, Cond flags,
                                         bool enabled) {
  window->SetWindowPosAllowFlags =
      enabled ? (window->SetWindowPosAllowFlags | flags)
              : (window->SetWindowPosAllowFlags & ~flags);
  window->SetWindowSizeAllowFlags =
      enabled ? (window->SetWindowSizeAllowFlags | flags)
              : (window->SetWindowSizeAllowFlags & ~flags);
  window->SetWindowCollapsedAllowFlags =
      enabled ? (window->SetWindowCollapsedAllowFlags | flags)
              : (window->SetWindowCollapsedAllowFlags & ~flags);
}

static void ApplyWindowSettings(Window *window, WindowSettings *settings) {
  window->Pos = Trunc(Vec2(settings->Pos.x, settings->Pos.y));
  if (settings->Size.x > 0 && settings->Size.y > 0)
    window->Size = window->SizeFull =
        Trunc(Vec2(settings->Size.x, settings->Size.y));
  window->Collapsed = settings->Collapsed;
}

static void UpdateWindowInFocusOrderList(Window *window, bool just_created,
                                         WindowFlags new_flags) {
  Context &g = *GGui;

  const bool new_is_explicit_child =
      (new_flags & WindowFlags_ChildWindow) != 0 &&
      ((new_flags & WindowFlags_Popup) == 0 ||
       (new_flags & WindowFlags_ChildMenu) != 0);
  const bool child_flag_changed =
      new_is_explicit_child != window->IsExplicitChild;
  if ((just_created || child_flag_changed) && !new_is_explicit_child) {
    GUI_ASSERT(!g.WindowsFocusOrder.contains(window));
    g.WindowsFocusOrder.push_back(window);
    window->FocusOrder = (short)(g.WindowsFocusOrder.Size - 1);
  } else if (!just_created && child_flag_changed && new_is_explicit_child) {
    GUI_ASSERT(g.WindowsFocusOrder[window->FocusOrder] == window);
    for (int n = window->FocusOrder + 1; n < g.WindowsFocusOrder.Size; n++)
      g.WindowsFocusOrder[n]->FocusOrder--;
    g.WindowsFocusOrder.erase(g.WindowsFocusOrder.Data + window->FocusOrder);
    window->FocusOrder = -1;
  }
  window->IsExplicitChild = new_is_explicit_child;
}

static void InitOrLoadWindowSettings(Window *window, WindowSettings *settings) {
  // Initial window state with e.g. default/arbitrary window position
  // Use SetNextWindowPos() with the appropriate condition flag to change the
  // initial position of a window.
  const Viewport *main_viewport = Gui::GetMainViewport();
  window->Pos = Add(main_viewport->Pos, Vec2(60, 60));
  window->Size = window->SizeFull = Vec2(0, 0);
  window->SetWindowPosAllowFlags = window->SetWindowSizeAllowFlags =
      window->SetWindowCollapsedAllowFlags =
          Cond_Always | Cond_Once | Cond_FirstUseEver | Cond_Appearing;

  if (settings != NULL) {
    SetWindowConditionAllowFlags(window, Cond_FirstUseEver, false);
    ApplyWindowSettings(window, settings);
  }
  window->DC.CursorStartPos = window->DC.CursorMaxPos = window->DC.IdealMaxPos =
      window->Pos; // So first call to CalcWindowContentSizes() doesn't return
                   // crazy values

  if ((window->Flags & WindowFlags_AlwaysAutoResize) != 0) {
    window->AutoFitFramesX = window->AutoFitFramesY = 2;
    window->AutoFitOnlyGrows = false;
  } else {
    if (window->Size.x <= 0.0f)
      window->AutoFitFramesX = 2;
    if (window->Size.y <= 0.0f)
      window->AutoFitFramesY = 2;
    window->AutoFitOnlyGrows =
        (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
  }
}

static Window *CreateNewWindow(const char *name, WindowFlags flags) {
  // Create window the first time
  // GUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);
  Context &g = *GGui;
  Window *window = GUI_NEW(Window)(&g, name);
  window->Flags = flags;
  g.WindowsById.SetVoidPtr(window->ID, window);

  WindowSettings *settings = NULL;
  if (!(flags & WindowFlags_NoSavedSettings))
    if ((settings = Gui::FindWindowSettingsByWindow(window)) != 0)
      window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);

  InitOrLoadWindowSettings(window, settings);

  if (flags & WindowFlags_NoBringToFrontOnFocus)
    g.Windows.push_front(window); // Quite slow but rare and only once
  else
    g.Windows.push_back(window);

  return window;
}

static inline Vec2 CalcWindowMinSize(Window *window) {
  // Popups, menus and childs bypass style.WindowMinSize by default, but we give
  // then a non-zero minimum size to facilitate understanding problematic cases
  // (e.g. empty popups)
  // FIXME: the if/else could probably be removed, "reduce artifacts" section
  // for all windows.
  Context &g = *GGui;
  Vec2 size_min;
  if (window->Flags &
      (WindowFlags_Popup | WindowFlags_ChildMenu | WindowFlags_ChildWindow)) {
    size_min.x = (window->ChildFlags & ChildFlags_ResizeX)
                     ? g.Style.WindowMinSize.x
                     : 4.0f;
    size_min.y = (window->ChildFlags & ChildFlags_ResizeY)
                     ? g.Style.WindowMinSize.y
                     : 4.0f;
  } else {
    Window *window_for_height = window;
    size_min.x = ((window->Flags & WindowFlags_AlwaysAutoResize) == 0)
                     ? g.Style.WindowMinSize.x
                     : 4.0f;
    size_min.y = ((window->Flags & WindowFlags_AlwaysAutoResize) == 0)
                     ? g.Style.WindowMinSize.y
                     : 4.0f;
    size_min.y = Max(
        size_min.y,
        window_for_height->TitleBarHeight() +
            window_for_height->MenuBarHeight() +
            Max(0.0f, g.Style.WindowRounding -
                          1.0f)); // Reduce artifacts with very small windows
  }
  return size_min;
}

static Vec2 CalcWindowSizeAfterConstraint(Window *window,
                                          const Vec2 &size_desired) {
  Context &g = *GGui;
  Vec2 new_size = size_desired;
  if (g.NextWindowData.Flags & NextWindowDataFlags_HasSizeConstraint) {
    // See comments in SetNextWindowSizeConstraints() for details about setting
    // size_min an size_max.
    Rect cr = g.NextWindowData.SizeConstraintRect;
    new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0)
                     ? Clamp(new_size.x, cr.Min.x, cr.Max.x)
                     : window->SizeFull.x;
    new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0)
                     ? Clamp(new_size.y, cr.Min.y, cr.Max.y)
                     : window->SizeFull.y;
    if (g.NextWindowData.SizeCallback) {
      SizeCallbackData data;
      data.UserData = g.NextWindowData.SizeCallbackUserData;
      data.Pos = window->Pos;
      data.CurrentSize = window->SizeFull;
      data.DesiredSize = new_size;
      g.NextWindowData.SizeCallback(&data);
      new_size = data.DesiredSize;
    }
    new_size.x = GUI_TRUNC(new_size.x);
    new_size.y = GUI_TRUNC(new_size.y);
  }

  // Minimum size
  Vec2 size_min = CalcWindowMinSize(window);
  return Max(new_size, size_min);
}

static void CalcWindowContentSizes(Window *window, Vec2 *content_size_current,
                                   Vec2 *content_size_ideal) {
  bool preserve_old_content_sizes = false;
  if (window->Collapsed && window->AutoFitFramesX <= 0 &&
      window->AutoFitFramesY <= 0)
    preserve_old_content_sizes = true;
  else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 &&
           window->HiddenFramesCanSkipItems > 0)
    preserve_old_content_sizes = true;
  if (preserve_old_content_sizes) {
    *content_size_current = window->ContentSize;
    *content_size_ideal = window->ContentSizeIdeal;
    return;
  }

  content_size_current->x =
      (window->ContentSizeExplicit.x != 0.0f)
          ? window->ContentSizeExplicit.x
          : GUI_TRUNC(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x);
  content_size_current->y =
      (window->ContentSizeExplicit.y != 0.0f)
          ? window->ContentSizeExplicit.y
          : GUI_TRUNC(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y);
  content_size_ideal->x =
      (window->ContentSizeExplicit.x != 0.0f)
          ? window->ContentSizeExplicit.x
          : GUI_TRUNC(Max(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) -
                      window->DC.CursorStartPos.x);
  content_size_ideal->y =
      (window->ContentSizeExplicit.y != 0.0f)
          ? window->ContentSizeExplicit.y
          : GUI_TRUNC(Max(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) -
                      window->DC.CursorStartPos.y);
}

static Vec2 CalcWindowAutoFitSize(Window *window, const Vec2 &size_contents) {
  Context &g = *GGui;
  Style &style = g.Style;
  const float decoration_w_without_scrollbars = window->DecoOuterSizeX1 +
                                                window->DecoOuterSizeX2 -
                                                window->ScrollbarSizes.x;
  const float decoration_h_without_scrollbars = window->DecoOuterSizeY1 +
                                                window->DecoOuterSizeY2 -
                                                window->ScrollbarSizes.y;
  Vec2 size_pad = Multiply(window->WindowPadding, 2.0f);
  Vec2 size_desired =
      Add(Add(size_contents, size_pad), Vec2(decoration_w_without_scrollbars,
                                             decoration_h_without_scrollbars));
  if (window->Flags & WindowFlags_Tooltip) {
    // Tooltip always resize
    return size_desired;
  } else {
    // Maximum window size is determined by the viewport size or monitor size
    Vec2 size_min = CalcWindowMinSize(window);
    Vec2 size_max =
        (window->Flags & WindowFlags_ChildWindow)
            ? Vec2(FLT_MAX, FLT_MAX)
            : Subtract(Gui::GetMainViewport()->WorkSize,
                       Multiply(style.DisplaySafeAreaPadding, 2.0f));
    Vec2 size_auto_fit = Clamp(size_desired, size_min, size_max);

    // When the window cannot fit all contents (either because of constraints,
    // either because screen is too small), we are growing the size on the other
    // axis to compensate for expected scrollbar. FIXME: Might turn bigger than
    // ViewportSize-WindowPadding.
    Vec2 size_auto_fit_after_constraint =
        CalcWindowSizeAfterConstraint(window, size_auto_fit);
    bool will_have_scrollbar_x =
        (size_auto_fit_after_constraint.x - size_pad.x -
                 decoration_w_without_scrollbars <
             size_contents.x &&
         !(window->Flags & WindowFlags_NoScrollbar) &&
         (window->Flags & WindowFlags_HorizontalScrollbar)) ||
        (window->Flags & WindowFlags_AlwaysHorizontalScrollbar);
    bool will_have_scrollbar_y =
        (size_auto_fit_after_constraint.y - size_pad.y -
                 decoration_h_without_scrollbars <
             size_contents.y &&
         !(window->Flags & WindowFlags_NoScrollbar)) ||
        (window->Flags & WindowFlags_AlwaysVerticalScrollbar);
    if (will_have_scrollbar_x)
      size_auto_fit.y += style.ScrollbarSize;
    if (will_have_scrollbar_y)
      size_auto_fit.x += style.ScrollbarSize;
    return size_auto_fit;
  }
}

inline Vec2 Gui::CalcWindowNextAutoFitSize(Window *window) {
  Vec2 size_contents_current;
  Vec2 size_contents_ideal;
  CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal);
  Vec2 size_auto_fit = CalcWindowAutoFitSize(window, size_contents_ideal);
  Vec2 size_final = CalcWindowSizeAfterConstraint(window, size_auto_fit);
  return size_final;
}

static Col GetWindowBgColorIdx(Window *window) {
  if (window->Flags & (WindowFlags_Tooltip | WindowFlags_Popup))
    return Col_PopupBg;
  if (window->Flags & WindowFlags_ChildWindow)
    return Col_ChildBg;
  return Col_WindowBg;
}

static void CalcResizePosSizeFromAnyCorner(Window *window,
                                           const Vec2 &corner_target,
                                           const Vec2 &corner_norm,
                                           Vec2 *out_pos, Vec2 *out_size) {
  Vec2 pos_min = Lerp(corner_target, window->Pos,
                      corner_norm); // Expected window upper-left
  Vec2 pos_max = Lerp(Add(window->Pos, window->Size), corner_target,
                      corner_norm); // Expected window lower-right
  Vec2 size_expected = Subtract(pos_max, pos_min);
  Vec2 size_constrained = CalcWindowSizeAfterConstraint(window, size_expected);
  *out_pos = pos_min;
  if (corner_norm.x == 0.0f)
    out_pos->x -= (size_constrained.x - size_expected.x);
  if (corner_norm.y == 0.0f)
    out_pos->y -= (size_constrained.y - size_expected.y);
  *out_size = size_constrained;
}

// Data for resizing from resize grip / corner
struct ResizeGripDef {
  Vec2 CornerPosN;
  Vec2 InnerDir;
  int AngleMin12, AngleMax12;
};
static const ResizeGripDef resize_grip_def[4] = {
    {Vec2(1, 1), Vec2(-1, -1), 0, 3}, // Lower-right
    {Vec2(0, 1), Vec2(+1, -1), 3, 6}, // Lower-left
    {Vec2(0, 0), Vec2(+1, +1), 6, 9}, // Upper-left (Unused)
    {Vec2(1, 0), Vec2(-1, +1), 9, 12} // Upper-right (Unused)
};

// Data for resizing from borders
struct ResizeBorderDef {
  Vec2 InnerDir;             // Normal toward inside
  Vec2 SegmentN1, SegmentN2; // End positions, normalized (0,0: upper left)
  float OuterAngle;          // Angle toward outside
};
static const ResizeBorderDef resize_border_def[4] = {
    {Vec2(+1, 0), Vec2(0, 1), Vec2(0, 0), GUI_PI * 1.00f}, // Left
    {Vec2(-1, 0), Vec2(1, 0), Vec2(1, 1), GUI_PI * 0.00f}, // Right
    {Vec2(0, +1), Vec2(0, 0), Vec2(1, 0), GUI_PI * 1.50f}, // Up
    {Vec2(0, -1), Vec2(1, 1), Vec2(0, 1), GUI_PI * 0.50f}  // Down
};

static Rect GetResizeBorderRect(Window *window, int border_n,
                                float perp_padding, float thickness) {
  Rect rect = window->Rect();
  if (thickness == 0.0f)
    rect.Max = Subtract(rect.Max, Vec2(1, 1));
  if (border_n == Dir_Left) {
    return Rect(rect.Min.x - thickness, rect.Min.y + perp_padding,
                rect.Min.x + thickness, rect.Max.y - perp_padding);
  }
  if (border_n == Dir_Right) {
    return Rect(rect.Max.x - thickness, rect.Min.y + perp_padding,
                rect.Max.x + thickness, rect.Max.y - perp_padding);
  }
  if (border_n == Dir_Up) {
    return Rect(rect.Min.x + perp_padding, rect.Min.y - thickness,
                rect.Max.x - perp_padding, rect.Min.y + thickness);
  }
  if (border_n == Dir_Down) {
    return Rect(rect.Min.x + perp_padding, rect.Max.y - thickness,
                rect.Max.x - perp_padding, rect.Max.y + thickness);
  }
  GUI_ASSERT(0);
  return Rect();
}

// 0..3: corners (Lower-right, Lower-left, Unused, Unused)
inline ID Gui::GetWindowResizeCornerID(Window *window, int n) {
  GUI_ASSERT(n >= 0 && n < 4);
  ID id = window->ID;
  id = HashStr("#RESIZE", 0, id);
  id = HashData(&n, sizeof(int), id);
  return id;
}

// Borders (Left, Right, Up, Down)
inline ID Gui::GetWindowResizeBorderID(Window *window, Dir dir) {
  GUI_ASSERT(dir >= 0 && dir < 4);
  int n = (int)dir + 4;
  ID id = window->ID;
  id = HashStr("#RESIZE", 0, id);
  id = HashData(&n, sizeof(int), id);
  return id;
}

// Handle resize for: Resize Grips, Borders, Gamepad
// Return true when using auto-fit (double-click on resize grip)
static int Gui::UpdateWindowManualResize(Window *window,
                                         const Vec2 &size_auto_fit,
                                         int *border_hovered, int *border_held,
                                         int resize_grip_count,
                                         U32 resize_grip_col[4],
                                         const Rect &visibility_rect) {
  Context &g = *GGui;
  WindowFlags flags = window->Flags;

  if ((flags & WindowFlags_NoResize) ||
      (flags & WindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 ||
      window->AutoFitFramesY > 0)
    return false;
  if (window->WasActive ==
      false) // Early out to avoid running this code for e.g. a hidden
             // implicit/fallback Debug window.
    return false;

  int ret_auto_fit_mask = 0x00;
  const float grip_draw_size = GUI_TRUNC(Max(
      g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
  const float grip_hover_inner_size = GUI_TRUNC(grip_draw_size * 0.75f);
  const float grip_hover_outer_size =
      g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;

  Rect clamp_rect = visibility_rect;
  const bool window_move_from_title_bar =
      g.IO.ConfigWindowsMoveFromTitleBarOnly &&
      !(window->Flags & WindowFlags_NoTitleBar);
  if (window_move_from_title_bar)
    clamp_rect.Min.y -= window->TitleBarHeight();

  Vec2 pos_target(FLT_MAX, FLT_MAX);
  Vec2 size_target(FLT_MAX, FLT_MAX);

  // Resize grips and borders are on layer 1
  window->DC.NavLayerCurrent = NavLayer_Menu;

  // Manual resize grips
  PushID("#RESIZE");
  for (int resize_grip_n = 0; resize_grip_n < resize_grip_count;
       resize_grip_n++) {
    const ResizeGripDef &def = resize_grip_def[resize_grip_n];
    const Vec2 corner =
        Lerp(window->Pos, Add(window->Pos, window->Size), def.CornerPosN);

    // Using the FlattenChilds button flag we make the resize button accessible
    // even if we are hovering over a child window
    bool hovered, held;
    Rect resize_rect(
        Subtract(corner, Multiply(def.InnerDir, grip_hover_outer_size)),
        Add(corner, Multiply(def.InnerDir, grip_hover_inner_size)));
    if (resize_rect.Min.x > resize_rect.Max.x)
      Swap(resize_rect.Min.x, resize_rect.Max.x);
    if (resize_rect.Min.y > resize_rect.Max.y)
      Swap(resize_rect.Min.y, resize_rect.Max.y);
    ID resize_grip_id =
        window->GetID(resize_grip_n); // == GetWindowResizeCornerID()
    ItemAdd(resize_rect, resize_grip_id, NULL, ItemFlags_NoNav);
    ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held,
                   ButtonFlags_FlattenChildren | ButtonFlags_NoNavFocus);
    // GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max,
    // GUI_COL32(255, 255, 0, 255));
    if (hovered || held)
      g.MouseCursor =
          (resize_grip_n & 1) ? MouseCursor_ResizeNESW : MouseCursor_ResizeNWSE;

    if (held && g.IO.MouseDoubleClicked[0]) {
      // Auto-fit when double-clicking
      size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit);
      ret_auto_fit_mask = 0x03; // Both axises
      ClearActiveID();
    } else if (held) {
      // Resize from any of the four corners
      // We don't use an incremental MouseDelta but rather compute an absolute
      // target size based on mouse position
      Vec2 clamp_min =
          Vec2(def.CornerPosN.x == 1.0f ? clamp_rect.Min.x : -FLT_MAX,
               (def.CornerPosN.y == 1.0f ||
                (def.CornerPosN.y == 0.0f && window_move_from_title_bar))
                   ? clamp_rect.Min.y
                   : -FLT_MAX);
      Vec2 clamp_max =
          Vec2(def.CornerPosN.x == 0.0f ? clamp_rect.Max.x : +FLT_MAX,
               def.CornerPosN.y == 0.0f ? clamp_rect.Max.y : +FLT_MAX);
      Vec2 corner_target =
          Add(Subtract(g.IO.MousePos, g.ActiveIdClickOffset),
              Lerp(Multiply(def.InnerDir, grip_hover_outer_size),
                   Multiply(def.InnerDir, -grip_hover_inner_size),
                   def.CornerPosN)); // Corner of the window corresponding to
                                     // our corner grip
      corner_target = Clamp(corner_target, clamp_min, clamp_max);
      CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN,
                                     &pos_target, &size_target);
    }

    // Only lower-left grip is visible before hovering/activating
    if (resize_grip_n == 0 || held || hovered)
      resize_grip_col[resize_grip_n] =
          GetColorU32(held      ? Col_ResizeGripActive
                      : hovered ? Col_ResizeGripHovered
                                : Col_ResizeGrip);
  }

  int resize_border_mask = 0x00;
  if (window->Flags & WindowFlags_ChildWindow)
    resize_border_mask |=
        ((window->ChildFlags & ChildFlags_ResizeX) ? 0x02 : 0) |
        ((window->ChildFlags & ChildFlags_ResizeY) ? 0x08 : 0);
  else
    resize_border_mask = g.IO.ConfigWindowsResizeFromEdges ? 0x0F : 0x00;
  for (int border_n = 0; border_n < 4; border_n++) {
    if ((resize_border_mask & (1 << border_n)) == 0)
      continue;
    const ResizeBorderDef &def = resize_border_def[border_n];
    const Axis axis =
        (border_n == Dir_Left || border_n == Dir_Right) ? Axis_X : Axis_Y;

    bool hovered, held;
    Rect border_rect = GetResizeBorderRect(
        window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
    ID border_id = window->GetID(border_n + 4); // == GetWindowResizeBorderID()
    ItemAdd(border_rect, border_id, NULL, ItemFlags_NoNav);
    ButtonBehavior(border_rect, border_id, &hovered, &held,
                   ButtonFlags_FlattenChildren | ButtonFlags_NoNavFocus);
    // GetForegroundDrawList(window)->AddRect(border_rect.Min, border_rect.Max,
    // GUI_COL32(255, 255, 0, 255));
    if (hovered && g.HoveredIdTimer <= WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER)
      hovered = false;
    if (hovered || held)
      g.MouseCursor =
          (axis == Axis_X) ? MouseCursor_ResizeEW : MouseCursor_ResizeNS;
    if (held && g.IO.MouseDoubleClicked[0]) {
      // Double-clicking bottom or right border auto-fit on this axis
      // FIXME: Support top and right borders: rework
      // CalcResizePosSizeFromAnyCorner() to be reusable in both cases.
      if (border_n == 1 || border_n == 3) // Right and bottom border
      {
        size_target[axis] =
            CalcWindowSizeAfterConstraint(window, size_auto_fit)[axis];
        ret_auto_fit_mask |= (1 << axis);
        hovered = held =
            false; // So border doesn't show highlighted at new position
      }
      ClearActiveID();
    } else if (held) {
      // Switch to relative resizing mode when border geometry moved (e.g.
      // resizing a child altering parent scroll), in order to avoid resizing
      // feedback loop. Currently only using relative mode on resizable child
      // windows, as the problem to solve is more likely noticeable for them,
      // but could apply for all windows eventually.
      // FIXME: May want to generalize this idiom at lower-level, so more
      // widgets can use it!
      const bool just_scrolled_manually_while_resizing =
          (g.WheelingWindow != NULL &&
           g.WheelingWindowScrolledFrame == g.FrameCount &&
           IsWindowChildOf(window, g.WheelingWindow, false));
      if (g.ActiveIdIsJustActivated || just_scrolled_manually_while_resizing) {
        g.WindowResizeBorderExpectedRect = border_rect;
        g.WindowResizeRelativeMode = false;
      }
      if ((window->Flags & WindowFlags_ChildWindow) &&
          memcmp(&g.WindowResizeBorderExpectedRect, &border_rect,
                 sizeof(Rect)) != 0)
        g.WindowResizeRelativeMode = true;

      const Vec2 border_curr =
          (Add(window->Pos,
               Multiply(Min(def.SegmentN1, def.SegmentN2), window->Size)));
      const float border_target_rel_mode_for_axis =
          border_curr[axis] + g.IO.MouseDelta[axis];
      const float border_target_abs_mode_for_axis =
          g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] +
          WINDOWS_HOVER_PADDING; // Match ButtonBehavior() padding above.

      // Use absolute mode position
      Vec2 border_target = window->Pos;
      border_target[axis] = border_target_abs_mode_for_axis;

      // Use relative mode target for child window, ignore resize when moving
      // back toward the ideal absolute position.
      bool ignore_resize = false;
      if (g.WindowResizeRelativeMode) {
        // GetForegroundDrawList()->AddText(GetMainViewport()->WorkPos,
        // GUI_COL32_WHITE, "Relative Mode");
        border_target[axis] = border_target_rel_mode_for_axis;
        if (g.IO.MouseDelta[axis] == 0.0f ||
            (g.IO.MouseDelta[axis] > 0.0f) == (border_target_rel_mode_for_axis >
                                               border_target_abs_mode_for_axis))
          ignore_resize = true;
      }

      // Clamp, apply
      Vec2 clamp_min(border_n == Dir_Right ? clamp_rect.Min.x : -FLT_MAX,
                     border_n == Dir_Down ||
                             (border_n == Dir_Up && window_move_from_title_bar)
                         ? clamp_rect.Min.y
                         : -FLT_MAX);
      Vec2 clamp_max(border_n == Dir_Left ? clamp_rect.Max.x : +FLT_MAX,
                     border_n == Dir_Up ? clamp_rect.Max.y : +FLT_MAX);
      border_target = Clamp(border_target, clamp_min, clamp_max);
      if (flags & WindowFlags_ChildWindow) // Clamp resizing of childs
                                           // within parent
      {
        if ((flags & (WindowFlags_HorizontalScrollbar |
                      WindowFlags_AlwaysHorizontalScrollbar)) == 0 ||
            (flags & WindowFlags_NoScrollbar))
          border_target.x =
              Clamp(border_target.x, window->ParentWindow->InnerClipRect.Min.x,
                    window->ParentWindow->InnerClipRect.Max.x);
        if (flags & WindowFlags_NoScrollbar)
          border_target.y =
              Clamp(border_target.y, window->ParentWindow->InnerClipRect.Min.y,
                    window->ParentWindow->InnerClipRect.Max.y);
      }
      if (!ignore_resize)
        CalcResizePosSizeFromAnyCorner(window, border_target,
                                       Min(def.SegmentN1, def.SegmentN2),
                                       &pos_target, &size_target);
    }
    if (hovered)
      *border_hovered = border_n;
    if (held)
      *border_held = border_n;
  }
  PopID();

  // Restore nav layer
  window->DC.NavLayerCurrent = NavLayer_Main;

  // Navigation resize (keyboard/gamepad)
  // FIXME: This cannot be moved to NavUpdateWindowing() because
  // CalcWindowSizeAfterConstraint() need to callback into user. Not even sure
  // the callback works here.
  if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window) {
    Vec2 nav_resize_dir;
    if (g.NavInputSource == InputSource_Keyboard && g.IO.KeyShift)
      nav_resize_dir = GetKeyMagnitude2d(Key_LeftArrow, Key_RightArrow,
                                         Key_UpArrow, Key_DownArrow);
    if (g.NavInputSource == InputSource_Gamepad)
      nav_resize_dir =
          GetKeyMagnitude2d(Key_GamepadDpadLeft, Key_GamepadDpadRight,
                            Key_GamepadDpadUp, Key_GamepadDpadDown);
    if (nav_resize_dir.x != 0.0f || nav_resize_dir.y != 0.0f) {
      const float NAV_RESIZE_SPEED = 600.0f;
      const float resize_step =
          NAV_RESIZE_SPEED * g.IO.DeltaTime *
          Min(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y);
      g.NavWindowingAccumDeltaSize = Add(g.NavWindowingAccumDeltaSize,
                                         Multiply(nav_resize_dir, resize_step));
      g.NavWindowingAccumDeltaSize =
          Max(g.NavWindowingAccumDeltaSize,
              Subtract(
                  Subtract(clamp_rect.Min, window->Pos),
                  window->Size)); // We need Pos+Size >= clmap_rect.Min, so Size
                                  // >= clmap_rect.Min - Pos, so size_delta >=
                                  // clmap_rect.Min - window->Pos - window->Size
      g.NavWindowingToggleLayer = false;
      g.NavDisableMouseHover = true;
      resize_grip_col[0] = GetColorU32(Col_ResizeGripActive);
      Vec2 accum_floored = Trunc(g.NavWindowingAccumDeltaSize);
      if (accum_floored.x != 0.0f || accum_floored.y != 0.0f) {
        // FIXME-NAV: Should store and accumulate into a separate size buffer to
        // handle sizing constraints properly, right now a constraint will make
        // us stuck.
        size_target = CalcWindowSizeAfterConstraint(
            window, Add(window->SizeFull, accum_floored));
        g.NavWindowingAccumDeltaSize =
            Subtract(g.NavWindowingAccumDeltaSize, accum_floored);
      }
    }
  }

  // Apply back modified position/size to window
  const Vec2 curr_pos = window->Pos;
  const Vec2 curr_size = window->SizeFull;
  if (size_target.x != FLT_MAX &&
      (window->Size.x != size_target.x || window->SizeFull.x != size_target.x))
    window->Size.x = window->SizeFull.x = size_target.x;
  if (size_target.y != FLT_MAX &&
      (window->Size.y != size_target.y || window->SizeFull.y != size_target.y))
    window->Size.y = window->SizeFull.y = size_target.y;
  if (pos_target.x != FLT_MAX && window->Pos.x != Trunc(pos_target.x))
    window->Pos.x = Trunc(pos_target.x);
  if (pos_target.y != FLT_MAX && window->Pos.y != Trunc(pos_target.y))
    window->Pos.y = Trunc(pos_target.y);
  if (curr_pos.x != window->Pos.x || curr_pos.y != window->Pos.y ||
      curr_size.x != window->SizeFull.x || curr_size.y != window->SizeFull.y)
    MarkIniSettingsDirty(window);

  // Recalculate next expected border expected coordinates
  if (*border_held != -1)
    g.WindowResizeBorderExpectedRect = GetResizeBorderRect(
        window, *border_held, grip_hover_inner_size, WINDOWS_HOVER_PADDING);

  return ret_auto_fit_mask;
}

static inline void ClampWindowPos(Window *window, const Rect &visibility_rect) {
  Context &g = *GGui;
  Vec2 size_for_clamping = window->Size;
  if (g.IO.ConfigWindowsMoveFromTitleBarOnly &&
      !(window->Flags & WindowFlags_NoTitleBar))
    size_for_clamping.y = window->TitleBarHeight();
  window->Pos =
      Clamp(window->Pos, Subtract(visibility_rect.Min, size_for_clamping),
            visibility_rect.Max);
}

static void Gui::RenderWindowOuterBorders(Window *window) {
  Context &g = *GGui;
  float rounding = window->WindowRounding;
  float border_size = window->WindowBorderSize;
  if (border_size > 0.0f && !(window->Flags & WindowFlags_NoBackground))
    window->DrawList->AddRect(window->Pos, Add(window->Pos, window->Size),
                              GetColorU32(Col_Border), rounding, 0,
                              border_size);

  if (window->ResizeBorderHovered != -1 || window->ResizeBorderHeld != -1) {
    const int border_n = (window->ResizeBorderHeld != -1)
                             ? window->ResizeBorderHeld
                             : window->ResizeBorderHovered;
    const ResizeBorderDef &def = resize_border_def[border_n];
    const Rect border_r = GetResizeBorderRect(window, border_n, rounding, 0.0f);
    const U32 border_col =
        GetColorU32((window->ResizeBorderHeld != -1) ? Col_SeparatorActive
                                                     : Col_SeparatorHovered);
    window->DrawList->PathArcTo(
        Add(Add(Lerp(border_r.Min, border_r.Max, def.SegmentN1),
                Vec2(0.5f, 0.5f)),
            Multiply(def.InnerDir, rounding)),
        rounding, def.OuterAngle - GUI_PI * 0.25f, def.OuterAngle);
    window->DrawList->PathArcTo(
        Add(Add(Lerp(border_r.Min, border_r.Max, def.SegmentN2),
                Vec2(0.5f, 0.5f)),
            Multiply(def.InnerDir, rounding)),
        rounding, def.OuterAngle, def.OuterAngle + GUI_PI * 0.25f);
    window->DrawList->PathStroke(border_col, 0,
                                 Max(2.0f, border_size)); // Thicker than usual
  }
  if (g.Style.FrameBorderSize > 0 &&
      !(window->Flags & WindowFlags_NoTitleBar)) {
    float y = window->Pos.y + window->TitleBarHeight() - 1;
    window->DrawList->AddLine(
        Vec2(window->Pos.x + border_size, y),
        Vec2(window->Pos.x + window->Size.x - border_size, y),
        GetColorU32(Col_Border), g.Style.FrameBorderSize);
  }
}

// Draw background and borders
// Draw and handle scrollbars
void Gui::RenderWindowDecorations(Window *window, const Rect &title_bar_rect,
                                  bool title_bar_is_highlight,
                                  bool handle_borders_and_resize_grips,
                                  int resize_grip_count,
                                  const U32 resize_grip_col[4],
                                  float resize_grip_draw_size) {
  Context &g = *GGui;
  Style &style = g.Style;
  WindowFlags flags = window->Flags;

  // Ensure that ScrollBar doesn't read last frame's SkipItems
  GUI_ASSERT(window->BeginCount == 0);
  window->SkipItems = false;

  // Draw window + handle manual resize
  // As we highlight the title bar when want_focus is set, multiple reappearing
  // windows will have their title bar highlighted on their reappearing frame.
  const float window_rounding = window->WindowRounding;
  const float window_border_size = window->WindowBorderSize;
  if (window->Collapsed) {
    // Title bar only
    const float backup_border_size = style.FrameBorderSize;
    g.Style.FrameBorderSize = window->WindowBorderSize;
    U32 title_bar_col =
        GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight)
                        ? Col_TitleBgActive
                        : Col_TitleBgCollapsed);
    RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true,
                window_rounding);
    g.Style.FrameBorderSize = backup_border_size;
  } else {
    // Window background
    if (!(flags & WindowFlags_NoBackground)) {
      U32 bg_col = GetColorU32(GetWindowBgColorIdx(window));
      bool override_alpha = false;
      float alpha = 1.0f;
      if (g.NextWindowData.Flags & NextWindowDataFlags_HasBgAlpha) {
        alpha = g.NextWindowData.BgAlphaVal;
        override_alpha = true;
      }
      if (override_alpha)
        bg_col = (bg_col & ~GUI_COL32_A_MASK) |
                 (GUI_F32_TO_INT8_SAT(alpha) << GUI_COL32_A_SHIFT);
      window->DrawList->AddRectFilled(
          Add(window->Pos, Vec2(0, window->TitleBarHeight())),
          Add(window->Pos, window->Size), bg_col, window_rounding,
          (flags & WindowFlags_NoTitleBar) ? 0 : DrawFlags_RoundCornersBottom);
    }

    // Title bar
    if (!(flags & WindowFlags_NoTitleBar)) {
      U32 title_bar_col =
          GetColorU32(title_bar_is_highlight ? Col_TitleBgActive : Col_TitleBg);
      window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max,
                                      title_bar_col, window_rounding,
                                      DrawFlags_RoundCornersTop);
    }

    // Menu bar
    if (flags & WindowFlags_MenuBar) {
      Rect menu_bar_rect = window->MenuBarRect();
      menu_bar_rect.ClipWith(
          window->Rect()); // Soft clipping, in particular child window don't
                           // have minimum size covering the menu bar so this is
                           // useful for them.
      window->DrawList->AddRectFilled(
          Add(menu_bar_rect.Min, Vec2(window_border_size, 0)),
          Subtract(menu_bar_rect.Max, Vec2(window_border_size, 0)),
          GetColorU32(Col_MenuBarBg),
          (flags & WindowFlags_NoTitleBar) ? window_rounding : 0.0f,
          DrawFlags_RoundCornersTop);
      if (style.FrameBorderSize > 0.0f &&
          menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
        window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(),
                                  GetColorU32(Col_Border),
                                  style.FrameBorderSize);
    }

    // Scrollbars
    if (window->ScrollbarX)
      Scrollbar(Axis_X);
    if (window->ScrollbarY)
      Scrollbar(Axis_Y);

    // Render resize grips (after their input handling so we don't have a frame
    // of latency)
    if (handle_borders_and_resize_grips && !(flags & WindowFlags_NoResize)) {
      for (int resize_grip_n = 0; resize_grip_n < resize_grip_count;
           resize_grip_n++) {
        const U32 col = resize_grip_col[resize_grip_n];
        if ((col & GUI_COL32_A_MASK) == 0)
          continue;
        const ResizeGripDef &grip = resize_grip_def[resize_grip_n];
        const Vec2 corner =
            Lerp(window->Pos, Add(window->Pos, window->Size), grip.CornerPosN);
        window->DrawList->PathLineTo(Add(
            corner,
            Multiply(grip.InnerDir,
                     ((resize_grip_n & 1))
                         ? Vec2(window_border_size, resize_grip_draw_size)
                         : Vec2(resize_grip_draw_size, window_border_size))));
        window->DrawList->PathLineTo(Add(
            corner,
            Multiply(grip.InnerDir,
                     ((resize_grip_n & 1))
                         ? Vec2(resize_grip_draw_size, window_border_size)
                         : Vec2(window_border_size, resize_grip_draw_size))));
        window->DrawList->PathArcToFast(
            Vec2(corner.x +
                     grip.InnerDir.x * (window_rounding + window_border_size),
                 corner.y +
                     grip.InnerDir.y * (window_rounding + window_border_size)),
            window_rounding, grip.AngleMin12, grip.AngleMax12);
        window->DrawList->PathFillConvex(col);
      }
    }

    // Borders
    if (handle_borders_and_resize_grips)
      RenderWindowOuterBorders(window);
  }
}

// Render title text, collapse button, close button
void Gui::RenderWindowTitleBarContents(Window *window,
                                       const Rect &title_bar_rect,
                                       const char *name, bool *p_open) {
  Context &g = *GGui;
  Style &style = g.Style;
  WindowFlags flags = window->Flags;

  const bool has_close_button = (p_open != NULL);
  const bool has_collapse_button = !(flags & WindowFlags_NoCollapse) &&
                                   (style.WindowMenuButtonPosition != Dir_None);

  // Close & Collapse button are on the Menu NavLayer and don't default focus
  // (unless there's nothing else on that layer)
  // FIXME-NAV: Might want (or not?) to set the equivalent of
  // ButtonFlags_NoNavFocus so that mouse clicks on standard title bar
  // items don't necessarily set nav/keyboard ref?
  const ItemFlags item_flags_backup = g.CurrentItemFlags;
  g.CurrentItemFlags |= ItemFlags_NoNavDefaultFocus;
  window->DC.NavLayerCurrent = NavLayer_Menu;

  // Layout buttons
  // FIXME: Would be nice to generalize the subtleties expressed here into
  // reusable code.
  float pad_l = style.FramePadding.x;
  float pad_r = style.FramePadding.x;
  float button_sz = g.FontSize;
  Vec2 close_button_pos;
  Vec2 collapse_button_pos;
  if (has_close_button) {
    close_button_pos = Vec2(title_bar_rect.Max.x - pad_r - button_sz,
                            title_bar_rect.Min.y + style.FramePadding.y);
    pad_r += button_sz + style.ItemInnerSpacing.x;
  }
  if (has_collapse_button && style.WindowMenuButtonPosition == Dir_Right) {
    collapse_button_pos = Vec2(title_bar_rect.Max.x - pad_r - button_sz,
                               title_bar_rect.Min.y + style.FramePadding.y);
    pad_r += button_sz + style.ItemInnerSpacing.x;
  }
  if (has_collapse_button && style.WindowMenuButtonPosition == Dir_Left) {
    collapse_button_pos = Vec2(title_bar_rect.Min.x + pad_l,
                               title_bar_rect.Min.y + style.FramePadding.y);
    pad_l += button_sz + style.ItemInnerSpacing.x;
  }

  // Collapse button (submitting first so it gets priority when choosing a
  // navigation init fallback)
  if (has_collapse_button)
    if (CollapseButton(window->GetID("#COLLAPSE"), collapse_button_pos))
      window->WantCollapseToggle =
          true; // Defer actual collapsing to next frame as we are too far in
                // the Begin() function

  // Close button
  if (has_close_button)
    if (CloseButton(window->GetID("#CLOSE"), close_button_pos))
      *p_open = false;

  window->DC.NavLayerCurrent = NavLayer_Main;
  g.CurrentItemFlags = item_flags_backup;

  // Title bar text (with: horizontal alignment, avoiding collapse/close button,
  // optional "unsaved document" marker)
  // FIXME: Refactor text alignment facilities along with RenderText helpers,
  // this is WAY too much messy code..
  const float marker_size_x =
      (flags & WindowFlags_UnsavedDocument) ? button_sz * 0.80f : 0.0f;
  const Vec2 text_size =
      Add(CalcTextSize(name, NULL, true), Vec2(marker_size_x, 0.0f));

  // As a nice touch we try to ensure that centered title text doesn't get
  // affected by visibility of Close/Collapse button, while uncentered title
  // text will still reach edges correctly.
  if (pad_l > style.FramePadding.x)
    pad_l += g.Style.ItemInnerSpacing.x;
  if (pad_r > style.FramePadding.x)
    pad_r += g.Style.ItemInnerSpacing.x;
  if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f) {
    float centerness =
        Saturate(1.0f - Fabs(style.WindowTitleAlign.x - 0.5f) *
                            2.0f); // 0.0f on either edges, 1.0f on center
    float pad_extend = Min(Max(pad_l, pad_r), title_bar_rect.GetWidth() -
                                                  pad_l - pad_r - text_size.x);
    pad_l = Max(pad_l, pad_extend * centerness);
    pad_r = Max(pad_r, pad_extend * centerness);
  }

  Rect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y,
                title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);
  Rect clip_r(
      layout_r.Min.x, layout_r.Min.y,
      Min(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x),
      layout_r.Max.y);
  if (flags & WindowFlags_UnsavedDocument) {
    Vec2 marker_pos;
    marker_pos.x = Clamp(layout_r.Min.x +
                             (layout_r.GetWidth() - text_size.x) *
                                 style.WindowTitleAlign.x +
                             text_size.x,
                         layout_r.Min.x, layout_r.Max.x);
    marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5f;
    if (marker_pos.x > layout_r.Min.x) {
      RenderBullet(window->DrawList, marker_pos, GetColorU32(Col_Text));
      clip_r.Max.x =
          Min(clip_r.Max.x, marker_pos.x - (int)(marker_size_x * 0.5f));
    }
  }
  // if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max,
  // GUI_COL32(255, 128, 0, 255)); // [DEBUG] if (g.IO.KeyCtrl)
  // window->DrawList->AddRect(clip_r.Min, clip_r.Max, GUI_COL32(255, 128, 0,
  // 255)); // [DEBUG]
  RenderTextClipped(layout_r.Min, layout_r.Max, name, NULL, &text_size,
                    style.WindowTitleAlign, &clip_r);
}

inline void Gui::UpdateWindowParentAndRootLinks(Window *window,
                                                WindowFlags flags,
                                                Window *parent_window) {
  window->ParentWindow = parent_window;
  window->RootWindow = window->RootWindowPopupTree =
      window->RootWindowForTitleBarHighlight = window->RootWindowForNav =
          window;
  if (parent_window && (flags & WindowFlags_ChildWindow) &&
      !(flags & WindowFlags_Tooltip))
    window->RootWindow = parent_window->RootWindow;
  if (parent_window && (flags & WindowFlags_Popup))
    window->RootWindowPopupTree = parent_window->RootWindowPopupTree;
  if (parent_window && !(flags & WindowFlags_Modal) &&
      (flags & (WindowFlags_ChildWindow | WindowFlags_Popup)))
    window->RootWindowForTitleBarHighlight =
        parent_window->RootWindowForTitleBarHighlight;
  while (window->RootWindowForNav->Flags & WindowFlags_NavFlattened) {
    GUI_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
    window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
  }
}

// When a modal popup is open, newly created windows that want focus (i.e. are
// not popups and do not specify WindowFlags_NoFocusOnAppearing) should be
// positioned behind that modal window, unless the window was created inside the
// modal begin-stack. In case of multiple stacked modals newly created window
// honors begin stack order and does not go below its own modal parent.
// - WindowA            // FindBlockingModal() returns Modal1
//   - WindowB          //                  .. returns Modal1
//   - Modal1           //                  .. returns Modal2
//      - WindowC       //                  .. returns Modal2
//          - WindowD   //                  .. returns Modal2
//          - Modal2    //                  .. returns Modal2
//            - WindowE //                  .. returns NULL
// Notes:
// - FindBlockingModal(NULL) == NULL is generally equivalent to
// GetTopMostPopupModal() == NULL.
//   Only difference is here we check for ->Active/WasActive but it may be
//   unecessary.

// Push a new Dear Gui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning
// of every frame so you can use widgets without explicitly calling a Begin/End
// pair.
// - Begin/End can be called multiple times during the frame with the same
// window name to append content.
// - The window name is used as a unique identifier to preserve window
// information across frames (and save rudimentary information to the .ini
// file).
//   You can use the "##" or "###" markers to use the same label with different
//   id, or same id with different label. See documentation at the top of this
//   file.
// - Return false when window is collapsed, so you can early out in your code.
// You always need to call Gui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of
// the window, the pointed value will be set to false when the button is
// pressed.
inline bool Gui::Begin(const char *name, bool *p_open, WindowFlags flags) {
  Context &g = *GGui;
  const Style &style = g.Style;
  GUI_ASSERT(name != NULL && name[0] != '\0'); // Window name required
  GUI_ASSERT(g.WithinFrameScope);              // Forgot to call Gui::NewFrame()
  GUI_ASSERT(g.FrameCountEnded !=
             g.FrameCount); // Called Gui::Render() or Gui::EndFrame() and
                            // haven't called Gui::NewFrame() again yet

  // Find or create
  Window *window = FindWindowByName(name);
  const bool window_just_created = (window == NULL);
  if (window_just_created)
    window = CreateNewWindow(name, flags);

  // Automatically disable manual moving/resizing when NoInputs is set
  if ((flags & WindowFlags_NoInputs) == WindowFlags_NoInputs)
    flags |= WindowFlags_NoMove | WindowFlags_NoResize;

  if (flags & WindowFlags_NavFlattened)
    GUI_ASSERT(flags & WindowFlags_ChildWindow);

  const int current_frame = g.FrameCount;
  const bool first_begin_of_the_frame =
      (window->LastFrameActive != current_frame);
  window->IsFallbackWindow =
      (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);

  // Update the Appearing flag
  bool window_just_activated_by_user =
      (window->LastFrameActive <
       current_frame - 1); // Not using !WasActive because the implicit "Debug"
                           // window would always toggle off->on
  if (flags & WindowFlags_Popup) {
    PopupData &popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
    window_just_activated_by_user |=
        (window->PopupId !=
         popup_ref.PopupId); // We recycle popups so treat window as activated
                             // if popup id changed
    window_just_activated_by_user |= (window != popup_ref.Window);
  }
  window->Appearing = window_just_activated_by_user;
  if (window->Appearing)
    SetWindowConditionAllowFlags(window, Cond_Appearing, true);

  // Update Flags, LastFrameActive, BeginOrderXXX fields
  if (first_begin_of_the_frame) {
    UpdateWindowInFocusOrderList(window, window_just_created, flags);
    window->Flags = (WindowFlags)flags;
    window->ChildFlags =
        (g.NextWindowData.Flags & NextWindowDataFlags_HasChildFlags)
            ? g.NextWindowData.ChildFlags
            : 0;
    window->LastFrameActive = current_frame;
    window->LastTimeActive = (float)g.Time;
    window->BeginOrderWithinParent = 0;
    window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
  } else {
    flags = window->Flags;
  }

  // Parent window is latched only on the first call to Begin() of the frame, so
  // further append-calls can be done from a different window stack
  Window *parent_window_in_stack =
      g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back().Window;
  Window *parent_window =
      first_begin_of_the_frame
          ? ((flags & (WindowFlags_ChildWindow | WindowFlags_Popup))
                 ? parent_window_in_stack
                 : NULL)
          : window->ParentWindow;
  GUI_ASSERT(parent_window != NULL || !(flags & WindowFlags_ChildWindow));

  // We allow window memory to be compacted so recreate the base stack when
  // needed.
  if (window->IDStack.Size == 0)
    window->IDStack.push_back(window->ID);

  // Add to stack
  g.CurrentWindow = window;
  WindowStackData window_stack_data;
  window_stack_data.Window = window;
  window_stack_data.ParentLastItemDataBackup = g.LastItemData;
  window_stack_data.StackSizesOnBegin.SetToContextState(&g);
  g.CurrentWindowStack.push_back(window_stack_data);
  if (flags & WindowFlags_ChildMenu)
    g.BeginMenuCount++;

  // Update ->RootWindow and others pointers (before any possible call to
  // FocusWindow)
  if (first_begin_of_the_frame) {
    UpdateWindowParentAndRootLinks(window, flags, parent_window);
    window->ParentWindowInBeginStack = parent_window_in_stack;
  }

  // Add to focus scope stack
  // We intentionally set g.CurrentWindow to NULL to prevent usage until when
  // the viewport is set, then will call SetCurrentWindow()
  if ((flags & WindowFlags_NavFlattened) == 0)
    PushFocusScope(window->ID);
  window->NavRootFocusScopeId = g.CurrentFocusScopeId;
  g.CurrentWindow = NULL;

  // Add to popup stack
  if (flags & WindowFlags_Popup) {
    PopupData &popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
    popup_ref.Window = window;
    popup_ref.ParentNavLayer = parent_window_in_stack->DC.NavLayerCurrent;
    g.BeginPopupStack.push_back(popup_ref);
    window->PopupId = popup_ref.PopupId;
  }

  // Process SetNextWindow***() calls
  // (FIXME: Consider splitting the HasXXX flags into X/Y components
  bool window_pos_set_by_api = false;
  bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
  if (g.NextWindowData.Flags & NextWindowDataFlags_HasPos) {
    window_pos_set_by_api =
        (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
    if (window_pos_set_by_api &&
        LengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f) {
      // May be processed on the next frame if this is our first frame and we
      // are measuring size
      // FIXME: Look into removing the branch so everything can go through this
      // same code path for consistency.
      window->SetWindowPosVal = g.NextWindowData.PosVal;
      window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
      window->SetWindowPosAllowFlags &=
          ~(Cond_Once | Cond_FirstUseEver | Cond_Appearing);
    } else {
      SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
    }
  }
  if (g.NextWindowData.Flags & NextWindowDataFlags_HasSize) {
    window_size_x_set_by_api =
        (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 &&
        (g.NextWindowData.SizeVal.x > 0.0f);
    window_size_y_set_by_api =
        (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 &&
        (g.NextWindowData.SizeVal.y > 0.0f);
    if ((window->ChildFlags & ChildFlags_ResizeX) &&
        (window->SetWindowSizeAllowFlags & Cond_FirstUseEver) ==
            0) // Axis-specific conditions for BeginChild()
      g.NextWindowData.SizeVal.x = window->SizeFull.x;
    if ((window->ChildFlags & ChildFlags_ResizeY) &&
        (window->SetWindowSizeAllowFlags & Cond_FirstUseEver) == 0)
      g.NextWindowData.SizeVal.y = window->SizeFull.y;
    SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
  }
  if (g.NextWindowData.Flags & NextWindowDataFlags_HasScroll) {
    if (g.NextWindowData.ScrollVal.x >= 0.0f) {
      window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
      window->ScrollTargetCenterRatio.x = 0.0f;
    }
    if (g.NextWindowData.ScrollVal.y >= 0.0f) {
      window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
      window->ScrollTargetCenterRatio.y = 0.0f;
    }
  }
  if (g.NextWindowData.Flags & NextWindowDataFlags_HasContentSize)
    window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
  else if (first_begin_of_the_frame)
    window->ContentSizeExplicit = Vec2(0.0f, 0.0f);
  if (g.NextWindowData.Flags & NextWindowDataFlags_HasCollapsed)
    SetWindowCollapsed(window, g.NextWindowData.CollapsedVal,
                       g.NextWindowData.CollapsedCond);
  if (g.NextWindowData.Flags & NextWindowDataFlags_HasFocus)
    FocusWindow(window);
  if (window->Appearing)
    SetWindowConditionAllowFlags(window, Cond_Appearing, false);

  // When reusing window again multiple times a frame, just append content
  // (don't need to setup again)
  if (first_begin_of_the_frame) {
    // Initialize
    const bool window_is_child_tooltip =
        (flags & WindowFlags_ChildWindow) &&
        (flags &
         WindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of
                               // Child+Tooltip for pinned tooltip (#1345)
    const bool window_just_appearing_after_hidden_for_resize =
        (window->HiddenFramesCannotSkipItems > 0);
    window->Active = true;
    window->HasCloseButton = (p_open != NULL);
    window->ClipRect = Vec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
    window->IDStack.resize(1);
    window->DrawList->_ResetForNewFrame();
    window->DC.CurrentTableIdx = -1;

    // Restore buffer capacity when woken from a compacted state, to avoid
    if (window->MemoryCompacted)
      GcAwakeTransientWindowBuffers(window);

    // Update stored window name when it changes (which can _only_ happen with
    // the "###" operator, so the ID would stay unchanged). The title bar always
    // display the 'name' parameter, so we only update the string storage if it
    // needs to be visible to the end-user elsewhere.
    bool window_title_visible_elsewhere = false;
    if (g.NavWindowingListWindow != NULL &&
        (window->Flags & WindowFlags_NoNavFocus) ==
            0) // Window titles visible when using CTRL+TAB
      window_title_visible_elsewhere = true;
    if (window_title_visible_elsewhere && !window_just_created &&
        strcmp(name, window->Name) != 0) {
      size_t buf_len = (size_t)window->NameBufLen;
      window->Name = Strdupcpy(window->Name, &buf_len, name);
      window->NameBufLen = (int)buf_len;
    }

    // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

    // Update contents size from last frame for auto-fitting (or use explicit
    // size)
    CalcWindowContentSizes(window, &window->ContentSize,
                           &window->ContentSizeIdeal);
    if (window->HiddenFramesCanSkipItems > 0)
      window->HiddenFramesCanSkipItems--;
    if (window->HiddenFramesCannotSkipItems > 0)
      window->HiddenFramesCannotSkipItems--;
    if (window->HiddenFramesForRenderOnly > 0)
      window->HiddenFramesForRenderOnly--;

    // Hide new windows for one frame until they calculate their size
    if (window_just_created &&
        (!window_size_x_set_by_api || !window_size_y_set_by_api))
      window->HiddenFramesCannotSkipItems = 1;

    // Hide popup/tooltip window when re-opening while we measure size (because
    // we recycle the windows) We reset Size/ContentSize for reappearing
    // popups/tooltips early in this function, so further code won't be tempted
    // to use the old size.
    if (window_just_activated_by_user &&
        (flags & (WindowFlags_Popup | WindowFlags_Tooltip)) != 0) {
      window->HiddenFramesCannotSkipItems = 1;
      if (flags & WindowFlags_AlwaysAutoResize) {
        if (!window_size_x_set_by_api)
          window->Size.x = window->SizeFull.x = 0.f;
        if (!window_size_y_set_by_api)
          window->Size.y = window->SizeFull.y = 0.f;
        window->ContentSize = window->ContentSizeIdeal = Vec2(0.f, 0.f);
      }
    }

    // SELECT VIEWPORT
    // FIXME-VIEWPORT: In the docking/viewport branch, this is the point where
    // we select the current viewport (which may affect the style)

    ViewportP *viewport = (ViewportP *)(void *)GetMainViewport();
    SetWindowViewport(window, viewport);
    SetCurrentWindow(window);

    // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't
    // cause inconsistencies)

    if (flags & WindowFlags_ChildWindow)
      window->WindowBorderSize = style.ChildBorderSize;
    else
      window->WindowBorderSize =
          ((flags & (WindowFlags_Popup | WindowFlags_Tooltip)) &&
           !(flags & WindowFlags_Modal))
              ? style.PopupBorderSize
              : style.WindowBorderSize;
    window->WindowPadding = style.WindowPadding;
    if ((flags & WindowFlags_ChildWindow) && !(flags & WindowFlags_Popup) &&
        !(window->ChildFlags & ChildFlags_AlwaysUseWindowPadding) &&
        window->WindowBorderSize == 0.0f)
      window->WindowPadding = Vec2(
          0.0f, (flags & WindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);

    // Lock menu offset so size calculation can use it as menu-bar windows need
    // a minimum size.
    window->DC.MenuBarOffset.x =
        Max(Max(window->WindowPadding.x, style.ItemSpacing.x),
            g.NextWindowData.MenuBarOffsetMinVal.x);
    window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

    bool use_current_size_for_scrollbar_x = window_just_created;
    bool use_current_size_for_scrollbar_y = window_just_created;

    // Collapse window by double-clicking on title bar
    // At this point we don't have a clipping rectangle setup yet, so we can use
    // the title bar area for hit detection and drawing
    if (!(flags & WindowFlags_NoTitleBar) &&
        !(flags & WindowFlags_NoCollapse)) {
      // We don't use a regular button+id to test for double-click on title bar
      // (mostly due to legacy reason, could be fixed), so verify that we don't
      // have items over the title bar.
      Rect title_bar_rect = window->TitleBarRect();
      if (g.HoveredWindow == window && g.HoveredId == 0 &&
          g.HoveredIdPreviousFrame == 0 &&
          IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) &&
          g.IO.MouseClickedCount[0] == 2)
        window->WantCollapseToggle = true;
      if (window->WantCollapseToggle) {
        window->Collapsed = !window->Collapsed;
        if (!window->Collapsed)
          use_current_size_for_scrollbar_y = true;
        MarkIniSettingsDirty(window);
      }
    } else {
      window->Collapsed = false;
    }
    window->WantCollapseToggle = false;

    // SIZE

    // Outer Decoration Sizes
    // (we need to clear ScrollbarSize immediatly as CalcWindowAutoFitSize()
    // needs it and can be called from other locations).
    const Vec2 scrollbar_sizes_from_last_frame = window->ScrollbarSizes;
    window->DecoOuterSizeX1 = 0.0f;
    window->DecoOuterSizeX2 = 0.0f;
    window->DecoOuterSizeY1 =
        window->TitleBarHeight() + window->MenuBarHeight();
    window->DecoOuterSizeY2 = 0.0f;
    window->ScrollbarSizes = Vec2(0.0f, 0.0f);

    // Calculate auto-fit size, handle automatic resize
    const Vec2 size_auto_fit =
        CalcWindowAutoFitSize(window, window->ContentSizeIdeal);
    if ((flags & WindowFlags_AlwaysAutoResize) && !window->Collapsed) {
      // Using SetNextWindowSize() overrides WindowFlags_AlwaysAutoResize,
      // so it can be used on tooltips/popups, etc.
      if (!window_size_x_set_by_api) {
        window->SizeFull.x = size_auto_fit.x;
        use_current_size_for_scrollbar_x = true;
      }
      if (!window_size_y_set_by_api) {
        window->SizeFull.y = size_auto_fit.y;
        use_current_size_for_scrollbar_y = true;
      }
    } else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0) {
      // Auto-fit may only grow window during the first few frames
      // We still process initial auto-fit on collapsed windows to get a window
      // width, but otherwise don't honor WindowFlags_AlwaysAutoResize when
      // collapsed.
      if (!window_size_x_set_by_api && window->AutoFitFramesX > 0) {
        window->SizeFull.x = window->AutoFitOnlyGrows
                                 ? Max(window->SizeFull.x, size_auto_fit.x)
                                 : size_auto_fit.x;
        use_current_size_for_scrollbar_x = true;
      }
      if (!window_size_y_set_by_api && window->AutoFitFramesY > 0) {
        window->SizeFull.y = window->AutoFitOnlyGrows
                                 ? Max(window->SizeFull.y, size_auto_fit.y)
                                 : size_auto_fit.y;
        use_current_size_for_scrollbar_y = true;
      }
      if (!window->Collapsed)
        MarkIniSettingsDirty(window);
    }

    // Apply minimum/maximum window size constraints and final size
    window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);
    window->Size = window->Collapsed && !(flags & WindowFlags_ChildWindow)
                       ? window->TitleBarRect().GetSize()
                       : window->SizeFull;

    // POSITION

    // Popup latch its initial position, will position itself when it appears
    // next frame
    if (window_just_activated_by_user) {
      window->AutoPosLastDirection = Dir_None;
      if ((flags & WindowFlags_Popup) != 0 && !(flags & WindowFlags_Modal) &&
          !window_pos_set_by_api) // FIXME: BeginPopup() could use
                                  // SetNextWindowPos()
        window->Pos = g.BeginPopupStack.back().OpenPopupPos;
    }

    // Position child window
    if (flags & WindowFlags_ChildWindow) {
      GUI_ASSERT(parent_window && parent_window->Active);
      window->BeginOrderWithinParent =
          (short)parent_window->DC.ChildWindows.Size;
      parent_window->DC.ChildWindows.push_back(window);
      if (!(flags & WindowFlags_Popup) && !window_pos_set_by_api &&
          !window_is_child_tooltip)
        window->Pos = parent_window->DC.CursorPos;
    }

    const bool window_pos_with_pivot =
        (window->SetWindowPosVal.x != FLT_MAX &&
         window->HiddenFramesCannotSkipItems == 0);
    if (window_pos_with_pivot)
      SetWindowPos(window,
                   Subtract(window->SetWindowPosVal,
                            Multiply(window->Size, window->SetWindowPosPivot)),
                   0); // Position given a pivot (e.g. for centering)
    else if ((flags & WindowFlags_ChildMenu) != 0)
      window->Pos = FindBestWindowPosForPopup(window);
    else if ((flags & WindowFlags_Popup) != 0 && !window_pos_set_by_api &&
             window_just_appearing_after_hidden_for_resize)
      window->Pos = FindBestWindowPosForPopup(window);
    else if ((flags & WindowFlags_Tooltip) != 0 && !window_pos_set_by_api &&
             !window_is_child_tooltip)
      window->Pos = FindBestWindowPosForPopup(window);

    // Calculate the range of allowed position for that window (to be movable
    // and visible past safe area padding) When clamping to stay visible, we
    // will enforce that window->Pos stays inside of visibility_rect.
    Rect viewport_rect(viewport->GetMainRect());
    Rect viewport_work_rect(viewport->GetWorkRect());
    Vec2 visibility_padding =
        Max(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
    Rect visibility_rect(Add(viewport_work_rect.Min, visibility_padding),
                         Subtract(viewport_work_rect.Max, visibility_padding));

    // Clamp position/size so window stays visible within its viewport or
    // monitor Ignore zero-sized display explicitly to avoid losing positions if
    // a window manager reports zero-sized window when initializing or
    // minimizing.
    if (!window_pos_set_by_api && !(flags & WindowFlags_ChildWindow))
      if (viewport_rect.GetWidth() > 0.0f && viewport_rect.GetHeight() > 0.0f)
        ClampWindowPos(window, visibility_rect);
    window->Pos = Trunc(window->Pos);

    // Lock window rounding for the frame (so that altering them doesn't cause
    // inconsistencies) Large values tend to lead to variety of artifacts and
    // are not recommended.
    window->WindowRounding =
        (flags & WindowFlags_ChildWindow) ? style.ChildRounding
        : ((flags & WindowFlags_Popup) && !(flags & WindowFlags_Modal))
            ? style.PopupRounding
            : style.WindowRounding;

    // For windows with title bar or menu bar, we clamp to FrameHeight(FontSize
    // + FramePadding.y * 2.0f) to completely hide artifacts.
    // if ((window->Flags & WindowFlags_MenuBar) || !(window->Flags &
    // WindowFlags_NoTitleBar))
    //    window->WindowRounding = Min(window->WindowRounding, g.FontSize +
    //    style.FramePadding.y * 2.0f);

    // Apply window focus (new and reactivated windows are moved to front)
    bool want_focus = false;
    if (window_just_activated_by_user &&
        !(flags & WindowFlags_NoFocusOnAppearing)) {
      if (flags & WindowFlags_Popup)
        want_focus = true;
      else if ((flags & (WindowFlags_ChildWindow | WindowFlags_Tooltip)) == 0)
        want_focus = true;
    }

    // [Test Engine] Register whole window in the item system (before submitting
    // further decorations)
#ifdef GUI_ENABLE_TEST_ENGINE
    if (g.TestEngineHookItems) {
      GUI_ASSERT(window->IDStack.Size == 1);
      window->IDStack.Size =
          0; // As window->IDStack[0] == window->ID here, make sure TestEngine
             // doesn't erroneously see window as parent of itself.
      GUI_TEST_ENGINE_ITEM_ADD(window->ID, window->Rect(), NULL);
      GUI_TEST_ENGINE_ITEM_INFO(
          window->ID, window->Name,
          (g.HoveredWindow == window) ? ItemStatusFlags_HoveredRect : 0);
      window->IDStack.Size = 1;
    }
#endif

    // Handle manual resize: Resize Grips, Borders, Gamepad
    int border_hovered = -1, border_held = -1;
    U32 resize_grip_col[4] = {};
    const int resize_grip_count =
        (window->Flags & WindowFlags_ChildWindow) ? 0
        : g.IO.ConfigWindowsResizeFromEdges
            ? 2
            : 1; // Allow resize from lower-left if we have the mouse cursor
                 // feedback for it.
    const float resize_grip_draw_size = GUI_TRUNC(Max(
        g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
    if (!window->Collapsed)
      if (int auto_fit_mask = UpdateWindowManualResize(
              window, size_auto_fit, &border_hovered, &border_held,
              resize_grip_count, &resize_grip_col[0], visibility_rect)) {
        if (auto_fit_mask & (1 << Axis_X))
          use_current_size_for_scrollbar_x = true;
        if (auto_fit_mask & (1 << Axis_Y))
          use_current_size_for_scrollbar_y = true;
      }
    window->ResizeBorderHovered = (signed char)border_hovered;
    window->ResizeBorderHeld = (signed char)border_held;

    // SCROLLBAR VISIBILITY

    // Update scrollbar visibility (based on the Size that was effective during
    // last frame or the auto-resized Size).
    if (!window->Collapsed) {
      // When reading the current size we need to read it after size constraints
      // have been applied. Intentionally use previous frame values for
      // InnerRect and ScrollbarSizes. And when we use window->DecorationUp here
      // it doesn't have ScrollbarSizes.y applied yet.
      Vec2 avail_size_from_current_frame =
          Vec2(window->SizeFull.x,
               window->SizeFull.y -
                   (window->DecoOuterSizeY1 + window->DecoOuterSizeY2));
      Vec2 avail_size_from_last_frame =
          Add(window->InnerRect.GetSize(), scrollbar_sizes_from_last_frame);
      Vec2 needed_size_from_last_frame =
          window_just_created
              ? Vec2(0, 0)
              : Add(window->ContentSize, Multiply(window->WindowPadding, 2.0f));
      float size_x_for_scrollbars = use_current_size_for_scrollbar_x
                                        ? avail_size_from_current_frame.x
                                        : avail_size_from_last_frame.x;
      float size_y_for_scrollbars = use_current_size_for_scrollbar_y
                                        ? avail_size_from_current_frame.y
                                        : avail_size_from_last_frame.y;
      // bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May
      // want to use that in the ScrollbarX expression? How many pros vs cons?
      window->ScrollbarY =
          (flags & WindowFlags_AlwaysVerticalScrollbar) ||
          ((needed_size_from_last_frame.y > size_y_for_scrollbars) &&
           !(flags & WindowFlags_NoScrollbar));
      window->ScrollbarX =
          (flags & WindowFlags_AlwaysHorizontalScrollbar) ||
          ((needed_size_from_last_frame.x >
            size_x_for_scrollbars -
                (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) &&
           !(flags & WindowFlags_NoScrollbar) &&
           (flags & WindowFlags_HorizontalScrollbar));
      if (window->ScrollbarX && !window->ScrollbarY)
        window->ScrollbarY =
            (needed_size_from_last_frame.y > size_y_for_scrollbars) &&
            !(flags & WindowFlags_NoScrollbar);
      window->ScrollbarSizes =
          Vec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f,
               window->ScrollbarX ? style.ScrollbarSize : 0.0f);

      // Amend the partially filled window->DecorationXXX values.
      window->DecoOuterSizeX2 += window->ScrollbarSizes.x;
      window->DecoOuterSizeY2 += window->ScrollbarSizes.y;
    }

    // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
    // Update various regions. Variables they depend on should be set above in
    // this function. We set this up after processing the resize grip so that
    // our rectangles doesn't lag by a frame.

    // Outer rectangle
    // Not affected by window border size. Used by:
    // - FindHoveredWindow() (w/ extra padding when border resize is enabled)
    // - Begin() initial clipping rect for drawing window background and
    // borders.
    // - Begin() clipping whole child
    const Rect host_rect =
        ((flags & WindowFlags_ChildWindow) && !(flags & WindowFlags_Popup) &&
         !window_is_child_tooltip)
            ? parent_window->ClipRect
            : viewport_rect;
    const Rect outer_rect = window->Rect();
    const Rect title_bar_rect = window->TitleBarRect();
    window->OuterRectClipped = outer_rect;
    window->OuterRectClipped.ClipWith(host_rect);

    // Inner rectangle
    // Not affected by window border size. Used by:
    // - InnerClipRect
    // - ScrollToRectEx()
    // - NavUpdatePageUpPageDown()
    // - Scrollbar()
    window->InnerRect.Min.x = window->Pos.x + window->DecoOuterSizeX1;
    window->InnerRect.Min.y = window->Pos.y + window->DecoOuterSizeY1;
    window->InnerRect.Max.x =
        window->Pos.x + window->Size.x - window->DecoOuterSizeX2;
    window->InnerRect.Max.y =
        window->Pos.y + window->Size.y - window->DecoOuterSizeY2;

    // Inner clipping rectangle.
    // Will extend a little bit outside the normal work region.
    // This is to allow e.g. Selectable or CollapsingHeader or some separators
    // to cover that space. Force round operator last to ensure that e.g.
    // (int)(max.x-min.x) in user's render code produce correct result. Note
    // that if our window is collapsed we will end up with an inverted (~null)
    // clipping rectangle which is the correct behavior. Affected by
    // window/frame border size. Used by:
    // - Begin() initial clip rect
    float top_border_size =
        (((flags & WindowFlags_MenuBar) || !(flags & WindowFlags_NoTitleBar))
             ? style.FrameBorderSize
             : window->WindowBorderSize);
    window->InnerClipRect.Min.x = Trunc(
        0.5f + window->InnerRect.Min.x +
        Max(Trunc(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
    window->InnerClipRect.Min.y =
        Trunc(0.5f + window->InnerRect.Min.y + top_border_size);
    window->InnerClipRect.Max.x = Trunc(
        0.5f + window->InnerRect.Max.x -
        Max(Trunc(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
    window->InnerClipRect.Max.y =
        Trunc(0.5f + window->InnerRect.Max.y - window->WindowBorderSize);
    window->InnerClipRect.ClipWithFull(host_rect);

    // Default item width. Make it proportional to window size if window
    // manually resizes
    if (window->Size.x > 0.0f && !(flags & WindowFlags_Tooltip) &&
        !(flags & WindowFlags_AlwaysAutoResize))
      window->ItemWidthDefault = Trunc(window->Size.x * 0.65f);
    else
      window->ItemWidthDefault = Trunc(g.FontSize * 16.0f);

    // SCROLLING

    // Lock down maximum scrolling
    // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is
    // intentionally using InnerRect from previous rect in order to accommodate
    // for right/bottom aligned items without creating a scrollbar.
    window->ScrollMax.x =
        Max(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f -
                      window->InnerRect.GetWidth());
    window->ScrollMax.y =
        Max(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f -
                      window->InnerRect.GetHeight());

    // Apply scrolling
    window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
    window->ScrollTarget = Vec2(FLT_MAX, FLT_MAX);
    window->DecoInnerSizeX1 = window->DecoInnerSizeY1 = 0.0f;

    // DRAWING

    // Setup draw list and outer clipping rectangle
    GUI_ASSERT(window->DrawList->CmdBuffer.Size == 1 &&
               window->DrawList->CmdBuffer[0].ElemCount == 0);
    window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
    PushClipRect(host_rect.Min, host_rect.Max, false);

    // Child windows can render their decoration (bg color, border, scrollbars,
    // etc.) within their parent to save a draw call (since 1.71) When using
    // overlapping child windows, this will break the assumption that child
    // z-order is mapped to submission order.
    // FIXME: User code may rely on explicit sorting of overlapping child window
    // and would need to disable this somehow. Please get in contact if you are
    // affected (github #4493)
    {
      bool render_decorations_in_parent = false;
      if ((flags & WindowFlags_ChildWindow) && !(flags & WindowFlags_Popup) &&
          !window_is_child_tooltip) {
        // - We test overlap with the previous child window only (testing all
        // would end up being O(log N) not a good investment here)
        // - We disable this when the parent window has zero vertices, which is
        // a common pattern leading to laying out multiple overlapping childs
        Window *previous_child =
            parent_window->DC.ChildWindows.Size >= 2
                ? parent_window->DC
                      .ChildWindows[parent_window->DC.ChildWindows.Size - 2]
                : NULL;
        bool previous_child_overlapping =
            previous_child ? previous_child->Rect().Overlaps(window->Rect())
                           : false;
        bool parent_is_empty = (parent_window->DrawList->VtxBuffer.Size == 0);
        if (window->DrawList->CmdBuffer.back().ElemCount == 0 &&
            !parent_is_empty && !previous_child_overlapping)
          render_decorations_in_parent = true;
      }
      if (render_decorations_in_parent)
        window->DrawList = parent_window->DrawList;

      // Handle title bar, scrollbar, resize grips and resize borders
      const Window *window_to_highlight =
          g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
      const bool title_bar_is_highlight =
          want_focus ||
          (window_to_highlight &&
           window->RootWindowForTitleBarHighlight ==
               window_to_highlight->RootWindowForTitleBarHighlight);
      const bool handle_borders_and_resize_grips =
          true; // This exists to facilitate merge with 'docking' branch.
      RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight,
                              handle_borders_and_resize_grips,
                              resize_grip_count, resize_grip_col,
                              resize_grip_draw_size);

      if (render_decorations_in_parent)
        window->DrawList = &window->DrawListInst;
    }

    // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)

    // Work rectangle.
    // Affected by window padding and border size. Used by:
    // - Columns() for right-most edge
    // - TreeNode(), CollapsingHeader() for right-most edge
    // - BeginTabBar() for right-most edge
    const bool allow_scrollbar_x = !(flags & WindowFlags_NoScrollbar) &&
                                   (flags & WindowFlags_HorizontalScrollbar);
    const bool allow_scrollbar_y = !(flags & WindowFlags_NoScrollbar);
    const float work_rect_size_x =
        (window->ContentSizeExplicit.x != 0.0f
             ? window->ContentSizeExplicit.x
             : Max(allow_scrollbar_x ? window->ContentSize.x : 0.0f,
                   window->Size.x - window->WindowPadding.x * 2.0f -
                       (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
    const float work_rect_size_y =
        (window->ContentSizeExplicit.y != 0.0f
             ? window->ContentSizeExplicit.y
             : Max(allow_scrollbar_y ? window->ContentSize.y : 0.0f,
                   window->Size.y - window->WindowPadding.y * 2.0f -
                       (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
    window->WorkRect.Min.x =
        Trunc(window->InnerRect.Min.x - window->Scroll.x +
              Max(window->WindowPadding.x, window->WindowBorderSize));
    window->WorkRect.Min.y =
        Trunc(window->InnerRect.Min.y - window->Scroll.y +
              Max(window->WindowPadding.y, window->WindowBorderSize));
    window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
    window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;
    window->ParentWorkRect = window->WorkRect;

    // [LEGACY] Content Region
    // FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very
    // misleading / partly faulty, but some BeginChild() patterns relies on it.
    // Unless explicit content size is specified by user, this currently
    // represent the region leading to no scrolling. Used by:
    // - Mouse wheel scrolling + many other things
    window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x +
                                      window->WindowPadding.x +
                                      window->DecoOuterSizeX1;
    window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y +
                                      window->WindowPadding.y +
                                      window->DecoOuterSizeY1;
    window->ContentRegionRect.Max.x =
        window->ContentRegionRect.Min.x +
        (window->ContentSizeExplicit.x != 0.0f
             ? window->ContentSizeExplicit.x
             : (window->Size.x - window->WindowPadding.x * 2.0f -
                (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
    window->ContentRegionRect.Max.y =
        window->ContentRegionRect.Min.y +
        (window->ContentSizeExplicit.y != 0.0f
             ? window->ContentSizeExplicit.y
             : (window->Size.y - window->WindowPadding.y * 2.0f -
                (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));

    // Setup drawing context
    // (NB: That term "drawing context / DC" lost its meaning a long time ago.
    // Initially was meant to hold transient data only. Nowadays difference
    // between window-> and window->DC-> is dubious.)
    window->DC.Indent.x =
        window->DecoOuterSizeX1 + window->WindowPadding.x - window->Scroll.x;
    window->DC.GroupOffset.x = 0.0f;
    window->DC.ColumnsOffset.x = 0.0f;

    // Record the loss of precision of CursorStartPos which can happen due to
    // really large scrolling amount. This is used by clipper to compensate and
    // fix the most common use case of large scroll area. Easy and cheap, next
    // best thing compared to switching everything to double orU64.
    double start_pos_highp_x = (double)window->Pos.x + window->WindowPadding.x -
                               (double)window->Scroll.x +
                               window->DecoOuterSizeX1 +
                               window->DC.ColumnsOffset.x;
    double start_pos_highp_y = (double)window->Pos.y + window->WindowPadding.y -
                               (double)window->Scroll.y +
                               window->DecoOuterSizeY1;
    window->DC.CursorStartPos =
        Vec2((float)start_pos_highp_x, (float)start_pos_highp_y);
    window->DC.CursorStartPosLossyness =
        Vec2((float)(start_pos_highp_x - window->DC.CursorStartPos.x),
             (float)(start_pos_highp_y - window->DC.CursorStartPos.y));
    window->DC.CursorPos = window->DC.CursorStartPos;
    window->DC.CursorPosPrevLine = window->DC.CursorPos;
    window->DC.CursorMaxPos = window->DC.CursorStartPos;
    window->DC.IdealMaxPos = window->DC.CursorStartPos;
    window->DC.CurrLineSize = window->DC.PrevLineSize = Vec2(0.0f, 0.0f);
    window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset =
        0.0f;
    window->DC.IsSameLine = window->DC.IsSetPos = false;

    window->DC.NavLayerCurrent = NavLayer_Main;
    window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;
    window->DC.NavLayersActiveMaskNext = 0x00;
    window->DC.NavIsScrollPushableX = true;
    window->DC.NavHideHighlightOneFrame = false;
    window->DC.NavWindowHasScrollY = (window->ScrollMax.y > 0.0f);

    window->DC.MenuBarAppending = false;
    window->DC.MenuColumns.Update(style.ItemSpacing.x,
                                  window_just_activated_by_user);
    window->DC.TreeDepth = 0;
    window->DC.TreeJumpToParentOnPopMask = 0x00;
    window->DC.ChildWindows.resize(0);
    window->DC.StateStorage = &window->StateStorage;
    window->DC.CurrentColumns = NULL;
    window->DC.LayoutType = LayoutType_Vertical;
    window->DC.ParentLayoutType =
        parent_window ? parent_window->DC.LayoutType : LayoutType_Vertical;

    window->DC.ItemWidth = window->ItemWidthDefault;
    window->DC.TextWrapPos = -1.0f; // disabled
    window->DC.ItemWidthStack.resize(0);
    window->DC.TextWrapPosStack.resize(0);

    if (window->AutoFitFramesX > 0)
      window->AutoFitFramesX--;
    if (window->AutoFitFramesY > 0)
      window->AutoFitFramesY--;

    // Apply focus (we need to call FocusWindow() AFTER setting
    // DC.CursorStartPos so our initial navigation reference rectangle can start
    // around there) We FocusRequestFlags_UnlessBelowModal to:
    // - Avoid focusing a window that is created outside of a modal. This will
    // prevent active modal from being closed.
    // - Position window behind the modal that is not a begin-parent of this
    // window.
    if (want_focus)
      FocusWindow(window, FocusRequestFlags_UnlessBelowModal);
    if (want_focus && window == g.NavWindow)
      NavInitWindow(window,
                    false); // <-- this is in the way for us to be able to defer
                            // and sort reappearing FocusWindow() calls

    // Title bar
    if (!(flags & WindowFlags_NoTitleBar))
      RenderWindowTitleBarContents(
          window,
          Rect(title_bar_rect.Min.x + window->WindowBorderSize,
               title_bar_rect.Min.y,
               title_bar_rect.Max.x - window->WindowBorderSize,
               title_bar_rect.Max.y),
          name, p_open);

    // Clear hit test shape every frame
    window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;

    // Pressing CTRL+C while holding on a window copy its content to the
    // clipboard This works but 1. doesn't handle multiple Begin/End pairs, 2.
    // recursing into another Begin/End pair - so we need to work that out and
    // add better logging scope. Maybe we can support CTRL+C on every element?
    /*
    //if (g.NavWindow == window && g.ActiveId == 0)
    if (g.ActiveId == window->MoveId)
        if (g.IO.KeyCtrl && IsKeyPressed(Key_C))
            LogToClipboard();
    */

    // We fill last item data based on Title Bar/Tab, in order for
    // IsItemHovered() and IsItemActive() to be usable after Begin(). This is
    // useful to allow creating context menus on title bar only, etc.
    SetLastItemData(
        window->MoveId, g.CurrentItemFlags,
        IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false)
            ? ItemStatusFlags_HoveredRect
            : 0,
        title_bar_rect);

    // [DEBUG]
#ifndef GUI_DISABLE_DEBUG_TOOLS
    if (g.DebugLocateId != 0 &&
        (window->ID == g.DebugLocateId || window->MoveId == g.DebugLocateId))
      DebugLocateItemResolveWithLastItem();
#endif

      // [Test Engine] Register title bar / tab with MoveId.
#ifdef GUI_ENABLE_TEST_ENGINE
    if (!(window->Flags & WindowFlags_NoTitleBar))
      GUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.ID, g.LastItemData.Rect,
                               &g.LastItemData);
#endif
  } else {
    // Append
    SetCurrentWindow(window);
  }

  PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

  // Clear 'accessed' flag last thing (After PushClipRect which will set the
  // flag. We want the flag to stay false when the default "Debug" window is
  // unused)
  window->WriteAccessed = false;
  window->BeginCount++;
  g.NextWindowData.ClearFlags();

  // Update visibility
  if (first_begin_of_the_frame) {
    if ((flags & WindowFlags_ChildWindow) && !(flags & WindowFlags_ChildMenu)) {
      // Child window can be out of sight and have "negative" clip windows.
      // Mark them as collapsed so commands are skipped earlier (we can't
      // manually collapse them because they have no title bar).
      GUI_ASSERT((flags & WindowFlags_NoTitleBar) != 0);
      const bool nav_request =
          (flags & WindowFlags_NavFlattened) &&
          (g.NavAnyRequest && g.NavWindow &&
           g.NavWindow->RootWindowForNav == window->RootWindowForNav);
      if (!g.LogEnabled && !nav_request)
        if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x ||
            window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y) {
          if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
            window->HiddenFramesCannotSkipItems = 1;
          else
            window->HiddenFramesCanSkipItems = 1;
        }

      // Hide along with parent or if parent is collapsed
      if (parent_window && (parent_window->Collapsed ||
                            parent_window->HiddenFramesCanSkipItems > 0))
        window->HiddenFramesCanSkipItems = 1;
      if (parent_window && (parent_window->Collapsed ||
                            parent_window->HiddenFramesCannotSkipItems > 0))
        window->HiddenFramesCannotSkipItems = 1;
    }

    // Don't render if style alpha is 0.0 at the time of Begin(). This is
    // arbitrary and inconsistent but has been there for a long while (may
    // remove at some point)
    if (style.Alpha <= 0.0f)
      window->HiddenFramesCanSkipItems = 1;

    // Update the Hidden flag
    bool hidden_regular = (window->HiddenFramesCanSkipItems > 0) ||
                          (window->HiddenFramesCannotSkipItems > 0);
    window->Hidden = hidden_regular || (window->HiddenFramesForRenderOnly > 0);

    // Disable inputs for requested number of frames
    if (window->DisableInputsFrames > 0) {
      window->DisableInputsFrames--;
      window->Flags |= WindowFlags_NoInputs;
    }

    // Update the SkipItems flag, used to early out of all items functions (no
    // layout required)
    bool skip_items = false;
    if (window->Collapsed || !window->Active || hidden_regular)
      if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 &&
          window->HiddenFramesCannotSkipItems <= 0)
        skip_items = true;
    window->SkipItems = skip_items;
  }

  // [DEBUG] io.ConfigDebugBeginReturnValue override return value to test
  // Begin/End and BeginChild/EndChild behaviors. (The implicit fallback window
  // is NOT automatically ended allowing it to always be able to receive
  // commands without crashing)
  if (!window->IsFallbackWindow &&
      ((g.IO.ConfigDebugBeginReturnValueOnce && window_just_created) ||
       (g.IO.ConfigDebugBeginReturnValueLoop &&
        g.DebugBeginReturnValueCullDepth == g.CurrentWindowStack.Size))) {
    if (window->AutoFitFramesX > 0) {
      window->AutoFitFramesX++;
    }
    if (window->AutoFitFramesY > 0) {
      window->AutoFitFramesY++;
    }
    return false;
  }

  return !window->SkipItems;
}

inline void Gui::End() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  // Error checking: verify that user hasn't called End() too many times!
  if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow) {
    GUI_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1,
                          "Calling End() too many times!");
    return;
  }
  GUI_ASSERT(g.CurrentWindowStack.Size > 0);

  // Error checking: verify that user doesn't directly call End() on a child
  // window.
  if (window->Flags & WindowFlags_ChildWindow)
    GUI_ASSERT_USER_ERROR(g.WithinEndChild,
                          "Must call EndChild() and not End()!");

  // Close anything that is open
  if (window->DC.CurrentColumns)
    EndColumns();
  PopClipRect(); // Inner window clip rectangle
  if ((window->Flags & WindowFlags_NavFlattened) == 0)
    PopFocusScope();

  // Stop logging
  if (!(window->Flags & WindowFlags_ChildWindow)) // FIXME: add more options
                                                  // for scope of logging
    LogFinish();

  if (window->DC.IsSetPos)
    ErrorCheckUsingSetCursorPosToExtendParentBoundaries();

  // Pop from window stack
  g.LastItemData = g.CurrentWindowStack.back().ParentLastItemDataBackup;
  if (window->Flags & WindowFlags_ChildMenu)
    g.BeginMenuCount--;
  if (window->Flags & WindowFlags_Popup)
    g.BeginPopupStack.pop_back();
  g.CurrentWindowStack.back().StackSizesOnBegin.CompareWithContextState(&g);
  g.CurrentWindowStack.pop_back();
  SetCurrentWindow(g.CurrentWindowStack.Size == 0
                       ? NULL
                       : g.CurrentWindowStack.back().Window);
}

inline void Gui::BringWindowToFocusFront(Window *window) {
  Context &g = *GGui;
  GUI_ASSERT(window == window->RootWindow);

  const int cur_order = window->FocusOrder;
  GUI_ASSERT(g.WindowsFocusOrder[cur_order] == window);
  if (g.WindowsFocusOrder.back() == window)
    return;

  const int new_order = g.WindowsFocusOrder.Size - 1;
  for (int n = cur_order; n < new_order; n++) {
    g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
    g.WindowsFocusOrder[n]->FocusOrder--;
    GUI_ASSERT(g.WindowsFocusOrder[n]->FocusOrder == n);
  }
  g.WindowsFocusOrder[new_order] = window;
  window->FocusOrder = (short)new_order;
}

inline void Gui::BringWindowToDisplayFront(Window *window) {
  Context &g = *GGui;
  Window *current_front_window = g.Windows.back();
  if (current_front_window == window ||
      current_front_window->RootWindow ==
          window) // Cheap early out (could be better)
    return;
  for (int i = g.Windows.Size - 2; i >= 0;
       i--) // We can ignore the top-most window
    if (g.Windows[i] == window) {
      memmove(&g.Windows[i], &g.Windows[i + 1],
              (size_t)(g.Windows.Size - i - 1) * sizeof(Window *));
      g.Windows[g.Windows.Size - 1] = window;
      break;
    }
}

inline void Gui::BringWindowToDisplayBack(Window *window) {
  Context &g = *GGui;
  if (g.Windows[0] == window)
    return;
  for (int i = 0; i < g.Windows.Size; i++)
    if (g.Windows[i] == window) {
      memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(Window *));
      g.Windows[0] = window;
      break;
    }
}

inline void Gui::BringWindowToDisplayBehind(Window *window,
                                            Window *behind_window) {
  GUI_ASSERT(window != NULL && behind_window != NULL);
  Context &g = *GGui;
  window = window->RootWindow;
  behind_window = behind_window->RootWindow;
  int pos_wnd = FindWindowDisplayIndex(window);
  int pos_beh = FindWindowDisplayIndex(behind_window);
  if (pos_wnd < pos_beh) {
    size_t copy_bytes = (pos_beh - pos_wnd - 1) * sizeof(Window *);
    memmove(&g.Windows.Data[pos_wnd], &g.Windows.Data[pos_wnd + 1], copy_bytes);
    g.Windows[pos_beh - 1] = window;
  } else {
    size_t copy_bytes = (pos_wnd - pos_beh) * sizeof(Window *);
    memmove(&g.Windows.Data[pos_beh + 1], &g.Windows.Data[pos_beh], copy_bytes);
    g.Windows[pos_beh] = window;
  }
}

// Moving window to front of display and set focus (which happens to be back of
// our sorted list)
inline void Gui::FocusWindow(Window *window, FocusRequestFlags flags) {
  Context &g = *GGui;

  // Modal check?
  if ((flags & FocusRequestFlags_UnlessBelowModal) &&
      (g.NavWindow != window)) // Early out in common case.
    if (Window *blocking_modal = FindBlockingModal(window)) {
      GUI_DEBUG_LOG_FOCUS("[focus] FocusWindow(\"%s\", UnlessBelowModal): "
                          "prevented by \"%s\".\n",
                          window ? window->Name : "<NULL>",
                          blocking_modal->Name);
      if (window && window == window->RootWindow &&
          (window->Flags & WindowFlags_NoBringToFrontOnFocus) == 0)
        BringWindowToDisplayBehind(
            window, blocking_modal); // Still bring to right below modal.
      return;
    }

  // Find last focused child (if any) and focus it instead.
  if ((flags & FocusRequestFlags_RestoreFocusedChild) && window != NULL)
    window = NavRestoreLastChildNavWindow(window);

  // Apply focus
  if (g.NavWindow != window) {
    SetNavWindow(window);
    if (window && g.NavDisableMouseHover)
      g.NavMousePosDirty = true;
    g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
    g.NavLayer = NavLayer_Main;
    g.NavFocusScopeId = window ? window->NavRootFocusScopeId : 0;
    g.NavIdIsAlive = false;
    g.NavLastValidSelectionUserData = SelectionUserData_Invalid;

    // Close popups if any
    ClosePopupsOverWindow(window, false);
  }

  // Move the root window to the top of the pile
  GUI_ASSERT(window == NULL || window->RootWindow != NULL);
  Window *focus_front_window =
      window ? window->RootWindow
             : NULL; // NB: In docking branch this is window->RootWindowDockStop
  Window *display_front_window = window ? window->RootWindow : NULL;

  // Steal active widgets. Some of the cases it triggers includes:
  // - Focus a window while an InputText in another window is active, if focus
  // happens before the old InputText can run.
  // - When using Nav to activate menu items (due to timing of activating on
  // press->new window appears->losing ActiveId)
  if (g.ActiveId != 0 && g.ActiveIdWindow &&
      g.ActiveIdWindow->RootWindow != focus_front_window)
    if (!g.ActiveIdNoClearOnFocusLoss)
      ClearActiveID();

  // Passing NULL allow to disable keyboard focus
  if (!window)
    return;

  // Bring to front
  BringWindowToFocusFront(focus_front_window);
  if (((window->Flags | display_front_window->Flags) &
       WindowFlags_NoBringToFrontOnFocus) == 0)
    BringWindowToDisplayFront(display_front_window);
}

inline void Gui::FocusTopMostWindowUnderOne(Window *under_this_window,
                                            Window *ignore_window,
                                            Viewport *filter_viewport,
                                            FocusRequestFlags flags) {
  Context &g = *GGui;
  GUI_UNUSED(filter_viewport); // Unused in master branch.
  int start_idx = g.WindowsFocusOrder.Size - 1;
  if (under_this_window != NULL) {
    // Aim at root window behind us, if we are in a child window that's our own
    // root (see #4640)
    int offset = -1;
    while (under_this_window->Flags & WindowFlags_ChildWindow) {
      under_this_window = under_this_window->ParentWindow;
      offset = 0;
    }
    start_idx = FindWindowFocusIndex(under_this_window) + offset;
  }
  for (int i = start_idx; i >= 0; i--) {
    // We may later decide to test for different NoXXXInputs based on the active
    // navigation input (mouse vs nav) but that may feel more confusing to the
    // user.
    Window *window = g.WindowsFocusOrder[i];
    if (window == ignore_window || !window->WasActive)
      continue;
    if ((window->Flags &
         (WindowFlags_NoMouseInputs | WindowFlags_NoNavInputs)) !=
        (WindowFlags_NoMouseInputs | WindowFlags_NoNavInputs)) {
      FocusWindow(window, flags);
      return;
    }
  }
  FocusWindow(NULL, flags);
}

// Important: this alone doesn't alter current DrawList state. This is called
// by PushFont/PopFont only.
inline void Gui::SetCurrentFont(Font *font) {
  Context &g = *GGui;
  GUI_ASSERT(
      font &&
      font->IsLoaded()); // Font Atlas not created. Did you call
                         // io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
  GUI_ASSERT(font->Scale > 0.0f);
  g.Font = font;
  g.FontBaseSize =
      Max(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
  g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

  FontAtlas *atlas = g.Font->ContainerAtlas;
  g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
  g.DrawListSharedData.TexUvLines = atlas->TexUvLines;
  g.DrawListSharedData.Font = g.Font;
  g.DrawListSharedData.FontSize = g.FontSize;
}

inline void Gui::PushFont(Font *font) {
  Context &g = *GGui;
  if (!font)
    font = GetDefaultFont();
  SetCurrentFont(font);
  g.FontStack.push_back(font);
  g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);
}

inline void Gui::PopFont() {
  Context &g = *GGui;
  g.CurrentWindow->DrawList->PopTextureID();
  g.FontStack.pop_back();
  SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());
}

inline void Gui::PushItemFlag(ItemFlags option, bool enabled) {
  Context &g = *GGui;
  ItemFlags item_flags = g.CurrentItemFlags;
  GUI_ASSERT(item_flags == g.ItemFlagsStack.back());
  if (enabled)
    item_flags |= option;
  else
    item_flags &= ~option;
  g.CurrentItemFlags = item_flags;
  g.ItemFlagsStack.push_back(item_flags);
}

inline void Gui::PopItemFlag() {
  Context &g = *GGui;
  GUI_ASSERT(g.ItemFlagsStack.Size >
             1); // Too many calls to PopItemFlag() - we always leave a 0 at the
                 // bottom of the stack.
  g.ItemFlagsStack.pop_back();
  g.CurrentItemFlags = g.ItemFlagsStack.back();
}

// BeginDisabled()/EndDisabled()
// - Those can be nested but it cannot be used to enable an already disabled
// section (a single BeginDisabled(true) in the stack is enough to keep
// everything disabled)
// - Visually this is currently altering alpha, but it is expected that in a
// future styling system this would work differently.
// - Feedback welcome at https://github.com/ocornut/imgui/issues/211
// - BeginDisabled(false) essentially does nothing useful but is provided to
// facilitate use of boolean expressions. If you can avoid calling
// BeginDisabled(False)/EndDisabled() best to avoid it.
// - Optimized shortcuts instead of PushStyleVar() + PushItemFlag()
inline void Gui::BeginDisabled(bool disabled) {
  Context &g = *GGui;
  bool was_disabled = (g.CurrentItemFlags & ItemFlags_Disabled) != 0;
  if (!was_disabled && disabled) {
    g.DisabledAlphaBackup = g.Style.Alpha;
    g.Style.Alpha *=
        g.Style.DisabledAlpha; // PushStyleVar(StyleVar_Alpha,
                               // g.Style.Alpha * g.Style.DisabledAlpha);
  }
  if (was_disabled || disabled)
    g.CurrentItemFlags |= ItemFlags_Disabled;
  g.ItemFlagsStack.push_back(g.CurrentItemFlags);
  g.DisabledStackSize++;
}

inline void Gui::EndDisabled() {
  Context &g = *GGui;
  GUI_ASSERT(g.DisabledStackSize > 0);
  g.DisabledStackSize--;
  bool was_disabled = (g.CurrentItemFlags & ItemFlags_Disabled) != 0;
  // PopItemFlag();
  g.ItemFlagsStack.pop_back();
  g.CurrentItemFlags = g.ItemFlagsStack.back();
  if (was_disabled && (g.CurrentItemFlags & ItemFlags_Disabled) == 0)
    g.Style.Alpha = g.DisabledAlphaBackup; // PopStyleVar();
}

inline void Gui::PushTabStop(bool tab_stop) {
  PushItemFlag(ItemFlags_NoTabStop, !tab_stop);
}

inline void Gui::PopTabStop() { PopItemFlag(); }

inline void Gui::PushButtonRepeat(bool repeat) {
  PushItemFlag(ItemFlags_ButtonRepeat, repeat);
}

inline void Gui::PopButtonRepeat() { PopItemFlag(); }

inline void Gui::PushTextWrapPos(float wrap_pos_x) {
  Window *window = GetCurrentWindow();
  window->DC.TextWrapPosStack.push_back(window->DC.TextWrapPos);
  window->DC.TextWrapPos = wrap_pos_x;
}

inline void Gui::PopTextWrapPos() {
  Window *window = GetCurrentWindow();
  window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();
  window->DC.TextWrapPosStack.pop_back();
}

static Window *GetCombinedRootWindow(Window *window, bool popup_hierarchy) {
  Window *last_window = NULL;
  while (last_window != window) {
    last_window = window;
    window = window->RootWindow;
    if (popup_hierarchy)
      window = window->RootWindowPopupTree;
  }
  return window;
}

inline bool Gui::IsWindowChildOf(Window *window, Window *potential_parent,
                                 bool popup_hierarchy) {
  Window *window_root = GetCombinedRootWindow(window, popup_hierarchy);
  if (window_root == potential_parent)
    return true;
  while (window != NULL) {
    if (window == potential_parent)
      return true;
    if (window == window_root) // end of chain
      return false;
    window = window->ParentWindow;
  }
  return false;
}

inline bool Gui::IsWindowAbove(Window *potential_above,
                               Window *potential_below) {
  Context &g = *GGui;

  // It would be saner to ensure that display layer is always reflected in the
  // g.Windows[] order, which would likely requires altering all manipulations
  // of that array
  const int display_layer_delta = GetWindowDisplayLayer(potential_above) -
                                  GetWindowDisplayLayer(potential_below);
  if (display_layer_delta != 0)
    return display_layer_delta > 0;

  for (int i = g.Windows.Size - 1; i >= 0; i--) {
    Window *candidate_window = g.Windows[i];
    if (candidate_window == potential_above)
      return true;
    if (candidate_window == potential_below)
      return false;
  }
  return false;
}

// Is current window hovered and hoverable (e.g. not blocked by a popup/modal)?
// See HoveredFlags_ for options. IMPORTANT: If you are trying to check
// whether your mouse should be dispatched to Dear Gui or to your underlying
// app, you should not use this function! Use the 'io.WantCaptureMouse' boolean
// for that! Refer to FAQ entry "How can I tell whether to dispatch
// mouse/keyboard to Dear Gui or my application?" for details.
inline bool Gui::IsWindowHovered(HoveredFlags flags) {
  GUI_ASSERT((flags & ~HoveredFlags_AllowedMaskForIsWindowHovered) == 0 &&
             "Invalid flags for IsWindowHovered()!");

  Context &g = *GGui;
  Window *ref_window = g.HoveredWindow;
  Window *cur_window = g.CurrentWindow;
  if (ref_window == NULL)
    return false;

  if ((flags & HoveredFlags_AnyWindow) == 0) {
    GUI_ASSERT(cur_window); // Not inside a Begin()/End()
    const bool popup_hierarchy = (flags & HoveredFlags_NoPopupHierarchy) == 0;
    if (flags & HoveredFlags_RootWindow)
      cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy);

    bool result;
    if (flags & HoveredFlags_ChildWindows)
      result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy);
    else
      result = (ref_window == cur_window);
    if (!result)
      return false;
  }

  if (!IsWindowContentHoverable(ref_window, flags))
    return false;
  if (!(flags & HoveredFlags_AllowWhenBlockedByActiveItem))
    if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap &&
        g.ActiveId != ref_window->MoveId)
      return false;

  // When changing hovered window we requires a bit of stationary delay before
  // activating hover timer.
  // FIXME: We don't support delay other than stationary one for now, other
  // delay would need a way to fullfill the possibility that multiple
  // IsWindowHovered() with varying flag could return true for different windows
  // of the hierarchy. Possibly need a Hash(Current+Flags) ==> (Timer) cache. We
  // can implement this for _Stationary because the data is linked to
  // HoveredWindow rather than CurrentWindow.
  if (flags & HoveredFlags_ForTooltip)
    flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);
  if ((flags & HoveredFlags_Stationary) != 0 &&
      g.HoverWindowUnlockedStationaryId != ref_window->ID)
    return false;

  return true;
}

inline bool Gui::IsWindowFocused(FocusedFlags flags) {
  Context &g = *GGui;
  Window *ref_window = g.NavWindow;
  Window *cur_window = g.CurrentWindow;

  if (ref_window == NULL)
    return false;
  if (flags & FocusedFlags_AnyWindow)
    return true;

  GUI_ASSERT(cur_window); // Not inside a Begin()/End()
  const bool popup_hierarchy = (flags & FocusedFlags_NoPopupHierarchy) == 0;
  if (flags & HoveredFlags_RootWindow)
    cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy);

  if (flags & HoveredFlags_ChildWindows)
    return IsWindowChildOf(ref_window, cur_window, popup_hierarchy);
  else
    return (ref_window == cur_window);
}

// Can we focus this window with CTRL+TAB (or PadMenu +
// PadFocusPrev/PadFocusNext) Note that NoNavFocus makes the window not
// reachable with CTRL+TAB but it can still be focused with mouse or
// programmatically. If you want a window to never be focused, you may use the
// e.g. NoInputs flag.

inline float Gui::GetWindowWidth() {
  Window *window = GGui->CurrentWindow;
  return window->Size.x;
}

inline float Gui::GetWindowHeight() {
  Window *window = GGui->CurrentWindow;
  return window->Size.y;
}

inline Vec2 Gui::GetWindowPos() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  return window->Pos;
}

inline void Gui::SetWindowPos(Window *window, const Vec2 &pos, Cond cond) {
  // Test condition (NB: bit 0 is always true) and clear flags for next time
  if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
    return;

  GUI_ASSERT(cond == 0 ||
             IsPowerOfTwo(cond)); // Make sure the user doesn't attempt to
                                  // combine multiple condition flags.
  window->SetWindowPosAllowFlags &=
      ~(Cond_Once | Cond_FirstUseEver | Cond_Appearing);
  window->SetWindowPosVal = Vec2(FLT_MAX, FLT_MAX);

  // Set
  const Vec2 old_pos = window->Pos;
  window->Pos = Trunc(pos);
  Vec2 offset = Subtract(window->Pos, old_pos);
  if (offset.x == 0.0f && offset.y == 0.0f)
    return;
  MarkIniSettingsDirty(window);
  window->DC.CursorPos =
      Add(window->DC.CursorPos,
          offset); // As we happen to move the window while it is being appended
                   // to (which is a bad idea - will smear) let's at least
                   // offset the cursor
  window->DC.CursorMaxPos =
      Add(window->DC.CursorMaxPos,
          offset); // And more importantly we need to offset
                   // CursorMaxPos/CursorStartPos this so ContentSize
                   // calculation doesn't get affected.
  window->DC.IdealMaxPos = Add(window->DC.IdealMaxPos, offset);
  window->DC.CursorStartPos = Add(window->DC.CursorStartPos, offset);
}

inline void Gui::SetWindowPos(const Vec2 &pos, Cond cond) {
  Window *window = GetCurrentWindowRead();
  SetWindowPos(window, pos, cond);
}

inline void Gui::SetWindowPos(const char *name, const Vec2 &pos, Cond cond) {
  if (Window *window = FindWindowByName(name))
    SetWindowPos(window, pos, cond);
}

inline Vec2 Gui::GetWindowSize() {
  Window *window = GetCurrentWindowRead();
  return window->Size;
}

inline void Gui::SetWindowSize(Window *window, const Vec2 &size, Cond cond) {
  // Test condition (NB: bit 0 is always true) and clear flags for next time
  if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
    return;

  GUI_ASSERT(cond == 0 ||
             IsPowerOfTwo(cond)); // Make sure the user doesn't attempt to
                                  // combine multiple condition flags.
  window->SetWindowSizeAllowFlags &=
      ~(Cond_Once | Cond_FirstUseEver | Cond_Appearing);

  // Enable auto-fit (not done in BeginChild() path unless appearing or combined
  // with ChildFlags_AlwaysAutoResize)
  if ((window->Flags & WindowFlags_ChildWindow) == 0 || window->Appearing ||
      (window->ChildFlags & ChildFlags_AlwaysAutoResize) != 0)
    window->AutoFitFramesX = (size.x <= 0.0f) ? 2 : 0;
  if ((window->Flags & WindowFlags_ChildWindow) == 0 || window->Appearing ||
      (window->ChildFlags & ChildFlags_AlwaysAutoResize) != 0)
    window->AutoFitFramesY = (size.y <= 0.0f) ? 2 : 0;

  // Set
  Vec2 old_size = window->SizeFull;
  if (size.x <= 0.0f)
    window->AutoFitOnlyGrows = false;
  else
    window->SizeFull.x = GUI_TRUNC(size.x);
  if (size.y <= 0.0f)
    window->AutoFitOnlyGrows = false;
  else
    window->SizeFull.y = GUI_TRUNC(size.y);
  if (old_size.x != window->SizeFull.x || old_size.y != window->SizeFull.y)
    MarkIniSettingsDirty(window);
}

inline void Gui::SetWindowSize(const Vec2 &size, Cond cond) {
  SetWindowSize(GGui->CurrentWindow, size, cond);
}

inline void Gui::SetWindowSize(const char *name, const Vec2 &size, Cond cond) {
  if (Window *window = FindWindowByName(name))
    SetWindowSize(window, size, cond);
}

inline void Gui::SetWindowHitTestHole(Window *window, const Vec2 &pos,
                                      const Vec2 &size) {
  GUI_ASSERT(window->HitTestHoleSize.x ==
             0); // We don't support multiple holes/hit test filters
  window->HitTestHoleSize = Vec2ih(size);
  window->HitTestHoleOffset = Vec2ih(Subtract(pos, window->Pos));
}

inline void Gui::SetWindowCollapsed(bool collapsed, Cond cond) {
  SetWindowCollapsed(GGui->CurrentWindow, collapsed, cond);
}

inline bool Gui::IsWindowCollapsed() {
  Window *window = GetCurrentWindowRead();
  return window->Collapsed;
}

inline bool Gui::IsWindowAppearing() {
  Window *window = GetCurrentWindowRead();
  return window->Appearing;
}

inline void Gui::SetWindowCollapsed(const char *name, bool collapsed,
                                    Cond cond) {
  if (Window *window = FindWindowByName(name))
    SetWindowCollapsed(window, collapsed, cond);
}

inline void Gui::SetWindowFocus() { FocusWindow(GGui->CurrentWindow); }

inline void Gui::SetWindowFocus(const char *name) {
  if (name) {
    if (Window *window = FindWindowByName(name))
      FocusWindow(window);
  } else {
    FocusWindow(NULL);
  }
}

inline void Gui::SetNextWindowPos(const Vec2 &pos, Cond cond,
                                  const Vec2 &pivot) {
  Context &g = *GGui;
  GUI_ASSERT(cond == 0 ||
             IsPowerOfTwo(cond)); // Make sure the user doesn't attempt to
                                  // combine multiple condition flags.
  g.NextWindowData.Flags |= NextWindowDataFlags_HasPos;
  g.NextWindowData.PosVal = pos;
  g.NextWindowData.PosPivotVal = pivot;
  g.NextWindowData.PosCond = cond ? cond : Cond_Always;
}

inline void Gui::SetNextWindowSize(const Vec2 &size, Cond cond) {
  Context &g = *GGui;
  GUI_ASSERT(cond == 0 ||
             IsPowerOfTwo(cond)); // Make sure the user doesn't attempt to
                                  // combine multiple condition flags.
  g.NextWindowData.Flags |= NextWindowDataFlags_HasSize;
  g.NextWindowData.SizeVal = size;
  g.NextWindowData.SizeCond = cond ? cond : Cond_Always;
}

// For each axis:
// - Use 0.0f as min or FLT_MAX as max if you don't want limits, e.g. size_min =
// (500.0f, 0.0f), size_max = (FLT_MAX, FLT_MAX) sets a minimum width.
// - Use -1 for both min and max of same axis to preserve current size which
// itself is a constraint.
// - See "Demo->Examples->Constrained-resizing window" for examples.
inline void Gui::SetNextWindowSizeConstraints(const Vec2 &size_min,
                                              const Vec2 &size_max,
                                              SizeCallback custom_callback,
                                              void *custom_callback_user_data) {
  Context &g = *GGui;
  g.NextWindowData.Flags |= NextWindowDataFlags_HasSizeConstraint;
  g.NextWindowData.SizeConstraintRect = Rect(size_min, size_max);
  g.NextWindowData.SizeCallback = custom_callback;
  g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}

// Content size = inner scrollable rectangle, padded with WindowPadding.
// SetNextWindowContentSize(Vec2(100,100) + WindowFlags_AlwaysAutoResize
// will always allow submitting a 100x100 item.
inline void Gui::SetNextWindowContentSize(const Vec2 &size) {
  Context &g = *GGui;
  g.NextWindowData.Flags |= NextWindowDataFlags_HasContentSize;
  g.NextWindowData.ContentSizeVal = Trunc(size);
}

inline void Gui::SetNextWindowScroll(const Vec2 &scroll) {
  Context &g = *GGui;
  g.NextWindowData.Flags |= NextWindowDataFlags_HasScroll;
  g.NextWindowData.ScrollVal = scroll;
}

inline void Gui::SetNextWindowCollapsed(bool collapsed, Cond cond) {
  Context &g = *GGui;
  GUI_ASSERT(cond == 0 ||
             IsPowerOfTwo(cond)); // Make sure the user doesn't attempt to
                                  // combine multiple condition flags.
  g.NextWindowData.Flags |= NextWindowDataFlags_HasCollapsed;
  g.NextWindowData.CollapsedVal = collapsed;
  g.NextWindowData.CollapsedCond = cond ? cond : Cond_Always;
}

inline void Gui::SetNextWindowFocus() {
  Context &g = *GGui;
  g.NextWindowData.Flags |= NextWindowDataFlags_HasFocus;
}

inline void Gui::SetNextWindowBgAlpha(float alpha) {
  Context &g = *GGui;
  g.NextWindowData.Flags |= NextWindowDataFlags_HasBgAlpha;
  g.NextWindowData.BgAlphaVal = alpha;
}

inline DrawList *Gui::GetWindowDrawList() {
  Window *window = GetCurrentWindow();
  return window->DrawList;
}

inline Font *Gui::GetFont() { return GGui->Font; }

inline float Gui::GetFontSize() { return GGui->FontSize; }

inline Vec2 Gui::GetFontTexUvWhitePixel() {
  return GGui->DrawListSharedData.TexUvWhitePixel;
}

inline void Gui::SetWindowFontScale(float scale) {
  GUI_ASSERT(scale > 0.0f);
  Context &g = *GGui;
  Window *window = GetCurrentWindow();
  window->FontWindowScale = scale;
  g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

inline void Gui::PopFocusScope() {
  Context &g = *GGui;
  GUI_ASSERT(g.FocusScopeStack.Size > 0); // Too many PopFocusScope() ?
  g.FocusScopeStack.pop_back();
  g.CurrentFocusScopeId = g.FocusScopeStack.Size ? g.FocusScopeStack.back() : 0;
}

// Focus = move navigation cursor, set scrolling, set focus window.
inline void Gui::FocusItem() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_DEBUG_LOG_FOCUS("FocusItem(0x%08x) in window \"%s\"\n", g.LastItemData.ID,
                      window->Name);
  if (g.DragDropActive ||
      g.MovingWindow != NULL) // FIXME: Opt-in flags for this?
  {
    GUI_DEBUG_LOG_FOCUS("FocusItem() ignored while DragDropActive!\n");
    return;
  }

  NavMoveFlags move_flags = NavMoveFlags_IsTabbing | NavMoveFlags_FocusApi |
                            NavMoveFlags_NoSetNavHighlight |
                            NavMoveFlags_NoSelect;
  ScrollFlags scroll_flags =
      window->Appearing
          ? ScrollFlags_KeepVisibleEdgeX | ScrollFlags_AlwaysCenterY
          : ScrollFlags_KeepVisibleEdgeX | ScrollFlags_KeepVisibleEdgeY;
  SetNavWindow(window);
  NavMoveRequestSubmit(Dir_None, Dir_Up, move_flags, scroll_flags);
  NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal);
}

// Note: this will likely be called ActivateItem() once we rework our
// Focus/Activation system! But ActivateItem() should function without altering
// scroll/focus?
inline void Gui::SetKeyboardFocusHere(int offset) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_ASSERT(offset >= -1); // -1 is allowed but not below
  GUI_DEBUG_LOG_FOCUS("SetKeyboardFocusHere(%d) in window \"%s\"\n", offset,
                      window->Name);

  // It makes sense in the vast majority of cases to never interrupt a drag and
  // drop. When we refactor this function into ActivateItem() we may want to
  // make this an option. MovingWindow is protected from most user inputs using
  // SetActiveIdUsingNavAndKeys(), but is also automatically dropped in the
  // event g.ActiveId is stolen.
  if (g.DragDropActive || g.MovingWindow != NULL) {
    GUI_DEBUG_LOG_FOCUS(
        "SetKeyboardFocusHere() ignored while DragDropActive!\n");
    return;
  }

  SetNavWindow(window);

  NavMoveFlags move_flags = NavMoveFlags_IsTabbing | NavMoveFlags_Activate |
                            NavMoveFlags_FocusApi |
                            NavMoveFlags_NoSetNavHighlight;
  ScrollFlags scroll_flags =
      window->Appearing
          ? ScrollFlags_KeepVisibleEdgeX | ScrollFlags_AlwaysCenterY
          : ScrollFlags_KeepVisibleEdgeX | ScrollFlags_KeepVisibleEdgeY;
  NavMoveRequestSubmit(
      Dir_None, offset < 0 ? Dir_Up : Dir_Down, move_flags,
      scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag
                     // to not activate non-inputable.
  if (offset == -1) {
    NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal);
  } else {
    g.NavTabbingDir = 1;
    g.NavTabbingCounter = offset + 1;
  }
}

inline void Gui::SetItemDefaultFocus() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (!window->Appearing)
    return;
  if (g.NavWindow != window->RootWindowForNav ||
      (!g.NavInitRequest && g.NavInitResult.ID == 0) ||
      g.NavLayer != window->DC.NavLayerCurrent)
    return;

  g.NavInitRequest = false;
  NavApplyItemToResult(&g.NavInitResult);
  NavUpdateAnyRequestFlag();

  // Scroll could be done in NavInitRequestApplyResult() via an opt-in flag (we
  // however don't want regular init requests to scroll)
  if (!window->ClipRect.Contains(g.LastItemData.Rect))
    ScrollToRectEx(window, g.LastItemData.Rect, ScrollFlags_None);
}

inline void Gui::SetStateStorage(Storage *tree) {
  Window *window = GGui->CurrentWindow;
  window->DC.StateStorage = tree ? tree : &window->StateStorage;
}

inline Storage *Gui::GetStateStorage() {
  Window *window = GGui->CurrentWindow;
  return window->DC.StateStorage;
}

inline void Gui::PushID(const char *str_id) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  ID id = window->GetID(str_id);
  window->IDStack.push_back(id);
}

inline void Gui::PushID(const char *str_id_begin, const char *str_id_end) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  ID id = window->GetID(str_id_begin, str_id_end);
  window->IDStack.push_back(id);
}

inline void Gui::PushID(const void *ptr_id) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  ID id = window->GetID(ptr_id);
  window->IDStack.push_back(id);
}

inline void Gui::PushID(int int_id) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  ID id = window->GetID(int_id);
  window->IDStack.push_back(id);
}

// Push a given id value ignoring the ID stack as a seed.
inline void Gui::PushOverrideID(ID id) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (g.DebugHookIdInfo == id)
    DebugHookIdInfo(id, DataType_ID, NULL, NULL);
  window->IDStack.push_back(id);
}

// Helper to avoid a common series of PushOverrideID -> GetID() -> PopID() call
// (note that when using this pattern, ID Stack Tool will tend to not display
// the intermediate stack level.
//  for that to work we would need to do PushOverrideID() -> ItemAdd() ->
//  PopID() which would alter widget code a little more)
inline ID Gui::GetIDWithSeed(const char *str, const char *str_end, ID seed) {
  ID id = HashStr(str, str_end ? (str_end - str) : 0, seed);
  Context &g = *GGui;
  if (g.DebugHookIdInfo == id)
    DebugHookIdInfo(id, DataType_String, str, str_end);
  return id;
}

inline ID Gui::GetIDWithSeed(int n, ID seed) {
  ID id = HashData(&n, sizeof(n), seed);
  Context &g = *GGui;
  if (g.DebugHookIdInfo == id)
    DebugHookIdInfo(id, DataType_S32, (void *)(intptr_t)n, NULL);
  return id;
}

inline void Gui::PopID() {
  Window *window = GGui->CurrentWindow;
  GUI_ASSERT(
      window->IDStack.Size >
      1); // Too many PopID(), or could be popping in a wrong/different window?
  window->IDStack.pop_back();
}

inline ID Gui::GetID(const char *str_id) {
  Window *window = GGui->CurrentWindow;
  return window->GetID(str_id);
}

inline ID Gui::GetID(const char *str_id_begin, const char *str_id_end) {
  Window *window = GGui->CurrentWindow;
  return window->GetID(str_id_begin, str_id_end);
}

inline ID Gui::GetID(const void *ptr_id) {
  Window *window = GGui->CurrentWindow;
  return window->GetID(ptr_id);
}

inline bool Gui::IsRectVisible(const Vec2 &size) {
  Window *window = GGui->CurrentWindow;
  return window->ClipRect.Overlaps(
      Rect(window->DC.CursorPos, Add(window->DC.CursorPos, size)));
}

inline bool Gui::IsRectVisible(const Vec2 &rect_min, const Vec2 &rect_max) {
  Window *window = GGui->CurrentWindow;
  return window->ClipRect.Overlaps(Rect(rect_min, rect_max));
}

//-----------------------------------------------------------------------------
// [SECTION] INPUTS
//-----------------------------------------------------------------------------
// - GetKeyData() [Internal]
// - GetKeyIndex() [Internal]
// - GetKeyName()
// - GetKeyChordName() [Internal]
// - CalcTypematicRepeatAmount() [Internal]
// - GetTypematicRepeatRate() [Internal]
// - GetKeyPressedAmount() [Internal]
// - GetKeyMagnitude2d() [Internal]
//-----------------------------------------------------------------------------
// - UpdateKeyRoutingTable() [Internal]
// - GetRoutingIdFromOwnerId() [Internal]
// - GetShortcutRoutingData() [Internal]
// - CalcRoutingScore() [Internal]
// - SetShortcutRouting() [Internal]
// - TestShortcutRouting() [Internal]
//-----------------------------------------------------------------------------
// - IsKeyDown()
// - IsKeyPressed()
// - IsKeyReleased()
//-----------------------------------------------------------------------------
// - IsMouseDown()
// - IsMouseClicked()
// - IsMouseReleased()
// - IsMouseDoubleClicked()
// - GetMouseClickedCount()
// - IsMouseHoveringRect() [Internal]
// - IsMouseDragPastThreshold() [Internal]
// - IsMouseDragging()
// - GetMousePos()
// - SetMousePos() [Internal]
// - GetMousePosOnOpeningCurrentPopup()
// - IsMousePosValid()
// - IsAnyMouseDown()
// - GetMouseDragDelta()
// - ResetMouseDragDelta()
// - GetMouseCursor()
// - SetMouseCursor()
//-----------------------------------------------------------------------------
// - UpdateAliasKey()
// - GetMergedModsFromKeys()
// - UpdateKeyboardInputs()
// - UpdateMouseInputs()
//-----------------------------------------------------------------------------
// - LockWheelingWindow [Internal]
// - FindBestWheelingWindow [Internal]
// - UpdateMouseWheel() [Internal]
//-----------------------------------------------------------------------------
// - SetNextFrameWantCaptureKeyboard()
// - SetNextFrameWantCaptureMouse()
//-----------------------------------------------------------------------------
// - GetInputSourceName() [Internal]
// - DebugPrintInputEvent() [Internal]
// - UpdateInputEvents() [Internal]
//-----------------------------------------------------------------------------
// - GetKeyOwner() [Internal]
// - TestKeyOwner() [Internal]
// - SetKeyOwner() [Internal]
// - SetItemKeyOwner() [Internal]
// - Shortcut() [Internal]
//-----------------------------------------------------------------------------

inline KeyData *Gui::GetKeyData(Context *ctx, Key key) {
  Context &g = *ctx;

  // Special storage location for mods
  if (key & Mod_Mask_)
    key = ConvertSingleModFlagToKey(ctx, key);

#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  GUI_ASSERT(key >= Key_LegacyNativeKey_BEGIN && key < Key_NamedKey_END);
  if (IsLegacyKey(key) && g.IO.KeyMap[key] != -1)
    key = (Key)g.IO.KeyMap[key]; // Remap native->imgui or gui->native
#else
  GUI_ASSERT(IsNamedKey(key) &&
             "Support for user key indices was dropped in favor of Key. "
             "Please update backend & user code.");
#endif
  return &g.IO.KeysData[key - Key_KeysData_OFFSET];
}

#ifndef GUI_DISABLE_OBSOLETE_KEYIO
inline Key Gui::GetKeyIndex(Key key) {
  Context &g = *GGui;
  GUI_ASSERT(IsNamedKey(key));
  const KeyData *key_data = GetKeyData(key);
  return (Key)(key_data - g.IO.KeysData);
}
#endif

// Those names a provided for debugging purpose and are not meant to be saved
// persistently not compared.
static const char *const GKeyNames[] = {
    "Tab",
    "LeftArrow",
    "RightArrow",
    "UpArrow",
    "DownArrow",
    "PageUp",
    "PageDown",
    "Home",
    "End",
    "Insert",
    "Delete",
    "Backspace",
    "Space",
    "Enter",
    "Escape",
    "LeftCtrl",
    "LeftShift",
    "LeftAlt",
    "LeftSuper",
    "RightCtrl",
    "RightShift",
    "RightAlt",
    "RightSuper",
    "Menu",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "F9",
    "F10",
    "F11",
    "F12",
    "F13",
    "F14",
    "F15",
    "F16",
    "F17",
    "F18",
    "F19",
    "F20",
    "F21",
    "F22",
    "F23",
    "F24",
    "Apostrophe",
    "Comma",
    "Minus",
    "Period",
    "Slash",
    "Semicolon",
    "Equal",
    "LeftBracket",
    "Backslash",
    "RightBracket",
    "GraveAccent",
    "CapsLock",
    "ScrollLock",
    "NumLock",
    "PrintScreen",
    "Pause",
    "Keypad0",
    "Keypad1",
    "Keypad2",
    "Keypad3",
    "Keypad4",
    "Keypad5",
    "Keypad6",
    "Keypad7",
    "Keypad8",
    "Keypad9",
    "KeypadDecimal",
    "KeypadDivide",
    "KeypadMultiply",
    "KeypadSubtract",
    "KeypadAdd",
    "KeypadEnter",
    "KeypadEqual",
    "AppBack",
    "AppForward",
    "GamepadStart",
    "GamepadBack",
    "GamepadFaceLeft",
    "GamepadFaceRight",
    "GamepadFaceUp",
    "GamepadFaceDown",
    "GamepadDpadLeft",
    "GamepadDpadRight",
    "GamepadDpadUp",
    "GamepadDpadDown",
    "GamepadL1",
    "GamepadR1",
    "GamepadL2",
    "GamepadR2",
    "GamepadL3",
    "GamepadR3",
    "GamepadLStickLeft",
    "GamepadLStickRight",
    "GamepadLStickUp",
    "GamepadLStickDown",
    "GamepadRStickLeft",
    "GamepadRStickRight",
    "GamepadRStickUp",
    "GamepadRStickDown",
    "MouseLeft",
    "MouseRight",
    "MouseMiddle",
    "MouseX1",
    "MouseX2",
    "MouseWheelX",
    "MouseWheelY",
    "ModCtrl",
    "ModShift",
    "ModAlt",
    "ModSuper", // ReservedForModXXX are showing the ModXXX names.
};
GUI_STATIC_ASSERT(Key_NamedKey_COUNT == GUI_ARRAYSIZE(GKeyNames));

inline const char *Gui::GetKeyName(Key key) {
  Context &g = *GGui;
#ifdef GUI_DISABLE_OBSOLETE_KEYIO
  GUI_ASSERT((IsNamedKeyOrModKey(key) || key == Key_None) &&
             "Support for user key indices was dropped in favor of Key. "
             "Please update backend and user code.");
#else
  if (IsLegacyKey(key)) {
    if (g.IO.KeyMap[key] == -1)
      return "N/A";
    GUI_ASSERT(IsNamedKey((Key)g.IO.KeyMap[key]));
    key = (Key)g.IO.KeyMap[key];
  }
#endif
  if (key == Key_None)
    return "None";
  if (key & Mod_Mask_)
    key = ConvertSingleModFlagToKey(&g, key);
  if (!IsNamedKey(key))
    return "Unknown";

  return GKeyNames[key - Key_NamedKey_BEGIN];
}

// Mod_Shortcut is translated to either Ctrl or Super.
inline void Gui::GetKeyChordName(KeyChord key_chord, char *out_buf,
                                 int out_buf_size) {
  Context &g = *GGui;
  if (key_chord & Mod_Shortcut)
    key_chord = ConvertShortcutMod(key_chord);
  FormatString(out_buf, (size_t)out_buf_size, "%s%s%s%s%s",
               (key_chord & Mod_Ctrl) ? "Ctrl+" : "",
               (key_chord & Mod_Shift) ? "Shift+" : "",
               (key_chord & Mod_Alt) ? "Alt+" : "",
               (key_chord & Mod_Super)
                   ? (g.IO.ConfigMacOSXBehaviors ? "Cmd+" : "Super+")
                   : "",
               GetKeyName((Key)(key_chord & ~Mod_Mask_)));
}

// t0 = previous time (e.g.: g.Time - g.IO.DeltaTime)
// t1 = current time (e.g.: g.Time)
// An event is triggered at:
//  t = 0.0f     t = repeat_delay,    t = repeat_delay + repeat_rate*N

// Return value representing the number of presses in the last time period, for
// the given repeat rate (most often returns 0 or 1. The result is generally
// only >1 when RepeatRate is smaller than DeltaTime, aka large DeltaTime or
// fast RepeatRate)
inline int Gui::GetKeyPressedAmount(Key key, float repeat_delay,
                                    float repeat_rate) {
  Context &g = *GGui;
  const KeyData *key_data = GetKeyData(key);
  if (!key_data
           ->Down) // In theory this should already be encoded as (DownDuration
                   // < 0.0f), but testing this facilitates eating mechanism
                   // (until we finish work on key ownership)
    return 0;
  const float t = key_data->DownDuration;
  return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay,
                                   repeat_rate);
}

// Return 2D vector representing the combination of four cardinal direction,
// with analog value support (for e.g. Key_GamepadLStick* values).

// Rewrite routing data buffers to strip old entries + sort by key to make
// queries not touch scattered data.
//   Entries   D,A,B,B,A,C,B     --> A,A,B,B,B,C,D
//   Index     A:1 B:2 C:5 D:0   --> A:0 B:2 C:5 D:6
// See 'Metrics->Key Owners & Shortcut Routing' to visualize the result of that
// operation.
static void Gui::UpdateKeyRoutingTable(KeyRoutingTable *rt) {
  Context &g = *GGui;
  rt->EntriesNext.resize(0);
  for (Key key = Key_NamedKey_BEGIN; key < Key_NamedKey_END;
       key = (Key)(key + 1)) {
    const int new_routing_start_idx = rt->EntriesNext.Size;
    KeyRoutingData *routing_entry;
    for (int old_routing_idx = rt->Index[key - Key_NamedKey_BEGIN];
         old_routing_idx != -1;
         old_routing_idx = routing_entry->NextEntryIndex) {
      routing_entry = &rt->Entries[old_routing_idx];
      routing_entry->RoutingCurr = routing_entry->RoutingNext; // Update entry
      routing_entry->RoutingNext = KeyOwner_None;
      routing_entry->RoutingNextScore = 255;
      if (routing_entry->RoutingCurr == KeyOwner_None)
        continue;
      rt->EntriesNext.push_back(
          *routing_entry); // Write alive ones into new buffer

      // Apply routing to owner if there's no owner already (RoutingCurr == None
      // at this point)
      if (routing_entry->Mods == g.IO.KeyMods) {
        KeyOwnerData *owner_data = GetKeyOwnerData(&g, key);
        if (owner_data->OwnerCurr == KeyOwner_None)
          owner_data->OwnerCurr = routing_entry->RoutingCurr;
      }
    }

    // Rewrite linked-list
    rt->Index[key - Key_NamedKey_BEGIN] =
        (KeyRoutingIndex)(new_routing_start_idx < rt->EntriesNext.Size
                              ? new_routing_start_idx
                              : -1);
    for (int n = new_routing_start_idx; n < rt->EntriesNext.Size; n++)
      rt->EntriesNext[n].NextEntryIndex =
          (KeyRoutingIndex)((n + 1 < rt->EntriesNext.Size) ? n + 1 : -1);
  }
  rt->Entries.swap(rt->EntriesNext); // Swap new and old indexes
}

// owner_id may be None/Any, but routing_id needs to be always be set, so we
// default to GetCurrentFocusScope().
static inline ID GetRoutingIdFromOwnerId(ID owner_id) {
  Context &g = *GGui;
  return (owner_id != KeyOwner_None && owner_id != KeyOwner_Any)
             ? owner_id
             : g.CurrentFocusScopeId;
}

inline KeyRoutingData *Gui::GetShortcutRoutingData(KeyChord key_chord) {
  // Majority of shortcuts will be Key + any number of Mods
  // We accept _Single_ mod with Key_None.
  //  - Shortcut(Key_S | Mod_Ctrl);                    // Legal
  //  - Shortcut(Key_S | Mod_Ctrl | Mod_Shift);   // Legal
  //  - Shortcut(Mod_Ctrl);                                 // Legal
  //  - Shortcut(Mod_Ctrl | Mod_Shift);                // Not legal
  Context &g = *GGui;
  KeyRoutingTable *rt = &g.KeysRoutingTable;
  KeyRoutingData *routing_data;
  if (key_chord & Mod_Shortcut)
    key_chord = ConvertShortcutMod(key_chord);
  Key key = (Key)(key_chord & ~Mod_Mask_);
  Key mods = (Key)(key_chord & Mod_Mask_);
  if (key == Key_None)
    key = ConvertSingleModFlagToKey(&g, mods);
  GUI_ASSERT(IsNamedKey(key));

  // Get (in the majority of case, the linked list will have one element so this
  // should be 2 reads. Subsequent elements will be contiguous in memory as list
  // is sorted/rebuilt in NewFrame).
  for (KeyRoutingIndex idx = rt->Index[key - Key_NamedKey_BEGIN]; idx != -1;
       idx = routing_data->NextEntryIndex) {
    routing_data = &rt->Entries[idx];
    if (routing_data->Mods == mods)
      return routing_data;
  }

  // Add to linked-list
  KeyRoutingIndex routing_data_idx = (KeyRoutingIndex)rt->Entries.Size;
  rt->Entries.push_back(KeyRoutingData());
  routing_data = &rt->Entries[routing_data_idx];
  routing_data->Mods = (U16)mods;
  routing_data->NextEntryIndex =
      rt->Index[key - Key_NamedKey_BEGIN]; // Setup linked list
  rt->Index[key - Key_NamedKey_BEGIN] = routing_data_idx;
  return routing_data;
}

// Current score encoding (lower is highest priority):
//  -   0: InputFlags_RouteGlobalHigh
//  -   1: InputFlags_RouteFocused (if item active)
//  -   2: InputFlags_RouteGlobal
//  -  3+: InputFlags_RouteFocused (if window in focus-stack)
//  - 254: InputFlags_RouteGlobalLow
//  - 255: never route
// 'flags' should include an explicit routing policy
static int CalcRoutingScore(Window *location, ID owner_id, InputFlags flags) {
  if (flags & InputFlags_RouteFocused) {
    Context &g = *GGui;
    Window *focused = g.NavWindow;

    // ActiveID gets top priority
    // (we don't check g.ActiveIdUsingAllKeys here. Routing is applied but if
    // input ownership is tested later it may discard it)
    if (owner_id != 0 && g.ActiveId == owner_id)
      return 1;

    // Early out when not in focus stack
    if (focused == NULL || focused->RootWindow != location->RootWindow)
      return 255;

    // Score based on distance to focused window (lower is better)
    // Assuming both windows are submitting a routing request,
    // - When Window....... is focused -> Window scores 3 (best), Window/ChildB
    // scores 255 (no match)
    // - When Window/ChildB is focused -> Window scores 4,        Window/ChildB
    // scores 3 (best) Assuming only WindowA is submitting a routing request,
    // - When Window/ChildB is focused -> Window scores 4 (best), Window/ChildB
    // doesn't have a score.
    for (int next_score = 3; focused != NULL; next_score++) {
      if (focused == location) {
        GUI_ASSERT(next_score < 255);
        return next_score;
      }
      focused =
          (focused->RootWindow != focused)
              ? focused->ParentWindow
              : NULL; // FIXME: This could be later abstracted as a focus path
    }
    return 255;
  }

  // InputFlags_RouteGlobalHigh is default, so calls without flags are not
  // conditional
  if (flags & InputFlags_RouteGlobal)
    return 2;
  if (flags & InputFlags_RouteGlobalLow)
    return 254;
  return 0;
}

// Request a desired route for an input chord (key + mods).
// Return true if the route is available this frame.
// - Routes and key ownership are attributed at the beginning of next frame
// based on best score and mod state.
//   (Conceptually this does a "Submit for next frame" + "Test for current
//   frame". As such, it could be called TrySetXXX or SubmitXXX, or the Submit
//   and Test operations should be separate.)
// - Using 'owner_id == KeyOwner_Any/0': auto-assign an owner based on
// current focus scope (each window has its focus scope by default)
// - Using 'owner_id == KeyOwner_None': allows disabling/locking a
// shortcut.
inline bool Gui::SetShortcutRouting(KeyChord key_chord, ID owner_id,
                                    InputFlags flags) {
  Context &g = *GGui;
  if ((flags & InputFlags_RouteMask_) == 0)
    flags |= InputFlags_RouteGlobalHigh; // IMPORTANT: This is the default
                                         // for SetShortcutRouting() but
                                         // NOT Shortcut()
  else
    GUI_ASSERT(IsPowerOfTwo(
        flags &
        InputFlags_RouteMask_)); // Check that only 1 routing flag is used

  if (flags & InputFlags_RouteUnlessBgFocused)
    if (g.NavWindow == NULL)
      return false;
  if (flags & InputFlags_RouteAlways)
    return true;

  const int score = CalcRoutingScore(g.CurrentWindow, owner_id, flags);
  if (score == 255)
    return false;

  // Submit routing for NEXT frame (assuming score is sufficient)
  // FIXME: Could expose a way to use a "serve last" policy for same score
  // resolution (using <= instead of <).
  KeyRoutingData *routing_data = GetShortcutRoutingData(key_chord);
  const ID routing_id = GetRoutingIdFromOwnerId(owner_id);
  // const bool set_route = (flags & InputFlags_ServeLast) ? (score <=
  // routing_data->RoutingNextScore) : (score < routing_data->RoutingNextScore);
  if (score < routing_data->RoutingNextScore) {
    routing_data->RoutingNext = routing_id;
    routing_data->RoutingNextScore = (U8)score;
  }

  // Return routing state for CURRENT frame
  return routing_data->RoutingCurr == routing_id;
}

// Currently unused by core (but used by tests)
// Note: this cannot be turned into GetShortcutRouting() because we do the
// owner_id->routing_id translation, name would be more misleading.
inline bool Gui::TestShortcutRouting(KeyChord key_chord, ID owner_id) {
  const ID routing_id = GetRoutingIdFromOwnerId(owner_id);
  KeyRoutingData *routing_data =
      GetShortcutRoutingData(key_chord); // FIXME: Could avoid creating entry.
  return routing_data->RoutingCurr == routing_id;
}

// Note that Dear Gui doesn't know the meaning/semantic of Key from
// 0..511: they are legacy native keycodes. Consider transitioning from
// 'IsKeyDown(MY_ENGINE_KEY_A)' (<1.87) to IsKeyDown(Key_A) (>= 1.87)
inline bool Gui::IsKeyDown(Key key) { return IsKeyDown(key, KeyOwner_Any); }

inline bool Gui::IsKeyPressed(Key key, bool repeat) {
  return IsKeyPressed(key, KeyOwner_Any,
                      repeat ? InputFlags_Repeat : InputFlags_None);
}

// Important: unless legacy IsKeyPressed(Key, bool repeat=true) which
// DEFAULT to repeat, this requires EXPLICIT repeat.
inline bool Gui::IsKeyPressed(Key key, ID owner_id, InputFlags flags) {
  const KeyData *key_data = GetKeyData(key);
  if (!key_data
           ->Down) // In theory this should already be encoded as (DownDuration
                   // < 0.0f), but testing this facilitates eating mechanism
                   // (until we finish work on key ownership)
    return false;
  const float t = key_data->DownDuration;
  if (t < 0.0f)
    return false;
  GUI_ASSERT((flags & ~InputFlags_SupportedByIsKeyPressed) ==
             0); // Passing flags not supported by this function!

  bool pressed = (t == 0.0f);
  if (!pressed && ((flags & InputFlags_Repeat) != 0)) {
    float repeat_delay, repeat_rate;
    GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate);
    pressed = (t > repeat_delay) &&
              GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0;
  }
  if (!pressed)
    return false;
  if (!TestKeyOwner(key, owner_id))
    return false;
  return true;
}

inline bool Gui::IsKeyReleased(Key key) {
  return IsKeyReleased(key, KeyOwner_Any);
}

inline bool Gui::IsMouseDown(MouseButton button) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  return g.IO.MouseDown[button] &&
         TestKeyOwner(MouseButtonToKey(button),
                      KeyOwner_Any); // should be same as
                                     // IsKeyDown(MouseButtonToKey(button),
                                     // KeyOwner_Any), but this allows legacy
                                     // code hijacking the io.Mousedown[] array.
}

inline bool Gui::IsMouseDown(MouseButton button, ID owner_id) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  return g.IO.MouseDown[button] &&
         TestKeyOwner(
             MouseButtonToKey(button),
             owner_id); // Should be same as IsKeyDown(MouseButtonToKey(button),
                        // owner_id), but this allows legacy code hijacking the
                        // io.Mousedown[] array.
}

inline bool Gui::IsMouseClicked(MouseButton button, bool repeat) {
  return IsMouseClicked(button, KeyOwner_Any,
                        repeat ? InputFlags_Repeat : InputFlags_None);
}

inline bool Gui::IsMouseClicked(MouseButton button, ID owner_id,
                                InputFlags flags) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  if (!g.IO.MouseDown[button]) // In theory this should already be encoded as
                               // (DownDuration < 0.0f), but testing this
                               // facilitates eating mechanism (until we finish
                               // work on key ownership)
    return false;
  const float t = g.IO.MouseDownDuration[button];
  if (t < 0.0f)
    return false;
  GUI_ASSERT((flags & ~InputFlags_SupportedByIsKeyPressed) ==
             0); // Passing flags not supported by this function!

  const bool repeat = (flags & InputFlags_Repeat) != 0;
  const bool pressed =
      (t == 0.0f) ||
      (repeat && t > g.IO.KeyRepeatDelay &&
       CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay,
                                 g.IO.KeyRepeatRate) > 0);
  if (!pressed)
    return false;

  if (!TestKeyOwner(MouseButtonToKey(button), owner_id))
    return false;

  return true;
}

inline bool Gui::IsMouseReleased(MouseButton button) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  return g.IO.MouseReleased[button] &&
         TestKeyOwner(MouseButtonToKey(button),
                      KeyOwner_Any); // Should be same as
                                     // IsKeyReleased(MouseButtonToKey(button),
                                     // KeyOwner_Any)
}

inline bool Gui::IsMouseReleased(MouseButton button, ID owner_id) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  return g.IO.MouseReleased[button] &&
         TestKeyOwner(
             MouseButtonToKey(button),
             owner_id); // Should be same as
                        // IsKeyReleased(MouseButtonToKey(button), owner_id)
}

inline bool Gui::IsMouseDoubleClicked(MouseButton button) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  return g.IO.MouseClickedCount[button] == 2 &&
         TestKeyOwner(MouseButtonToKey(button), KeyOwner_Any);
}

inline bool Gui::IsMouseDoubleClicked(MouseButton button, ID owner_id) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  return g.IO.MouseClickedCount[button] == 2 &&
         TestKeyOwner(MouseButtonToKey(button), owner_id);
}

inline int Gui::GetMouseClickedCount(MouseButton button) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  return g.IO.MouseClickedCount[button];
}

// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems
// (g.Style.TouchExtraPadding)
inline bool Gui::IsMouseHoveringRect(const Vec2 &r_min, const Vec2 &r_max,
                                     bool clip) {
  Context &g = *GGui;

  // Clip
  Rect rect_clipped(r_min, r_max);
  if (clip)
    rect_clipped.ClipWith(g.CurrentWindow->ClipRect);

  // Hit testing, expanded for touch input
  if (!rect_clipped.ContainsWithPad(g.IO.MousePos, g.Style.TouchExtraPadding))
    return false;
  return true;
}

// Return if a mouse click/drag went past the given threshold. Valid to call
// during the MouseReleased frame. [Internal] This doesn't test if the button is
// pressed
inline bool Gui::IsMouseDragPastThreshold(MouseButton button,
                                          float lock_threshold) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  if (lock_threshold < 0.0f)
    lock_threshold = g.IO.MouseDragThreshold;
  return g.IO.MouseDragMaxDistanceSqr[button] >=
         lock_threshold * lock_threshold;
}

inline bool Gui::IsMouseDragging(MouseButton button, float lock_threshold) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  if (!g.IO.MouseDown[button])
    return false;
  return IsMouseDragPastThreshold(button, lock_threshold);
}

inline Vec2 Gui::GetMousePos() {
  Context &g = *GGui;
  return g.IO.MousePos;
}

// This is called TeleportMousePos() and not SetMousePos() to emphasis that
// setting MousePosPrev will effectively clear mouse delta as well. It is
// expected you only call this if (io.BackendFlags &
// BackendFlags_HasSetMousePos) is set and supported by backend.

// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem
// is activated, the popup is already closed!
inline Vec2 Gui::GetMousePosOnOpeningCurrentPopup() {
  Context &g = *GGui;
  if (g.BeginPopupStack.Size > 0)
    return g.OpenPopupStack[g.BeginPopupStack.Size - 1].OpenMousePos;
  return g.IO.MousePos;
}

// We typically use Vec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse
// position.
inline bool Gui::IsMousePosValid(const Vec2 *mouse_pos) {
  // The assert is only to silence a false-positive in XCode Static Analysis.
  // Because GGui is not dereferenced in every code path, the static analyzer
  // assume that it may be NULL (which it doesn't for other functions).
  GUI_ASSERT(GGui != NULL);
  const float MOUSE_INVALID = -256000.0f;
  Vec2 p = mouse_pos ? *mouse_pos : GGui->IO.MousePos;
  return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
}

// [WILL OBSOLETE] This was designed for backends, but prefer having backend
// maintain a mask of held mouse buttons, because upcoming input queue system
// will make this invalid.
inline bool Gui::IsAnyMouseDown() {
  Context &g = *GGui;
  for (int n = 0; n < GUI_ARRAYSIZE(g.IO.MouseDown); n++)
    if (g.IO.MouseDown[n])
      return true;
  return false;
}

// Return the delta from the initial clicking position while the mouse button is
// clicked or was just released. This is locked and return 0.0f until the mouse
// moves past a distance threshold at least once. NB: This is only valid if
// IsMousePosValid(). backends in theory should always keep mouse position valid
// when dragging even outside the client window.
inline Vec2 Gui::GetMouseDragDelta(MouseButton button, float lock_threshold) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  if (lock_threshold < 0.0f)
    lock_threshold = g.IO.MouseDragThreshold;
  if (g.IO.MouseDown[button] || g.IO.MouseReleased[button])
    if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
      if (IsMousePosValid(&g.IO.MousePos) &&
          IsMousePosValid(&g.IO.MouseClickedPos[button]))
        return Subtract(g.IO.MousePos, g.IO.MouseClickedPos[button]);
  return Vec2(0.0f, 0.0f);
}

inline void Gui::ResetMouseDragDelta(MouseButton button) {
  Context &g = *GGui;
  GUI_ASSERT(button >= 0 && button < GUI_ARRAYSIZE(g.IO.MouseDown));
  // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
  g.IO.MouseClickedPos[button] = g.IO.MousePos;
}

// Get desired mouse cursor shape.
// Important: this is meant to be used by a platform backend, it is reset in
// Gui::NewFrame(), updated during the frame, and locked in EndFrame()/Render().
// If you use software rendering by setting io.MouseDrawCursor then Dear Gui
// will render those for you
inline MouseCursor Gui::GetMouseCursor() {
  Context &g = *GGui;
  return g.MouseCursor;
}

inline void Gui::SetMouseCursor(MouseCursor cursor_type) {
  Context &g = *GGui;
  g.MouseCursor = cursor_type;
}

static void UpdateAliasKey(Key key, bool v, float analog_value) {
  GUI_ASSERT(Gui::IsAliasKey(key));
  KeyData *key_data = Gui::GetKeyData(key);
  key_data->Down = v;
  key_data->AnalogValue = analog_value;
}

// [Internal] Do not use directly
static KeyChord GetMergedModsFromKeys() {
  KeyChord mods = 0;
  if (Gui::IsKeyDown(Mod_Ctrl)) {
    mods |= Mod_Ctrl;
  }
  if (Gui::IsKeyDown(Mod_Shift)) {
    mods |= Mod_Shift;
  }
  if (Gui::IsKeyDown(Mod_Alt)) {
    mods |= Mod_Alt;
  }
  if (Gui::IsKeyDown(Mod_Super)) {
    mods |= Mod_Super;
  }
  return mods;
}

static void Gui::UpdateKeyboardInputs() {
  Context &g = *GGui;
  IO &io = g.IO;

  // Import legacy keys or verify they are not used
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  if (io.BackendUsingLegacyKeyArrays == 0) {
    // Backend used new io.AddKeyEvent() API: Good! Verify that old arrays are
    // never written to externally.
    for (int n = 0; n < Key_LegacyNativeKey_END; n++)
      GUI_ASSERT((io.KeysDown[n] == false || IsKeyDown((Key)n)) &&
                 "Backend needs to either only use io.AddKeyEvent(), either "
                 "only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
  } else {
    if (g.FrameCount == 0)
      for (int n = Key_LegacyNativeKey_BEGIN; n < Key_LegacyNativeKey_END; n++)
        GUI_ASSERT(g.IO.KeyMap[n] == -1 &&
                   "Backend is not allowed to write to io.KeyMap[0..511]!");

    // Build reverse KeyMap (Named -> Legacy)
    for (int n = Key_NamedKey_BEGIN; n < Key_NamedKey_END; n++)
      if (io.KeyMap[n] != -1) {
        GUI_ASSERT(IsLegacyKey((Key)io.KeyMap[n]));
        io.KeyMap[io.KeyMap[n]] = n;
      }

    // Import legacy keys into new ones
    for (int n = Key_LegacyNativeKey_BEGIN; n < Key_LegacyNativeKey_END; n++)
      if (io.KeysDown[n] || io.BackendUsingLegacyKeyArrays == 1) {
        const Key key = (Key)(io.KeyMap[n] != -1 ? io.KeyMap[n] : n);
        GUI_ASSERT(io.KeyMap[n] == -1 || IsNamedKey(key));
        io.KeysData[key].Down = io.KeysDown[n];
        if (key != n)
          io.KeysDown[key] =
              io.KeysDown[n]; // Allow legacy code using
                              // io.KeysDown[GetKeyIndex()] with old backends
        io.BackendUsingLegacyKeyArrays = 1;
      }
    if (io.BackendUsingLegacyKeyArrays == 1) {
      GetKeyData(Mod_Ctrl)->Down = io.KeyCtrl;
      GetKeyData(Mod_Shift)->Down = io.KeyShift;
      GetKeyData(Mod_Alt)->Down = io.KeyAlt;
      GetKeyData(Mod_Super)->Down = io.KeySuper;
    }
  }

#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  const bool nav_gamepad_active =
      (io.ConfigFlags & ConfigFlags_NavEnableGamepad) != 0 &&
      (io.BackendFlags & BackendFlags_HasGamepad) != 0;
  if (io.BackendUsingLegacyNavInputArray && nav_gamepad_active) {
#define MAP_LEGACY_NAV_INPUT_TO_KEY1(_KEY, _NAV1)                              \
  do {                                                                         \
    io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f);                     \
    io.KeysData[_KEY].AnalogValue = io.NavInputs[_NAV1];                       \
  } while (0)
#define MAP_LEGACY_NAV_INPUT_TO_KEY2(_KEY, _NAV1, _NAV2)                       \
  do {                                                                         \
    io.KeysData[_KEY].Down =                                                   \
        (io.NavInputs[_NAV1] > 0.0f) || (io.NavInputs[_NAV2] > 0.0f);          \
    io.KeysData[_KEY].AnalogValue =                                            \
        Max(io.NavInputs[_NAV1], io.NavInputs[_NAV2]);                         \
  } while (0)
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadFaceDown, NavInput_Activate);
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadFaceRight, NavInput_Cancel);
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadFaceLeft, NavInput_Menu);
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadFaceUp, NavInput_Input);
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadDpadLeft, NavInput_DpadLeft);
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadDpadRight, NavInput_DpadRight);
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadDpadUp, NavInput_DpadUp);
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadDpadDown, NavInput_DpadDown);
    MAP_LEGACY_NAV_INPUT_TO_KEY2(Key_GamepadL1, NavInput_FocusPrev,
                                 NavInput_TweakSlow);
    MAP_LEGACY_NAV_INPUT_TO_KEY2(Key_GamepadR1, NavInput_FocusNext,
                                 NavInput_TweakFast);
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadLStickLeft, NavInput_LStickLeft);
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadLStickRight, NavInput_LStickRight);
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadLStickUp, NavInput_LStickUp);
    MAP_LEGACY_NAV_INPUT_TO_KEY1(Key_GamepadLStickDown, NavInput_LStickDown);
#undef NAV_MAP_KEY
  }
#endif
#endif

  // Update aliases
  for (int n = 0; n < MouseButton_COUNT; n++)
    UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n],
                   io.MouseDown[n] ? 1.0f : 0.0f);
  UpdateAliasKey(Key_MouseWheelX, io.MouseWheelH != 0.0f, io.MouseWheelH);
  UpdateAliasKey(Key_MouseWheelY, io.MouseWheel != 0.0f, io.MouseWheel);

  // Synchronize io.KeyMods and io.KeyXXX values.
  // - New backends (1.87+): send io.AddKeyEvent(Mod_XXX) -> -> (here)
  // deriving io.KeyMods + io.KeyXXX from key array.
  // - Legacy backends:      set io.KeyXXX bools               -> (above) set
  // key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key
  // array. So with legacy backends the 4 values will do a unnecessary
  // back-and-forth but it makes the code simpler and future facing.
  io.KeyMods = GetMergedModsFromKeys();
  io.KeyCtrl = (io.KeyMods & Mod_Ctrl) != 0;
  io.KeyShift = (io.KeyMods & Mod_Shift) != 0;
  io.KeyAlt = (io.KeyMods & Mod_Alt) != 0;
  io.KeySuper = (io.KeyMods & Mod_Super) != 0;

  // Clear gamepad data if disabled
  if ((io.BackendFlags & BackendFlags_HasGamepad) == 0)
    for (int i = Key_Gamepad_BEGIN; i < Key_Gamepad_END; i++) {
      io.KeysData[i - Key_KeysData_OFFSET].Down = false;
      io.KeysData[i - Key_KeysData_OFFSET].AnalogValue = 0.0f;
    }

  // Update keys
  for (int i = 0; i < Key_KeysData_SIZE; i++) {
    KeyData *key_data = &io.KeysData[i];
    key_data->DownDurationPrev = key_data->DownDuration;
    key_data->DownDuration = key_data->Down
                                 ? (key_data->DownDuration < 0.0f
                                        ? 0.0f
                                        : key_data->DownDuration + io.DeltaTime)
                                 : -1.0f;
  }

  // Update keys/input owner (named keys only): one entry per key
  for (Key key = Key_NamedKey_BEGIN; key < Key_NamedKey_END;
       key = (Key)(key + 1)) {
    KeyData *key_data = &io.KeysData[key - Key_KeysData_OFFSET];
    KeyOwnerData *owner_data = &g.KeysOwnerData[key - Key_NamedKey_BEGIN];
    owner_data->OwnerCurr = owner_data->OwnerNext;
    if (!key_data
             ->Down) // Important: ownership is released on the frame after a
                     // release. Ensure a 'MouseDown -> CloseWindow -> MouseUp'
                     // chain doesn't lead to someone else seeing the MouseUp.
      owner_data->OwnerNext = KeyOwner_None;
    owner_data->LockThisFrame = owner_data->LockUntilRelease =
        owner_data->LockUntilRelease &&
        key_data->Down; // Clear LockUntilRelease when key is not Down anymore
  }

  UpdateKeyRoutingTable(&g.KeysRoutingTable);
}

static void Gui::UpdateMouseInputs() {
  Context &g = *GGui;
  IO &io = g.IO;

  // Mouse Wheel swapping flag
  // As a standard behavior holding SHIFT while using Vertical Mouse Wheel
  // triggers Horizontal scroll instead
  // - We avoid doing it on OSX as it the OS input layer handles this already.
  // - FIXME: However this means when running on OSX over Emscripten,
  // Shift+WheelY will incur two swapping (1 in OS, 1 here), canceling the
  // feature.
  // - FIXME: When we can distinguish e.g. touchpad scroll events from mouse
  // ones, we'll set this accordingly based on input source.
  io.MouseWheelRequestAxisSwap = io.KeyShift && !io.ConfigMacOSXBehaviors;

  // Round mouse position to avoid spreading non-rounded position (e.g.
  // UpdateManualResize doesn't support them well)
  if (IsMousePosValid(&io.MousePos))
    io.MousePos = g.MouseLastValidPos = Floor(io.MousePos);

  // If mouse just appeared or disappeared (usually denoted by -FLT_MAX
  // components) we cancel out movement in MouseDelta
  if (IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev))
    io.MouseDelta = Subtract(io.MousePos, io.MousePosPrev);
  else
    io.MouseDelta = Vec2(0.0f, 0.0f);

  // Update stationary timer.
  // FIXME: May need to rework again to have some tolerance for occasional small
  // movement, while being functional on high-framerates.
  const float mouse_stationary_threshold =
      (io.MouseSource == MouseSource_Mouse)
          ? 2.0f
          : 3.0f; // Slightly higher threshold for
                  // MouseSource_TouchScreen/MouseSource_Pen, may need
                  // rework.
  const bool mouse_stationary =
      (LengthSqr(io.MouseDelta) <=
       mouse_stationary_threshold * mouse_stationary_threshold);
  g.MouseStationaryTimer =
      mouse_stationary ? (g.MouseStationaryTimer + io.DeltaTime) : 0.0f;
  // GUI_DEBUG_LOG("%.4f\n", g.MouseStationaryTimer);

  // If mouse moved we re-enable mouse hovering in case it was disabled by
  // gamepad/keyboard. In theory should use a >0.0f threshold but would need to
  // reset in everywhere we set this to true.
  if (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)
    g.NavDisableMouseHover = false;

  for (int i = 0; i < GUI_ARRAYSIZE(io.MouseDown); i++) {
    io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0f;
    io.MouseClickedCount[i] = 0; // Will be filled below
    io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0f;
    io.MouseDownDurationPrev[i] = io.MouseDownDuration[i];
    io.MouseDownDuration[i] =
        io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0f
                               ? 0.0f
                               : io.MouseDownDuration[i] + io.DeltaTime)
                        : -1.0f;
    if (io.MouseClicked[i]) {
      bool is_repeated_click = false;
      if ((float)(g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime) {
        Vec2 delta_from_click_pos =
            IsMousePosValid(&io.MousePos)
                ? Subtract(io.MousePos, io.MouseClickedPos[i])
                : Vec2(0.0f, 0.0f);
        if (LengthSqr(delta_from_click_pos) <
            io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist)
          is_repeated_click = true;
      }
      if (is_repeated_click)
        io.MouseClickedLastCount[i]++;
      else
        io.MouseClickedLastCount[i] = 1;
      io.MouseClickedTime[i] = g.Time;
      io.MouseClickedPos[i] = io.MousePos;
      io.MouseClickedCount[i] = io.MouseClickedLastCount[i];
      io.MouseDragMaxDistanceSqr[i] = 0.0f;
    } else if (io.MouseDown[i]) {
      // Maintain the maximum distance we reaching from the initial click
      // position, which is used with dragging threshold
      float delta_sqr_click_pos =
          IsMousePosValid(&io.MousePos)
              ? LengthSqr(Subtract(io.MousePos, io.MouseClickedPos[i]))
              : 0.0f;
      io.MouseDragMaxDistanceSqr[i] =
          Max(io.MouseDragMaxDistanceSqr[i], delta_sqr_click_pos);
    }

    // We provide io.MouseDoubleClicked[] as a legacy service
    io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2);

    // Clicking any mouse button reactivate mouse hovering which may have been
    // deactivated by gamepad/keyboard navigation
    if (io.MouseClicked[i])
      g.NavDisableMouseHover = false;
  }
}

static void LockWheelingWindow(Window *window, float wheel_amount) {
  Context &g = *GGui;
  if (window)
    g.WheelingWindowReleaseTimer =
        Min(g.WheelingWindowReleaseTimer +
                Abs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER,
            WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER);
  else
    g.WheelingWindowReleaseTimer = 0.0f;
  if (g.WheelingWindow == window)
    return;
  GUI_DEBUG_LOG_IO("[io] LockWheelingWindow() \"%s\"\n",
                   window ? window->Name : "NULL");
  g.WheelingWindow = window;
  g.WheelingWindowRefMousePos = g.IO.MousePos;
  if (window == NULL) {
    g.WheelingWindowStartFrame = -1;
    g.WheelingAxisAvg = Vec2(0.0f, 0.0f);
  }
}

static Window *FindBestWheelingWindow(const Vec2 &wheel) {
  // For each axis, find window in the hierarchy that may want to use scrolling
  Context &g = *GGui;
  Window *windows[2] = {NULL, NULL};
  for (int axis = 0; axis < 2; axis++)
    if (wheel[axis] != 0.0f)
      for (Window *window = windows[axis] = g.HoveredWindow;
           window->Flags & WindowFlags_ChildWindow;
           window = windows[axis] = window->ParentWindow) {
        // Bubble up into parent window if:
        // - a child window doesn't allow any scrolling.
        // - a child window has the WindowFlags_NoScrollWithMouse flag.
        //// - a child window doesn't need scrolling because it is already at
        /// the edge for the direction we are going in (FIXME-WIP)
        const bool has_scrolling = (window->ScrollMax[axis] != 0.0f);
        const bool inputs_disabled =
            (window->Flags & WindowFlags_NoScrollWithMouse) &&
            !(window->Flags & WindowFlags_NoMouseInputs);
        // const bool scrolling_past_limits = (wheel_v < 0.0f) ?
        // (window->Scroll[axis] <= 0.0f) : (window->Scroll[axis] >=
        // window->ScrollMax[axis]);
        if (has_scrolling && !inputs_disabled) // && !scrolling_past_limits)
          break;                               // select this window
      }
  if (windows[0] == NULL && windows[1] == NULL)
    return NULL;

  // If there's only one window or only one axis then there's no ambiguity
  if (windows[0] == windows[1] || windows[0] == NULL || windows[1] == NULL)
    return windows[1] ? windows[1] : windows[0];

  // If candidate are different windows we need to decide which one to
  // prioritize
  // - First frame: only find a winner if one axis is zero.
  // - Subsequent frames: only find a winner when one is more than the other.
  if (g.WheelingWindowStartFrame == -1)
    g.WheelingWindowStartFrame = g.FrameCount;
  if ((g.WheelingWindowStartFrame == g.FrameCount && wheel.x != 0.0f &&
       wheel.y != 0.0f) ||
      (g.WheelingAxisAvg.x == g.WheelingAxisAvg.y)) {
    g.WheelingWindowWheelRemainder = wheel;
    return NULL;
  }
  return (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? windows[0] : windows[1];
}

// Called by NewFrame()
void Gui::UpdateMouseWheel() {
  // Reset the locked window if we move the mouse or after the timer elapses.
  // FIXME: Ideally we could refactor to have one timer for "changing window w/
  // same axis" and a shorter timer for "changing window or axis w/ other axis"
  // (#3795)
  Context &g = *GGui;
  if (g.WheelingWindow != NULL) {
    g.WheelingWindowReleaseTimer -= g.IO.DeltaTime;
    if (IsMousePosValid() &&
        LengthSqr(Subtract(g.IO.MousePos, g.WheelingWindowRefMousePos)) >
            g.IO.MouseDragThreshold * g.IO.MouseDragThreshold)
      g.WheelingWindowReleaseTimer = 0.0f;
    if (g.WheelingWindowReleaseTimer <= 0.0f)
      LockWheelingWindow(NULL, 0.0f);
  }

  Vec2 wheel;
  wheel.x =
      TestKeyOwner(Key_MouseWheelX, KeyOwner_None) ? g.IO.MouseWheelH : 0.0f;
  wheel.y =
      TestKeyOwner(Key_MouseWheelY, KeyOwner_None) ? g.IO.MouseWheel : 0.0f;

  // GUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
  Window *mouse_window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
  if (!mouse_window || mouse_window->Collapsed)
    return;

  // Zoom / Scale window
  // FIXME-OBSOLETE: This is an old feature, it still works but pretty much
  // nobody is using it and may be best redesigned.
  if (wheel.y != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling) {
    LockWheelingWindow(mouse_window, wheel.y);
    Window *window = mouse_window;
    const float new_font_scale =
        Clamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
    const float scale = new_font_scale / window->FontWindowScale;
    window->FontWindowScale = new_font_scale;
    if (window == window->RootWindow) {
      const Vec2 offset =
          Divide(Multiply(Multiply(window->Size, (1.0f - scale)),
                          (Subtract(g.IO.MousePos, window->Pos))),
                 window->Size);
      SetWindowPos(window, Add(window->Pos, offset), 0);
      window->Size = Trunc(Multiply(window->Size, scale));
      window->SizeFull = Trunc(Multiply(window->SizeFull, scale));
    }
    return;
  }
  if (g.IO.KeyCtrl)
    return;

  // Mouse wheel scrolling
  // Read about io.MouseWheelRequestAxisSwap and its issue on Mac+Emscripten in
  // UpdateMouseInputs()
  if (g.IO.MouseWheelRequestAxisSwap)
    wheel = Vec2(wheel.y, 0.0f);

  // Maintain a rough average of moving magnitude on both axises
  // FIXME: should by based on wall clock time rather than frame-counter
  g.WheelingAxisAvg.x =
      ExponentialMovingAverage(g.WheelingAxisAvg.x, Abs(wheel.x), 30);
  g.WheelingAxisAvg.y =
      ExponentialMovingAverage(g.WheelingAxisAvg.y, Abs(wheel.y), 30);

  // In the rare situation where FindBestWheelingWindow() had to defer first
  // frame of wheeling due to ambiguous main axis, reinject it now.
  wheel = Add(wheel, g.WheelingWindowWheelRemainder);
  g.WheelingWindowWheelRemainder = Vec2(0.0f, 0.0f);
  if (wheel.x == 0.0f && wheel.y == 0.0f)
    return;

  // Mouse wheel scrolling: find target and apply
  // - don't renew lock if axis doesn't apply on the window.
  // - select a main axis when both axises are being moved.
  if (Window *window =
          (g.WheelingWindow ? g.WheelingWindow : FindBestWheelingWindow(wheel)))
    if (!(window->Flags & WindowFlags_NoScrollWithMouse) &&
        !(window->Flags & WindowFlags_NoMouseInputs)) {
      bool do_scroll[2] = {wheel.x != 0.0f && window->ScrollMax.x != 0.0f,
                           wheel.y != 0.0f && window->ScrollMax.y != 0.0f};
      if (do_scroll[Axis_X] && do_scroll[Axis_Y])
        do_scroll[(g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? Axis_Y
                                                              : Axis_X] = false;
      if (do_scroll[Axis_X]) {
        LockWheelingWindow(window, wheel.x);
        float max_step = window->InnerRect.GetWidth() * 0.67f;
        float scroll_step = Trunc(Min(2 * window->CalcFontSize(), max_step));
        SetScrollX(window, window->Scroll.x - wheel.x * scroll_step);
        g.WheelingWindowScrolledFrame = g.FrameCount;
      }
      if (do_scroll[Axis_Y]) {
        LockWheelingWindow(window, wheel.y);
        float max_step = window->InnerRect.GetHeight() * 0.67f;
        float scroll_step = Trunc(Min(5 * window->CalcFontSize(), max_step));
        SetScrollY(window, window->Scroll.y - wheel.y * scroll_step);
        g.WheelingWindowScrolledFrame = g.FrameCount;
      }
    }
}

inline void Gui::SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard) {
  Context &g = *GGui;
  g.WantCaptureKeyboardNextFrame = want_capture_keyboard ? 1 : 0;
}

inline void Gui::SetNextFrameWantCaptureMouse(bool want_capture_mouse) {
  Context &g = *GGui;
  g.WantCaptureMouseNextFrame = want_capture_mouse ? 1 : 0;
}

#ifndef GUI_DISABLE_DEBUG_TOOLS
static const char *GetInputSourceName(InputSource source) {
  const char *input_source_names[] = {"None", "Mouse", "Keyboard", "Gamepad",
                                      "Clipboard"};
  GUI_ASSERT(GUI_ARRAYSIZE(input_source_names) == InputSource_COUNT &&
             source >= 0 && source < InputSource_COUNT);
  return input_source_names[source];
}
static const char *GetMouseSourceName(MouseSource source) {
  const char *mouse_source_names[] = {"Mouse", "TouchScreen", "Pen"};
  GUI_ASSERT(GUI_ARRAYSIZE(mouse_source_names) == MouseSource_COUNT &&
             source >= 0 && source < MouseSource_COUNT);
  return mouse_source_names[source];
}
static void DebugPrintInputEvent(const char *prefix, const InputEvent *e) {
  Context &g = *GGui;
  if (e->Type == InputEventType_MousePos) {
    if (e->MousePos.PosX == -FLT_MAX && e->MousePos.PosY == -FLT_MAX)
      GUI_DEBUG_LOG_IO("[io] %s: MousePos (-FLT_MAX, -FLT_MAX)\n", prefix);
    else
      GUI_DEBUG_LOG_IO("[io] %s: MousePos (%.1f, %.1f) (%s)\n", prefix,
                       e->MousePos.PosX, e->MousePos.PosY,
                       GetMouseSourceName(e->MousePos.MouseSource));
    return;
  }
  if (e->Type == InputEventType_MouseButton) {
    GUI_DEBUG_LOG_IO("[io] %s: MouseButton %d %s (%s)\n", prefix,
                     e->MouseButton.Button, e->MouseButton.Down ? "Down" : "Up",
                     GetMouseSourceName(e->MouseButton.MouseSource));
    return;
  }
  if (e->Type == InputEventType_MouseWheel) {
    GUI_DEBUG_LOG_IO("[io] %s: MouseWheel (%.3f, %.3f) (%s)\n", prefix,
                     e->MouseWheel.WheelX, e->MouseWheel.WheelY,
                     GetMouseSourceName(e->MouseWheel.MouseSource));
    return;
  }
  if (e->Type == InputEventType_Key) {
    GUI_DEBUG_LOG_IO("[io] %s: Key \"%s\" %s\n", prefix,
                     Gui::GetKeyName(e->Key.Key), e->Key.Down ? "Down" : "Up");
    return;
  }
  if (e->Type == InputEventType_Text) {
    GUI_DEBUG_LOG_IO("[io] %s: Text: %c (U+%08X)\n", prefix, e->Text.Char,
                     e->Text.Char);
    return;
  }
  if (e->Type == InputEventType_Focus) {
    GUI_DEBUG_LOG_IO("[io] %s: AppFocused %d\n", prefix, e->AppFocused.Focused);
    return;
  }
}
#endif

// Process input queue
// We always call this with the value of 'bool
// g.IO.ConfigInputTrickleEventQueue'.
// - trickle_fast_inputs = false : process all events, turn into flattened input
// state (e.g. successive down/up/down/up will be lost)
// - trickle_fast_inputs = true  : process as many events as possible
// (successive down/up/down/up will be trickled over several frames so nothing
// is lost) (new feature in 1.87)
inline void Gui::UpdateInputEvents(bool trickle_fast_inputs) {
  Context &g = *GGui;
  IO &io = g.IO;

  // Only trickle chars<>key when working with InputText()
  // FIXME: InputText() could parse event trail?
  // FIXME: Could specialize chars<>keys trickling rules for control keys (those
  // not typically associated to characters)
  const bool trickle_interleaved_keys_and_text =
      (trickle_fast_inputs && g.WantTextInputNextFrame == 1);

  bool mouse_moved = false, mouse_wheeled = false, key_changed = false,
       text_inputted = false;
  int mouse_button_changed = 0x00;
  BitArray<Key_KeysData_SIZE> key_changed_mask;

  int event_n = 0;
  for (; event_n < g.InputEventsQueue.Size; event_n++) {
    InputEvent *e = &g.InputEventsQueue[event_n];
    if (e->Type == InputEventType_MousePos) {
      if (g.IO.WantSetMousePos)
        continue;
      // Trickling Rule: Stop processing queued events if we already handled a
      // mouse button change
      Vec2 event_pos(e->MousePos.PosX, e->MousePos.PosY);
      if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled ||
                                  key_changed || text_inputted))
        break;
      io.MousePos = event_pos;
      io.MouseSource = e->MousePos.MouseSource;
      mouse_moved = true;
    } else if (e->Type == InputEventType_MouseButton) {
      // Trickling Rule: Stop processing queued events if we got multiple action
      // on the same button
      const MouseButton button = e->MouseButton.Button;
      GUI_ASSERT(button >= 0 && button < MouseButton_COUNT);
      if (trickle_fast_inputs &&
          ((mouse_button_changed & (1 << button)) || mouse_wheeled))
        break;
      if (trickle_fast_inputs &&
          e->MouseButton.MouseSource == MouseSource_TouchScreen &&
          mouse_moved) // #2702: TouchScreen have no initial hover.
        break;
      io.MouseDown[button] = e->MouseButton.Down;
      io.MouseSource = e->MouseButton.MouseSource;
      mouse_button_changed |= (1 << button);
    } else if (e->Type == InputEventType_MouseWheel) {
      // Trickling Rule: Stop processing queued events if we got multiple action
      // on the event
      if (trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0))
        break;
      io.MouseWheelH += e->MouseWheel.WheelX;
      io.MouseWheel += e->MouseWheel.WheelY;
      io.MouseSource = e->MouseWheel.MouseSource;
      mouse_wheeled = true;
    } else if (e->Type == InputEventType_Key) {
      // Trickling Rule: Stop processing queued events if we got multiple action
      // on the same button
      Key key = e->Key.Key;
      GUI_ASSERT(key != Key_None);
      KeyData *key_data = GetKeyData(key);
      const int key_data_index = (int)(key_data - g.IO.KeysData);
      if (trickle_fast_inputs && key_data->Down != e->Key.Down &&
          (key_changed_mask.TestBit(key_data_index) || text_inputted ||
           mouse_button_changed != 0))
        break;
      key_data->Down = e->Key.Down;
      key_data->AnalogValue = e->Key.AnalogValue;
      key_changed = true;
      key_changed_mask.SetBit(key_data_index);

      // Allow legacy code using io.KeysDown[GetKeyIndex()] with new backends
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
      io.KeysDown[key_data_index] = key_data->Down;
      if (io.KeyMap[key_data_index] != -1)
        io.KeysDown[io.KeyMap[key_data_index]] = key_data->Down;
#endif
    } else if (e->Type == InputEventType_Text) {
      // Trickling Rule: Stop processing queued events if keys/mouse have been
      // interacted with
      if (trickle_fast_inputs &&
          ((key_changed && trickle_interleaved_keys_and_text) ||
           mouse_button_changed != 0 || mouse_moved || mouse_wheeled))
        break;
      unsigned int c = e->Text.Char;
      io.InputQueueCharacters.push_back(c <= GUI_UNICODE_CODEPOINT_MAX
                                            ? (Wchar)c
                                            : GUI_UNICODE_CODEPOINT_INVALID);
      if (trickle_interleaved_keys_and_text)
        text_inputted = true;
    } else if (e->Type == InputEventType_Focus) {
      // We intentionally overwrite this and process in NewFrame(), in order to
      // give a chance to multi-viewports backends to queue AddFocusEvent(false)
      // + AddFocusEvent(true) in same frame.
      const bool focus_lost = !e->AppFocused.Focused;
      io.AppFocusLost = focus_lost;
    } else {
      GUI_ASSERT(0 && "Unknown event!");
    }
  }

  // Record trail (for domain-specific applications wanting to access a precise
  // trail)
  // if (event_n != 0) GUI_DEBUG_LOG_IO("Processed: %d / Remaining: %d\n",
  // event_n, g.InputEventsQueue.Size - event_n);
  for (int n = 0; n < event_n; n++)
    g.InputEventsTrail.push_back(g.InputEventsQueue[n]);

    // [DEBUG]
#ifndef GUI_DISABLE_DEBUG_TOOLS
  if (event_n != 0 && (g.DebugLogFlags & DebugLogFlags_EventIO))
    for (int n = 0; n < g.InputEventsQueue.Size; n++)
      DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining",
                           &g.InputEventsQueue[n]);
#endif

  // Remaining events will be processed on the next frame
  if (event_n == g.InputEventsQueue.Size)
    g.InputEventsQueue.resize(0);
  else
    g.InputEventsQueue.erase(g.InputEventsQueue.Data,
                             g.InputEventsQueue.Data + event_n);

  // Clear buttons state when focus is lost
  // - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't
  // trigger the Alt menu toggle.
  // - we clear in EndFrame() and not now in order allow application/user code
  // polling this flag
  //   (e.g. custom backend may want to clear additional data, custom widgets
  //   may want to react with a "canceling" event).
  if (g.IO.AppFocusLost)
    g.IO.ClearInputKeys();
}

inline ID Gui::GetKeyOwner(Key key) {
  if (!IsNamedKeyOrModKey(key))
    return KeyOwner_None;

  Context &g = *GGui;
  KeyOwnerData *owner_data = GetKeyOwnerData(&g, key);
  ID owner_id = owner_data->OwnerCurr;

  if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId &&
      owner_id != KeyOwner_Any)
    if (key >= Key_Keyboard_BEGIN && key < Key_Keyboard_END)
      return KeyOwner_None;

  return owner_id;
}

// TestKeyOwner(..., ID)   : (owner == None || owner == ID)
// TestKeyOwner(..., None) : (owner == None)
// TestKeyOwner(..., Any)  : no owner test
// All paths are also testing for key not being locked, for the rare cases that
// key have been locked with using InputFlags_LockXXX flags.
inline bool Gui::TestKeyOwner(Key key, ID owner_id) {
  if (!IsNamedKeyOrModKey(key))
    return true;

  Context &g = *GGui;
  if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId &&
      owner_id != KeyOwner_Any)
    if (key >= Key_Keyboard_BEGIN && key < Key_Keyboard_END)
      return false;

  KeyOwnerData *owner_data = GetKeyOwnerData(&g, key);
  if (owner_id == KeyOwner_Any)
    return (owner_data->LockThisFrame == false);

  // Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most
  // mouse routing overlap (because of ActiveId/HoveredId are acting as filter
  // before this has a chance to filter), but sane as soon as user tries to look
  // into things. Setting OwnerCurr in SetKeyOwner() is more consistent than
  // testing OwnerNext here: would be inconsistent with getter and other
  // functions.
  if (owner_data->OwnerCurr != owner_id) {
    if (owner_data->LockThisFrame)
      return false;
    if (owner_data->OwnerCurr != KeyOwner_None)
      return false;
  }

  return true;
}

// _LockXXX flags are useful to lock keys away from code which is not
// input-owner aware. When using _LockXXX flags, you can use KeyOwner_Any
// to lock keys from everyone.
// - SetKeyOwner(..., None)              : clears owner
// - SetKeyOwner(..., Any, !Lock)        : illegal (assert)
// - SetKeyOwner(..., Any or None, Lock) : set lock
inline void Gui::SetKeyOwner(Key key, ID owner_id, InputFlags flags) {
  GUI_ASSERT(
      IsNamedKeyOrModKey(key) &&
      (owner_id != KeyOwner_Any ||
       (flags & (InputFlags_LockThisFrame |
                 InputFlags_LockUntilRelease)))); // Can only use _Any with
                                                  // _LockXXX flags (to eat
                                                  // a key away without an
                                                  // ID to retrieve it)
  GUI_ASSERT((flags & ~InputFlags_SupportedBySetKeyOwner) ==
             0); // Passing flags not supported by this function!

  Context &g = *GGui;
  KeyOwnerData *owner_data = GetKeyOwnerData(&g, key);
  owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;

  // We cannot lock by default as it would likely break lots of legacy code.
  // In the case of using LockUntilRelease while key is not down we still lock
  // during the frame (no key_data->Down test)
  owner_data->LockUntilRelease = (flags & InputFlags_LockUntilRelease) != 0;
  owner_data->LockThisFrame =
      (flags & InputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);
}

// Rarely used helper

// This is more or less equivalent to:
//   if (IsItemHovered() || IsItemActive())
//       SetKeyOwner(key, GetItemID());
// Extensive uses of that (e.g. many calls for a single item) may want to
// manually perform the tests once and then call SetKeyOwner() multiple times.
// More advanced usage scenarios may want to call SetKeyOwner() manually based
// on different condition. Worth noting is that only one item can be hovered and
// only one item can be active, therefore this usage pattern doesn't need to
// bother with routing and priority.
inline void Gui::SetItemKeyOwner(Key key, InputFlags flags) {
  Context &g = *GGui;
  ID id = g.LastItemData.ID;
  if (id == 0 || (g.HoveredId != id && g.ActiveId != id))
    return;
  if ((flags & InputFlags_CondMask_) == 0)
    flags |= InputFlags_CondDefault_;
  if ((g.HoveredId == id && (flags & InputFlags_CondHovered)) ||
      (g.ActiveId == id && (flags & InputFlags_CondActive))) {
    GUI_ASSERT((flags & ~InputFlags_SupportedBySetItemKeyOwner) ==
               0); // Passing flags not supported by this function!
    SetKeyOwner(key, id, flags & ~InputFlags_CondMask_);
  }
}

// This is the only public API until we expose owner_id versions of the API as
// replacements.
inline bool Gui::IsKeyChordPressed(KeyChord key_chord) {
  return IsKeyChordPressed(key_chord, 0, InputFlags_None);
}

// This is equivalent to comparing KeyMods + doing a IsKeyPressed()

inline bool Gui::Shortcut(KeyChord key_chord, ID owner_id, InputFlags flags) {
  // When using (owner_id == 0/Any): SetShortcutRouting() will use
  // CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he
  // 0/Any.
  if ((flags & InputFlags_RouteMask_) == 0)
    flags |= InputFlags_RouteFocused;
  if (!SetShortcutRouting(key_chord, owner_id, flags))
    return false;

  if (!IsKeyChordPressed(key_chord, owner_id, flags))
    return false;
  GUI_ASSERT((flags & ~InputFlags_SupportedByShortcut) ==
             0); // Passing flags not supported by this function!
  return true;
}

//-----------------------------------------------------------------------------
// [SECTION] ERROR CHECKING
//-----------------------------------------------------------------------------

// Helper function to verify ABI compatibility between caller code and compiled
// version of Dear Gui. Verify that the type sizes are matching between the
// calling file's compilation unit and gui.cpp's compilation unit If this
// triggers you have an issue:
// - Most commonly: mismatched headers and compiled code version.
// - Or: mismatched configuration #define, compilation settings, packing pragma
// etc.
//   The configuration settings mentioned in config.hpp must be set for all
//   compilation units involved with Dear Gui, which is way it is required you
//   put them in your imconfig file (and not just before including gui.hpp).
//   Otherwise it is possible that different compilation units would see
//   different structure layout
inline bool Gui::DebugCheckVersionAndDataLayout(const char *version,
                                                size_t sz_io, size_t sz_style,
                                                size_t sz_vec2, size_t sz_vec4,
                                                size_t sz_vert, size_t sz_idx) {
  bool error = false;
  if (strcmp(version, GUI_VERSION) != 0) {
    error = true;
    GUI_ASSERT(strcmp(version, GUI_VERSION) == 0 &&
               "Mismatched version string!");
  }
  if (sz_io != sizeof(IO)) {
    error = true;
    GUI_ASSERT(sz_io == sizeof(IO) && "Mismatched struct layout!");
  }
  if (sz_style != sizeof(Style)) {
    error = true;
    GUI_ASSERT(sz_style == sizeof(Style) && "Mismatched struct layout!");
  }
  if (sz_vec2 != sizeof(Vec2)) {
    error = true;
    GUI_ASSERT(sz_vec2 == sizeof(Vec2) && "Mismatched struct layout!");
  }
  if (sz_vec4 != sizeof(Vec4)) {
    error = true;
    GUI_ASSERT(sz_vec4 == sizeof(Vec4) && "Mismatched struct layout!");
  }
  if (sz_vert != sizeof(DrawVert)) {
    error = true;
    GUI_ASSERT(sz_vert == sizeof(DrawVert) && "Mismatched struct layout!");
  }
  if (sz_idx != sizeof(DrawIdx)) {
    error = true;
    GUI_ASSERT(sz_idx == sizeof(DrawIdx) && "Mismatched struct layout!");
  }
  return !error;
}

// Until 1.89 (GUI_VERSION_NUM < 18814) it was legal to use SetCursorPos() to
// extend the boundary of a parent (e.g. window or table cell) This is causing
// issues and ambiguity and we need to retire that. See
// https://github.com/ocornut/imgui/issues/5548 for more details. [Scenario 1]
//  Previously this would make the window content size ~200x200:
//    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + Vec2(200,200)) +
//    End();  // NOT OK
//  Instead, please submit an item:
//    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + Vec2(200,200)) +
//    Dummy(Vec2(0,0)) + End(); // OK
//  Alternative:
//    Begin(...) + Dummy(Vec2(200,200)) + End(); // OK
// [Scenario 2]
//  For reference this is one of the issue what we aim to fix with this change:
//    BeginGroup() + SomeItem("foobar") +
//    SetCursorScreenPos(GetCursorScreenPos()) + EndGroup()
//  The previous logic made SetCursorScreenPos(GetCursorScreenPos()) have a
//  side-effect! It would erroneously incorporate ItemSpacing.y after the item
//  into content size, making the group taller! While this code is a little
//  twisted, no-one would expect SetXXX(GetXXX()) to have a side-effect. Using
//  vertical alignment patterns could trigger this issue.
inline void Gui::ErrorCheckUsingSetCursorPosToExtendParentBoundaries() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_ASSERT(window->DC.IsSetPos);
  window->DC.IsSetPos = false;
#ifdef GUI_DISABLE_OBSOLETE_FUNCTIONS
  if (window->DC.CursorPos.x <= window->DC.CursorMaxPos.x &&
      window->DC.CursorPos.y <= window->DC.CursorMaxPos.y)
    return;
  if (window->SkipItems)
    return;
  GUI_ASSERT(
      0 &&
      "Code uses SetCursorPos()/SetCursorScreenPos() to extend window/parent "
      "boundaries. Please submit an item e.g. Dummy() to validate extent.");
#else
  window->DC.CursorMaxPos = Max(window->DC.CursorMaxPos, window->DC.CursorPos);
#endif
}

static void Gui::ErrorCheckNewFrameSanityChecks() {
  Context &g = *GGui;

  // Check user GUI_ASSERT macro
  // (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is
  // incorrectly defined!
  //  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do
  //  { ... } while (0)' block. This is a common C/C++ idiom to allow multiple
  //  statements macros to be used in control flow blocks.)
  // #define GUI_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode(); // Wrong!
  // #define GUI_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while
  // (0)   // Correct!
  if (true)
    GUI_ASSERT(1);
  else
    GUI_ASSERT(0);

    // Emscripten backends are often imprecise in their submission of DeltaTime.
    // (#6114, #3644) Ideally the Emscripten app/backend should aim to fix or
    // smooth this value and avoid feeding zero, but we tolerate it.
#ifdef __EMSCRIPTEN__
  if (g.IO.DeltaTime <= 0.0f && g.FrameCount > 0)
    g.IO.DeltaTime = 0.00001f;
#endif

  // Check user data
  // (We pass an error message in the assert expression to make it visible to
  // programmers who are not using a debugger, as most assert handlers display
  // their argument)
  GUI_ASSERT(g.Initialized);
  GUI_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0) &&
             "Need a positive DeltaTime!");
  GUI_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount) &&
             "Forgot to call Render() or EndFrame() at the end of the previous "
             "frame?");
  GUI_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f &&
             "Invalid DisplaySize value!");
  GUI_ASSERT(
      g.IO.Fonts->IsBuilt() &&
      "Font Atlas not built! Make sure you called Gui_ImplXXXX_NewFrame() "
      "function for renderer backend, which should call "
      "io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()");
  GUI_ASSERT(g.Style.CurveTessellationTol > 0.0f && "Invalid style setting!");
  GUI_ASSERT(g.Style.CircleTessellationMaxError > 0.0f &&
             "Invalid style setting!");
  GUI_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f &&
             "Invalid style setting!"); // Allows us to avoid a few clamps in
                                        // color computations
  GUI_ASSERT(g.Style.WindowMinSize.x >= 1.0f &&
             g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
  GUI_ASSERT(g.Style.WindowMenuButtonPosition == Dir_None ||
             g.Style.WindowMenuButtonPosition == Dir_Left ||
             g.Style.WindowMenuButtonPosition == Dir_Right);
  GUI_ASSERT(g.Style.ColorButtonPosition == Dir_Left ||
             g.Style.ColorButtonPosition == Dir_Right);
#ifndef GUI_DISABLE_OBSOLETE_KEYIO
  for (int n = Key_NamedKey_BEGIN; n < Key_COUNT; n++)
    GUI_ASSERT(g.IO.KeyMap[n] >= -1 &&
               g.IO.KeyMap[n] < Key_LegacyNativeKey_END &&
               "io.KeyMap[] contains an out of bound value (need to be 0..511, "
               "or -1 for unmapped key)");

  // Check: required key mapping (we intentionally do NOT check all keys to not
  // pressure user into setting up everything, but Space is required and was
  // only added in 1.60 WIP)
  if ((g.IO.ConfigFlags & ConfigFlags_NavEnableKeyboard) &&
      g.IO.BackendUsingLegacyKeyArrays == 1)
    GUI_ASSERT(g.IO.KeyMap[Key_Space] != -1 &&
               "Key_Space is not mapped, required for keyboard navigation.");
#endif

  // Check: the io.ConfigWindowsResizeFromEdges option requires backend to honor
  // mouse cursor changes and set the BackendFlags_HasMouseCursors flag
  // accordingly.
  if (g.IO.ConfigWindowsResizeFromEdges &&
      !(g.IO.BackendFlags & BackendFlags_HasMouseCursors))
    g.IO.ConfigWindowsResizeFromEdges = false;
}

static void Gui::ErrorCheckEndFrameSanityChecks() {
  Context &g = *GGui;

  // Verify that io.KeyXXX fields haven't been tampered with. Key mods should
  // not be modified between NewFrame() and EndFrame() One possible reason
  // leading to this assert is that your backends update inputs _AFTER_
  // NewFrame(). It is known that when some modal native windows called
  // mid-frame takes focus away, some backends such as GLFW will send key
  // release events mid-frame. This would normally trigger this assertion and
  // lead to sheared inputs. We silently accommodate for this case by ignoring
  // the case where all io.KeyXXX modifiers were released (aka key_mod_flags ==
  // 0), while still correctly asserting on mid-frame key press events.
  const KeyChord key_mods = GetMergedModsFromKeys();
  GUI_ASSERT(
      (key_mods == 0 || g.IO.KeyMods == key_mods) &&
      "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods");
  GUI_UNUSED(key_mods);

  // [EXPERIMENTAL] Recover from errors: You may call this yourself before
  // EndFrame().
  // ErrorCheckEndFrameRecover();

  // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls.
  // Important: Remember that the Begin/BeginChild API requires you to always
  // call End/EndChild even if Begin/BeginChild returns false! (this is
  // unfortunately inconsistent with most other Begin* API).
  if (g.CurrentWindowStack.Size != 1) {
    if (g.CurrentWindowStack.Size > 1) {
      Window *window =
          g.CurrentWindowStack.back().Window; // <-- This window was not Ended!
      GUI_ASSERT_USER_ERROR(
          g.CurrentWindowStack.Size == 1,
          "Mismatched Begin/BeginChild vs End/EndChild calls: "
          "did you forget to call End/EndChild?");
      GUI_UNUSED(window);
      while (g.CurrentWindowStack.Size > 1)
        End();
    } else {
      GUI_ASSERT_USER_ERROR(
          g.CurrentWindowStack.Size == 1,
          "Mismatched Begin/BeginChild vs End/EndChild calls: "
          "did you call End/EndChild too much?");
    }
  }

  GUI_ASSERT_USER_ERROR(g.GroupStack.Size == 0, "Missing EndGroup call!");
}

// Experimental recovery from incorrect usage of BeginXXX/EndXXX/PushXXX/PopXXX
// calls. Must be called during or before EndFrame(). This is generally flawed
// as we are not necessarily End/Popping things in the right order.
// FIXME: Can't recover from inside BeginTabItem/EndTabItem yet.
// FIXME: Can't recover from interleaved BeginTabBar/Begin
inline void Gui::ErrorCheckEndFrameRecover(ErrorLogCallback log_callback,
                                           void *user_data) {
  // PVS-Studio V1044 is "Loop break conditions do not depend on the number of
  // iterations"
  Context &g = *GGui;
  while (g.CurrentWindowStack.Size > 0) //-V1044
  {
    ErrorCheckEndWindowRecover(log_callback, user_data);
    Window *window = g.CurrentWindow;
    if (g.CurrentWindowStack.Size == 1) {
      GUI_ASSERT(window->IsFallbackWindow);
      break;
    }
    if (window->Flags & WindowFlags_ChildWindow) {
      if (log_callback)
        log_callback(user_data, "Recovered from missing EndChild() for '%s'",
                     window->Name);
      EndChild();
    } else {
      if (log_callback)
        log_callback(user_data, "Recovered from missing End() for '%s'",
                     window->Name);
      End();
    }
  }
}

// Must be called before End()/EndChild()
inline void Gui::ErrorCheckEndWindowRecover(ErrorLogCallback log_callback,
                                            void *user_data) {
  Context &g = *GGui;
  while (g.CurrentTable && (g.CurrentTable->OuterWindow == g.CurrentWindow ||
                            g.CurrentTable->InnerWindow == g.CurrentWindow)) {
    if (log_callback)
      log_callback(user_data, "Recovered from missing EndTable() in '%s'",
                   g.CurrentTable->OuterWindow->Name);
    EndTable();
  }

  Window *window = g.CurrentWindow;
  StackSizes *stack_sizes = &g.CurrentWindowStack.back().StackSizesOnBegin;
  GUI_ASSERT(window != NULL);
  while (g.CurrentTabBar != NULL) //-V1044
  {
    if (log_callback)
      log_callback(user_data, "Recovered from missing EndTabBar() in '%s'",
                   window->Name);
    EndTabBar();
  }
  while (window->DC.TreeDepth > 0) {
    if (log_callback)
      log_callback(user_data, "Recovered from missing TreePop() in '%s'",
                   window->Name);
    TreePop();
  }
  while (g.GroupStack.Size > stack_sizes->SizeOfGroupStack) //-V1044
  {
    if (log_callback)
      log_callback(user_data, "Recovered from missing EndGroup() in '%s'",
                   window->Name);
    EndGroup();
  }
  while (window->IDStack.Size > 1) {
    if (log_callback)
      log_callback(user_data, "Recovered from missing PopID() in '%s'",
                   window->Name);
    PopID();
  }
  while (g.DisabledStackSize > stack_sizes->SizeOfDisabledStack) //-V1044
  {
    if (log_callback)
      log_callback(user_data, "Recovered from missing EndDisabled() in '%s'",
                   window->Name);
    EndDisabled();
  }
  while (g.ColorStack.Size > stack_sizes->SizeOfColorStack) {
    if (log_callback)
      log_callback(user_data,
                   "Recovered from missing PopStyleColor() in '%s' for Col_%s",
                   window->Name, GetStyleColorName(g.ColorStack.back().Col));
    PopStyleColor();
  }
  while (g.ItemFlagsStack.Size > stack_sizes->SizeOfItemFlagsStack) //-V1044
  {
    if (log_callback)
      log_callback(user_data, "Recovered from missing PopItemFlag() in '%s'",
                   window->Name);
    PopItemFlag();
  }
  while (g.StyleVarStack.Size > stack_sizes->SizeOfStyleVarStack) //-V1044
  {
    if (log_callback)
      log_callback(user_data, "Recovered from missing PopStyleVar() in '%s'",
                   window->Name);
    PopStyleVar();
  }
  while (g.FontStack.Size > stack_sizes->SizeOfFontStack) //-V1044
  {
    if (log_callback)
      log_callback(user_data, "Recovered from missing PopFont() in '%s'",
                   window->Name);
    PopFont();
  }
  while (g.FocusScopeStack.Size >
         stack_sizes->SizeOfFocusScopeStack + 1) //-V1044
  {
    if (log_callback)
      log_callback(user_data, "Recovered from missing PopFocusScope() in '%s'",
                   window->Name);
    PopFocusScope();
  }
}

// Save current stack sizes for later compare
inline void StackSizes::SetToContextState(Context *ctx) {
  Context &g = *ctx;
  Window *window = g.CurrentWindow;
  SizeOfIDStack = (short)window->IDStack.Size;
  SizeOfColorStack = (short)g.ColorStack.Size;
  SizeOfStyleVarStack = (short)g.StyleVarStack.Size;
  SizeOfFontStack = (short)g.FontStack.Size;
  SizeOfFocusScopeStack = (short)g.FocusScopeStack.Size;
  SizeOfGroupStack = (short)g.GroupStack.Size;
  SizeOfItemFlagsStack = (short)g.ItemFlagsStack.Size;
  SizeOfBeginPopupStack = (short)g.BeginPopupStack.Size;
  SizeOfDisabledStack = (short)g.DisabledStackSize;
}

// Compare to detect usage errors
inline void StackSizes::CompareWithContextState(Context *ctx) {
  Context &g = *ctx;
  Window *window = g.CurrentWindow;
  GUI_UNUSED(window);

  // Window stacks
  // NOT checking: DC.ItemWidth, DC.TextWrapPos (per window) to allow user to
  // conveniently push once and not pop (they are cleared on Begin)
  GUI_ASSERT(SizeOfIDStack == window->IDStack.Size &&
             "PushID/PopID or TreeNode/TreePop Mismatch!");

  // Global stacks
  // For color, style and font stacks there is an incentive to use
  // Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow
  // them.
  GUI_ASSERT(SizeOfGroupStack == g.GroupStack.Size &&
             "BeginGroup/EndGroup Mismatch!");
  GUI_ASSERT(SizeOfBeginPopupStack == g.BeginPopupStack.Size &&
             "BeginPopup/EndPopup or BeginMenu/EndMenu Mismatch!");
  GUI_ASSERT(SizeOfDisabledStack == g.DisabledStackSize &&
             "BeginDisabled/EndDisabled Mismatch!");
  GUI_ASSERT(SizeOfItemFlagsStack >= g.ItemFlagsStack.Size &&
             "PushItemFlag/PopItemFlag Mismatch!");
  GUI_ASSERT(SizeOfColorStack >= g.ColorStack.Size &&
             "PushStyleColor/PopStyleColor Mismatch!");
  GUI_ASSERT(SizeOfStyleVarStack >= g.StyleVarStack.Size &&
             "PushStyleVar/PopStyleVar Mismatch!");
  GUI_ASSERT(SizeOfFontStack >= g.FontStack.Size &&
             "PushFont/PopFont Mismatch!");
  GUI_ASSERT(SizeOfFocusScopeStack == g.FocusScopeStack.Size &&
             "PushFocusScope/PopFocusScope Mismatch!");
}

//-----------------------------------------------------------------------------
// [SECTION] LAYOUT
//-----------------------------------------------------------------------------
// - ItemSize()
// - ItemAdd()
// - SameLine()
// - GetCursorScreenPos()
// - SetCursorScreenPos()
// - GetCursorPos(), GetCursorPosX(), GetCursorPosY()
// - SetCursorPos(), SetCursorPosX(), SetCursorPosY()
// - GetCursorStartPos()
// - Indent()
// - Unindent()
// - SetNextItemWidth()
// - PushItemWidth()
// - PushMultiItemsWidths()
// - PopItemWidth()
// - CalcItemWidth()
// - CalcItemSize()
// - GetTextLineHeight()
// - GetTextLineHeightWithSpacing()
// - GetFrameHeight()
// - GetFrameHeightWithSpacing()
// - GetContentRegionMax()
// - GetContentRegionMaxAbs() [Internal]
// - GetContentRegionAvail(),
// - GetWindowContentRegionMin(), GetWindowContentRegionMax()
// - BeginGroup()
// - EndGroup()
// Also see in gui_widgets: tab bars, and in gui_tables: tables, columns.
//-----------------------------------------------------------------------------

// Advance cursor given item size for layout.
// Register minimum needed size so it can extend the bounding box used for
// auto-fit calculation. See comments in ItemAdd() about how/why the size
// provided to ItemSize() vs ItemAdd() may often different. THIS IS IN THE
// PERFORMANCE CRITICAL PATH.

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize().
// Typically, widgets that spread over available surface declare their minimum
// size requirement to ItemSize() and provide a larger region to ItemAdd() which
// is used drawing/interaction. THIS IS IN THE PERFORMANCE CRITICAL PATH (UNTIL
// THE CLIPPING TEST AND EARLY-RETURN)
inline bool Gui::ItemAdd(const Rect &bb, ID id, const Rect *nav_bb_arg,
                         ItemFlags extra_flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  // Set item data
  // (DisplayRect is left untouched, made valid when
  // ItemStatusFlags_HasDisplayRect is set)
  g.LastItemData.ID = id;
  g.LastItemData.Rect = bb;
  g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
  g.LastItemData.InFlags =
      g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;
  g.LastItemData.StatusFlags = ItemStatusFlags_None;
  // Note: we don't copy 'g.NextItemData.SelectionUserData' to an hypothetical
  // g.LastItemData.SelectionUserData: since the former is not cleared.

  if (id != 0) {
    KeepAliveID(id);

    // Directional navigation processing
    // Runs prior to clipping early-out
    //  (a) So that NavInitRequest can be honored, for newly opened windows to
    //  select a default widget (b) So that we can scroll up/down past clipped
    //  items. This adds a small O(N) cost to regular navigation requests
    //      unfortunately, but it is still limited to one window. It may not
    //      scale very well for windows with ten of thousands of item, but at
    //      least NavMoveRequest is only set on user interaction, aka maximum
    //      once a frame. We could early out with "if (is_clipped &&
    //      !g.NavInitRequest) return false;" but when we wouldn't be able to
    //      reach unclipped widgets. This would work if user had explicit
    //      scrolling control (e.g. mapped on a stick).
    // We intentionally don't check if g.NavWindow != NULL because
    // g.NavAnyRequest should only be set when it is non null. If we crash on a
    // NULL g.NavWindow we need to fix the bug elsewhere.
    if (!(g.LastItemData.InFlags & ItemFlags_NoNav)) {
      // FIMXE-NAV: investigate changing the window tests into a simple 'if
      // (g.NavFocusScopeId == g.CurrentFocusScopeId)' test.
      window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
      if (g.NavId == id || g.NavAnyRequest)
        if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
          if (window == g.NavWindow ||
              ((window->Flags | g.NavWindow->Flags) & WindowFlags_NavFlattened))
            NavProcessItem();
    }
  }

  // Lightweight clear of SetNextItemXXX data.
  g.NextItemData.Flags = NextItemDataFlags_None;
  g.NextItemData.ItemFlags = ItemFlags_None;

#ifdef GUI_ENABLE_TEST_ENGINE
  if (id != 0)
    GUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
#endif

  // Clipping test
  // (this is a modified copy of IsClippedEx() so we can reuse the
  // is_rect_visible value)
  // const bool is_clipped = IsClippedEx(bb, id);
  // if (is_clipped)
  //    return false;
  const bool is_rect_visible = bb.Overlaps(window->ClipRect);
  if (!is_rect_visible)
    if (id == 0 ||
        (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId))
      if (!g.LogEnabled)
        return false;

        // [DEBUG]
#ifndef GUI_DISABLE_DEBUG_TOOLS
  if (id != 0) {
    if (id == g.DebugLocateId)
      DebugLocateItemResolveWithLastItem();

    // [DEBUG] People keep stumbling on this problem and using "" as identifier
    // in the root of a window instead of "##something". Empty identifier are
    // valid and useful in a small amount of cases, but 99.9% of the time you
    // want to use "##something". READ THE FAQ: https://dearimgui.com/faq
    GUI_ASSERT(
        id != window->ID &&
        "Cannot have an empty ID at the root of a window. If you need an empty "
        "label, use ## and read the FAQ about how the ID Stack works!");
  }
  // if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max,
  // GUI_COL32(255,255,0,120)); // [DEBUG] if ((g.LastItemData.InFlags &
  // ItemFlags_NoNav) == 0)
  //     window->DrawList->AddRect(g.LastItemData.NavRect.Min,
  //     g.LastItemData.NavRect.Max, GUI_COL32(255,255,0,255)); // [DEBUG]
#endif

  // We need to calculate this now to take account of the current clipping
  // rectangle (as items like Selectable may change them)
  if (is_rect_visible)
    g.LastItemData.StatusFlags |= ItemStatusFlags_Visible;
  if (IsMouseHoveringRect(bb.Min, bb.Max))
    g.LastItemData.StatusFlags |= ItemStatusFlags_HoveredRect;
  return true;
}

// Gets back to previous line and continue with horizontal layout
//      offset_from_start_x == 0 : follow right after previous item
//      offset_from_start_x != 0 : align to specified x position (relative to
//      window/group left) spacing_w < 0            : use default spacing if
//      offset_from_start_x == 0, no spacing if offset_from_start_x != 0
//      spacing_w >= 0           : enforce spacing amount
inline void Gui::SameLine(float offset_from_start_x, float spacing_w) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return;

  if (offset_from_start_x != 0.0f) {
    if (spacing_w < 0.0f)
      spacing_w = 0.0f;
    window->DC.CursorPos.x =
        window->Pos.x - window->Scroll.x + offset_from_start_x + spacing_w +
        window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
    window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
  } else {
    if (spacing_w < 0.0f)
      spacing_w = g.Style.ItemSpacing.x;
    window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
    window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
  }
  window->DC.CurrLineSize = window->DC.PrevLineSize;
  window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
  window->DC.IsSameLine = true;
}

inline Vec2 Gui::GetCursorScreenPos() {
  Window *window = GetCurrentWindowRead();
  return window->DC.CursorPos;
}

inline void Gui::SetCursorScreenPos(const Vec2 &pos) {
  Window *window = GetCurrentWindow();
  window->DC.CursorPos = pos;
  // window->DC.CursorMaxPos = Max(window->DC.CursorMaxPos,
  // window->DC.CursorPos);
  window->DC.IsSetPos = true;
}

// User generally sees positions in window coordinates. Internally we store
// CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming
// convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos).
// May want to rename 'DC.CursorPos'.
inline Vec2 Gui::GetCursorPos() {
  Window *window = GetCurrentWindowRead();
  return Add(Subtract(window->DC.CursorPos, window->Pos), window->Scroll);
}

inline float Gui::GetCursorPosX() {
  Window *window = GetCurrentWindowRead();
  return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
}

inline float Gui::GetCursorPosY() {
  Window *window = GetCurrentWindowRead();
  return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
}

inline void Gui::SetCursorPos(const Vec2 &local_pos) {
  Window *window = GetCurrentWindow();
  window->DC.CursorPos = Add(Subtract(window->Pos, window->Scroll), local_pos);
  // window->DC.CursorMaxPos = Max(window->DC.CursorMaxPos,
  // window->DC.CursorPos);
  window->DC.IsSetPos = true;
}

inline void Gui::SetCursorPosX(float x) {
  Window *window = GetCurrentWindow();
  window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
  // window->DC.CursorMaxPos.x = Max(window->DC.CursorMaxPos.x,
  // window->DC.CursorPos.x);
  window->DC.IsSetPos = true;
}

inline void Gui::SetCursorPosY(float y) {
  Window *window = GetCurrentWindow();
  window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
  // window->DC.CursorMaxPos.y = Max(window->DC.CursorMaxPos.y,
  // window->DC.CursorPos.y);
  window->DC.IsSetPos = true;
}

inline Vec2 Gui::GetCursorStartPos() {
  Window *window = GetCurrentWindowRead();
  return Subtract(window->DC.CursorStartPos, window->Pos);
}

inline void Gui::Indent(float indent_w) {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();
  window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
  window->DC.CursorPos.x =
      window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

inline void Gui::Unindent(float indent_w) {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();
  window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
  window->DC.CursorPos.x =
      window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

// Affect large frame+labels widgets only.
inline void Gui::SetNextItemWidth(float item_width) {
  Context &g = *GGui;
  g.NextItemData.Flags |= NextItemDataFlags_HasWidth;
  g.NextItemData.Width = item_width;
}

// FIXME: Remove the == 0.0f behavior?
inline void Gui::PushItemWidth(float item_width) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  window->DC.ItemWidthStack.push_back(
      window->DC.ItemWidth); // Backup current width
  window->DC.ItemWidth =
      (item_width == 0.0f ? window->ItemWidthDefault : item_width);
  g.NextItemData.Flags &= ~NextItemDataFlags_HasWidth;
}

inline void Gui::PushMultiItemsWidths(int components, float w_full) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_ASSERT(components > 0);
  const Style &style = g.Style;
  window->DC.ItemWidthStack.push_back(
      window->DC.ItemWidth); // Backup current width
  float w_items = w_full - style.ItemInnerSpacing.x * (components - 1);
  float prev_split = w_items;
  for (int i = components - 1; i > 0; i--) {
    float next_split = GUI_TRUNC(w_items * i / components);
    window->DC.ItemWidthStack.push_back(Max(prev_split - next_split, 1.0f));
    prev_split = next_split;
  }
  window->DC.ItemWidth = Max(prev_split, 1.0f);
  g.NextItemData.Flags &= ~NextItemDataFlags_HasWidth;
}

inline void Gui::PopItemWidth() {
  Window *window = GetCurrentWindow();
  window->DC.ItemWidth = window->DC.ItemWidthStack.back();
  window->DC.ItemWidthStack.pop_back();
}

// Calculate default item width given value passed to PushItemWidth() or
// SetNextItemWidth(). The SetNextItemWidth() data is generally cleared/consumed
// by ItemAdd() or NextItemData.ClearFlags()
inline float Gui::CalcItemWidth() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  float w;
  if (g.NextItemData.Flags & NextItemDataFlags_HasWidth)
    w = g.NextItemData.Width;
  else
    w = window->DC.ItemWidth;
  if (w < 0.0f) {
    float region_max_x = GetContentRegionMaxAbs().x;
    w = Max(1.0f, region_max_x - window->DC.CursorPos.x + w);
  }
  w = GUI_TRUNC(w);
  return w;
}

// [Internal] Calculate full item size given user provided 'size' parameter and
// default width/height. Default width is often == CalcItemWidth(). Those two
// functions CalcItemWidth vs CalcItemSize are awkwardly named because they are
// not fully symmetrical. Note that only CalcItemWidth() is publicly exposed.
// The 4.0f here may be changed to match CalcItemWidth() and/or BeginChild()
// (right now we have a mismatch which is harmless but undesirable)
inline Vec2 Gui::CalcItemSize(Vec2 size, float default_w, float default_h) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  Vec2 region_max;
  if (size.x < 0.0f || size.y < 0.0f)
    region_max = GetContentRegionMaxAbs();

  if (size.x == 0.0f)
    size.x = default_w;
  else if (size.x < 0.0f)
    size.x = Max(4.0f, region_max.x - window->DC.CursorPos.x + size.x);

  if (size.y == 0.0f)
    size.y = default_h;
  else if (size.y < 0.0f)
    size.y = Max(4.0f, region_max.y - window->DC.CursorPos.y + size.y);

  return size;
}

inline float Gui::GetTextLineHeight() {
  Context &g = *GGui;
  return g.FontSize;
}

inline float Gui::GetTextLineHeightWithSpacing() {
  Context &g = *GGui;
  return g.FontSize + g.Style.ItemSpacing.y;
}

inline float Gui::GetFrameHeight() {
  Context &g = *GGui;
  return g.FontSize + g.Style.FramePadding.y * 2.0f;
}

inline float Gui::GetFrameHeightWithSpacing() {
  Context &g = *GGui;
  return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
}

// FIXME: All the Contents Region function are messy or misleading. WE WILL AIM
// TO OBSOLETE ALL OF THEM WITH A NEW "WORK RECT" API. Thanks for your patience!

// FIXME: This is in window space (not screen space!).
inline Vec2 Gui::GetContentRegionMax() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  Vec2 mx = (window->DC.CurrentColumns || g.CurrentTable)
                ? window->WorkRect.Max
                : window->ContentRegionRect.Max;
  return Subtract(mx, window->Pos);
}

// [Internal] Absolute coordinate. Saner. This is not exposed until we finishing
// refactoring work rect features.

inline Vec2 Gui::GetContentRegionAvail() {
  Window *window = GGui->CurrentWindow;
  return Subtract(GetContentRegionMaxAbs(), window->DC.CursorPos);
}

// In window space (not screen space!)
inline Vec2 Gui::GetWindowContentRegionMin() {
  Window *window = GGui->CurrentWindow;
  return Subtract(window->ContentRegionRect.Min, window->Pos);
}

inline Vec2 Gui::GetWindowContentRegionMax() {
  Window *window = GGui->CurrentWindow;
  return Subtract(window->ContentRegionRect.Max, window->Pos);
}

// Lock horizontal starting position + capture group bounding box into one
// "item" (so you can use IsItemHovered() or layout primitives such as
// SameLine() on whole group, etc.) Groups are currently a mishmash of
// functionalities which should perhaps be clarified and separated.
// FIXME-OPT: Could we safely early out on ->SkipItems?
inline void Gui::BeginGroup() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  g.GroupStack.resize(g.GroupStack.Size + 1);
  GroupData &group_data = g.GroupStack.back();
  group_data.WindowID = window->ID;
  group_data.BackupCursorPos = window->DC.CursorPos;
  group_data.BackupCursorPosPrevLine = window->DC.CursorPosPrevLine;
  group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
  group_data.BackupIndent = window->DC.Indent;
  group_data.BackupGroupOffset = window->DC.GroupOffset;
  group_data.BackupCurrLineSize = window->DC.CurrLineSize;
  group_data.BackupCurrLineTextBaseOffset = window->DC.CurrLineTextBaseOffset;
  group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
  group_data.BackupHoveredIdIsAlive = g.HoveredId != 0;
  group_data.BackupIsSameLine = window->DC.IsSameLine;
  group_data.BackupActiveIdPreviousFrameIsAlive =
      g.ActiveIdPreviousFrameIsAlive;
  group_data.EmitItem = true;

  window->DC.GroupOffset.x =
      window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
  window->DC.Indent = window->DC.GroupOffset;
  window->DC.CursorMaxPos = window->DC.CursorPos;
  window->DC.CurrLineSize = Vec2(0.0f, 0.0f);
  if (g.LogEnabled)
    g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
}

inline void Gui::EndGroup() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_ASSERT(g.GroupStack.Size > 0); // Mismatched BeginGroup()/EndGroup() calls

  GroupData &group_data = g.GroupStack.back();
  GUI_ASSERT(group_data.WindowID == window->ID); // EndGroup() in wrong window?

  if (window->DC.IsSetPos)
    ErrorCheckUsingSetCursorPosToExtendParentBoundaries();

  Rect group_bb(group_data.BackupCursorPos,
                Max(window->DC.CursorMaxPos, group_data.BackupCursorPos));

  window->DC.CursorPos = group_data.BackupCursorPos;
  window->DC.CursorPosPrevLine = group_data.BackupCursorPosPrevLine;
  window->DC.CursorMaxPos =
      Max(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);
  window->DC.Indent = group_data.BackupIndent;
  window->DC.GroupOffset = group_data.BackupGroupOffset;
  window->DC.CurrLineSize = group_data.BackupCurrLineSize;
  window->DC.CurrLineTextBaseOffset = group_data.BackupCurrLineTextBaseOffset;
  window->DC.IsSameLine = group_data.BackupIsSameLine;
  if (g.LogEnabled)
    g.LogLinePosY = -FLT_MAX; // To enforce a carriage return

  if (!group_data.EmitItem) {
    g.GroupStack.pop_back();
    return;
  }

  window->DC.CurrLineTextBaseOffset = Max(
      window->DC.PrevLineTextBaseOffset,
      group_data.BackupCurrLineTextBaseOffset); // FIXME: Incorrect, we should
                                                // grab the base offset from the
                                                // *first line* of the group but
                                                // it is hard to obtain now.
  ItemSize(group_bb.GetSize());
  ItemAdd(group_bb, 0, NULL, ItemFlags_NoTabStop);

  // If the current ActiveId was declared within the boundary of our group, we
  // copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be
  // functional on the entire group. It would be neater if we replaced
  // window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a
  // little more burden on individual widgets. Also if you grep for LastItemId
  // you'll notice it is only used in that context. (The two tests not the same
  // because ActiveIdIsAlive is an ID itself, in order to be able to handle
  // ActiveId being overwritten during the frame.)
  const bool group_contains_curr_active_id =
      (group_data.BackupActiveIdIsAlive != g.ActiveId) &&
      (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId;
  const bool group_contains_prev_active_id =
      (group_data.BackupActiveIdPreviousFrameIsAlive == false) &&
      (g.ActiveIdPreviousFrameIsAlive == true);
  if (group_contains_curr_active_id)
    g.LastItemData.ID = g.ActiveId;
  else if (group_contains_prev_active_id)
    g.LastItemData.ID = g.ActiveIdPreviousFrame;
  g.LastItemData.Rect = group_bb;

  // Forward Hovered flag
  const bool group_contains_curr_hovered_id =
      (group_data.BackupHoveredIdIsAlive == false) && g.HoveredId != 0;
  if (group_contains_curr_hovered_id)
    g.LastItemData.StatusFlags |= ItemStatusFlags_HoveredWindow;

  // Forward Edited flag
  if (group_contains_curr_active_id && g.ActiveIdHasBeenEditedThisFrame)
    g.LastItemData.StatusFlags |= ItemStatusFlags_Edited;

  // Forward Deactivated flag
  g.LastItemData.StatusFlags |= ItemStatusFlags_HasDeactivated;
  if (group_contains_prev_active_id && g.ActiveId != g.ActiveIdPreviousFrame)
    g.LastItemData.StatusFlags |= ItemStatusFlags_Deactivated;

  g.GroupStack.pop_back();
  if (g.DebugShowGroupRects)
    window->DrawList->AddRect(group_bb.Min, group_bb.Max,
                              GUI_COL32(255, 0, 255, 255)); // [Debug]
}

//-----------------------------------------------------------------------------
// [SECTION] SCROLLING
//-----------------------------------------------------------------------------

// Helper to snap on edges when aiming at an item very close to the edge,
// So the difference between WindowPadding and ItemSpacing will be in the
// visible area after scrolling. When we refactor the scrolling API this may be
// configurable with a flag? Note that the effect for this won't be visible on X
// axis with default Style settings as WindowPadding.x == ItemSpacing.x by
// default.
static float CalcScrollEdgeSnap(float target, float snap_min, float snap_max,
                                float snap_threshold, float center_ratio) {
  if (target <= snap_min + snap_threshold)
    return Lerp(snap_min, target, center_ratio);
  if (target >= snap_max - snap_threshold)
    return Lerp(target, snap_max, center_ratio);
  return target;
}

static Vec2 CalcNextScrollFromScrollTargetAndClamp(Window *window) {
  Vec2 scroll = window->Scroll;
  Vec2 decoration_size(window->DecoOuterSizeX1 + window->DecoInnerSizeX1 +
                           window->DecoOuterSizeX2,
                       window->DecoOuterSizeY1 + window->DecoInnerSizeY1 +
                           window->DecoOuterSizeY2);
  for (int axis = 0; axis < 2; axis++) {
    if (window->ScrollTarget[axis] < FLT_MAX) {
      float center_ratio = window->ScrollTargetCenterRatio[axis];
      float scroll_target = window->ScrollTarget[axis];
      if (window->ScrollTargetEdgeSnapDist[axis] > 0.0f) {
        float snap_min = 0.0f;
        float snap_max = window->ScrollMax[axis] + window->SizeFull[axis] -
                         decoration_size[axis];
        scroll_target = CalcScrollEdgeSnap(
            scroll_target, snap_min, snap_max,
            window->ScrollTargetEdgeSnapDist[axis], center_ratio);
      }
      scroll[axis] = scroll_target - center_ratio * (window->SizeFull[axis] -
                                                     decoration_size[axis]);
    }
    scroll[axis] = GUI_ROUND(Max(scroll[axis], 0.0f));
    if (!window->Collapsed && !window->SkipItems)
      scroll[axis] = Min(scroll[axis], window->ScrollMax[axis]);
  }
  return scroll;
}

inline void Gui::ScrollToItem(ScrollFlags flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  ScrollToRectEx(window, g.LastItemData.NavRect, flags);
}

inline void Gui::ScrollToRect(Window *window, const Rect &item_rect,
                              ScrollFlags flags) {
  ScrollToRectEx(window, item_rect, flags);
}

// Scroll to keep newly navigated item fully into view
inline Vec2 Gui::ScrollToRectEx(Window *window, const Rect &item_rect,
                                ScrollFlags flags) {
  Context &g = *GGui;
  Rect scroll_rect(Subtract(window->InnerRect.Min, Vec2(1, 1)),
                   Add(window->InnerRect.Max, Vec2(1, 1)));
  scroll_rect.Min.x =
      Min(scroll_rect.Min.x + window->DecoInnerSizeX1, scroll_rect.Max.x);
  scroll_rect.Min.y =
      Min(scroll_rect.Min.y + window->DecoInnerSizeY1, scroll_rect.Max.y);
  // GetForegroundDrawList(window)->AddRect(item_rect.Min, item_rect.Max,
  // GUI_COL32(255,0,0,255), 0.0f, 0, 5.0f); // [DEBUG]
  // GetForegroundDrawList(window)->AddRect(scroll_rect.Min, scroll_rect.Max,
  // GUI_COL32_WHITE); // [DEBUG]

  // Check that only one behavior is selected per axis
  GUI_ASSERT((flags & ScrollFlags_MaskX_) == 0 ||
             IsPowerOfTwo(flags & ScrollFlags_MaskX_));
  GUI_ASSERT((flags & ScrollFlags_MaskY_) == 0 ||
             IsPowerOfTwo(flags & ScrollFlags_MaskY_));

  // Defaults
  ScrollFlags in_flags = flags;
  if ((flags & ScrollFlags_MaskX_) == 0 && window->ScrollbarX)
    flags |= ScrollFlags_KeepVisibleEdgeX;
  if ((flags & ScrollFlags_MaskY_) == 0)
    flags |= window->Appearing ? ScrollFlags_AlwaysCenterY
                               : ScrollFlags_KeepVisibleEdgeY;

  const bool fully_visible_x = item_rect.Min.x >= scroll_rect.Min.x &&
                               item_rect.Max.x <= scroll_rect.Max.x;
  const bool fully_visible_y = item_rect.Min.y >= scroll_rect.Min.y &&
                               item_rect.Max.y <= scroll_rect.Max.y;
  const bool can_be_fully_visible_x =
      (item_rect.GetWidth() + g.Style.ItemSpacing.x * 2.0f) <=
          scroll_rect.GetWidth() ||
      (window->AutoFitFramesX > 0) ||
      (window->Flags & WindowFlags_AlwaysAutoResize) != 0;
  const bool can_be_fully_visible_y =
      (item_rect.GetHeight() + g.Style.ItemSpacing.y * 2.0f) <=
          scroll_rect.GetHeight() ||
      (window->AutoFitFramesY > 0) ||
      (window->Flags & WindowFlags_AlwaysAutoResize) != 0;

  if ((flags & ScrollFlags_KeepVisibleEdgeX) && !fully_visible_x) {
    if (item_rect.Min.x < scroll_rect.Min.x || !can_be_fully_visible_x)
      SetScrollFromPosX(window,
                        item_rect.Min.x - g.Style.ItemSpacing.x - window->Pos.x,
                        0.0f);
    else if (item_rect.Max.x >= scroll_rect.Max.x)
      SetScrollFromPosX(window,
                        item_rect.Max.x + g.Style.ItemSpacing.x - window->Pos.x,
                        1.0f);
  } else if (((flags & ScrollFlags_KeepVisibleCenterX) && !fully_visible_x) ||
             (flags & ScrollFlags_AlwaysCenterX)) {
    if (can_be_fully_visible_x)
      SetScrollFromPosX(window,
                        Trunc((item_rect.Min.x + item_rect.Max.x) * 0.5f) -
                            window->Pos.x,
                        0.5f);
    else
      SetScrollFromPosX(window, item_rect.Min.x - window->Pos.x, 0.0f);
  }

  if ((flags & ScrollFlags_KeepVisibleEdgeY) && !fully_visible_y) {
    if (item_rect.Min.y < scroll_rect.Min.y || !can_be_fully_visible_y)
      SetScrollFromPosY(window,
                        item_rect.Min.y - g.Style.ItemSpacing.y - window->Pos.y,
                        0.0f);
    else if (item_rect.Max.y >= scroll_rect.Max.y)
      SetScrollFromPosY(window,
                        item_rect.Max.y + g.Style.ItemSpacing.y - window->Pos.y,
                        1.0f);
  } else if (((flags & ScrollFlags_KeepVisibleCenterY) && !fully_visible_y) ||
             (flags & ScrollFlags_AlwaysCenterY)) {
    if (can_be_fully_visible_y)
      SetScrollFromPosY(window,
                        Trunc((item_rect.Min.y + item_rect.Max.y) * 0.5f) -
                            window->Pos.y,
                        0.5f);
    else
      SetScrollFromPosY(window, item_rect.Min.y - window->Pos.y, 0.0f);
  }

  Vec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
  Vec2 delta_scroll = Subtract(next_scroll, window->Scroll);

  // Also scroll parent window to keep us into view if necessary
  if (!(flags & ScrollFlags_NoScrollParent) &&
      (window->Flags & WindowFlags_ChildWindow)) {
    // FIXME-SCROLL: May be an option?
    if ((in_flags &
         (ScrollFlags_AlwaysCenterX | ScrollFlags_KeepVisibleCenterX)) != 0)
      in_flags =
          (in_flags & ~ScrollFlags_MaskX_) | ScrollFlags_KeepVisibleEdgeX;
    if ((in_flags &
         (ScrollFlags_AlwaysCenterY | ScrollFlags_KeepVisibleCenterY)) != 0)
      in_flags =
          (in_flags & ~ScrollFlags_MaskY_) | ScrollFlags_KeepVisibleEdgeY;
    delta_scroll =
        Add(delta_scroll,
            ScrollToRectEx(window->ParentWindow,
                           Rect(Subtract(item_rect.Min, delta_scroll),
                                Subtract(item_rect.Max, delta_scroll)),
                           in_flags));
  }

  return delta_scroll;
}

inline float Gui::GetScrollX() {
  Window *window = GGui->CurrentWindow;
  return window->Scroll.x;
}

inline float Gui::GetScrollY() {
  Window *window = GGui->CurrentWindow;
  return window->Scroll.y;
}

inline float Gui::GetScrollMaxX() {
  Window *window = GGui->CurrentWindow;
  return window->ScrollMax.x;
}

inline float Gui::GetScrollMaxY() {
  Window *window = GGui->CurrentWindow;
  return window->ScrollMax.y;
}

inline void Gui::SetScrollX(float scroll_x) {
  Context &g = *GGui;
  SetScrollX(g.CurrentWindow, scroll_x);
}

inline void Gui::SetScrollY(float scroll_y) {
  Context &g = *GGui;
  SetScrollY(g.CurrentWindow, scroll_y);
}

// Note that a local position will vary depending on initial scroll value,
// This is a little bit confusing so bear with us:
//  - local_pos = (absolution_pos - window->Pos)
//  - So local_x/local_y are 0.0f for a position at the upper-left corner of a
//  window,
//    and generally local_x/local_y are >(padding+decoration) &&
//    <(size-padding-decoration) when in the visible area.
//  - They mostly exist because of legacy API.
// Following the rules above, when trying to work with scrolling code, consider
// that:
//  - SetScrollFromPosY(0.0f) == SetScrollY(0.0f + scroll.y) == has no effect!
//  - SetScrollFromPosY(-scroll.y) == SetScrollY(-scroll.y + scroll.y) ==
//  SetScrollY(0.0f) == reset scroll. Of course writing SetScrollY(0.0f)
//  directly then makes more sense
// We store a target position so centering and clamping can occur on the next
// frame when we are guaranteed to have a known window size
inline void Gui::SetScrollFromPosX(Window *window, float local_x,
                                   float center_x_ratio) {
  GUI_ASSERT(center_x_ratio >= 0.0f && center_x_ratio <= 1.0f);
  window->ScrollTarget.x =
      GUI_TRUNC(local_x - window->DecoOuterSizeX1 - window->DecoInnerSizeX1 +
                window->Scroll.x); // Convert local position to scroll offset
  window->ScrollTargetCenterRatio.x = center_x_ratio;
  window->ScrollTargetEdgeSnapDist.x = 0.0f;
}

inline void Gui::SetScrollFromPosY(Window *window, float local_y,
                                   float center_y_ratio) {
  GUI_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
  window->ScrollTarget.y =
      GUI_TRUNC(local_y - window->DecoOuterSizeY1 - window->DecoInnerSizeY1 +
                window->Scroll.y); // Convert local position to scroll offset
  window->ScrollTargetCenterRatio.y = center_y_ratio;
  window->ScrollTargetEdgeSnapDist.y = 0.0f;
}

inline void Gui::SetScrollFromPosX(float local_x, float center_x_ratio) {
  Context &g = *GGui;
  SetScrollFromPosX(g.CurrentWindow, local_x, center_x_ratio);
}

inline void Gui::SetScrollFromPosY(float local_y, float center_y_ratio) {
  Context &g = *GGui;
  SetScrollFromPosY(g.CurrentWindow, local_y, center_y_ratio);
}

// center_x_ratio: 0.0f left of last item, 0.5f horizontal center of last
// item, 1.0f right of last item.
inline void Gui::SetScrollHereX(float center_x_ratio) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  float spacing_x = Max(window->WindowPadding.x, g.Style.ItemSpacing.x);
  float target_pos_x =
      Lerp(g.LastItemData.Rect.Min.x - spacing_x,
           g.LastItemData.Rect.Max.x + spacing_x, center_x_ratio);
  SetScrollFromPosX(window, target_pos_x - window->Pos.x,
                    center_x_ratio); // Convert from absolute to local pos

  // Tweak: snap on edges when aiming at an item very close to the edge
  window->ScrollTargetEdgeSnapDist.x =
      Max(0.0f, window->WindowPadding.x - spacing_x);
}

// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last
// item, 1.0f bottom of last item.
inline void Gui::SetScrollHereY(float center_y_ratio) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  float spacing_y = Max(window->WindowPadding.y, g.Style.ItemSpacing.y);
  float target_pos_y = Lerp(window->DC.CursorPosPrevLine.y - spacing_y,
                            window->DC.CursorPosPrevLine.y +
                                window->DC.PrevLineSize.y + spacing_y,
                            center_y_ratio);
  SetScrollFromPosY(window, target_pos_y - window->Pos.y,
                    center_y_ratio); // Convert from absolute to local pos

  // Tweak: snap on edges when aiming at an item very close to the edge
  window->ScrollTargetEdgeSnapDist.y =
      Max(0.0f, window->WindowPadding.y - spacing_y);
}

//-----------------------------------------------------------------------------
// [SECTION] TOOLTIPS
//-----------------------------------------------------------------------------

inline bool Gui::BeginTooltip() {
  return BeginTooltipEx(TooltipFlags_None, WindowFlags_None);
}

inline bool Gui::BeginItemTooltip() {
  if (!IsItemHovered(HoveredFlags_ForTooltip))
    return false;
  return BeginTooltipEx(TooltipFlags_None, WindowFlags_None);
}

inline bool Gui::BeginTooltipEx(TooltipFlags tooltip_flags,
                                WindowFlags extra_window_flags) {
  Context &g = *GGui;

  if (g.DragDropWithinSource || g.DragDropWithinTarget) {
    // Drag and Drop tooltips are positioning differently than other tooltips:
    // - offset visibility to increase visibility around mouse.
    // - never clamp within outer viewport boundary.
    // We call SetNextWindowPos() to enforce position and disable clamping.
    // See FindBestWindowPosForPopup() for positionning logic of other tooltips
    // (not drag and drop ones).
    // Vec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset -
    // g.Style.WindowPadding;
    Vec2 tooltip_pos = Add(g.IO.MousePos, Multiply(TOOLTIP_DEFAULT_OFFSET,
                                                   g.Style.MouseCursorScale));
    SetNextWindowPos(tooltip_pos);
    SetNextWindowBgAlpha(g.Style.Colors[Col_PopupBg].w * 0.60f);
    // PushStyleVar(StyleVar_Alpha, g.Style.Alpha * 0.60f); // This would
    // be nice but e.g ColorButton with checkboard has issue with transparent
    // colors :(
    tooltip_flags |= TooltipFlags_OverridePrevious;
  }

  char window_name[16];
  FormatString(window_name, GUI_ARRAYSIZE(window_name), "##Tooltip_%02d",
               g.TooltipOverrideCount);
  if (tooltip_flags & TooltipFlags_OverridePrevious)
    if (Window *window = FindWindowByName(window_name))
      if (window->Active) {
        // Hide previous tooltip from being displayed. We can't easily "reset"
        // the content of a window so we create a new one.
        SetWindowHiddenAndSkipItemsForCurrentFrame(window);
        FormatString(window_name, GUI_ARRAYSIZE(window_name), "##Tooltip_%02d",
                     ++g.TooltipOverrideCount);
      }
  WindowFlags flags = WindowFlags_Tooltip | WindowFlags_NoInputs |
                      WindowFlags_NoTitleBar | WindowFlags_NoMove |
                      WindowFlags_NoResize | WindowFlags_NoSavedSettings |
                      WindowFlags_AlwaysAutoResize;
  Begin(window_name, NULL, flags | extra_window_flags);
  // 2023-03-09: Added bool return value to the API, but currently always
  // returning true. If this ever returns false we need to update
  // BeginDragDropSource() accordingly.
  // if (!ret)
  //    End();
  // return ret;
  return true;
}

inline void Gui::EndTooltip() {
  GUI_ASSERT(
      GetCurrentWindowRead()->Flags &
      WindowFlags_Tooltip); // Mismatched BeginTooltip()/EndTooltip() calls
  End();
}

inline void Gui::SetTooltip(const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  SetTooltipV(fmt, args);
  va_end(args);
}

inline void Gui::SetTooltipV(const char *fmt, va_list args) {
  if (!BeginTooltipEx(TooltipFlags_OverridePrevious, WindowFlags_None))
    return;
  TextV(fmt, args);
  EndTooltip();
}

// Shortcut to use 'style.HoverFlagsForTooltipMouse' or
// 'style.HoverFlagsForTooltipNav'. Defaults to == HoveredFlags_Stationary
// | HoveredFlags_DelayShort when using the mouse.
inline void Gui::SetItemTooltip(const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  if (IsItemHovered(HoveredFlags_ForTooltip))
    SetTooltipV(fmt, args);
  va_end(args);
}

inline void Gui::SetItemTooltipV(const char *fmt, va_list args) {
  if (IsItemHovered(HoveredFlags_ForTooltip))
    SetTooltipV(fmt, args);
}

//-----------------------------------------------------------------------------
// [SECTION] POPUPS
//-----------------------------------------------------------------------------

// Supported flags: PopupFlags_AnyPopupId, PopupFlags_AnyPopupLevel
inline bool Gui::IsPopupOpen(ID id, PopupFlags popup_flags) {
  Context &g = *GGui;
  if (popup_flags & PopupFlags_AnyPopupId) {
    // Return true if any popup is open at the current BeginPopup() level of the
    // popup stack This may be used to e.g. test for another popups already
    // opened to handle popups priorities at the same level.
    GUI_ASSERT(id == 0);
    if (popup_flags & PopupFlags_AnyPopupLevel)
      return g.OpenPopupStack.Size > 0;
    else
      return g.OpenPopupStack.Size > g.BeginPopupStack.Size;
  } else {
    if (popup_flags & PopupFlags_AnyPopupLevel) {
      // Return true if the popup is open anywhere in the popup stack
      for (int n = 0; n < g.OpenPopupStack.Size; n++)
        if (g.OpenPopupStack[n].PopupId == id)
          return true;
      return false;
    } else {
      // Return true if the popup is open at the current BeginPopup() level of
      // the popup stack (this is the most-common query)
      return g.OpenPopupStack.Size > g.BeginPopupStack.Size &&
             g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
    }
  }
}

inline bool Gui::IsPopupOpen(const char *str_id, PopupFlags popup_flags) {
  Context &g = *GGui;
  ID id = (popup_flags & PopupFlags_AnyPopupId)
              ? 0
              : g.CurrentWindow->GetID(str_id);
  if ((popup_flags & PopupFlags_AnyPopupLevel) && id != 0)
    GUI_ASSERT(0 && "Cannot use IsPopupOpen() with a string id and "
                    "PopupFlags_AnyPopupLevel."); // But non-string version is
                                                  // legal and used internally
  return IsPopupOpen(id, popup_flags);
}

// Also see FindBlockingModal(NULL)

// See Demo->Stacked Modal to confirm what this is for.
inline Window *Gui::GetTopMostAndVisiblePopupModal() {
  Context &g = *GGui;
  for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
    if (Window *popup = g.OpenPopupStack.Data[n].Window)
      if ((popup->Flags & WindowFlags_Modal) && IsWindowActiveAndVisible(popup))
        return popup;
  return NULL;
}

inline void Gui::OpenPopup(const char *str_id, PopupFlags popup_flags) {
  Context &g = *GGui;
  ID id = g.CurrentWindow->GetID(str_id);
  GUI_DEBUG_LOG_POPUP("[popup] OpenPopup(\"%s\" -> 0x%08X)\n", str_id, id);
  OpenPopupEx(id, popup_flags);
}

inline void Gui::OpenPopup(ID id, PopupFlags popup_flags) {
  OpenPopupEx(id, popup_flags);
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or
// CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. Popup
// identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup
// needs to be at the same level). One open popup per level of the popup
// hierarchy (NB: when assigning we reset the Window member of PopupRef to
// NULL)
inline void Gui::OpenPopupEx(ID id, PopupFlags popup_flags) {
  Context &g = *GGui;
  Window *parent_window = g.CurrentWindow;
  const int current_stack_size = g.BeginPopupStack.Size;

  if (popup_flags & PopupFlags_NoOpenOverExistingPopup)
    if (IsPopupOpen((ID)0, PopupFlags_AnyPopupId))
      return;

  PopupData popup_ref; // Tagged as new ref as Window will be set back to
                       // NULL if we write this into OpenPopupStack.
  popup_ref.PopupId = id;
  popup_ref.Window = NULL;
  popup_ref.BackupNavWindow =
      g.NavWindow; // When popup closes focus may be restored to NavWindow
                   // (depend on window type).
  popup_ref.OpenFrameCount = g.FrameCount;
  popup_ref.OpenParentId = parent_window->IDStack.back();
  popup_ref.OpenPopupPos = NavCalcPreferredRefPos();
  popup_ref.OpenMousePos =
      IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;

  GUI_DEBUG_LOG_POPUP("[popup] OpenPopupEx(0x%08X)\n", id);
  if (g.OpenPopupStack.Size < current_stack_size + 1) {
    g.OpenPopupStack.push_back(popup_ref);
  } else {
    // Gently handle the user mistakenly calling OpenPopup() every frame. It is
    // a programming mistake! However, if we were to run the regular code path,
    // the ui would become completely unusable because the popup will always be
    // in hidden-while-calculating-size state _while_ claiming focus. Which
    // would be a very confusing situation for the programmer. Instead, we
    // silently allow the popup to proceed, it will keep reappearing and the
    // programming error will be more obvious to understand.
    if (g.OpenPopupStack[current_stack_size].PopupId == id &&
        g.OpenPopupStack[current_stack_size].OpenFrameCount ==
            g.FrameCount - 1) {
      g.OpenPopupStack[current_stack_size].OpenFrameCount =
          popup_ref.OpenFrameCount;
    } else {
      // Close child popups if any, then flag popup for open/reopen
      ClosePopupToLevel(current_stack_size, false);
      g.OpenPopupStack.push_back(popup_ref);
    }

    // When reopening a popup we first refocus its parent, otherwise if its
    // parent is itself a popup it would get closed by ClosePopupsOverWindow().
    // This is equivalent to what ClosePopupToLevel() does.
    // if (g.OpenPopupStack[current_stack_size].PopupId == id)
    //    FocusWindow(parent_window);
  }
}

// When popups are stacked, clicking on a lower level popups puts focus back to
// it and close popups above it. This function closes any popups that are over
// 'ref_window'.
inline void
Gui::ClosePopupsOverWindow(Window *ref_window,
                           bool restore_focus_to_window_under_popup) {
  Context &g = *GGui;
  if (g.OpenPopupStack.Size == 0)
    return;

  // Don't close our own child popup windows.
  int popup_count_to_keep = 0;
  if (ref_window) {
    // Find the highest popup which is a descendant of the reference window
    // (generally reference window = NavWindow)
    for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++) {
      PopupData &popup = g.OpenPopupStack[popup_count_to_keep];
      if (!popup.Window)
        continue;
      GUI_ASSERT((popup.Window->Flags & WindowFlags_Popup) != 0);
      if (popup.Window->Flags & WindowFlags_ChildWindow)
        continue;

      // Trim the stack unless the popup is a direct parent of the reference
      // window (the reference window is often the NavWindow)
      // - With this stack of window, clicking/focusing Popup1 will close Popup2
      // and Popup3:
      //     Window -> Popup1 -> Popup2 -> Popup3
      // - Each popups may contain child windows, which is why we compare
      // ->RootWindow!
      //     Window -> Popup1 -> Popup1_Child -> Popup2 -> Popup2_Child
      bool ref_window_is_descendent_of_popup = false;
      for (int n = popup_count_to_keep; n < g.OpenPopupStack.Size; n++)
        if (Window *popup_window = g.OpenPopupStack[n].Window)
          if (IsWindowWithinBeginStackOf(ref_window, popup_window)) {
            ref_window_is_descendent_of_popup = true;
            break;
          }
      if (!ref_window_is_descendent_of_popup)
        break;
    }
  }
  if (popup_count_to_keep <
      g.OpenPopupStack.Size) // This test is not required but it allows to set a
                             // convenient breakpoint on the statement below
  {
    GUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\")\n",
                        ref_window ? ref_window->Name : "<NULL>");
    ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
  }
}

inline void Gui::ClosePopupToLevel(int remaining,
                                   bool restore_focus_to_window_under_popup) {
  Context &g = *GGui;
  GUI_DEBUG_LOG_POPUP(
      "[popup] ClosePopupToLevel(%d), restore_focus_to_window_under_popup=%d\n",
      remaining, restore_focus_to_window_under_popup);
  GUI_ASSERT(remaining >= 0 && remaining < g.OpenPopupStack.Size);

  // Trim open popup stack
  Window *popup_window = g.OpenPopupStack[remaining].Window;
  Window *popup_backup_nav_window = g.OpenPopupStack[remaining].BackupNavWindow;
  g.OpenPopupStack.resize(remaining);

  if (restore_focus_to_window_under_popup) {
    Window *focus_window =
        (popup_window && popup_window->Flags & WindowFlags_ChildMenu)
            ? popup_window->ParentWindow
            : popup_backup_nav_window;
    if (focus_window && !focus_window->WasActive && popup_window)
      FocusTopMostWindowUnderOne(
          popup_window, NULL, NULL,
          FocusRequestFlags_RestoreFocusedChild); // Fallback
    else
      FocusWindow(focus_window, (g.NavLayer == NavLayer_Main)
                                    ? FocusRequestFlags_RestoreFocusedChild
                                    : FocusRequestFlags_None);
  }
}

// Close the popup we have begin-ed into.
inline void Gui::CloseCurrentPopup() {
  Context &g = *GGui;
  int popup_idx = g.BeginPopupStack.Size - 1;
  if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size ||
      g.BeginPopupStack[popup_idx].PopupId !=
          g.OpenPopupStack[popup_idx].PopupId)
    return;

  // Closing a menu closes its top-most parent popup (unless a modal)
  while (popup_idx > 0) {
    Window *popup_window = g.OpenPopupStack[popup_idx].Window;
    Window *parent_popup_window = g.OpenPopupStack[popup_idx - 1].Window;
    bool close_parent = false;
    if (popup_window && (popup_window->Flags & WindowFlags_ChildMenu))
      if (parent_popup_window &&
          !(parent_popup_window->Flags & WindowFlags_MenuBar))
        close_parent = true;
    if (!close_parent)
      break;
    popup_idx--;
  }
  GUI_DEBUG_LOG_POPUP("[popup] CloseCurrentPopup %d -> %d\n",
                      g.BeginPopupStack.Size - 1, popup_idx);
  ClosePopupToLevel(popup_idx, true);

  // A common pattern is to close a popup when selecting a menu item/selectable
  // that will open another window. To improve this usage pattern, we avoid nav
  // highlight for a single frame in the parent window. Similarly, we could
  // avoid mouse hover highlight in this window but it is less visually
  // problematic.
  if (Window *window = g.NavWindow)
    window->DC.NavHideHighlightOneFrame = true;
}

// Attention! BeginPopup() adds default flags which BeginPopupEx()!

inline bool Gui::BeginPopup(const char *str_id, WindowFlags flags) {
  Context &g = *GGui;
  if (g.OpenPopupStack.Size <=
      g.BeginPopupStack.Size) // Early out for performance
  {
    g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume
                                   // those values
    return false;
  }
  flags |= WindowFlags_AlwaysAutoResize | WindowFlags_NoTitleBar |
           WindowFlags_NoSavedSettings;
  ID id = g.CurrentWindow->GetID(str_id);
  return BeginPopupEx(id, flags);
}

// If 'p_open' is specified for a modal popup window, the popup will have a
// regular close button which will close the popup. Note that popup visibility
// status is owned by Dear Gui (and manipulated with e.g. OpenPopup).
// - *p_open set back to false in BeginPopupModal() when popup is not open.
// - if you set *p_open to false before calling BeginPopupModal(), it will close
// the popup.
inline bool Gui::BeginPopupModal(const char *name, bool *p_open,
                                 WindowFlags flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  const ID id = window->GetID(name);
  if (!IsPopupOpen(id, PopupFlags_None)) {
    g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume
                                   // those values
    if (p_open && *p_open)
      *p_open = false;
    return false;
  }

  // Center modal windows by default for increased visibility
  // (this won't really last as settings will kick in, and is mostly for
  // backward compatibility. user may do the same themselves)
  // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the
  // upcoming window.
  if ((g.NextWindowData.Flags & NextWindowDataFlags_HasPos) == 0) {
    const Viewport *viewport = GetMainViewport();
    SetNextWindowPos(viewport->GetCenter(), Cond_FirstUseEver,
                     Vec2(0.5f, 0.5f));
  }

  flags |= WindowFlags_Popup | WindowFlags_Modal | WindowFlags_NoCollapse;
  const bool is_open = Begin(name, p_open, flags);
  if (!is_open ||
      (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is
                            // completely clipped (e.g. zero size display)
  {
    EndPopup();
    if (is_open)
      ClosePopupToLevel(g.BeginPopupStack.Size, true);
    return false;
  }
  return is_open;
}

inline void Gui::EndPopup() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_ASSERT(window->Flags &
             WindowFlags_Popup); // Mismatched BeginPopup()/EndPopup() calls
  GUI_ASSERT(g.BeginPopupStack.Size > 0);

  // Make all menus and popups wrap around for now, may need to expose that
  // policy (e.g. focus scope could include wrap/loop policy flags used by new
  // move requests)
  if (g.NavWindow == window)
    NavMoveRequestTryWrapping(window, NavMoveFlags_LoopY);

  // Child-popups don't need to be laid out
  GUI_ASSERT(g.WithinEndChild == false);
  if (window->Flags & WindowFlags_ChildWindow)
    g.WithinEndChild = true;
  End();
  g.WithinEndChild = false;
}

// Helper to open a popup if mouse button is released over the item
// - This is essentially the same as BeginPopupContextItem() but without the
// trailing BeginPopup()
inline void Gui::OpenPopupOnItemClick(const char *str_id,
                                      PopupFlags popup_flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  int mouse_button = (popup_flags & PopupFlags_MouseButtonMask_);
  if (IsMouseReleased(mouse_button) &&
      IsItemHovered(HoveredFlags_AllowWhenBlockedByPopup)) {
    ID id = str_id ? window->GetID(str_id)
                   : g.LastItemData.ID; // If user hasn't passed an ID, we can
                                        // use the LastItemID. Using LastItemID
                                        // as a Popup ID won't conflict!
    GUI_ASSERT(id != 0); // You cannot pass a NULL str_id if the last item has
                         // no identifier (e.g. a Text() item)
    OpenPopupEx(id, popup_flags);
  }
}

// This is a helper to handle the simplest case of associating one named popup
// to one given widget.
// - To create a popup associated to the last item, you generally want to pass a
// NULL value to str_id.
// - To create a popup with a specific identifier, pass it in str_id.
//    - This is useful when using using BeginPopupContextItem() on an item which
//    doesn't have an identifier, e.g. a Text() call.
//    - This is useful when multiple code locations may want to manipulate/open
//    the same popup, given an explicit id.
// - You may want to handle the whole on user side if you have specific needs
// (e.g. tweaking IsItemHovered() parameters).
//   This is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       OpenPopupOnItemClick(str_id, PopupFlags_MouseButtonRight);
//       return BeginPopup(id);
//   Which is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       if (IsItemHovered() && IsMouseReleased(MouseButton_Right))
//           OpenPopup(id);
//       return BeginPopup(id);
//   The main difference being that this is tweaked to avoid computing the ID
//   twice.
inline bool Gui::BeginPopupContextItem(const char *str_id,
                                       PopupFlags popup_flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return false;
  ID id =
      str_id
          ? window->GetID(str_id)
          : g.LastItemData
                .ID; // If user hasn't passed an ID, we can use the LastItemID.
                     // Using LastItemID as a Popup ID won't conflict!
  GUI_ASSERT(id != 0); // You cannot pass a NULL str_id if the last item has no
                       // identifier (e.g. a Text() item)
  int mouse_button = (popup_flags & PopupFlags_MouseButtonMask_);
  if (IsMouseReleased(mouse_button) &&
      IsItemHovered(HoveredFlags_AllowWhenBlockedByPopup))
    OpenPopupEx(id, popup_flags);
  return BeginPopupEx(id, WindowFlags_AlwaysAutoResize |
                              WindowFlags_NoTitleBar |
                              WindowFlags_NoSavedSettings);
}

inline bool Gui::BeginPopupContextWindow(const char *str_id,
                                         PopupFlags popup_flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (!str_id)
    str_id = "window_context";
  ID id = window->GetID(str_id);
  int mouse_button = (popup_flags & PopupFlags_MouseButtonMask_);
  if (IsMouseReleased(mouse_button) &&
      IsWindowHovered(HoveredFlags_AllowWhenBlockedByPopup))
    if (!(popup_flags & PopupFlags_NoOpenOverItems) || !IsAnyItemHovered())
      OpenPopupEx(id, popup_flags);
  return BeginPopupEx(id, WindowFlags_AlwaysAutoResize |
                              WindowFlags_NoTitleBar |
                              WindowFlags_NoSavedSettings);
}

inline bool Gui::BeginPopupContextVoid(const char *str_id,
                                       PopupFlags popup_flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (!str_id)
    str_id = "void_context";
  ID id = window->GetID(str_id);
  int mouse_button = (popup_flags & PopupFlags_MouseButtonMask_);
  if (IsMouseReleased(mouse_button) && !IsWindowHovered(HoveredFlags_AnyWindow))
    if (GetTopMostPopupModal() == NULL)
      OpenPopupEx(id, popup_flags);
  return BeginPopupEx(id, WindowFlags_AlwaysAutoResize |
                              WindowFlags_NoTitleBar |
                              WindowFlags_NoSavedSettings);
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around
// the mouse cursor which we want to avoid. for popups it's a small point around
// the cursor.) r_outer = the visible area rectangle, minus safe area padding.
// If our popup size won't fit because of safe area padding we ignore it.
// (r_outer is usually equivalent to the viewport rectangle minus padding, but
// when multi-viewports are enabled and monitor
//  information are available, it may represent the entire platform monitor from
//  the frame of reference of the current viewport. this allows us to have
//  tooltips/popups displayed out of the parent viewport.)
inline Vec2 Gui::FindBestWindowPosForPopupEx(const Vec2 &ref_pos,
                                             const Vec2 &size, Dir *last_dir,
                                             const Rect &r_outer,
                                             const Rect &r_avoid,
                                             PopupPositionPolicy policy) {
  Vec2 base_pos_clamped =
      Clamp(ref_pos, r_outer.Min, Subtract(r_outer.Max, size));
  // GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max,
  // GUI_COL32(255,0,0,255)); GetForegroundDrawList()->AddRect(r_outer.Min,
  // r_outer.Max, GUI_COL32(0,255,0,255));

  // Combo Box policy (we want a connecting edge)
  if (policy == PopupPositionPolicy_ComboBox) {
    const Dir dir_prefered_order[Dir_COUNT] = {Dir_Down, Dir_Right, Dir_Left,
                                               Dir_Up};
    for (int n = (*last_dir != Dir_None) ? -1 : 0; n < Dir_COUNT; n++) {
      const Dir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
      if (n != -1 && dir == *last_dir) // Already tried this direction?
        continue;
      Vec2 pos;
      if (dir == Dir_Down)
        pos = Vec2(r_avoid.Min.x,
                   r_avoid.Max.y); // Below, Toward Right (default)
      if (dir == Dir_Right)
        pos = Vec2(r_avoid.Min.x,
                   r_avoid.Min.y - size.y); // Above, Toward Right
      if (dir == Dir_Left)
        pos = Vec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left
      if (dir == Dir_Up)
        pos = Vec2(r_avoid.Max.x - size.x,
                   r_avoid.Min.y - size.y); // Above, Toward Left
      if (!r_outer.Contains(Rect(pos, Add(pos, size))))
        continue;
      *last_dir = dir;
      return pos;
    }
  }

  // Tooltip and Default popup policy
  // (Always first try the direction we used on the last frame, if any)
  if (policy == PopupPositionPolicy_Tooltip ||
      policy == PopupPositionPolicy_Default) {
    const Dir dir_prefered_order[Dir_COUNT] = {Dir_Right, Dir_Down, Dir_Up,
                                               Dir_Left};
    for (int n = (*last_dir != Dir_None) ? -1 : 0; n < Dir_COUNT; n++) {
      const Dir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
      if (n != -1 && dir == *last_dir) // Already tried this direction?
        continue;

      const float avail_w = (dir == Dir_Left ? r_avoid.Min.x : r_outer.Max.x) -
                            (dir == Dir_Right ? r_avoid.Max.x : r_outer.Min.x);
      const float avail_h = (dir == Dir_Up ? r_avoid.Min.y : r_outer.Max.y) -
                            (dir == Dir_Down ? r_avoid.Max.y : r_outer.Min.y);

      // If there's not enough room on one axis, there's no point in positioning
      // on a side on this axis (e.g. when not enough width, use a top/bottom
      // position to maximize available width)
      if (avail_w < size.x && (dir == Dir_Left || dir == Dir_Right))
        continue;
      if (avail_h < size.y && (dir == Dir_Up || dir == Dir_Down))
        continue;

      Vec2 pos;
      pos.x = (dir == Dir_Left)    ? r_avoid.Min.x - size.x
              : (dir == Dir_Right) ? r_avoid.Max.x
                                   : base_pos_clamped.x;
      pos.y = (dir == Dir_Up)     ? r_avoid.Min.y - size.y
              : (dir == Dir_Down) ? r_avoid.Max.y
                                  : base_pos_clamped.y;

      // Clamp top-left corner of popup
      pos.x = Max(pos.x, r_outer.Min.x);
      pos.y = Max(pos.y, r_outer.Min.y);

      *last_dir = dir;
      return pos;
    }
  }

  // Fallback when not enough room:
  *last_dir = Dir_None;

  // For tooltip we prefer avoiding the cursor at all cost even if it means that
  // part of the tooltip won't be visible.
  if (policy == PopupPositionPolicy_Tooltip)
    return Add(ref_pos, Vec2(2, 2));

  // Otherwise try to keep within display
  Vec2 pos = ref_pos;
  pos.x = Max(Min(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
  pos.y = Max(Min(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
  return pos;
}

// Note that this is used for popups, which can overlap the non work-area of
// individual viewports.

inline Vec2 Gui::FindBestWindowPosForPopup(Window *window) {
  Context &g = *GGui;

  Rect r_outer = GetPopupAllowedExtentRect(window);
  if (window->Flags & WindowFlags_ChildMenu) {
    // Child menus typically request _any_ position within the parent menu item,
    // and then we move the new menu outside the parent bounds. This is how we
    // end up with child menus appearing (most-commonly) on the right of the
    // parent menu.
    GUI_ASSERT(g.CurrentWindow == window);
    Window *parent_window =
        g.CurrentWindowStack[g.CurrentWindowStack.Size - 2].Window;
    float horizontal_overlap =
        g.Style.ItemInnerSpacing
            .x; // We want some overlap to convey the relative depth of each
                // menu (currently the amount of overlap is hard-coded to
                // style.ItemSpacing.x).
    Rect r_avoid;
    if (parent_window->DC.MenuBarAppending)
      r_avoid = Rect(
          -FLT_MAX, parent_window->ClipRect.Min.y, FLT_MAX,
          parent_window->ClipRect.Max
              .y); // Avoid parent menu-bar. If we wanted multi-line menu-bar,
                   // we may instead want to have the calling window setup e.g.
                   // a NextWindowData.PosConstraintAvoidRect field
    else
      r_avoid = Rect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX,
                     parent_window->Pos.x + parent_window->Size.x -
                         horizontal_overlap - parent_window->ScrollbarSizes.x,
                     FLT_MAX);
    return FindBestWindowPosForPopupEx(window->Pos, window->Size,
                                       &window->AutoPosLastDirection, r_outer,
                                       r_avoid, PopupPositionPolicy_Default);
  }
  if (window->Flags & WindowFlags_Popup) {
    return FindBestWindowPosForPopupEx(
        window->Pos, window->Size, &window->AutoPosLastDirection, r_outer,
        Rect(window->Pos, window->Pos),
        PopupPositionPolicy_Default); // Ideally we'd disable r_avoid here
  }
  if (window->Flags & WindowFlags_Tooltip) {
    // Position tooltip (always follows mouse + clamp within outer boundaries)
    // Note that drag and drop tooltips are NOT using this path:
    // BeginTooltipEx() manually sets their position. In theory we could handle
    // both cases in same location, but requires a bit of shuffling as drag and
    // drop tooltips are calling SetWindowPos() leading to
    // 'window_pos_set_by_api' being set in Begin()
    GUI_ASSERT(g.CurrentWindow == window);
    const float scale = g.Style.MouseCursorScale;
    const Vec2 ref_pos = NavCalcPreferredRefPos();
    const Vec2 tooltip_pos =
        Add(ref_pos, Multiply(TOOLTIP_DEFAULT_OFFSET, scale));
    Rect r_avoid;
    if (!g.NavDisableHighlight && g.NavDisableMouseHover &&
        !(g.IO.ConfigFlags & ConfigFlags_NavEnableSetMousePos))
      r_avoid =
          Rect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
    else
      r_avoid = Rect(
          ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * scale,
          ref_pos.y +
              24 * scale); // FIXME: Hard-coded based on mouse cursor shape
                           // expectation. Exact dimension not very important.
    // GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, GUI_COL32(255,
    // 0, 255, 255));
    return FindBestWindowPosForPopupEx(tooltip_pos, window->Size,
                                       &window->AutoPosLastDirection, r_outer,
                                       r_avoid, PopupPositionPolicy_Tooltip);
  }
  GUI_ASSERT(0);
  return window->Pos;
}

//-----------------------------------------------------------------------------
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
//-----------------------------------------------------------------------------

// FIXME-NAV: The existence of SetNavID vs SetFocusID vs FocusWindow() needs to
// be clarified/reworked. In our terminology those should be interchangeable,
// yet right now this is super confusing. Those two functions are merely a
// legacy artifact, so at minimum naming should be clarified.

inline void Gui::SetNavWindow(Window *window) {
  Context &g = *GGui;
  if (g.NavWindow != window) {
    GUI_DEBUG_LOG_FOCUS("[focus] SetNavWindow(\"%s\")\n",
                        window ? window->Name : "<NULL>");
    g.NavWindow = window;
    g.NavLastValidSelectionUserData = SelectionUserData_Invalid;
  }
  g.NavInitRequest = g.NavMoveSubmitted = g.NavMoveScoringItems = false;
  NavUpdateAnyRequestFlag();
}

inline void Gui::SetNavID(ID id, NavLayer nav_layer, ID focus_scope_id,
                          const Rect &rect_rel) {
  Context &g = *GGui;
  GUI_ASSERT(g.NavWindow != NULL);
  GUI_ASSERT(nav_layer == NavLayer_Main || nav_layer == NavLayer_Menu);
  g.NavId = id;
  g.NavLayer = nav_layer;
  g.NavFocusScopeId = focus_scope_id;
  g.NavWindow->NavLastIds[nav_layer] = id;
  g.NavWindow->NavRectRel[nav_layer] = rect_rel;

  // Clear preferred scoring position (NavMoveRequestApplyResult() will tend to
  // restore it)
  NavClearPreferredPosForAxis(Axis_X);
  NavClearPreferredPosForAxis(Axis_Y);
}

inline void Gui::SetFocusID(ID id, Window *window) {
  Context &g = *GGui;
  GUI_ASSERT(id != 0);

  if (g.NavWindow != window)
    SetNavWindow(window);

  // Assume that SetFocusID() is called in the context where its
  // window->DC.NavLayerCurrent and g.CurrentFocusScopeId are valid. Note that
  // window may be != g.CurrentWindow (e.g. SetFocusID call in InputTextEx for
  // multi-line text)
  const NavLayer nav_layer = window->DC.NavLayerCurrent;
  g.NavId = id;
  g.NavLayer = nav_layer;
  g.NavFocusScopeId = g.CurrentFocusScopeId;
  window->NavLastIds[nav_layer] = id;
  if (g.LastItemData.ID == id)
    window->NavRectRel[nav_layer] =
        WindowRectAbsToRel(window, g.LastItemData.NavRect);

  if (g.ActiveIdSource == InputSource_Keyboard ||
      g.ActiveIdSource == InputSource_Gamepad)
    g.NavDisableMouseHover = true;
  else
    g.NavDisableHighlight = true;

  // Clear preferred scoring position (NavMoveRequestApplyResult() will tend to
  // restore it)
  NavClearPreferredPosForAxis(Axis_X);
  NavClearPreferredPosForAxis(Axis_Y);
}

static Dir GetDirQuadrantFromDelta(float dx, float dy) {
  if (Fabs(dx) > Fabs(dy))
    return (dx > 0.0f) ? Dir_Right : Dir_Left;
  return (dy > 0.0f) ? Dir_Down : Dir_Up;
}

static float inline NavScoreItemDistInterval(float cand_min, float cand_max,
                                             float curr_min, float curr_max) {
  if (cand_max < curr_min)
    return cand_max - curr_min;
  if (curr_max < cand_min)
    return cand_min - curr_max;
  return 0.0f;
}

// Scoring function for gamepad/keyboard directional navigation. Based on
// https://gist.github.com/rygorous/6981057
static bool Gui::NavScoreItem(NavItemData *result) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (g.NavLayer != window->DC.NavLayerCurrent)
    return false;

  // FIXME: Those are not good variables names
  Rect cand = g.LastItemData.NavRect; // Current item nav rectangle
  const Rect curr =
      g.NavScoringRect; // Current modified source rect (NB: we've applied Max.x
                        // = Min.x in NavUpdate() to inhibit the effect of
                        // having varied item width)
  g.NavScoringDebugCount++;

  // When entering through a NavFlattened border, we consider child window items
  // as fully clipped for scoring
  if (window->ParentWindow == g.NavWindow) {
    GUI_ASSERT((window->Flags | g.NavWindow->Flags) & WindowFlags_NavFlattened);
    if (!window->ClipRect.Overlaps(cand))
      return false;
    cand.ClipWithFull(
        window->ClipRect); // This allows the scored item to not overlap other
                           // candidates in the parent window
  }

  // Compute distance between boxes
  // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
  float dbx =
      NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
  float dby = NavScoreItemDistInterval(
      Lerp(cand.Min.y, cand.Max.y, 0.2f), Lerp(cand.Min.y, cand.Max.y, 0.8f),
      Lerp(curr.Min.y, curr.Max.y, 0.2f),
      Lerp(curr.Min.y, curr.Max.y,
           0.8f)); // Scale down on Y to keep using box-distance for
                   // vertically touching items
  if (dby != 0.0f && dbx != 0.0f)
    dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
  float dist_box = Fabs(dbx) + Fabs(dby);

  // Compute distance between centers (this is off by a factor of 2, but we only
  // compare center distances with each other so it doesn't matter)
  float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
  float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
  float dist_center =
      Fabs(dcx) +
      Fabs(dcy); // L1 metric (need this for our connectedness guarantee)

  // Determine which quadrant of 'curr' our candidate item 'cand' lies in based
  // on distance
  Dir quadrant;
  float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
  if (dbx != 0.0f || dby != 0.0f) {
    // For non-overlapping boxes, use distance between boxes
    dax = dbx;
    day = dby;
    dist_axial = dist_box;
    quadrant = GetDirQuadrantFromDelta(dbx, dby);
  } else if (dcx != 0.0f || dcy != 0.0f) {
    // For overlapping boxes with different centers, use distance between
    // centers
    dax = dcx;
    day = dcy;
    dist_axial = dist_center;
    quadrant = GetDirQuadrantFromDelta(dcx, dcy);
  } else {
    // Degenerate case: two overlapping buttons with same center, break ties
    // arbitrarily (note that LastItemId here is really the _previous_ item
    // order, but it doesn't matter)
    quadrant = (g.LastItemData.ID < g.NavId) ? Dir_Left : Dir_Right;
  }

  const Dir move_dir = g.NavMoveDir;
#if GUI_DEBUG_NAV_SCORING
  char buf[200];
  if (g.IO.KeyCtrl) // Hold CTRL to preview score in matching quadrant.
                    // CTRL+Arrow to rotate.
  {
    if (quadrant == move_dir) {
      FormatString(buf, GUI_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
      DrawList *draw_list = GetForegroundDrawList(window);
      draw_list->AddRectFilled(cand.Min, cand.Max, GUI_COL32(255, 0, 0, 80));
      draw_list->AddRectFilled(cand.Min, cand.Min + CalcTextSize(buf),
                               GUI_COL32(255, 0, 0, 200));
      draw_list->AddText(cand.Min, GUI_COL32(255, 255, 255, 255), buf);
    }
  }
  const bool debug_hovering = IsMouseHoveringRect(cand.Min, cand.Max);
  const bool debug_tty = (g.IO.KeyCtrl && IsKeyPressed(Key_Space));
  if (debug_hovering || debug_tty) {
    FormatString(buf, GUI_ARRAYSIZE(buf),
                 "d-box    (%7.3f,%7.3f) -> %7.3f\nd-center (%7.3f,%7.3f) -> "
                 "%7.3f\nd-axial  (%7.3f,%7.3f) -> %7.3f\nnav %c, quadrant %c",
                 dbx, dby, dist_box, dcx, dcy, dist_center, dax, day,
                 dist_axial, "-WENS"[move_dir + 1], "-WENS"[quadrant + 1]);
    if (debug_hovering) {
      DrawList *draw_list = GetForegroundDrawList(window);
      draw_list->AddRect(curr.Min, curr.Max, GUI_COL32(255, 200, 0, 100));
      draw_list->AddRect(cand.Min, cand.Max, GUI_COL32(255, 255, 0, 200));
      draw_list->AddRectFilled(cand.Max - Vec2(4, 4),
                               cand.Max + CalcTextSize(buf) + Vec2(4, 4),
                               GUI_COL32(40, 0, 0, 200));
      draw_list->AddText(cand.Max, ~0U, buf);
    }
    if (debug_tty) {
      GUI_DEBUG_LOG_NAV("id 0x%08X\n%s\n", g.LastItemData.ID, buf);
    }
  }
#endif

  // Is it in the quadrant we're interested in moving to?
  bool new_best = false;
  if (quadrant == move_dir) {
    // Does it beat the current best candidate?
    if (dist_box < result->DistBox) {
      result->DistBox = dist_box;
      result->DistCenter = dist_center;
      return true;
    }
    if (dist_box == result->DistBox) {
      // Try using distance between center points to break ties
      if (dist_center < result->DistCenter) {
        result->DistCenter = dist_center;
        new_best = true;
      } else if (dist_center == result->DistCenter) {
        // Still tied! we need to be extra-careful to make sure everything gets
        // linked properly. We consistently break ties by symbolically moving
        // "later" items (with higher index) to the right/downwards by an
        // infinitesimal amount since we the current "best" button already (so
        // it must have a lower index), this is fairly easy. This rule ensures
        // that all buttons with dx==dy==0 will end up being linked in order of
        // appearance along the x axis.
        if (((move_dir == Dir_Up || move_dir == Dir_Down) ? dby : dbx) <
            0.0f) // moving bj to the right/down decreases distance
          new_best = true;
      }
    }
  }

  // Axial check: if 'curr' has no link at all in some direction and 'cand' lies
  // roughly in that direction, add a tentative link. This will only be kept if
  // no "real" matches are found, so it only augments the graph produced by the
  // above method using extra links. (important, since it doesn't guarantee
  // strong connectedness) This is just to avoid buttons having no links in a
  // particular direction when there's a suitable neighbor. you get good graphs
  // without this too. 2017/09/29: FIXME: This now currently only enabled inside
  // menu bars, ideally we'd disable it everywhere. Menus in particular need to
  // catch failure. For general navigation it feels awkward. Disabling it may
  // lead to disconnected graphs when nodes are very spaced out on different
  // axis. Perhaps consider offering this as an option?
  if (result->DistBox == FLT_MAX &&
      dist_axial < result->DistAxial) // Check axial match
    if (g.NavLayer == NavLayer_Menu &&
        !(g.NavWindow->Flags & WindowFlags_ChildMenu))
      if ((move_dir == Dir_Left && dax < 0.0f) ||
          (move_dir == Dir_Right && dax > 0.0f) ||
          (move_dir == Dir_Up && day < 0.0f) ||
          (move_dir == Dir_Down && day > 0.0f)) {
        result->DistAxial = dist_axial;
        new_best = true;
      }

  return new_best;
}

static void Gui::NavApplyItemToResult(NavItemData *result) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  result->Window = window;
  result->ID = g.LastItemData.ID;
  result->FocusScopeId = g.CurrentFocusScopeId;
  result->InFlags = g.LastItemData.InFlags;
  result->RectRel = WindowRectAbsToRel(window, g.LastItemData.NavRect);
  if (result->InFlags & ItemFlags_HasSelectionUserData) {
    GUI_ASSERT(g.NextItemData.SelectionUserData != SelectionUserData_Invalid);
    result->SelectionUserData =
        g.NextItemData
            .SelectionUserData; // INTENTIONAL: At this point this field is not
                                // cleared in NextItemData. Avoid unnecessary
                                // copy to LastItemData.
  }
}

// True when current work location may be scrolled horizontally when moving left
// / right. This is generally always true UNLESS within a column. We don't have
// a vertical equivalent.

// We get there when either NavId == id, or when g.NavAnyRequest is set (which
// is updated by NavUpdateAnyRequestFlag above) This is called after
// LastItemData is set, but NextItemData is also still valid.
static void Gui::NavProcessItem() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  const ID id = g.LastItemData.ID;
  const ItemFlags item_flags = g.LastItemData.InFlags;

  // When inside a container that isn't scrollable with Left<>Right, clip
  // NavRect accordingly (#2221)
  if (window->DC.NavIsScrollPushableX == false) {
    g.LastItemData.NavRect.Min.x =
        Clamp(g.LastItemData.NavRect.Min.x, window->ClipRect.Min.x,
              window->ClipRect.Max.x);
    g.LastItemData.NavRect.Max.x =
        Clamp(g.LastItemData.NavRect.Max.x, window->ClipRect.Min.x,
              window->ClipRect.Max.x);
  }
  const Rect nav_bb = g.LastItemData.NavRect;

  // Process Init Request
  if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent &&
      (item_flags & ItemFlags_Disabled) == 0) {
    // Even if 'ItemFlags_NoNavDefaultFocus' is on (typically
    // collapse/close button) we record the first ResultId so they can be used
    // as a fallback
    const bool candidate_for_nav_default_focus =
        (item_flags & ItemFlags_NoNavDefaultFocus) == 0;
    if (candidate_for_nav_default_focus || g.NavInitResult.ID == 0) {
      NavApplyItemToResult(&g.NavInitResult);
    }
    if (candidate_for_nav_default_focus) {
      g.NavInitRequest = false; // Found a match, clear request
      NavUpdateAnyRequestFlag();
    }
  }

  // Process Move Request (scoring for navigation)
  // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect
  // + scoring from a rect wrapped according to current wrapping policy)
  if (g.NavMoveScoringItems && (item_flags & ItemFlags_Disabled) == 0) {
    const bool is_tabbing = (g.NavMoveFlags & NavMoveFlags_IsTabbing) != 0;
    if (is_tabbing) {
      NavProcessItemForTabbingRequest(id, item_flags, g.NavMoveFlags);
    } else if (g.NavId != id ||
               (g.NavMoveFlags & NavMoveFlags_AllowCurrentNavId)) {
      NavItemData *result = (window == g.NavWindow) ? &g.NavMoveResultLocal
                                                    : &g.NavMoveResultOther;
      if (NavScoreItem(result))
        NavApplyItemToResult(result);

      // Features like PageUp/PageDown need to maintain a separate score for the
      // visible set of items.
      const float VISIBLE_RATIO = 0.70f;
      if ((g.NavMoveFlags & NavMoveFlags_AlsoScoreVisibleSet) &&
          window->ClipRect.Overlaps(nav_bb))
        if (Clamp(nav_bb.Max.y, window->ClipRect.Min.y,
                  window->ClipRect.Max.y) -
                Clamp(nav_bb.Min.y, window->ClipRect.Min.y,
                      window->ClipRect.Max.y) >=
            (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
          if (NavScoreItem(&g.NavMoveResultLocalVisible))
            NavApplyItemToResult(&g.NavMoveResultLocalVisible);
    }
  }

  // Update information for currently focused/navigated item
  if (g.NavId == id) {
    if (g.NavWindow != window)
      SetNavWindow(
          window); // Always refresh g.NavWindow, because some operations such
                   // as FocusItem() may not have a window.
    g.NavLayer = window->DC.NavLayerCurrent;
    g.NavFocusScopeId = g.CurrentFocusScopeId;
    g.NavIdIsAlive = true;
    if (g.LastItemData.InFlags & ItemFlags_HasSelectionUserData) {
      GUI_ASSERT(g.NextItemData.SelectionUserData != SelectionUserData_Invalid);
      g.NavLastValidSelectionUserData =
          g.NextItemData
              .SelectionUserData; // INTENTIONAL: At this point this field is
                                  // not cleared in NextItemData. Avoid
                                  // unnecessary copy to LastItemData.
    }
    window->NavRectRel[window->DC.NavLayerCurrent] = WindowRectAbsToRel(
        window,
        nav_bb); // Store item bounding box (relative to window position)
  }
}

// Handle "scoring" of an item for a tabbing/focusing request initiated by
// NavUpdateCreateTabbingRequest(). Note that SetKeyboardFocusHere() API calls
// are considered tabbing requests!
// - Case 1: no nav/active id:    set result to first eligible item, stop
// storing.
// - Case 2: tab forward:         on ref id set counter, on counter elapse store
// result
// - Case 3: tab forward wrap:    set result to first eligible item
// (preemptively), on ref id set counter, on next frame if counter hasn't
// elapsed store result. // FIXME-TABBING: Could be done as a next-frame
// forwarded request
// - Case 4: tab backward:        store all results, on ref id pick prev, stop
// storing
// - Case 5: tab backward wrap:   store all results, on ref id if no result keep
// storing until last // FIXME-TABBING: Could be done as next-frame forwarded
// requested
void Gui::NavProcessItemForTabbingRequest(ID id, ItemFlags item_flags,
                                          NavMoveFlags move_flags) {
  Context &g = *GGui;

  if ((move_flags & NavMoveFlags_FocusApi) == 0)
    if (g.NavLayer != g.CurrentWindow->DC.NavLayerCurrent)
      return;
  if (g.NavFocusScopeId != g.CurrentFocusScopeId)
    return;

  // - Can always land on an item when using API call.
  // - Tabbing with _NavEnableKeyboard (space/enter/arrows): goes through every
  // item.
  // - Tabbing without _NavEnableKeyboard: goes through inputable items only.
  bool can_stop;
  if (move_flags & NavMoveFlags_FocusApi)
    can_stop = true;
  else
    can_stop = (item_flags & ItemFlags_NoTabStop) == 0 &&
               ((g.IO.ConfigFlags & ConfigFlags_NavEnableKeyboard) ||
                (item_flags & ItemFlags_Inputable));

  // Always store in NavMoveResultLocal (unlike directional request which uses
  // NavMoveResultOther on sibling/flattened windows)
  NavItemData *result = &g.NavMoveResultLocal;
  if (g.NavTabbingDir == +1) {
    // Tab Forward or SetKeyboardFocusHere() with >= 0
    if (can_stop && g.NavTabbingResultFirst.ID == 0)
      NavApplyItemToResult(&g.NavTabbingResultFirst);
    if (can_stop && g.NavTabbingCounter > 0 && --g.NavTabbingCounter == 0)
      NavMoveRequestResolveWithLastItem(result);
    else if (g.NavId == id)
      g.NavTabbingCounter = 1;
  } else if (g.NavTabbingDir == -1) {
    // Tab Backward
    if (g.NavId == id) {
      if (result->ID) {
        g.NavMoveScoringItems = false;
        NavUpdateAnyRequestFlag();
      }
    } else if (can_stop) {
      // Keep applying until reaching NavId
      NavApplyItemToResult(result);
    }
  } else if (g.NavTabbingDir == 0) {
    if (can_stop && g.NavId == id)
      NavMoveRequestResolveWithLastItem(result);
    if (can_stop && g.NavTabbingResultFirst.ID == 0) // Tab init
      NavApplyItemToResult(&g.NavTabbingResultFirst);
  }
}

// FIXME: ScoringRect is not set
inline void Gui::NavMoveRequestSubmit(Dir move_dir, Dir clip_dir,
                                      NavMoveFlags move_flags,
                                      ScrollFlags scroll_flags) {
  Context &g = *GGui;
  GUI_ASSERT(g.NavWindow != NULL);

  if (move_flags & NavMoveFlags_IsTabbing)
    move_flags |= NavMoveFlags_AllowCurrentNavId;

  g.NavMoveSubmitted = g.NavMoveScoringItems = true;
  g.NavMoveDir = move_dir;
  g.NavMoveDirForDebug = move_dir;
  g.NavMoveClipDir = clip_dir;
  g.NavMoveFlags = move_flags;
  g.NavMoveScrollFlags = scroll_flags;
  g.NavMoveForwardToNextFrame = false;
  g.NavMoveKeyMods = (move_flags & NavMoveFlags_FocusApi) ? 0 : g.IO.KeyMods;
  g.NavMoveResultLocal.Clear();
  g.NavMoveResultLocalVisible.Clear();
  g.NavMoveResultOther.Clear();
  g.NavTabbingCounter = 0;
  g.NavTabbingResultFirst.Clear();
  NavUpdateAnyRequestFlag();
}

inline void Gui::NavMoveRequestResolveWithLastItem(NavItemData *result) {
  Context &g = *GGui;
  g.NavMoveScoringItems = false; // Ensure request doesn't need more processing
  NavApplyItemToResult(result);
  NavUpdateAnyRequestFlag();
}

// Called by TreePop() to implement TreeNodeFlags_NavLeftJumpsBackHere
inline void
Gui::NavMoveRequestResolveWithPastTreeNode(NavItemData *result,
                                           NavTreeNodeData *tree_node_data) {
  Context &g = *GGui;
  g.NavMoveScoringItems = false;
  g.LastItemData.ID = tree_node_data->ID;
  g.LastItemData.InFlags =
      tree_node_data->InFlags &
      ~ItemFlags_HasSelectionUserData; // Losing SelectionUserData,
                                       // recovered next-frame (cheaper).
  g.LastItemData.NavRect = tree_node_data->NavRect;
  NavApplyItemToResult(result); // Result this instead of implementing a
                                // NavApplyPastTreeNodeToResult()
  NavClearPreferredPosForAxis(Axis_Y);
  NavUpdateAnyRequestFlag();
}

inline void Gui::NavMoveRequestCancel() {
  Context &g = *GGui;
  g.NavMoveSubmitted = g.NavMoveScoringItems = false;
  NavUpdateAnyRequestFlag();
}

// Forward will reuse the move request again on the next frame (generally with
// modifications done to it)
inline void Gui::NavMoveRequestForward(Dir move_dir, Dir clip_dir,
                                       NavMoveFlags move_flags,
                                       ScrollFlags scroll_flags) {
  Context &g = *GGui;
  GUI_ASSERT(g.NavMoveForwardToNextFrame == false);
  NavMoveRequestCancel();
  g.NavMoveForwardToNextFrame = true;
  g.NavMoveDir = move_dir;
  g.NavMoveClipDir = clip_dir;
  g.NavMoveFlags = move_flags | NavMoveFlags_Forwarded;
  g.NavMoveScrollFlags = scroll_flags;
}

// Navigation wrap-around logic is delayed to the end of the frame because this
// operation is only valid after entire popup is assembled and in case of
// appended popups it is not clear which EndPopup() call is final.
inline void Gui::NavMoveRequestTryWrapping(Window *window,
                                           NavMoveFlags wrap_flags) {
  Context &g = *GGui;
  GUI_ASSERT((wrap_flags & NavMoveFlags_WrapMask_) != 0 &&
             (wrap_flags & ~NavMoveFlags_WrapMask_) ==
                 0); // Call with _WrapX, _WrapY, _LoopX, _LoopY

  // In theory we should test for NavMoveRequestButNoResultYet() but there's no
  // point doing it: as NavEndFrame() will do the same test. It will end up
  // calling NavUpdateCreateWrappingRequest().
  if (g.NavWindow == window && g.NavMoveScoringItems &&
      g.NavLayer == NavLayer_Main)
    g.NavMoveFlags = (g.NavMoveFlags & ~NavMoveFlags_WrapMask_) | wrap_flags;
}

// FIXME: This could be replaced by updating a frame number in each window when
// (window == NavWindow) and (NavLayer == 0). This way we could find the last
// focused window among our children. It would be much less confusing this way?
static void Gui::NavSaveLastChildNavWindowIntoParent(Window *nav_window) {
  Window *parent = nav_window;
  while (parent && parent->RootWindow != parent &&
         (parent->Flags & (WindowFlags_Popup | WindowFlags_ChildMenu)) == 0)
    parent = parent->ParentWindow;
  if (parent && parent != nav_window)
    parent->NavLastChildNavWindow = nav_window;
}

// Restore the last focused child.
// Call when we are expected to land on the Main Layer (0) after FocusWindow()
static Window *Gui::NavRestoreLastChildNavWindow(Window *window) {
  if (window->NavLastChildNavWindow && window->NavLastChildNavWindow->WasActive)
    return window->NavLastChildNavWindow;
  return window;
}

void Gui::NavRestoreLayer(NavLayer layer) {
  Context &g = *GGui;
  if (layer == NavLayer_Main) {
    Window *prev_nav_window = g.NavWindow;
    g.NavWindow = NavRestoreLastChildNavWindow(
        g.NavWindow); // FIXME-NAV: Should clear ongoing nav requests?
    g.NavLastValidSelectionUserData = SelectionUserData_Invalid;
    if (prev_nav_window)
      GUI_DEBUG_LOG_FOCUS(
          "[focus] NavRestoreLayer: from \"%s\" to SetNavWindow(\"%s\")\n",
          prev_nav_window->Name, g.NavWindow->Name);
  }
  Window *window = g.NavWindow;
  if (window->NavLastIds[layer] != 0) {
    SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);
  } else {
    g.NavLayer = layer;
    NavInitWindow(window, true);
  }
}

static inline void Gui::NavUpdateAnyRequestFlag() {
  Context &g = *GGui;
  g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest ||
                    (GUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
  if (g.NavAnyRequest)
    GUI_ASSERT(g.NavWindow != NULL);
}

// This needs to be called before we submit any widget (aka in or before Begin)
inline void Gui::NavInitWindow(Window *window, bool force_reinit) {
  Context &g = *GGui;
  GUI_ASSERT(window == g.NavWindow);

  if (window->Flags & WindowFlags_NoNavInputs) {
    g.NavId = 0;
    g.NavFocusScopeId = window->NavRootFocusScopeId;
    return;
  }

  bool init_for_nav = false;
  if (window == window->RootWindow || (window->Flags & WindowFlags_Popup) ||
      (window->NavLastIds[0] == 0) || force_reinit)
    init_for_nav = true;
  GUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), "
                    "init_for_nav=%d, window=\"%s\", layer=%d\n",
                    init_for_nav, window->Name, g.NavLayer);
  if (init_for_nav) {
    SetNavID(0, g.NavLayer, window->NavRootFocusScopeId, Rect());
    g.NavInitRequest = true;
    g.NavInitRequestFromMove = false;
    g.NavInitResult.ID = 0;
    NavUpdateAnyRequestFlag();
  } else {
    g.NavId = window->NavLastIds[0];
    g.NavFocusScopeId = window->NavRootFocusScopeId;
  }
}

static Vec2 Gui::NavCalcPreferredRefPos() {
  Context &g = *GGui;
  Window *window = g.NavWindow;
  if (g.NavDisableHighlight || !g.NavDisableMouseHover || !window) {
    // Mouse (we need a fallback in case the mouse becomes invalid after being
    // used) The +1.0f offset when stored by OpenPopupEx() allows reopening this
    // or another popup (same or another mouse button) while not moving the
    // mouse, it is pretty standard. In theory we could move that +1.0f offset
    // in OpenPopupEx()
    Vec2 p =
        IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : g.MouseLastValidPos;
    return Vec2(p.x + 1.0f, p.y);
  } else {
    // When navigation is active and mouse is disabled, pick a position around
    // the bottom left of the currently navigated item Take account of upcoming
    // scrolling (maybe set mouse pos should be done in EndFrame?)
    Rect rect_rel = WindowRectRelToAbs(window, window->NavRectRel[g.NavLayer]);
    if (window->LastFrameActive != g.FrameCount &&
        (window->ScrollTarget.x != FLT_MAX ||
         window->ScrollTarget.y != FLT_MAX)) {
      Vec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
      rect_rel.Translate(Subtract(window->Scroll, next_scroll));
    }
    Vec2 pos = Vec2(
        rect_rel.Min.x + Min(g.Style.FramePadding.x * 4, rect_rel.GetWidth()),
        rect_rel.Max.y - Min(g.Style.FramePadding.y, rect_rel.GetHeight()));
    Viewport *viewport = GetMainViewport();
    return Trunc(Clamp(
        pos, viewport->Pos,
        Add(viewport->Pos,
            viewport
                ->Size))); // Trunc() is important because non-integer
                           // mouse position application in backend might be
                           // lossy and result in undesirable non-zero delta.
  }
}

inline float Gui::GetNavTweakPressedAmount(Axis axis) {
  Context &g = *GGui;
  float repeat_delay, repeat_rate;
  GetTypematicRepeatRate(InputFlags_RepeatRateNavTweak, &repeat_delay,
                         &repeat_rate);

  Key key_less, key_more;
  if (g.NavInputSource == InputSource_Gamepad) {
    key_less = (axis == Axis_X) ? Key_GamepadDpadLeft : Key_GamepadDpadUp;
    key_more = (axis == Axis_X) ? Key_GamepadDpadRight : Key_GamepadDpadDown;
  } else {
    key_less = (axis == Axis_X) ? Key_LeftArrow : Key_UpArrow;
    key_more = (axis == Axis_X) ? Key_RightArrow : Key_DownArrow;
  }
  float amount =
      (float)GetKeyPressedAmount(key_more, repeat_delay, repeat_rate) -
      (float)GetKeyPressedAmount(key_less, repeat_delay, repeat_rate);
  if (amount != 0.0f && IsKeyDown(key_less) &&
      IsKeyDown(key_more)) // Cancel when opposite directions are held,
                           // regardless of repeat phase
    amount = 0.0f;
  return amount;
}

static void Gui::NavUpdate() {
  Context &g = *GGui;
  IO &io = g.IO;

  io.WantSetMousePos = false;
  // if (g.NavScoringDebugCount > 0) GUI_DEBUG_LOG_NAV("[nav]
  // NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n",
  // g.NavScoringDebugCount, g.NavWindow ? g.NavWindow->Name : "NULL",
  // g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);

  // Set input source based on which keys are last pressed (as some features
  // differs when used with Gamepad vs Keyboard)
  // FIXME-NAV: Now that keys are separated maybe we can get rid of
  // NavInputSource?
  const bool nav_gamepad_active =
      (io.ConfigFlags & ConfigFlags_NavEnableGamepad) != 0 &&
      (io.BackendFlags & BackendFlags_HasGamepad) != 0;
  const Key nav_gamepad_keys_to_change_source[] = {
      Key_GamepadFaceRight, Key_GamepadFaceLeft,  Key_GamepadFaceUp,
      Key_GamepadFaceDown,  Key_GamepadDpadRight, Key_GamepadDpadLeft,
      Key_GamepadDpadUp,    Key_GamepadDpadDown};
  if (nav_gamepad_active)
    for (Key key : nav_gamepad_keys_to_change_source)
      if (IsKeyDown(key))
        g.NavInputSource = InputSource_Gamepad;
  const bool nav_keyboard_active =
      (io.ConfigFlags & ConfigFlags_NavEnableKeyboard) != 0;
  const Key nav_keyboard_keys_to_change_source[] = {
      Key_Space,     Key_Enter,   Key_Escape,   Key_RightArrow,
      Key_LeftArrow, Key_UpArrow, Key_DownArrow};
  if (nav_keyboard_active)
    for (Key key : nav_keyboard_keys_to_change_source)
      if (IsKeyDown(key))
        g.NavInputSource = InputSource_Keyboard;

  // Process navigation init request (select first/default focus)
  g.NavJustMovedToId = 0;
  if (g.NavInitResult.ID != 0)
    NavInitRequestApplyResult();
  g.NavInitRequest = false;
  g.NavInitRequestFromMove = false;
  g.NavInitResult.ID = 0;

  // Process navigation move request
  if (g.NavMoveSubmitted)
    NavMoveRequestApplyResult();
  g.NavTabbingCounter = 0;
  g.NavMoveSubmitted = g.NavMoveScoringItems = false;

  // Schedule mouse position update (will be done at the bottom of this
  // function, after 1) processing all move requests and 2) updating scrolling)
  bool set_mouse_pos = false;
  if (g.NavMousePosDirty && g.NavIdIsAlive)
    if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
      set_mouse_pos = true;
  g.NavMousePosDirty = false;
  GUI_ASSERT(g.NavLayer == NavLayer_Main || g.NavLayer == NavLayer_Menu);

  // Store our return window (for returning from Menu Layer to Main Layer) and
  // clear it as soon as we step back in our own Layer 0
  if (g.NavWindow)
    NavSaveLastChildNavWindowIntoParent(g.NavWindow);
  if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL &&
      g.NavLayer == NavLayer_Main)
    g.NavWindow->NavLastChildNavWindow = NULL;

  // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
  NavUpdateWindowing();

  // Set output flags for user application
  io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow &&
                 !(g.NavWindow->Flags & WindowFlags_NoNavInputs);
  io.NavVisible = (io.NavActive && g.NavId != 0 && !g.NavDisableHighlight) ||
                  (g.NavWindowingTarget != NULL);

  // Process NavCancel input (to close a popup, get back to parent, clear focus)
  NavUpdateCancelRequest();

  // Process manual activation request
  g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = 0;
  g.NavActivateFlags = ActivateFlags_None;
  if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget &&
      g.NavWindow && !(g.NavWindow->Flags & WindowFlags_NoNavInputs)) {
    const bool activate_down =
        (nav_keyboard_active && IsKeyDown(Key_Space)) ||
        (nav_gamepad_active && IsKeyDown(Key_NavGamepadActivate));
    const bool activate_pressed =
        activate_down &&
        ((nav_keyboard_active && IsKeyPressed(Key_Space, false)) ||
         (nav_gamepad_active && IsKeyPressed(Key_NavGamepadActivate, false)));
    const bool input_down =
        (nav_keyboard_active &&
         (IsKeyDown(Key_Enter) || IsKeyDown(Key_KeypadEnter))) ||
        (nav_gamepad_active && IsKeyDown(Key_NavGamepadInput));
    const bool input_pressed =
        input_down &&
        ((nav_keyboard_active && (IsKeyPressed(Key_Enter, false) ||
                                  IsKeyPressed(Key_KeypadEnter, false))) ||
         (nav_gamepad_active && IsKeyPressed(Key_NavGamepadInput, false)));
    if (g.ActiveId == 0 && activate_pressed) {
      g.NavActivateId = g.NavId;
      g.NavActivateFlags = ActivateFlags_PreferTweak;
    }
    if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && input_pressed) {
      g.NavActivateId = g.NavId;
      g.NavActivateFlags = ActivateFlags_PreferInput;
    }
    if ((g.ActiveId == 0 || g.ActiveId == g.NavId) &&
        (activate_down || input_down))
      g.NavActivateDownId = g.NavId;
    if ((g.ActiveId == 0 || g.ActiveId == g.NavId) &&
        (activate_pressed || input_pressed))
      g.NavActivatePressedId = g.NavId;
  }
  if (g.NavWindow && (g.NavWindow->Flags & WindowFlags_NoNavInputs))
    g.NavDisableHighlight = true;
  if (g.NavActivateId != 0)
    GUI_ASSERT(g.NavActivateDownId == g.NavActivateId);

  // Process programmatic activation request
  // FIXME-NAV: Those should eventually be queued (unlike focus they don't
  // cancel each others)
  if (g.NavNextActivateId != 0) {
    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId =
        g.NavNextActivateId;
    g.NavActivateFlags = g.NavNextActivateFlags;
  }
  g.NavNextActivateId = 0;

  // Process move requests
  NavUpdateCreateMoveRequest();
  if (g.NavMoveDir == Dir_None)
    NavUpdateCreateTabbingRequest();
  NavUpdateAnyRequestFlag();
  g.NavIdIsAlive = false;

  // Scrolling
  if (g.NavWindow && !(g.NavWindow->Flags & WindowFlags_NoNavInputs) &&
      !g.NavWindowingTarget) {
    // *Fallback* manual-scroll with Nav directional keys when window has no
    // navigable item
    Window *window = g.NavWindow;
    const float scroll_speed =
        GUI_ROUND(window->CalcFontSize() * 100 *
                  io.DeltaTime); // We need round the scrolling speed because
                                 // sub-pixel scroll isn't reliably supported.
    const Dir move_dir = g.NavMoveDir;
    if (window->DC.NavLayersActiveMask == 0x00 &&
        window->DC.NavWindowHasScrollY && move_dir != Dir_None) {
      if (move_dir == Dir_Left || move_dir == Dir_Right)
        SetScrollX(window, Trunc(window->Scroll.x +
                                 ((move_dir == Dir_Left) ? -1.0f : +1.0f) *
                                     scroll_speed));
      if (move_dir == Dir_Up || move_dir == Dir_Down)
        SetScrollY(window, Trunc(window->Scroll.y +
                                 ((move_dir == Dir_Up) ? -1.0f : +1.0f) *
                                     scroll_speed));
    }

    // *Normal* Manual scroll with LStick
    // Next movement request will clamp the NavId reference rectangle to the
    // visible area, so navigation will resume within those bounds.
    if (nav_gamepad_active) {
      const Vec2 scroll_dir =
          GetKeyMagnitude2d(Key_GamepadLStickLeft, Key_GamepadLStickRight,
                            Key_GamepadLStickUp, Key_GamepadLStickDown);
      const float tweak_factor = IsKeyDown(Key_NavGamepadTweakSlow)
                                     ? 1.0f / 10.0f
                                 : IsKeyDown(Key_NavGamepadTweakFast) ? 10.0f
                                                                      : 1.0f;
      if (scroll_dir.x != 0.0f && window->ScrollbarX)
        SetScrollX(window, Trunc(window->Scroll.x +
                                 scroll_dir.x * scroll_speed * tweak_factor));
      if (scroll_dir.y != 0.0f)
        SetScrollY(window, Trunc(window->Scroll.y +
                                 scroll_dir.y * scroll_speed * tweak_factor));
    }
  }

  // Always prioritize mouse highlight if navigation is disabled
  if (!nav_keyboard_active && !nav_gamepad_active) {
    g.NavDisableHighlight = true;
    g.NavDisableMouseHover = set_mouse_pos = false;
  }

  // Update mouse position if requested
  // (This will take into account the possibility that a Scroll was queued in
  // the window to offset our absolute mouse position before scroll has been
  // applied)
  if (set_mouse_pos && (io.ConfigFlags & ConfigFlags_NavEnableSetMousePos) &&
      (io.BackendFlags & BackendFlags_HasSetMousePos))
    TeleportMousePos(NavCalcPreferredRefPos());

  // [DEBUG]
  g.NavScoringDebugCount = 0;
#if GUI_DEBUG_NAV_RECTS
  if (Window *debug_window = g.NavWindow) {
    DrawList *draw_list = GetForegroundDrawList(debug_window);
    int layer = g.NavLayer; /* for (int layer = 0; layer < 2; layer++)*/
    {
      Rect r =
          WindowRectRelToAbs(debug_window, debug_window->NavRectRel[layer]);
      draw_list->AddRect(r.Min, r.Max, GUI_COL32(255, 200, 0, 255));
    }
    // if (1) {U32 col = (!debug_window->Hidden) ? GUI_COL32(255,0,255,255) :
    // GUI_COL32(255,0,0,255); Vec2 p = NavCalcPreferredRefPos(); char
    // buf[32]; FormatString(buf, 32, "%d", g.NavLayer);
    // draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f,
    // p + Vec2(8,-4), col, buf); }
  }
#endif
}

inline void Gui::NavInitRequestApplyResult() {
  // In very rare cases g.NavWindow may be null (e.g. clearing focus after
  // requesting an init request, which does happen when releasing Alt while
  // clicking on void)
  Context &g = *GGui;
  if (!g.NavWindow)
    return;

  NavItemData *result = &g.NavInitResult;
  if (g.NavId != result->ID) {
    g.NavJustMovedToId = result->ID;
    g.NavJustMovedToFocusScopeId = result->FocusScopeId;
    g.NavJustMovedToKeyMods = 0;
  }

  // Apply result from previous navigation init request (will typically select
  // the first item, unless SetItemDefaultFocus() has been called)
  // FIXME-NAV: On _NavFlattened windows, g.NavWindow will only be updated
  // during subsequent frame. Not a problem currently.
  GUI_DEBUG_LOG_NAV("[nav] NavInitRequest: ApplyResult: NavID 0x%08X in "
                    "Layer %d Window \"%s\"\n",
                    result->ID, g.NavLayer, g.NavWindow->Name);
  SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
  g.NavIdIsAlive = true; // Mark as alive from previous frame as we got a result
  if (result->SelectionUserData != SelectionUserData_Invalid)
    g.NavLastValidSelectionUserData = result->SelectionUserData;
  if (g.NavInitRequestFromMove)
    NavRestoreHighlightAfterMove();
}

// Bias scoring rect ahead of scoring + update preferred pos (if missing) using
// source position
static void NavBiasScoringRect(Rect &r, Vec2 &preferred_pos_rel, Dir move_dir,
                               NavMoveFlags move_flags) {
  // Bias initial rect
  Context &g = *GGui;
  const Vec2 rel_to_abs_offset = g.NavWindow->DC.CursorStartPos;

  // Initialize bias on departure if we don't have any. So mouse-click + arrow
  // will record bias.
  // - We default to L/U bias, so moving down from a large source item into
  // several columns will land on left-most column.
  // - But each successful move sets new bias on one axis, only cleared when
  // using mouse.
  if ((move_flags & NavMoveFlags_Forwarded) == 0) {
    if (preferred_pos_rel.x == FLT_MAX)
      preferred_pos_rel.x = Min(r.Min.x + 1.0f, r.Max.x) - rel_to_abs_offset.x;
    if (preferred_pos_rel.y == FLT_MAX)
      preferred_pos_rel.y = r.GetCenter().y - rel_to_abs_offset.y;
  }

  // Apply general bias on the other axis
  if ((move_dir == Dir_Up || move_dir == Dir_Down) &&
      preferred_pos_rel.x != FLT_MAX)
    r.Min.x = r.Max.x = preferred_pos_rel.x + rel_to_abs_offset.x;
  else if ((move_dir == Dir_Left || move_dir == Dir_Right) &&
           preferred_pos_rel.y != FLT_MAX)
    r.Min.y = r.Max.y = preferred_pos_rel.y + rel_to_abs_offset.y;
}

void Gui::NavUpdateCreateMoveRequest() {
  Context &g = *GGui;
  IO &io = g.IO;
  Window *window = g.NavWindow;
  const bool nav_gamepad_active =
      (io.ConfigFlags & ConfigFlags_NavEnableGamepad) != 0 &&
      (io.BackendFlags & BackendFlags_HasGamepad) != 0;
  const bool nav_keyboard_active =
      (io.ConfigFlags & ConfigFlags_NavEnableKeyboard) != 0;

  if (g.NavMoveForwardToNextFrame && window != NULL) {
    // Forwarding previous request (which has been modified, e.g. wrap around
    // menus rewrite the requests with a starting rectangle at the other side of
    // the window) (preserve most state, which were already set by the
    // NavMoveRequestForward() function)
    GUI_ASSERT(g.NavMoveDir != Dir_None && g.NavMoveClipDir != Dir_None);
    GUI_ASSERT(g.NavMoveFlags & NavMoveFlags_Forwarded);
    GUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir);
  } else {
    // Initiate directional inputs request
    g.NavMoveDir = Dir_None;
    g.NavMoveFlags = NavMoveFlags_None;
    g.NavMoveScrollFlags = ScrollFlags_None;
    if (window && !g.NavWindowingTarget &&
        !(window->Flags & WindowFlags_NoNavInputs)) {
      const InputFlags repeat_mode =
          InputFlags_Repeat | (InputFlags)InputFlags_RepeatRateNavMove;
      if (!IsActiveIdUsingNavDir(Dir_Left) &&
          ((nav_gamepad_active &&
            IsKeyPressed(Key_GamepadDpadLeft, KeyOwner_None, repeat_mode)) ||
           (nav_keyboard_active &&
            IsKeyPressed(Key_LeftArrow, KeyOwner_None, repeat_mode)))) {
        g.NavMoveDir = Dir_Left;
      }
      if (!IsActiveIdUsingNavDir(Dir_Right) &&
          ((nav_gamepad_active &&
            IsKeyPressed(Key_GamepadDpadRight, KeyOwner_None, repeat_mode)) ||
           (nav_keyboard_active &&
            IsKeyPressed(Key_RightArrow, KeyOwner_None, repeat_mode)))) {
        g.NavMoveDir = Dir_Right;
      }
      if (!IsActiveIdUsingNavDir(Dir_Up) &&
          ((nav_gamepad_active &&
            IsKeyPressed(Key_GamepadDpadUp, KeyOwner_None, repeat_mode)) ||
           (nav_keyboard_active &&
            IsKeyPressed(Key_UpArrow, KeyOwner_None, repeat_mode)))) {
        g.NavMoveDir = Dir_Up;
      }
      if (!IsActiveIdUsingNavDir(Dir_Down) &&
          ((nav_gamepad_active &&
            IsKeyPressed(Key_GamepadDpadDown, KeyOwner_None, repeat_mode)) ||
           (nav_keyboard_active &&
            IsKeyPressed(Key_DownArrow, KeyOwner_None, repeat_mode)))) {
        g.NavMoveDir = Dir_Down;
      }
    }
    g.NavMoveClipDir = g.NavMoveDir;
    g.NavScoringNoClipRect = Rect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
  }

  // Update PageUp/PageDown/Home/End scroll
  // FIXME-NAV: Consider enabling those keys even without the master
  // ConfigFlags_NavEnableKeyboard flag?
  float scoring_rect_offset_y = 0.0f;
  if (window && g.NavMoveDir == Dir_None && nav_keyboard_active)
    scoring_rect_offset_y = NavUpdatePageUpPageDown();
  if (scoring_rect_offset_y != 0.0f) {
    g.NavScoringNoClipRect = window->InnerRect;
    g.NavScoringNoClipRect.TranslateY(scoring_rect_offset_y);
  }

  // [DEBUG] Always send a request when holding CTRL. Hold CTRL + Arrow change
  // the direction.
#if GUI_DEBUG_NAV_SCORING
  // if (io.KeyCtrl && IsKeyPressed(Key_C))
  //     g.NavMoveDirForDebug = (Dir)((g.NavMoveDirForDebug + 1) & 3);
  if (io.KeyCtrl) {
    if (g.NavMoveDir == Dir_None)
      g.NavMoveDir = g.NavMoveDirForDebug;
    g.NavMoveClipDir = g.NavMoveDir;
    g.NavMoveFlags |= NavMoveFlags_DebugNoResult;
  }
#endif

  // Submit
  g.NavMoveForwardToNextFrame = false;
  if (g.NavMoveDir != Dir_None)
    NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags,
                         g.NavMoveScrollFlags);

  // Moving with no reference triggers an init request (will be used as a
  // fallback if the direction fails to find a match)
  if (g.NavMoveSubmitted && g.NavId == 0) {
    GUI_DEBUG_LOG_NAV(
        "[nav] NavInitRequest: from move, window \"%s\", layer=%d\n",
        window ? window->Name : "<NULL>", g.NavLayer);
    g.NavInitRequest = g.NavInitRequestFromMove = true;
    g.NavInitResult.ID = 0;
    g.NavDisableHighlight = false;
  }

  // When using gamepad, we project the reference nav bounding box into window
  // visible area. This is to allow resuming navigation inside the visible area
  // after doing a large amount of scrolling, since with gamepad all movements
  // are relative (can't focus a visible object like we can with the mouse).
  if (g.NavMoveSubmitted && g.NavInputSource == InputSource_Gamepad &&
      g.NavLayer == NavLayer_Main &&
      window != NULL) // && (g.NavMoveFlags & NavMoveFlags_Forwarded))
  {
    bool clamp_x =
        (g.NavMoveFlags & (NavMoveFlags_LoopX | NavMoveFlags_WrapX)) == 0;
    bool clamp_y =
        (g.NavMoveFlags & (NavMoveFlags_LoopY | NavMoveFlags_WrapY)) == 0;
    Rect inner_rect_rel = WindowRectAbsToRel(
        window, Rect(Subtract(window->InnerRect.Min, Vec2(1, 1)),
                     Add(window->InnerRect.Max, Vec2(1, 1))));

    // Take account of changing scroll to handle triggering a new move request
    // on a scrolling frame. (#6171) Otherwise 'inner_rect_rel' would be off on
    // the move result frame.
    inner_rect_rel.Translate(Subtract(
        CalcNextScrollFromScrollTargetAndClamp(window), window->Scroll));

    if ((clamp_x || clamp_y) &&
        !inner_rect_rel.Contains(window->NavRectRel[g.NavLayer])) {
      GUI_DEBUG_LOG_NAV(
          "[nav] NavMoveRequest: clamp NavRectRel for gamepad move\n");
      float pad_x =
          Min(inner_rect_rel.GetWidth(), window->CalcFontSize() * 0.5f);
      float pad_y =
          Min(inner_rect_rel.GetHeight(),
              window->CalcFontSize() *
                  0.5f); // Terrible approximation for the intent of starting
                         // navigation from first fully visible item
      inner_rect_rel.Min.x =
          clamp_x ? (inner_rect_rel.Min.x + pad_x) : -FLT_MAX;
      inner_rect_rel.Max.x =
          clamp_x ? (inner_rect_rel.Max.x - pad_x) : +FLT_MAX;
      inner_rect_rel.Min.y =
          clamp_y ? (inner_rect_rel.Min.y + pad_y) : -FLT_MAX;
      inner_rect_rel.Max.y =
          clamp_y ? (inner_rect_rel.Max.y - pad_y) : +FLT_MAX;
      window->NavRectRel[g.NavLayer].ClipWithFull(inner_rect_rel);
      g.NavId = 0;
    }
  }

  // For scoring we use a single segment on the left side our current item
  // bounding box (not touching the edge to avoid box overlap with zero-spaced
  // items)
  Rect scoring_rect;
  if (window != NULL) {
    Rect nav_rect_rel = !window->NavRectRel[g.NavLayer].IsInverted()
                            ? window->NavRectRel[g.NavLayer]
                            : Rect(0, 0, 0, 0);
    scoring_rect = WindowRectRelToAbs(window, nav_rect_rel);
    scoring_rect.TranslateY(scoring_rect_offset_y);
    if (g.NavMoveSubmitted)
      NavBiasScoringRect(
          scoring_rect,
          window->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer],
          g.NavMoveDir, g.NavMoveFlags);
    GUI_ASSERT(
        !scoring_rect
             .IsInverted()); // Ensure we have a non-inverted bounding box
                             // here will allow us to remove extraneous
                             // Fabs() calls in NavScoreItem().
    // GetForegroundDrawList()->AddRect(scoring_rect.Min, scoring_rect.Max,
    // GUI_COL32(255,200,0,255)); // [DEBUG] if
    // (!g.NavScoringNoClipRect.IsInverted()) {
    // GetForegroundDrawList()->AddRect(g.NavScoringNoClipRect.Min,
    // g.NavScoringNoClipRect.Max, GUI_COL32(255, 200, 0, 255)); } // [DEBUG]
  }
  g.NavScoringRect = scoring_rect;
  g.NavScoringNoClipRect.Add(scoring_rect);
}

void Gui::NavUpdateCreateTabbingRequest() {
  Context &g = *GGui;
  Window *window = g.NavWindow;
  GUI_ASSERT(g.NavMoveDir == Dir_None);
  if (window == NULL || g.NavWindowingTarget != NULL ||
      (window->Flags & WindowFlags_NoNavInputs))
    return;

  const bool tab_pressed =
      IsKeyPressed(Key_Tab, KeyOwner_None, InputFlags_Repeat) &&
      !g.IO.KeyCtrl && !g.IO.KeyAlt;
  if (!tab_pressed)
    return;

  // Initiate tabbing request
  // (this is ALWAYS ENABLED, regardless of ConfigFlags_NavEnableKeyboard
  // flag!) See NavProcessItemForTabbingRequest() for a description of the
  // various forward/backward tabbing cases with and without wrapping.
  const bool nav_keyboard_active =
      (g.IO.ConfigFlags & ConfigFlags_NavEnableKeyboard) != 0;
  if (nav_keyboard_active)
    g.NavTabbingDir = g.IO.KeyShift                                        ? -1
                      : (g.NavDisableHighlight == true && g.ActiveId == 0) ? 0
                                                                           : +1;
  else
    g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0 : +1;
  NavMoveFlags move_flags = NavMoveFlags_IsTabbing | NavMoveFlags_Activate;
  ScrollFlags scroll_flags =
      window->Appearing
          ? ScrollFlags_KeepVisibleEdgeX | ScrollFlags_AlwaysCenterY
          : ScrollFlags_KeepVisibleEdgeX | ScrollFlags_KeepVisibleEdgeY;
  Dir clip_dir = (g.NavTabbingDir < 0) ? Dir_Up : Dir_Down;
  NavMoveRequestSubmit(
      Dir_None, clip_dir, move_flags,
      scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag
                     // to not activate non-inputable.
  g.NavTabbingCounter = -1;
}

// Apply result from previous frame navigation directional move request. Always
// called from NavUpdate()
inline void Gui::NavMoveRequestApplyResult() {
  Context &g = *GGui;
#if GUI_DEBUG_NAV_SCORING
  if (g.NavMoveFlags & NavMoveFlags_DebugNoResult) // [DEBUG] Scoring all items
                                                   // in NavWindow at all times
    return;
#endif

  // Select which result to use
  NavItemData *result = (g.NavMoveResultLocal.ID != 0)   ? &g.NavMoveResultLocal
                        : (g.NavMoveResultOther.ID != 0) ? &g.NavMoveResultOther
                                                         : NULL;

  // Tabbing forward wrap
  if ((g.NavMoveFlags & NavMoveFlags_IsTabbing) && result == NULL)
    if ((g.NavTabbingCounter == 1 || g.NavTabbingDir == 0) &&
        g.NavTabbingResultFirst.ID)
      result = &g.NavTabbingResultFirst;

  // In a situation when there are no results but NavId != 0, re-enable the
  // Navigation highlight (because g.NavId is not considered as a possible
  // result)
  const Axis axis =
      (g.NavMoveDir == Dir_Up || g.NavMoveDir == Dir_Down) ? Axis_Y : Axis_X;
  if (result == NULL) {
    if (g.NavMoveFlags & NavMoveFlags_IsTabbing)
      g.NavMoveFlags |= NavMoveFlags_NoSetNavHighlight;
    if (g.NavId != 0 && (g.NavMoveFlags & NavMoveFlags_NoSetNavHighlight) == 0)
      NavRestoreHighlightAfterMove();
    NavClearPreferredPosForAxis(
        axis); // On a failed move, clear preferred pos for this axis.
    GUI_DEBUG_LOG_NAV("[nav] NavMoveSubmitted but not led to a result!\n");
    return;
  }

  // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item,
  // _otherwise_ use the result from the previous/next page.
  if (g.NavMoveFlags & NavMoveFlags_AlsoScoreVisibleSet)
    if (g.NavMoveResultLocalVisible.ID != 0 &&
        g.NavMoveResultLocalVisible.ID != g.NavId)
      result = &g.NavMoveResultLocalVisible;

  // Maybe entering a flattened child from the outside? In this case solve the
  // tie using the regular scoring rules.
  if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 &&
      g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
    if ((g.NavMoveResultOther.DistBox < result->DistBox) ||
        (g.NavMoveResultOther.DistBox == result->DistBox &&
         g.NavMoveResultOther.DistCenter < result->DistCenter))
      result = &g.NavMoveResultOther;
  GUI_ASSERT(g.NavWindow && result->Window);

  // Scroll to keep newly navigated item fully into view.
  if (g.NavLayer == NavLayer_Main) {
    Rect rect_abs = WindowRectRelToAbs(result->Window, result->RectRel);
    ScrollToRectEx(result->Window, rect_abs, g.NavMoveScrollFlags);

    if (g.NavMoveFlags & NavMoveFlags_ScrollToEdgeY) {
      // FIXME: Should remove this? Or make more precise: use ScrollToRectEx()
      // with edge?
      float scroll_target =
          (g.NavMoveDir == Dir_Up) ? result->Window->ScrollMax.y : 0.0f;
      SetScrollY(result->Window, scroll_target);
    }
  }

  if (g.NavWindow != result->Window) {
    GUI_DEBUG_LOG_FOCUS("[focus] NavMoveRequest: SetNavWindow(\"%s\")\n",
                        result->Window->Name);
    g.NavWindow = result->Window;
    g.NavLastValidSelectionUserData = SelectionUserData_Invalid;
  }
  if (g.ActiveId != result->ID)
    ClearActiveID();

  // Don't set NavJustMovedToId if just landed on the same spot (which may
  // happen with NavMoveFlags_AllowCurrentNavId) PageUp/PageDown however
  // sets always set NavJustMovedTo (vs Home/End which doesn't) mimicking
  // Windows behavior.
  if ((g.NavId != result->ID || (g.NavMoveFlags & NavMoveFlags_IsPageMove)) &&
      (g.NavMoveFlags & NavMoveFlags_NoSelect) == 0) {
    g.NavJustMovedToId = result->ID;
    g.NavJustMovedToFocusScopeId = result->FocusScopeId;
    g.NavJustMovedToKeyMods = g.NavMoveKeyMods;
  }

  // Apply new NavID/Focus
  GUI_DEBUG_LOG_NAV(
      "[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n",
      result->ID, g.NavLayer, g.NavWindow->Name);
  Vec2 preferred_scoring_pos_rel =
      g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer];
  SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
  if (result->SelectionUserData != SelectionUserData_Invalid)
    g.NavLastValidSelectionUserData = result->SelectionUserData;

  // Restore last preferred position for current axis
  // (storing in RootWindowForNav-> as the info is desirable at the beginning of
  // a Move Request. In theory all storage should use RootWindowForNav..)
  if ((g.NavMoveFlags & NavMoveFlags_IsTabbing) == 0) {
    preferred_scoring_pos_rel[axis] = result->RectRel.GetCenter()[axis];
    g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer] =
        preferred_scoring_pos_rel;
  }

  // Tabbing: Activates Inputable, otherwise only Focus
  if ((g.NavMoveFlags & NavMoveFlags_IsTabbing) &&
      (result->InFlags & ItemFlags_Inputable) == 0)
    g.NavMoveFlags &= ~NavMoveFlags_Activate;

  // Activate
  if (g.NavMoveFlags & NavMoveFlags_Activate) {
    g.NavNextActivateId = result->ID;
    g.NavNextActivateFlags = ActivateFlags_None;
    if (g.NavMoveFlags & NavMoveFlags_IsTabbing)
      g.NavNextActivateFlags |= ActivateFlags_PreferInput |
                                ActivateFlags_TryToPreserveState |
                                ActivateFlags_FromTabbing;
  }

  // Enable nav highlight
  if ((g.NavMoveFlags & NavMoveFlags_NoSetNavHighlight) == 0)
    NavRestoreHighlightAfterMove();
}

// Process NavCancel input (to close a popup, get back to parent, clear focus)
// FIXME: In order to support e.g. Escape to clear a selection we'll need:
// - either to store the equivalent of ActiveIdUsingKeyInputMask for a
// FocusScope and test for it.
// - either to move most/all of those tests to the epilogue/end functions of the
// scope they are dealing with (e.g. exit child window in EndChild()) or in
// EndFrame(), to allow an earlier intercept
static void Gui::NavUpdateCancelRequest() {
  Context &g = *GGui;
  const bool nav_gamepad_active =
      (g.IO.ConfigFlags & ConfigFlags_NavEnableGamepad) != 0 &&
      (g.IO.BackendFlags & BackendFlags_HasGamepad) != 0;
  const bool nav_keyboard_active =
      (g.IO.ConfigFlags & ConfigFlags_NavEnableKeyboard) != 0;
  if (!(nav_keyboard_active && IsKeyPressed(Key_Escape, KeyOwner_None)) &&
      !(nav_gamepad_active &&
        IsKeyPressed(Key_NavGamepadCancel, KeyOwner_None)))
    return;

  GUI_DEBUG_LOG_NAV("[nav] NavUpdateCancelRequest()\n");
  if (g.ActiveId != 0) {
    ClearActiveID();
  } else if (g.NavLayer != NavLayer_Main) {
    // Leave the "menu" layer
    NavRestoreLayer(NavLayer_Main);
    NavRestoreHighlightAfterMove();
  } else if (g.NavWindow && g.NavWindow != g.NavWindow->RootWindow &&
             !(g.NavWindow->Flags & WindowFlags_Popup) &&
             g.NavWindow->ParentWindow) {
    // Exit child window
    Window *child_window = g.NavWindow;
    Window *parent_window = g.NavWindow->ParentWindow;
    GUI_ASSERT(child_window->ChildId != 0);
    Rect child_rect = child_window->Rect();
    FocusWindow(parent_window);
    SetNavID(child_window->ChildId, NavLayer_Main, 0,
             WindowRectAbsToRel(parent_window, child_rect));
    NavRestoreHighlightAfterMove();
  } else if (g.OpenPopupStack.Size > 0 &&
             g.OpenPopupStack.back().Window != NULL &&
             !(g.OpenPopupStack.back().Window->Flags & WindowFlags_Modal)) {
    // Close open popup/menu
    ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
  } else {
    // Clear NavLastId for popups but keep it for regular child window so we can
    // leave one and come back where we were
    if (g.NavWindow && ((g.NavWindow->Flags & WindowFlags_Popup) ||
                        !(g.NavWindow->Flags & WindowFlags_ChildWindow)))
      g.NavWindow->NavLastIds[0] = 0;
    g.NavId = 0;
  }
}

// Handle PageUp/PageDown/Home/End keys
// Called from NavUpdateCreateMoveRequest() which will use our output to create
// a move request
// FIXME-NAV: This doesn't work properly with NavFlattened siblings as we use
// NavWindow rectangle for reference
// FIXME-NAV: how to get Home/End to aim at the beginning/end of a 2D grid?
static float Gui::NavUpdatePageUpPageDown() {
  Context &g = *GGui;
  Window *window = g.NavWindow;
  if ((window->Flags & WindowFlags_NoNavInputs) || g.NavWindowingTarget != NULL)
    return 0.0f;

  const bool page_up_held = IsKeyDown(Key_PageUp, KeyOwner_None);
  const bool page_down_held = IsKeyDown(Key_PageDown, KeyOwner_None);
  const bool home_pressed =
      IsKeyPressed(Key_Home, KeyOwner_None, InputFlags_Repeat);
  const bool end_pressed =
      IsKeyPressed(Key_End, KeyOwner_None, InputFlags_Repeat);
  if (page_up_held == page_down_held &&
      home_pressed == end_pressed) // Proceed if either (not both) are pressed,
                                   // otherwise early out
    return 0.0f;

  if (g.NavLayer != NavLayer_Main)
    NavRestoreLayer(NavLayer_Main);

  if (window->DC.NavLayersActiveMask == 0x00 &&
      window->DC.NavWindowHasScrollY) {
    // Fallback manual-scroll when window has no navigable item
    if (IsKeyPressed(Key_PageUp, KeyOwner_None, InputFlags_Repeat))
      SetScrollY(window, window->Scroll.y - window->InnerRect.GetHeight());
    else if (IsKeyPressed(Key_PageDown, KeyOwner_None, InputFlags_Repeat))
      SetScrollY(window, window->Scroll.y + window->InnerRect.GetHeight());
    else if (home_pressed)
      SetScrollY(window, 0.0f);
    else if (end_pressed)
      SetScrollY(window, window->ScrollMax.y);
  } else {
    Rect &nav_rect_rel = window->NavRectRel[g.NavLayer];
    const float page_offset_y =
        Max(0.0f, window->InnerRect.GetHeight() -
                      window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
    float nav_scoring_rect_offset_y = 0.0f;
    if (IsKeyPressed(Key_PageUp, true)) {
      nav_scoring_rect_offset_y = -page_offset_y;
      g.NavMoveDir = Dir_Down; // Because our scoring rect is offset up, we
                               // request the down direction (so we can
                               // always land on the last item)
      g.NavMoveClipDir = Dir_Up;
      g.NavMoveFlags = NavMoveFlags_AllowCurrentNavId |
                       NavMoveFlags_AlsoScoreVisibleSet |
                       NavMoveFlags_IsPageMove;
    } else if (IsKeyPressed(Key_PageDown, true)) {
      nav_scoring_rect_offset_y = +page_offset_y;
      g.NavMoveDir = Dir_Up; // Because our scoring rect is offset down, we
                             // request the up direction (so we can always
                             // land on the last item)
      g.NavMoveClipDir = Dir_Down;
      g.NavMoveFlags = NavMoveFlags_AllowCurrentNavId |
                       NavMoveFlags_AlsoScoreVisibleSet |
                       NavMoveFlags_IsPageMove;
    } else if (home_pressed) {
      // FIXME-NAV: handling of Home/End is assuming that the top/bottom most
      // item will be visible with Scroll.y == 0/ScrollMax.y Scrolling will be
      // handled via the NavMoveFlags_ScrollToEdgeY flag, we don't scroll
      // immediately to avoid scrolling happening before nav result. Preserve
      // current horizontal position if we have any.
      nav_rect_rel.Min.y = nav_rect_rel.Max.y = 0.0f;
      if (nav_rect_rel.IsInverted())
        nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
      g.NavMoveDir = Dir_Down;
      g.NavMoveFlags =
          NavMoveFlags_AllowCurrentNavId | NavMoveFlags_ScrollToEdgeY;
      // FIXME-NAV: MoveClipDir left to _None, intentional?
    } else if (end_pressed) {
      nav_rect_rel.Min.y = nav_rect_rel.Max.y = window->ContentSize.y;
      if (nav_rect_rel.IsInverted())
        nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
      g.NavMoveDir = Dir_Up;
      g.NavMoveFlags =
          NavMoveFlags_AllowCurrentNavId | NavMoveFlags_ScrollToEdgeY;
      // FIXME-NAV: MoveClipDir left to _None, intentional?
    }
    return nav_scoring_rect_offset_y;
  }
  return 0.0f;
}

static void Gui::NavEndFrame() {
  Context &g = *GGui;

  // Show CTRL+TAB list window
  if (g.NavWindowingTarget != NULL)
    NavUpdateWindowingOverlay();

  // Perform wrap-around in menus
  // FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4
  // grid with 2 last items missing on last item won't handle LoopY/WrapY
  // correctly.
  // FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function
  // and then WrapX would function without an extra frame.
  if (g.NavWindow && NavMoveRequestButNoResultYet() &&
      (g.NavMoveFlags & NavMoveFlags_WrapMask_) &&
      (g.NavMoveFlags & NavMoveFlags_Forwarded) == 0)
    NavUpdateCreateWrappingRequest();
}

static void Gui::NavUpdateCreateWrappingRequest() {
  Context &g = *GGui;
  Window *window = g.NavWindow;

  bool do_forward = false;
  Rect bb_rel = window->NavRectRel[g.NavLayer];
  Dir clip_dir = g.NavMoveDir;

  const NavMoveFlags move_flags = g.NavMoveFlags;
  // const Axis move_axis = (g.NavMoveDir == Dir_Up || g.NavMoveDir ==
  // Dir_Down) ? Axis_Y : Axis_X;
  if (g.NavMoveDir == Dir_Left &&
      (move_flags & (NavMoveFlags_WrapX | NavMoveFlags_LoopX))) {
    bb_rel.Min.x = bb_rel.Max.x =
        window->ContentSize.x + window->WindowPadding.x;
    if (move_flags & NavMoveFlags_WrapX) {
      bb_rel.TranslateY(-bb_rel.GetHeight()); // Previous row
      clip_dir = Dir_Up;
    }
    do_forward = true;
  }
  if (g.NavMoveDir == Dir_Right &&
      (move_flags & (NavMoveFlags_WrapX | NavMoveFlags_LoopX))) {
    bb_rel.Min.x = bb_rel.Max.x = -window->WindowPadding.x;
    if (move_flags & NavMoveFlags_WrapX) {
      bb_rel.TranslateY(+bb_rel.GetHeight()); // Next row
      clip_dir = Dir_Down;
    }
    do_forward = true;
  }
  if (g.NavMoveDir == Dir_Up &&
      (move_flags & (NavMoveFlags_WrapY | NavMoveFlags_LoopY))) {
    bb_rel.Min.y = bb_rel.Max.y =
        window->ContentSize.y + window->WindowPadding.y;
    if (move_flags & NavMoveFlags_WrapY) {
      bb_rel.TranslateX(-bb_rel.GetWidth()); // Previous column
      clip_dir = Dir_Left;
    }
    do_forward = true;
  }
  if (g.NavMoveDir == Dir_Down &&
      (move_flags & (NavMoveFlags_WrapY | NavMoveFlags_LoopY))) {
    bb_rel.Min.y = bb_rel.Max.y = -window->WindowPadding.y;
    if (move_flags & NavMoveFlags_WrapY) {
      bb_rel.TranslateX(+bb_rel.GetWidth()); // Next column
      clip_dir = Dir_Right;
    }
    do_forward = true;
  }
  if (!do_forward)
    return;
  window->NavRectRel[g.NavLayer] = bb_rel;
  NavClearPreferredPosForAxis(Axis_X);
  NavClearPreferredPosForAxis(Axis_Y);
  NavMoveRequestForward(g.NavMoveDir, clip_dir, move_flags,
                        g.NavMoveScrollFlags);
}

static int Gui::FindWindowFocusIndex(Window *window) {
  Context &g = *GGui;
  GUI_UNUSED(g);
  int order = window->FocusOrder;
  GUI_ASSERT(
      window->RootWindow ==
      window); // No child window (not testing _ChildWindow because of docking)
  GUI_ASSERT(g.WindowsFocusOrder[order] == window);
  return order;
}

static Window *FindWindowNavFocusable(int i_start, int i_stop,
                                      int dir) // FIXME-OPT O(N)
{
  Context &g = *GGui;
  for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop;
       i += dir)
    if (Gui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))
      return g.WindowsFocusOrder[i];
  return NULL;
}

static void NavUpdateWindowingHighlightWindow(int focus_change_dir) {
  Context &g = *GGui;
  GUI_ASSERT(g.NavWindowingTarget);
  if (g.NavWindowingTarget->Flags & WindowFlags_Modal)
    return;

  const int i_current = Gui::FindWindowFocusIndex(g.NavWindowingTarget);
  Window *window_target = FindWindowNavFocusable(i_current + focus_change_dir,
                                                 -INT_MAX, focus_change_dir);
  if (!window_target)
    window_target = FindWindowNavFocusable(
        (focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current,
        focus_change_dir);
  if (window_target) // Don't reset windowing target if there's a single window
                     // in the list
  {
    g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
    g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize =
        Vec2(0.0f, 0.0f);
  }
  g.NavWindowingToggleLayer = false;
}

// Windowing management mode
// Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
// Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square
// (toggle menu layer)
static void Gui::NavUpdateWindowing() {
  Context &g = *GGui;
  IO &io = g.IO;

  Window *apply_focus_window = NULL;
  bool apply_toggle_layer = false;

  Window *modal_window = GetTopMostPopupModal();
  bool allow_windowing =
      (modal_window ==
       NULL); // FIXME: This prevent CTRL+TAB from being usable with windows
              // that are inside the Begin-stack of that modal.
  if (!allow_windowing)
    g.NavWindowingTarget = NULL;

  // Fade out
  if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL) {
    g.NavWindowingHighlightAlpha =
        Max(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0f, 0.0f);
    if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
      g.NavWindowingTargetAnim = NULL;
  }

  // Start CTRL+Tab or Square+L/R window selection
  const ID owner_id = HashStr("###NavUpdateWindowing");
  const bool nav_gamepad_active =
      (io.ConfigFlags & ConfigFlags_NavEnableGamepad) != 0 &&
      (io.BackendFlags & BackendFlags_HasGamepad) != 0;
  const bool nav_keyboard_active =
      (io.ConfigFlags & ConfigFlags_NavEnableKeyboard) != 0;
  const bool keyboard_next_window =
      allow_windowing && g.ConfigNavWindowingKeyNext &&
      Shortcut(g.ConfigNavWindowingKeyNext, owner_id,
               InputFlags_Repeat | InputFlags_RouteAlways);
  const bool keyboard_prev_window =
      allow_windowing && g.ConfigNavWindowingKeyPrev &&
      Shortcut(g.ConfigNavWindowingKeyPrev, owner_id,
               InputFlags_Repeat | InputFlags_RouteAlways);
  const bool start_windowing_with_gamepad =
      allow_windowing && nav_gamepad_active && !g.NavWindowingTarget &&
      IsKeyPressed(Key_NavGamepadMenu, 0, InputFlags_None);
  const bool start_windowing_with_keyboard =
      allow_windowing && !g.NavWindowingTarget &&
      (keyboard_next_window ||
       keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
  if (start_windowing_with_gamepad || start_windowing_with_keyboard)
    if (Window *window =
            g.NavWindow ? g.NavWindow
                        : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1,
                                                 -INT_MAX, -1)) {
      g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow;
      g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
      g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize =
          Vec2(0.0f, 0.0f);
      g.NavWindowingToggleLayer = start_windowing_with_gamepad
                                      ? true
                                      : false; // Gamepad starts toggling layer
      g.NavInputSource = start_windowing_with_keyboard ? InputSource_Keyboard
                                                       : InputSource_Gamepad;

      // Register ownership of our mods. Using InputFlags_RouteGlobalHigh
      // in the Shortcut() calls instead would probably be correct but may have
      // more side-effects.
      if (keyboard_next_window || keyboard_prev_window)
        SetKeyOwnersForKeyChord(
            (g.ConfigNavWindowingKeyNext | g.ConfigNavWindowingKeyPrev) &
                Mod_Mask_,
            owner_id);
    }

  // Gamepad update
  g.NavWindowingTimer += io.DeltaTime;
  if (g.NavWindowingTarget && g.NavInputSource == InputSource_Gamepad) {
    // Highlight only appears after a brief time holding the button, so that a
    // fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
    g.NavWindowingHighlightAlpha =
        Max(g.NavWindowingHighlightAlpha,
            Saturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) /
                     0.05f));

    // Select window to focus
    const int focus_change_dir =
        (int)IsKeyPressed(Key_GamepadL1) - (int)IsKeyPressed(Key_GamepadR1);
    if (focus_change_dir != 0) {
      NavUpdateWindowingHighlightWindow(focus_change_dir);
      g.NavWindowingHighlightAlpha = 1.0f;
    }

    // Single press toggles NavLayer, long press with L/R apply actual focus on
    // release (until then the window was merely rendered top-most)
    if (!IsKeyDown(Key_NavGamepadMenu)) {
      g.NavWindowingToggleLayer &=
          (g.NavWindowingHighlightAlpha <
           1.0f); // Once button was held long enough we don't consider it a
                  // tap-to-toggle-layer press anymore.
      if (g.NavWindowingToggleLayer && g.NavWindow)
        apply_toggle_layer = true;
      else if (!g.NavWindowingToggleLayer)
        apply_focus_window = g.NavWindowingTarget;
      g.NavWindowingTarget = NULL;
    }
  }

  // Keyboard: Focus
  if (g.NavWindowingTarget && g.NavInputSource == InputSource_Keyboard) {
    // Visuals only appears after a brief time after pressing TAB the first
    // time, so that a fast CTRL+TAB doesn't add visual noise
    KeyChord shared_mods =
        ((g.ConfigNavWindowingKeyNext ? g.ConfigNavWindowingKeyNext
                                      : Mod_Mask_) &
         (g.ConfigNavWindowingKeyPrev ? g.ConfigNavWindowingKeyPrev
                                      : Mod_Mask_)) &
        Mod_Mask_;
    GUI_ASSERT(
        shared_mods !=
        0); // Next/Prev shortcut currently needs a shared modifier to "hold",
            // otherwise Prev actions would keep cycling between two windows.
    g.NavWindowingHighlightAlpha =
        Max(g.NavWindowingHighlightAlpha,
            Saturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) /
                     0.05f)); // 1.0f
    if (keyboard_next_window || keyboard_prev_window)
      NavUpdateWindowingHighlightWindow(keyboard_next_window ? -1 : +1);
    else if ((io.KeyMods & shared_mods) != shared_mods)
      apply_focus_window = g.NavWindowingTarget;
  }

  // Keyboard: Press and Release ALT to toggle menu layer
  // - Testing that only Alt is tested prevents Alt+Shift or AltGR from toggling
  // menu layer.
  // - AltGR is normally Alt+Ctrl but we can't reliably detect it (not all
  // backends/systems/layout emit it as Alt+Ctrl). But even on keyboards without
  // AltGR we don't want Alt+Ctrl to open menu anyway.
  if (nav_keyboard_active && IsKeyPressed(Mod_Alt, KeyOwner_None)) {
    g.NavWindowingToggleLayer = true;
    g.NavInputSource = InputSource_Keyboard;
  }
  if (g.NavWindowingToggleLayer && g.NavInputSource == InputSource_Keyboard) {
    // We cancel toggling nav layer when any text has been typed (generally
    // while holding Alt). (See #370) We cancel toggling nav layer when other
    // modifiers are pressed. (See #4439) We cancel toggling nav layer if an
    // owner has claimed the key.
    if (io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift ||
        io.KeySuper || TestKeyOwner(Mod_Alt, KeyOwner_None) == false)
      g.NavWindowingToggleLayer = false;

    // Apply layer toggle on release
    // Important: as before version <18314 we lacked an explicit IO event for
    // focus gain/loss, we also compare mouse validity to detect old backends
    // clearing mouse pos on focus loss.
    if (IsKeyReleased(Mod_Alt) && g.NavWindowingToggleLayer)
      if (g.ActiveId == 0 || g.ActiveIdAllowOverlap)
        if (IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev))
          apply_toggle_layer = true;
    if (!IsKeyDown(Mod_Alt))
      g.NavWindowingToggleLayer = false;
  }

  // Move window
  if (g.NavWindowingTarget &&
      !(g.NavWindowingTarget->Flags & WindowFlags_NoMove)) {
    Vec2 nav_move_dir;
    if (g.NavInputSource == InputSource_Keyboard && !io.KeyShift)
      nav_move_dir = GetKeyMagnitude2d(Key_LeftArrow, Key_RightArrow,
                                       Key_UpArrow, Key_DownArrow);
    if (g.NavInputSource == InputSource_Gamepad)
      nav_move_dir =
          GetKeyMagnitude2d(Key_GamepadLStickLeft, Key_GamepadLStickRight,
                            Key_GamepadLStickUp, Key_GamepadLStickDown);
    if (nav_move_dir.x != 0.0f || nav_move_dir.y != 0.0f) {
      const float NAV_MOVE_SPEED = 800.0f;
      const float move_step =
          NAV_MOVE_SPEED * io.DeltaTime *
          Min(io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);
      g.NavWindowingAccumDeltaPos =
          Add(g.NavWindowingAccumDeltaPos, Multiply(nav_move_dir, move_step));
      g.NavDisableMouseHover = true;
      Vec2 accum_floored = Trunc(g.NavWindowingAccumDeltaPos);
      if (accum_floored.x != 0.0f || accum_floored.y != 0.0f) {
        Window *moving_window = g.NavWindowingTarget->RootWindow;
        SetWindowPos(moving_window, Add(moving_window->Pos, accum_floored),
                     Cond_Always);
        g.NavWindowingAccumDeltaPos =
            Subtract(g.NavWindowingAccumDeltaPos, accum_floored);
      }
    }
  }

  // Apply final focus
  if (apply_focus_window &&
      (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow)) {
    ClearActiveID();
    NavRestoreHighlightAfterMove();
    ClosePopupsOverWindow(apply_focus_window, false);
    FocusWindow(apply_focus_window, FocusRequestFlags_RestoreFocusedChild);
    apply_focus_window = g.NavWindow;
    if (apply_focus_window->NavLastIds[0] == 0)
      NavInitWindow(apply_focus_window, false);

    // If the window has ONLY a menu layer (no main layer), select it directly
    // Use NavLayersActiveMaskNext since windows didn't have a chance to be
    // Begin()-ed on this frame, so CTRL+Tab where the keys are only held for 1
    // frame will be able to use correct layers mask since the target window as
    // already been previewed once.
    // FIXME-NAV: This should be done in NavInit.. or in FocusWindow... However
    // in both of those cases, we won't have a guarantee that windows has been
    // visible before and therefore NavLayersActiveMask* won't be valid.
    if (apply_focus_window->DC.NavLayersActiveMaskNext == (1 << NavLayer_Menu))
      g.NavLayer = NavLayer_Menu;
  }
  if (apply_focus_window)
    g.NavWindowingTarget = NULL;

  // Apply menu/layer toggle
  if (apply_toggle_layer && g.NavWindow) {
    ClearActiveID();

    // Move to parent menu if necessary
    Window *new_nav_window = g.NavWindow;
    while (
        new_nav_window->ParentWindow &&
        (new_nav_window->DC.NavLayersActiveMask & (1 << NavLayer_Menu)) == 0 &&
        (new_nav_window->Flags & WindowFlags_ChildWindow) != 0 &&
        (new_nav_window->Flags & (WindowFlags_Popup | WindowFlags_ChildMenu)) ==
            0)
      new_nav_window = new_nav_window->ParentWindow;
    if (new_nav_window != g.NavWindow) {
      Window *old_nav_window = g.NavWindow;
      FocusWindow(new_nav_window);
      new_nav_window->NavLastChildNavWindow = old_nav_window;
    }

    // Toggle layer
    const NavLayer new_nav_layer =
        (g.NavWindow->DC.NavLayersActiveMask & (1 << NavLayer_Menu))
            ? (NavLayer)((int)g.NavLayer ^ 1)
            : NavLayer_Main;
    if (new_nav_layer != g.NavLayer) {
      // Reinitialize navigation when entering menu bar with the Alt key (FIXME:
      // could be a properly of the layer?)
      if (new_nav_layer == NavLayer_Menu)
        g.NavWindow->NavLastIds[new_nav_layer] = 0;
      NavRestoreLayer(new_nav_layer);
      NavRestoreHighlightAfterMove();
    }
  }
}

// Window has already passed the IsWindowNavFocusable()
static const char *GetFallbackWindowNameForWindowingList(Window *window) {
  if (window->Flags & WindowFlags_Popup)
    return Gui::LocalizeGetMsg(LocKey_WindowingPopup);
  if ((window->Flags & WindowFlags_MenuBar) &&
      strcmp(window->Name, "##MainMenuBar") == 0)
    return Gui::LocalizeGetMsg(LocKey_WindowingMainMenuBar);
  return Gui::LocalizeGetMsg(LocKey_WindowingUntitled);
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
void Gui::NavUpdateWindowingOverlay() {
  Context &g = *GGui;
  GUI_ASSERT(g.NavWindowingTarget != NULL);

  if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)
    return;

  if (g.NavWindowingListWindow == NULL)
    g.NavWindowingListWindow = FindWindowByName("###NavWindowingList");
  const Viewport *viewport = GetMainViewport();
  SetNextWindowSizeConstraints(
      Vec2(viewport->Size.x * 0.20f, viewport->Size.y * 0.20f),
      Vec2(FLT_MAX, FLT_MAX));
  SetNextWindowPos(viewport->GetCenter(), Cond_Always, Vec2(0.5f, 0.5f));
  PushStyleVar(StyleVar_WindowPadding, Multiply(g.Style.WindowPadding, 2.0f));
  Begin("###NavWindowingList", NULL,
        WindowFlags_NoTitleBar | WindowFlags_NoFocusOnAppearing |
            WindowFlags_NoResize | WindowFlags_NoMove | WindowFlags_NoInputs |
            WindowFlags_AlwaysAutoResize | WindowFlags_NoSavedSettings);
  for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--) {
    Window *window = g.WindowsFocusOrder[n];
    GUI_ASSERT(window != NULL); // Fix static analyzers
    if (!IsWindowNavFocusable(window))
      continue;
    const char *label = window->Name;
    if (label == FindRenderedTextEnd(label))
      label = GetFallbackWindowNameForWindowingList(window);
    Selectable(label, g.NavWindowingTarget == window);
  }
  End();
  PopStyleVar();
}

//-----------------------------------------------------------------------------
// [SECTION] DRAG AND DROP
//-----------------------------------------------------------------------------

inline void Gui::ClearDragDrop() {
  Context &g = *GGui;
  g.DragDropActive = false;
  g.DragDropPayload.Clear();
  g.DragDropAcceptFlags = DragDropFlags_None;
  g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
  g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
  g.DragDropAcceptFrameCount = -1;

  g.DragDropPayloadBufHeap.clear();
  memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
}

// When this returns true you need to: a) call SetDragDropPayload() exactly
// once, b) you may render the payload visual/description, c) call
// EndDragDropSource() If the item has an identifier:
// - This assume/require the item to be activated (typically via
// ButtonBehavior).
// - Therefore if you want to use this with a mouse button other than left mouse
// button, it is up to the item itself to activate with another button.
// - We then pull and use the mouse button that was used to activate the item
// and use it to carry on the drag. If the item has no identifier:
// - Currently always assume left mouse button.
inline bool Gui::BeginDragDropSource(DragDropFlags flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  // FIXME-DRAGDROP: While in the common-most "drag from non-zero active id"
  // case we can tell the mouse button, in both SourceExtern and id==0 cases we
  // may requires something else (explicit flags or some heuristic).
  MouseButton mouse_button = MouseButton_Left;

  bool source_drag_active = false;
  ID source_id = 0;
  ID source_parent_id = 0;
  if (!(flags & DragDropFlags_SourceExtern)) {
    source_id = g.LastItemData.ID;
    if (source_id != 0) {
      // Common path: items with ID
      if (g.ActiveId != source_id)
        return false;
      if (g.ActiveIdMouseButton != -1)
        mouse_button = g.ActiveIdMouseButton;
      if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
        return false;
      g.ActiveIdAllowOverlap = false;
    } else {
      // Uncommon path: items without ID
      if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
        return false;
      if ((g.LastItemData.StatusFlags & ItemStatusFlags_HoveredRect) == 0 &&
          (g.ActiveId == 0 || g.ActiveIdWindow != window))
        return false;

      // If you want to use BeginDragDropSource() on an item with no unique
      // identifier for interaction, such as Text() or Image(), you need to: A)
      // Read the explanation below, B) Use the
      // DragDropFlags_SourceAllowNullID flag.
      if (!(flags & DragDropFlags_SourceAllowNullID)) {
        GUI_ASSERT(0);
        return false;
      }

      // Magic fallback to handle items with no assigned ID, e.g. Text(),
      // Image() We build a throwaway ID based on current ID stack + relative
      // AABB of items in window. THE IDENTIFIER WON'T SURVIVE ANY
      // REPOSITIONING/RESIZINGG OF THE WIDGET, so if your widget moves your
      // dragging operation will be canceled. We don't need to maintain/call
      // ClearActiveID() as releasing the button will early out this function
      // and trigger !ActiveIdIsAlive. Rely on keeping other window->LastItemXXX
      // fields intact.
      source_id = g.LastItemData.ID =
          window->GetIDFromRectangle(g.LastItemData.Rect);
      KeepAliveID(source_id);
      bool is_hovered =
          ItemHoverable(g.LastItemData.Rect, source_id, g.LastItemData.InFlags);
      if (is_hovered && g.IO.MouseClicked[mouse_button]) {
        SetActiveID(source_id, window);
        FocusWindow(window);
      }
      if (g.ActiveId ==
          source_id) // Allow the underlying widget to display/return hovered
                     // during the mouse release frame, else we would get a
                     // flicker.
        g.ActiveIdAllowOverlap = is_hovered;
    }
    if (g.ActiveId != source_id)
      return false;
    source_parent_id = window->IDStack.back();
    source_drag_active = IsMouseDragging(mouse_button);

    // Disable navigation and key inputs while dragging + cancel existing
    // request if any
    SetActiveIdUsingAllKeyboardKeys();
  } else {
    window = NULL;
    source_id = HashStr("#SourceExtern");
    source_drag_active = true;
  }

  if (source_drag_active) {
    if (!g.DragDropActive) {
      GUI_ASSERT(source_id != 0);
      ClearDragDrop();
      Payload &payload = g.DragDropPayload;
      payload.SourceId = source_id;
      payload.SourceParentId = source_parent_id;
      g.DragDropActive = true;
      g.DragDropSourceFlags = flags;
      g.DragDropMouseButton = mouse_button;
      if (payload.SourceId == g.ActiveId)
        g.ActiveIdNoClearOnFocusLoss = true;
    }
    g.DragDropSourceFrameCount = g.FrameCount;
    g.DragDropWithinSource = true;

    if (!(flags & DragDropFlags_SourceNoPreviewTooltip)) {
      // Target can request the Source to not display its tooltip (we use a
      // dedicated flag to make this request explicit) We unfortunately can't
      // just modify the source flags and skip the call to BeginTooltip, as
      // caller may be emitting contents.
      bool ret;
      if (g.DragDropAcceptIdPrev &&
          (g.DragDropAcceptFlags & DragDropFlags_AcceptNoPreviewTooltip))
        ret = BeginTooltipHidden();
      else
        ret = BeginTooltip();
      GUI_ASSERT(ret); // FIXME-NEWBEGIN: If this ever becomes false, we need to
                       // Begin("##Hidden", NULL, WindowFlags_NoSavedSettings)
                       // + SetWindowHiddendAndSkipItemsForCurrentFrame().
      GUI_UNUSED(ret);
    }

    if (!(flags & DragDropFlags_SourceNoDisableHover) &&
        !(flags & DragDropFlags_SourceExtern))
      g.LastItemData.StatusFlags &= ~ItemStatusFlags_HoveredRect;

    return true;
  }
  return false;
}

inline void Gui::EndDragDropSource() {
  Context &g = *GGui;
  GUI_ASSERT(g.DragDropActive);
  GUI_ASSERT(g.DragDropWithinSource && "Not after a BeginDragDropSource()?");

  if (!(g.DragDropSourceFlags & DragDropFlags_SourceNoPreviewTooltip))
    EndTooltip();

  // Discard the drag if have not called SetDragDropPayload()
  if (g.DragDropPayload.DataFrameCount == -1)
    ClearDragDrop();
  g.DragDropWithinSource = false;
}

// Use 'cond' to choose to submit payload on drag start or every frame
inline bool Gui::SetDragDropPayload(const char *type, const void *data,
                                    size_t data_size, Cond cond) {
  Context &g = *GGui;
  Payload &payload = g.DragDropPayload;
  if (cond == 0)
    cond = Cond_Always;

  GUI_ASSERT(type != NULL);
  GUI_ASSERT(strlen(type) < GUI_ARRAYSIZE(payload.DataType) &&
             "Payload type can be at most 32 characters long");
  GUI_ASSERT((data != NULL && data_size > 0) ||
             (data == NULL && data_size == 0));
  GUI_ASSERT(cond == Cond_Always || cond == Cond_Once);
  GUI_ASSERT(
      payload.SourceId !=
      0); // Not called between BeginDragDropSource() and EndDragDropSource()

  if (cond == Cond_Always || payload.DataFrameCount == -1) {
    // Copy payload
    Strncpy(payload.DataType, type, GUI_ARRAYSIZE(payload.DataType));
    g.DragDropPayloadBufHeap.resize(0);
    if (data_size > sizeof(g.DragDropPayloadBufLocal)) {
      // Store in heap
      g.DragDropPayloadBufHeap.resize((int)data_size);
      payload.Data = g.DragDropPayloadBufHeap.Data;
      memcpy(payload.Data, data, data_size);
    } else if (data_size > 0) {
      // Store locally
      memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
      payload.Data = g.DragDropPayloadBufLocal;
      memcpy(payload.Data, data, data_size);
    } else {
      payload.Data = NULL;
    }
    payload.DataSize = (int)data_size;
  }
  payload.DataFrameCount = g.FrameCount;

  // Return whether the payload has been accepted
  return (g.DragDropAcceptFrameCount == g.FrameCount) ||
         (g.DragDropAcceptFrameCount == g.FrameCount - 1);
}

inline bool Gui::BeginDragDropTargetCustom(const Rect &bb, ID id) {
  Context &g = *GGui;
  if (!g.DragDropActive)
    return false;

  Window *window = g.CurrentWindow;
  Window *hovered_window = g.HoveredWindowUnderMovingWindow;
  if (hovered_window == NULL ||
      window->RootWindow != hovered_window->RootWindow)
    return false;
  GUI_ASSERT(id != 0);
  if (!IsMouseHoveringRect(bb.Min, bb.Max) ||
      (id == g.DragDropPayload.SourceId))
    return false;
  if (window->SkipItems)
    return false;

  GUI_ASSERT(g.DragDropWithinTarget == false);
  g.DragDropTargetRect = bb;
  g.DragDropTargetClipRect =
      window
          ->ClipRect; // May want to be overriden by user depending on use case?
  g.DragDropTargetId = id;
  g.DragDropWithinTarget = true;
  return true;
}

// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemData's ItemStatusFlags_HoveredRect which handles items
// that push a temporarily clip rectangle in their code. Calling
// BeginDragDropTargetCustom(LastItemRect) would not handle them. 2) and it's
// faster. as this code may be very frequently called, we want to early out as
// fast as we can. Also note how the HoveredWindow test is positioned
// differently in both functions (in both functions we optimize for the cheapest
// early out case)
inline bool Gui::BeginDragDropTarget() {
  Context &g = *GGui;
  if (!g.DragDropActive)
    return false;

  Window *window = g.CurrentWindow;
  if (!(g.LastItemData.StatusFlags & ItemStatusFlags_HoveredRect))
    return false;
  Window *hovered_window = g.HoveredWindowUnderMovingWindow;
  if (hovered_window == NULL ||
      window->RootWindow != hovered_window->RootWindow || window->SkipItems)
    return false;

  const Rect &display_rect =
      (g.LastItemData.StatusFlags & ItemStatusFlags_HasDisplayRect)
          ? g.LastItemData.DisplayRect
          : g.LastItemData.Rect;
  ID id = g.LastItemData.ID;
  if (id == 0) {
    id = window->GetIDFromRectangle(display_rect);
    KeepAliveID(id);
  }
  if (g.DragDropPayload.SourceId == id)
    return false;

  GUI_ASSERT(g.DragDropWithinTarget == false);
  g.DragDropTargetRect = display_rect;
  g.DragDropTargetClipRect =
      (g.LastItemData.StatusFlags & ItemStatusFlags_HasClipRect)
          ? g.LastItemData.ClipRect
          : window->ClipRect;
  g.DragDropTargetId = id;
  g.DragDropWithinTarget = true;
  return true;
}

inline const Payload *Gui::AcceptDragDropPayload(const char *type,
                                                 DragDropFlags flags) {
  Context &g = *GGui;
  Payload &payload = g.DragDropPayload;
  GUI_ASSERT(g.DragDropActive); // Not called between BeginDragDropTarget() and
                                // EndDragDropTarget() ?
  GUI_ASSERT(payload.DataFrameCount !=
             -1); // Forgot to call EndDragDropTarget() ?
  if (type != NULL && !payload.IsDataType(type))
    return NULL;

  // Accept smallest drag target bounding box, this allows us to nest drag
  // targets conveniently without ordering constraints. NB: We currently accept
  // NULL id as target. However, overlapping targets requires a unique ID to
  // function!
  const bool was_accepted_previously =
      (g.DragDropAcceptIdPrev == g.DragDropTargetId);
  Rect r = g.DragDropTargetRect;
  float r_surface = r.GetWidth() * r.GetHeight();
  if (r_surface > g.DragDropAcceptIdCurrRectSurface)
    return NULL;

  g.DragDropAcceptFlags = flags;
  g.DragDropAcceptIdCurr = g.DragDropTargetId;
  g.DragDropAcceptIdCurrRectSurface = r_surface;
  // GUI_DEBUG_LOG("AcceptDragDropPayload(): %08X: accept\n",
  // g.DragDropTargetId);

  // Render default drop visuals
  payload.Preview = was_accepted_previously;
  flags |= (g.DragDropSourceFlags &
            DragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit
                                                    // the preview (useful for
                                                    // external sources that
                                                    // live for 1 frame)
  if (!(flags & DragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
    RenderDragDropTargetRect(r, g.DragDropTargetClipRect);

  g.DragDropAcceptFrameCount = g.FrameCount;
  payload.Delivery =
      was_accepted_previously &&
      !IsMouseDown(
          g.DragDropMouseButton); // For extern drag sources affecting OS window
                                  // focus, it's easier to just test
                                  // !IsMouseDown() instead of IsMouseReleased()
  if (!payload.Delivery && !(flags & DragDropFlags_AcceptBeforeDelivery))
    return NULL;

  // GUI_DEBUG_LOG("AcceptDragDropPayload(): %08X: return payload\n",
  // g.DragDropTargetId);
  return &payload;
}

// FIXME-STYLE FIXME-DRAGDROP: Settle on a proper default visuals for drop
// target.

inline const Payload *Gui::GetDragDropPayload() {
  Context &g = *GGui;
  return (g.DragDropActive && g.DragDropPayload.DataFrameCount != -1)
             ? &g.DragDropPayload
             : NULL;
}

inline void Gui::EndDragDropTarget() {
  Context &g = *GGui;
  GUI_ASSERT(g.DragDropActive);
  GUI_ASSERT(g.DragDropWithinTarget);
  g.DragDropWithinTarget = false;

  // Clear drag and drop state payload right after delivery
  if (g.DragDropPayload.Delivery)
    ClearDragDrop();
}

//-----------------------------------------------------------------------------
// [SECTION] LOGGING/CAPTURING
//-----------------------------------------------------------------------------
// All text output from the interface can be captured into tty/file/clipboard.
// By default, tree nodes are automatically opened during logging.
//-----------------------------------------------------------------------------

// Pass text data straight to log (without being displayed)
static inline void LogTextV(Context &g, const char *fmt, va_list args) {
  if (g.LogFile) {
    g.LogBuffer.Buf.resize(0);
    g.LogBuffer.appendfv(fmt, args);
    FileWrite(g.LogBuffer.c_str(), sizeof(char), (U64)g.LogBuffer.size(),
              g.LogFile);
  } else {
    g.LogBuffer.appendfv(fmt, args);
  }
}

inline void Gui::LogText(const char *fmt, ...) {
  Context &g = *GGui;
  if (!g.LogEnabled)
    return;

  va_list args;
  va_start(args, fmt);
  LogTextV(g, fmt, args);
  va_end(args);
}

inline void Gui::LogTextV(const char *fmt, va_list args) {
  Context &g = *GGui;
  if (!g.LogEnabled)
    return;

  LogTextV(g, fmt, args);
}

// Internal version that takes a position to decide on newline placement and pad
// items according to their depth. We split text into individual lines to add
// current tree level padding
// FIXME: This code is a little complicated perhaps, considering simplifying the
// whole system.
inline void Gui::LogRenderedText(const Vec2 *ref_pos, const char *text,
                                 const char *text_end) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  const char *prefix = g.LogNextPrefix;
  const char *suffix = g.LogNextSuffix;
  g.LogNextPrefix = g.LogNextSuffix = NULL;

  if (!text_end)
    text_end = FindRenderedTextEnd(text, text_end);

  const bool log_new_line =
      ref_pos && (ref_pos->y > g.LogLinePosY + g.Style.FramePadding.y + 1);
  if (ref_pos)
    g.LogLinePosY = ref_pos->y;
  if (log_new_line) {
    LogText(GUI_NEWLINE);
    g.LogLineFirstItem = true;
  }

  if (prefix)
    LogRenderedText(ref_pos, prefix,
                    prefix + strlen(prefix)); // Calculate end ourself to ensure
                                              // "##" are included here.

  // Re-adjust padding if we have popped out of our starting depth
  if (g.LogDepthRef > window->DC.TreeDepth)
    g.LogDepthRef = window->DC.TreeDepth;
  const int tree_depth = (window->DC.TreeDepth - g.LogDepthRef);

  const char *text_remaining = text;
  for (;;) {
    // Split the string. Each new line (after a '\n') is followed by indentation
    // corresponding to the current depth of our log entry. We don't add a
    // trailing \n yet to allow a subsequent item on the same line to be
    // captured.
    const char *line_start = text_remaining;
    const char *line_end = StreolRange(line_start, text_end);
    const bool is_last_line = (line_end == text_end);
    if (line_start != line_end || !is_last_line) {
      const int line_length = (int)(line_end - line_start);
      const int indentation = g.LogLineFirstItem ? tree_depth * 4 : 1;
      LogText("%*s%.*s", indentation, "", line_length, line_start);
      g.LogLineFirstItem = false;
      if (*line_end == '\n') {
        LogText(GUI_NEWLINE);
        g.LogLineFirstItem = true;
      }
    }
    if (is_last_line)
      break;
    text_remaining = line_end + 1;
  }

  if (suffix)
    LogRenderedText(ref_pos, suffix, suffix + strlen(suffix));
}

// Start logging/capturing text output
inline void Gui::LogBegin(LogType type, int auto_open_depth) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_ASSERT(g.LogEnabled == false);
  GUI_ASSERT(g.LogFile == NULL);
  GUI_ASSERT(g.LogBuffer.empty());
  g.LogEnabled = true;
  g.LogType = type;
  g.LogNextPrefix = g.LogNextSuffix = NULL;
  g.LogDepthRef = window->DC.TreeDepth;
  g.LogDepthToExpand =
      ((auto_open_depth >= 0) ? auto_open_depth : g.LogDepthToExpandDefault);
  g.LogLinePosY = FLT_MAX;
  g.LogLineFirstItem = true;
}

// Important: doesn't copy underlying data, use carefully (prefix/suffix must be
// in scope at the time of the next LogRenderedText)

inline void Gui::LogToTTY(int auto_open_depth) {
  Context &g = *GGui;
  if (g.LogEnabled)
    return;
  GUI_UNUSED(auto_open_depth);
#ifndef GUI_DISABLE_TTY_FUNCTIONS
  LogBegin(LogType_TTY, auto_open_depth);
  g.LogFile = stdout;
#endif
}

// Start logging/capturing text output to given file
inline void Gui::LogToFile(int auto_open_depth, const char *filename) {
  Context &g = *GGui;
  if (g.LogEnabled)
    return;

  // FIXME: We could probably open the file in text mode "at", however note that
  // clipboard/buffer logging will still be subject to outputting
  // OS-incompatible carriage return if within strings the user doesn't use
  // GUI_NEWLINE. By opening the file in binary mode "ab" we have consistent
  // output everywhere.
  if (!filename)
    filename = g.IO.LogFilename;
  if (!filename || !filename[0])
    return;
  FileHandle f = FileOpen(filename, "ab");
  if (!f) {
    GUI_ASSERT(0);
    return;
  }

  LogBegin(LogType_File, auto_open_depth);
  g.LogFile = f;
}

// Start logging/capturing text output to clipboard
inline void Gui::LogToClipboard(int auto_open_depth) {
  Context &g = *GGui;
  if (g.LogEnabled)
    return;
  LogBegin(LogType_Clipboard, auto_open_depth);
}

inline void Gui::LogFinish() {
  Context &g = *GGui;
  if (!g.LogEnabled)
    return;

  LogText(GUI_NEWLINE);
  switch (g.LogType) {
  case LogType_TTY:
#ifndef GUI_DISABLE_TTY_FUNCTIONS
    fflush(g.LogFile);
#endif
    break;
  case LogType_File:
    FileClose(g.LogFile);
    break;
  case LogType_Buffer:
    break;
  case LogType_Clipboard:
    if (!g.LogBuffer.empty())
      SetClipboardText(g.LogBuffer.begin());
    break;
  case LogType_None:
    GUI_ASSERT(0);
    break;
  }

  g.LogEnabled = false;
  g.LogType = LogType_None;
  g.LogFile = NULL;
  g.LogBuffer.clear();
}

// Helper to display logging buttons
// FIXME-OBSOLETE: We should probably obsolete this and let the user have their
// own helper (this is one of the oldest function alive!)
inline void Gui::LogButtons() {
  Context &g = *GGui;

  PushID("LogButtons");
#ifndef GUI_DISABLE_TTY_FUNCTIONS
  const bool log_to_tty = Button("Log To TTY");
  SameLine();
#else
  const bool log_to_tty = false;
#endif
  const bool log_to_file = Button("Log To File");
  SameLine();
  const bool log_to_clipboard = Button("Log To Clipboard");
  SameLine();
  PushTabStop(false);
  SetNextItemWidth(80.0f);
  SliderInt("Default Depth", &g.LogDepthToExpandDefault, 0, 9, NULL);
  PopTabStop();
  PopID();

  // Start logging at the end of the function so that the buttons don't appear
  // in the log
  if (log_to_tty)
    LogToTTY();
  if (log_to_file)
    LogToFile();
  if (log_to_clipboard)
    LogToClipboard();
}

//-----------------------------------------------------------------------------
// [SECTION] SETTINGS
//-----------------------------------------------------------------------------
// - UpdateSettings() [Internal]
// - MarkIniSettingsDirty() [Internal]
// - FindSettingsHandler() [Internal]
// - ClearIniSettings() [Internal]
// - LoadIniSettingsFromDisk()
// - LoadIniSettingsFromMemory()
// - SaveIniSettingsToDisk()
// - SaveIniSettingsToMemory()
//-----------------------------------------------------------------------------
// - CreateNewWindowSettings() [Internal]
// - FindWindowSettingsByID() [Internal]
// - FindWindowSettingsByWindow() [Internal]
// - ClearWindowSettings() [Internal]
// - WindowSettingsHandler_***() [Internal]
//-----------------------------------------------------------------------------

// Called by NewFrame()
void Gui::UpdateSettings() {
  // Load settings on first frame (if not explicitly loaded manually before)
  Context &g = *GGui;
  if (!g.SettingsLoaded) {
    GUI_ASSERT(g.SettingsWindows.empty());
    if (g.IO.IniFilename)
      LoadIniSettingsFromDisk(g.IO.IniFilename);
    g.SettingsLoaded = true;
  }

  // Save settings (with a delay after the last modification, so we don't spam
  // disk too much)
  if (g.SettingsDirtyTimer > 0.0f) {
    g.SettingsDirtyTimer -= g.IO.DeltaTime;
    if (g.SettingsDirtyTimer <= 0.0f) {
      if (g.IO.IniFilename != NULL)
        SaveIniSettingsToDisk(g.IO.IniFilename);
      else
        g.IO.WantSaveIniSettings =
            true; // Let user know they can call SaveIniSettingsToMemory(). user
                  // will need to clear io.WantSaveIniSettings themselves.
      g.SettingsDirtyTimer = 0.0f;
    }
  }
}

inline void Gui::AddSettingsHandler(const SettingsHandler *handler) {
  Context &g = *GGui;
  GUI_ASSERT(FindSettingsHandler(handler->TypeName) == NULL);
  g.SettingsHandlers.push_back(*handler);
}

inline void Gui::RemoveSettingsHandler(const char *type_name) {
  Context &g = *GGui;
  if (SettingsHandler *handler = FindSettingsHandler(type_name))
    g.SettingsHandlers.erase(handler);
}

// Clear all settings (windows, tables, docking etc.)

inline void Gui::LoadIniSettingsFromDisk(const char *ini_filename) {
  size_t file_data_size = 0;
  char *file_data =
      (char *)FileLoadToMemory(ini_filename, "rb", &file_data_size);
  if (!file_data)
    return;
  if (file_data_size > 0)
    LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
  GUI_FREE(file_data);
}

// Zero-tolerance, no error reporting, cheap .ini parsing
// Set ini_size==0 to let us use strlen(ini_data). Do not call this function
// with a 0 if your buffer is actually empty!
inline void Gui::LoadIniSettingsFromMemory(const char *ini_data,
                                           size_t ini_size) {
  Context &g = *GGui;
  GUI_ASSERT(g.Initialized);
  // GUI_ASSERT(!g.WithinFrameScope && "Cannot be called between NewFrame() and
  // EndFrame()"); GUI_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);

  // For user convenience, we allow passing a non zero-terminated string (hence
  // the ini_size parameter). For our convenience and to make the code simpler,
  // we'll also write zero-terminators within the buffer. So let's create a
  // writable copy..
  if (ini_size == 0)
    ini_size = strlen(ini_data);
  g.SettingsIniData.Buf.resize((int)ini_size + 1);
  char *const buf = g.SettingsIniData.Buf.Data;
  char *const buf_end = buf + ini_size;
  memcpy(buf, ini_data, ini_size);
  buf_end[0] = 0;

  // Call pre-read handlers
  // Some types will clear their data (e.g. dock information) some types will
  // allow merge/override (window)
  for (SettingsHandler &handler : g.SettingsHandlers)
    if (handler.ReadInitFn != NULL)
      handler.ReadInitFn(&g, &handler);

  void *entry_data = NULL;
  SettingsHandler *entry_handler = NULL;

  char *line_end = NULL;
  for (char *line = buf; line < buf_end; line = line_end + 1) {
    // Skip new lines markers, then find end of the line
    while (*line == '\n' || *line == '\r')
      line++;
    line_end = line;
    while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
      line_end++;
    line_end[0] = 0;
    if (line[0] == ';')
      continue;
    if (line[0] == '[' && line_end > line && line_end[-1] == ']') {
      // Parse "[Type][Name]". Note that 'Name' can itself contains []
      // characters, which is acceptable with the current format and parsing
      // code.
      line_end[-1] = 0;
      const char *name_end = line_end - 1;
      const char *type_start = line + 1;
      char *type_end = (char *)(void *)StrchrRange(type_start, name_end, ']');
      const char *name_start =
          type_end ? StrchrRange(type_end + 1, name_end, '[') : NULL;
      if (!type_end || !name_start)
        continue;
      *type_end = 0; // Overwrite first ']'
      name_start++;  // Skip second '['
      entry_handler = FindSettingsHandler(type_start);
      entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler,
                                                             name_start)
                                 : NULL;
    } else if (entry_handler != NULL && entry_data != NULL) {
      // Let type handler parse the line
      entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
    }
  }
  g.SettingsLoaded = true;

  // [DEBUG] Restore untouched copy so it can be browsed in Metrics (not
  // strictly necessary)
  memcpy(buf, ini_data, ini_size);

  // Call post-read handlers
  for (SettingsHandler &handler : g.SettingsHandlers)
    if (handler.ApplyAllFn != NULL)
      handler.ApplyAllFn(&g, &handler);
}

inline void Gui::SaveIniSettingsToDisk(const char *ini_filename) {
  Context &g = *GGui;
  g.SettingsDirtyTimer = 0.0f;
  if (!ini_filename)
    return;

  size_t ini_data_size = 0;
  const char *ini_data = SaveIniSettingsToMemory(&ini_data_size);
  FileHandle f = FileOpen(ini_filename, "wt");
  if (!f)
    return;
  FileWrite(ini_data, sizeof(char), ini_data_size, f);
  FileClose(f);
}

// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom
// handlers) to write their stuff into a text buffer
inline const char *Gui::SaveIniSettingsToMemory(size_t *out_size) {
  Context &g = *GGui;
  g.SettingsDirtyTimer = 0.0f;
  g.SettingsIniData.Buf.resize(0);
  g.SettingsIniData.Buf.push_back(0);
  for (SettingsHandler &handler : g.SettingsHandlers)
    handler.WriteAllFn(&g, &handler, &g.SettingsIniData);
  if (out_size)
    *out_size = (size_t)g.SettingsIniData.size();
  return g.SettingsIniData.c_str();
}

inline WindowSettings *Gui::CreateNewWindowSettings(const char *name) {
  Context &g = *GGui;

  if (g.IO.ConfigDebugIniSettings == false) {
    // Skip to the "###" marker if any. We don't skip past to match the behavior
    // of GetID() Preserve the full string when ConfigDebugVerboseIniSettings is
    // set to make .ini inspection easier.
    if (const char *p = strstr(name, "###"))
      name = p;
  }
  const size_t name_len = strlen(name);

  // Allocate chunk
  const size_t chunk_size = sizeof(WindowSettings) + name_len + 1;
  WindowSettings *settings = g.SettingsWindows.alloc_chunk(chunk_size);
  GUI_PLACEMENT_NEW(settings) WindowSettings();
  settings->ID = HashStr(name, name_len);
  memcpy(settings->GetName(), name, name_len + 1); // Store with zero terminator

  return settings;
}

// We don't provide a FindWindowSettingsByName() because Docking system doesn't
// always hold on names. This is called once per window .ini entry + once per
// newly instantiated window.

// This is faster if you are holding on a Window already as we don't need to
// perform a search.

// This will revert window to its initial state, including enabling the
// Cond_FirstUseEver/Cond_Once conditions once more.
inline void Gui::ClearWindowSettings(const char *name) {
  // GUI_DEBUG_LOG("ClearWindowSettings('%s')\n", name);
  Window *window = FindWindowByName(name);
  if (window != NULL) {
    window->Flags |= WindowFlags_NoSavedSettings;
    InitOrLoadWindowSettings(window, NULL);
  }
  if (WindowSettings *settings = window ? FindWindowSettingsByWindow(window)
                                        : FindWindowSettingsByID(HashStr(name)))
    settings->WantDelete = true;
}

static void WindowSettingsHandler_ClearAll(Context *ctx, SettingsHandler *) {
  Context &g = *ctx;
  for (Window *window : g.Windows)
    window->SettingsOffset = -1;
  g.SettingsWindows.clear();
}

static void *WindowSettingsHandler_ReadOpen(Context *, SettingsHandler *,
                                            const char *name) {
  ID id = HashStr(name);
  WindowSettings *settings = Gui::FindWindowSettingsByID(id);
  if (settings)
    *settings = WindowSettings(); // Clear existing if recycling previous entry
  else
    settings = Gui::CreateNewWindowSettings(name);
  settings->ID = id;
  settings->WantApply = true;
  return (void *)settings;
}

static void WindowSettingsHandler_ReadLine(Context *, SettingsHandler *,
                                           void *entry, const char *line) {
  WindowSettings *settings = (WindowSettings *)entry;
  int x, y;
  int i;
  if (sscanf(line, "Pos=%i,%i", &x, &y) == 2) {
    settings->Pos = Vec2ih((short)x, (short)y);
  } else if (sscanf(line, "Size=%i,%i", &x, &y) == 2) {
    settings->Size = Vec2ih((short)x, (short)y);
  } else if (sscanf(line, "Collapsed=%d", &i) == 1) {
    settings->Collapsed = (i != 0);
  } else if (sscanf(line, "IsChild=%d", &i) == 1) {
    settings->IsChild = (i != 0);
  }
}

// Apply to existing windows (if any)
static void WindowSettingsHandler_ApplyAll(Context *ctx, SettingsHandler *) {
  Context &g = *ctx;
  for (WindowSettings *settings = g.SettingsWindows.begin(); settings != NULL;
       settings = g.SettingsWindows.next_chunk(settings))
    if (settings->WantApply) {
      if (Window *window = Gui::FindWindowByID(settings->ID))
        ApplyWindowSettings(window, settings);
      settings->WantApply = false;
    }
}

static void WindowSettingsHandler_WriteAll(Context *ctx,
                                           SettingsHandler *handler,
                                           TextBuffer *buf) {
  // Gather data from windows that were active during this session
  // (if a window wasn't opened in this session we preserve its settings)
  Context &g = *ctx;
  for (Window *window : g.Windows) {
    if (window->Flags & WindowFlags_NoSavedSettings)
      continue;

    WindowSettings *settings = Gui::FindWindowSettingsByWindow(window);
    if (!settings) {
      settings = Gui::CreateNewWindowSettings(window->Name);
      window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
    }
    GUI_ASSERT(settings->ID == window->ID);
    settings->Pos = Vec2ih(window->Pos);
    settings->Size = Vec2ih(window->SizeFull);
    settings->IsChild = (window->Flags & WindowFlags_ChildWindow) != 0;
    settings->Collapsed = window->Collapsed;
    settings->WantDelete = false;
  }

  // Write to text buffer
  buf->reserve(buf->size() + g.SettingsWindows.size() * 6); // ballpark reserve
  for (WindowSettings *settings = g.SettingsWindows.begin(); settings != NULL;
       settings = g.SettingsWindows.next_chunk(settings)) {
    if (settings->WantDelete)
      continue;
    const char *settings_name = settings->GetName();
    buf->appendf("[%s][%s]\n", handler->TypeName, settings_name);
    if (settings->IsChild) {
      buf->appendf("IsChild=1\n");
      buf->appendf("Size=%d,%d\n", settings->Size.x, settings->Size.y);
    } else {
      buf->appendf("Pos=%d,%d\n", settings->Pos.x, settings->Pos.y);
      buf->appendf("Size=%d,%d\n", settings->Size.x, settings->Size.y);
      if (settings->Collapsed)
        buf->appendf("Collapsed=1\n");
    }
    buf->append("\n");
  }
}

//-----------------------------------------------------------------------------
// [SECTION] LOCALIZATION
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
//-----------------------------------------------------------------------------
// - GetMainViewport()
// - SetWindowViewport() [Internal]
// - UpdateViewportsNewFrame() [Internal]
// (this section is more complete in the 'docking' branch)
//-----------------------------------------------------------------------------

inline Viewport *Gui::GetMainViewport() {
  Context &g = *GGui;
  return g.Viewports[0];
}

// Update viewports and monitor infos
static void Gui::UpdateViewportsNewFrame() {
  Context &g = *GGui;
  GUI_ASSERT(g.Viewports.Size == 1);

  // Update main viewport with current platform position.
  // FIXME-VIEWPORT: Size is driven by backend/user code for
  // backward-compatibility but we should aim to make this more consistent.
  ViewportP *main_viewport = g.Viewports[0];
  main_viewport->Flags =
      ViewportFlags_IsPlatformWindow | ViewportFlags_OwnedByApp;
  main_viewport->Pos = Vec2(0.0f, 0.0f);
  main_viewport->Size = g.IO.DisplaySize;

  for (ViewportP *viewport : g.Viewports) {
    // Lock down space taken by menu bars and status bars, reset the offset for
    // fucntions like BeginMainMenuBar() to alter them again.
    viewport->WorkOffsetMin = viewport->BuildWorkOffsetMin;
    viewport->WorkOffsetMax = viewport->BuildWorkOffsetMax;
    viewport->BuildWorkOffsetMin = viewport->BuildWorkOffsetMax =
        Vec2(0.0f, 0.0f);
    viewport->UpdateWorkRect();
  }
}

//-----------------------------------------------------------------------------
// [SECTION] DOCKING
//-----------------------------------------------------------------------------

// (this section is filled in the 'docking' branch)

//-----------------------------------------------------------------------------
// [SECTION] PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------

#if defined(_WIN32) && !defined(GUI_DISABLE_WIN32_FUNCTIONS) &&                \
    !defined(GUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)

#ifdef _MSC_VER
#pragma comment(lib, "user32")
#pragma comment(lib, "kernel32")
#endif

// Win32 clipboard implementation
// We use g.ClipboardHandlerData for temporary storage to ensure it is freed on
// Shutdown()
static const char *GetClipboardTextFn_DefaultImpl(void *user_data_ctx) {
  Context &g = *(Context *)user_data_ctx;
  g.ClipboardHandlerData.clear();
  if (!::OpenClipboard(NULL))
    return NULL;
  HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);
  if (wbuf_handle == NULL) {
    ::CloseClipboard();
    return NULL;
  }
  if (const WCHAR *wbuf_global = (const WCHAR *)::GlobalLock(wbuf_handle)) {
    int buf_len =
        ::WideCharToMultiByte(CP_UTF8, 0, wbuf_global, -1, NULL, 0, NULL, NULL);
    g.ClipboardHandlerData.resize(buf_len);
    ::WideCharToMultiByte(CP_UTF8, 0, wbuf_global, -1,
                          g.ClipboardHandlerData.Data, buf_len, NULL, NULL);
  }
  ::GlobalUnlock(wbuf_handle);
  ::CloseClipboard();
  return g.ClipboardHandlerData.Data;
}

static void SetClipboardTextFn_DefaultImpl(void *, const char *text) {
  if (!::OpenClipboard(NULL))
    return;
  const int wbuf_length = ::MultiByteToWideChar(CP_UTF8, 0, text, -1, NULL, 0);
  HGLOBAL wbuf_handle =
      ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(WCHAR));
  if (wbuf_handle == NULL) {
    ::CloseClipboard();
    return;
  }
  WCHAR *wbuf_global = (WCHAR *)::GlobalLock(wbuf_handle);
  ::MultiByteToWideChar(CP_UTF8, 0, text, -1, wbuf_global, wbuf_length);
  ::GlobalUnlock(wbuf_handle);
  ::EmptyClipboard();
  if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)
    ::GlobalFree(wbuf_handle);
  ::CloseClipboard();
}

#elif defined(__APPLE__) && TARGET_OS_OSX &&                                   \
    defined(GUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS)

#include <Carbon/Carbon.h> // Use old API to avoid need for separate .mm file
static PasteboardRef main_clipboard = 0;

// OSX clipboard implementation
// If you enable this you will need to add '-framework ApplicationServices' to
// your linker command-line!
static void SetClipboardTextFn_DefaultImpl(void *, const char *text) {
  if (!main_clipboard)
    PasteboardCreate(kPasteboardClipboard, &main_clipboard);
  PasteboardClear(main_clipboard);
  CFDataRef cf_data =
      CFDataCreate(kCFAllocatorDefault, (const UInt8 *)text, strlen(text));
  if (cf_data) {
    PasteboardPutItemFlavor(main_clipboard, (PasteboardItemID)1,
                            CFSTR("public.utf8-plain-text"), cf_data, 0);
    CFRelease(cf_data);
  }
}

static const char *GetClipboardTextFn_DefaultImpl(void *user_data_ctx) {
  Context &g = *(Context *)user_data_ctx;
  if (!main_clipboard)
    PasteboardCreate(kPasteboardClipboard, &main_clipboard);
  PasteboardSynchronize(main_clipboard);

  ItemCount item_count = 0;
  PasteboardGetItemCount(main_clipboard, &item_count);
  for (ItemCount i = 0; i < item_count; i++) {
    PasteboardItemID item_id = 0;
    PasteboardGetItemIdentifier(main_clipboard, i + 1, &item_id);
    CFArrayRef flavor_type_array = 0;
    PasteboardCopyItemFlavors(main_clipboard, item_id, &flavor_type_array);
    for (CFIndex j = 0, nj = CFArrayGetCount(flavor_type_array); j < nj; j++) {
      CFDataRef cf_data;
      if (PasteboardCopyItemFlavorData(main_clipboard, item_id,
                                       CFSTR("public.utf8-plain-text"),
                                       &cf_data) == noErr) {
        g.ClipboardHandlerData.clear();
        int length = (int)CFDataGetLength(cf_data);
        g.ClipboardHandlerData.resize(length + 1);
        CFDataGetBytes(cf_data, CFRangeMake(0, length),
                       (UInt8 *)g.ClipboardHandlerData.Data);
        g.ClipboardHandlerData[length] = 0;
        CFRelease(cf_data);
        return g.ClipboardHandlerData.Data;
      }
    }
  }
  return NULL;
}

#else

// Local Dear Gui-only clipboard implementation, if user hasn't defined better
// clipboard handlers.
static const char *GetClipboardTextFn_DefaultImpl(void *user_data_ctx) {
  Context &g = *(Context *)user_data_ctx;
  return g.ClipboardHandlerData.empty() ? NULL : g.ClipboardHandlerData.begin();
}

static void SetClipboardTextFn_DefaultImpl(void *user_data_ctx,
                                           const char *text) {
  Context &g = *(Context *)user_data_ctx;
  g.ClipboardHandlerData.clear();
  const char *text_end = text + strlen(text);
  g.ClipboardHandlerData.resize((int)(text_end - text) + 1);
  memcpy(&g.ClipboardHandlerData[0], text, (size_t)(text_end - text));
  g.ClipboardHandlerData[(int)(text_end - text)] = 0;
}

#endif

// Win32 API IME support (for Asian languages, etc.)
#if defined(_WIN32) && !defined(GUI_DISABLE_WIN32_FUNCTIONS) &&                \
    !defined(GUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)

#include <imm.h>
#ifdef _MSC_VER
#pragma comment(lib, "imm32")
#endif

static void SetPlatformImeDataFn_DefaultImpl(Viewport *viewport,
                                             PlatformImeData *data) {
  // Notify OS Input Method Editor of text input position
  HWND hwnd = (HWND)viewport->PlatformHandleRaw;
  if (hwnd == 0)
    return;

  //::ImmAssociateContextEx(hwnd, NULL, data->WantVisible ? IACE_DEFAULT : 0);
  if (HIMC himc = ::ImmGetContext(hwnd)) {
    COMPOSITIONFORM composition_form = {};
    composition_form.ptCurrentPos.x = (LONG)data->InputPos.x;
    composition_form.ptCurrentPos.y = (LONG)data->InputPos.y;
    composition_form.dwStyle = CFS_FORCE_POSITION;
    ::ImmSetCompositionWindow(himc, &composition_form);
    CANDIDATEFORM candidate_form = {};
    candidate_form.dwStyle = CFS_CANDIDATEPOS;
    candidate_form.ptCurrentPos.x = (LONG)data->InputPos.x;
    candidate_form.ptCurrentPos.y = (LONG)data->InputPos.y;
    ::ImmSetCandidateWindow(himc, &candidate_form);
    ::ImmReleaseContext(hwnd, himc);
  }
}

#else

static void SetPlatformImeDataFn_DefaultImpl(Viewport *, PlatformImeData *) {}

#endif

//-----------------------------------------------------------------------------
// [SECTION] METRICS/DEBUGGER WINDOW
//-----------------------------------------------------------------------------
// - RenderViewportThumbnail() [Internal]
// - RenderViewportsThumbnails() [Internal]
// - DebugTextEncoding()
// - MetricsHelpMarker() [Internal]
// - ShowFontAtlas() [Internal]
// - ShowMetricsWindow()
// - DebugNodeColumns() [Internal]
// - DebugNodeDrawList() [Internal]
// - DebugNodeDrawCmdShowMeshAndBoundingBox() [Internal]
// - DebugNodeFont() [Internal]
// - DebugNodeFontGlyph() [Internal]
// - DebugNodeStorage() [Internal]
// - DebugNodeTabBar() [Internal]
// - DebugNodeViewport() [Internal]
// - DebugNodeWindow() [Internal]
// - DebugNodeWindowSettings() [Internal]
// - DebugNodeWindowsList() [Internal]
// - DebugNodeWindowsListByBeginStackParent() [Internal]
//-----------------------------------------------------------------------------

#ifndef GUI_DISABLE_DEBUG_TOOLS

inline void Gui::DebugRenderViewportThumbnail(DrawList *draw_list,
                                              ViewportP *viewport,
                                              const Rect &bb) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  Vec2 scale = Divide(bb.GetSize(), viewport->Size);
  Vec2 off = Subtract(bb.Min, Multiply(viewport->Pos, scale));
  float alpha_mul = 1.0f;
  window->DrawList->AddRectFilled(bb.Min, bb.Max,
                                  GetColorU32(Col_Border, alpha_mul * 0.40f));
  for (Window *thumb_window : g.Windows) {
    if (!thumb_window->WasActive ||
        (thumb_window->Flags & WindowFlags_ChildWindow))
      continue;

    Rect thumb_r = thumb_window->Rect();
    Rect title_r = thumb_window->TitleBarRect();
    thumb_r = Rect(Trunc(Add(off, Multiply(thumb_r.Min, scale))),
                   Trunc(Add(off, Multiply(thumb_r.Max, scale))));
    title_r = Rect(
        Trunc(Add(off, Multiply(title_r.Min, scale))),
        Trunc(Add(Add(off, Multiply(Vec2(title_r.Max.x, title_r.Min.y), scale)),
                  Vec2(0, 5)))); // Exaggerate title bar height
    thumb_r.ClipWithFull(bb);
    title_r.ClipWithFull(bb);
    const bool window_is_focused =
        (g.NavWindow && thumb_window->RootWindowForTitleBarHighlight ==
                            g.NavWindow->RootWindowForTitleBarHighlight);
    window->DrawList->AddRectFilled(thumb_r.Min, thumb_r.Max,
                                    GetColorU32(Col_WindowBg, alpha_mul));
    window->DrawList->AddRectFilled(
        title_r.Min, title_r.Max,
        GetColorU32(window_is_focused ? Col_TitleBgActive : Col_TitleBg,
                    alpha_mul));
    window->DrawList->AddRect(thumb_r.Min, thumb_r.Max,
                              GetColorU32(Col_Border, alpha_mul));
    window->DrawList->AddText(g.Font, g.FontSize * 1.0f, title_r.Min,
                              GetColorU32(Col_Text, alpha_mul),
                              thumb_window->Name,
                              FindRenderedTextEnd(thumb_window->Name));
  }
  draw_list->AddRect(bb.Min, bb.Max, GetColorU32(Col_Border, alpha_mul));
}

static void RenderViewportsThumbnails() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  // We don't display full monitor bounds (we could, but it often looks
  // awkward), instead we display just enough to cover all of our viewports.
  float SCALE = 1.0f / 8.0f;
  Rect bb_full(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
  for (ViewportP *viewport : g.Viewports)
    bb_full.Add(viewport->GetMainRect());
  Vec2 p = window->DC.CursorPos;
  Vec2 off = Subtract(p, Multiply(bb_full.Min, SCALE));
  for (ViewportP *viewport : g.Viewports) {
    Rect viewport_draw_bb(
        Add(off, Multiply((viewport->Pos), SCALE)),
        Add(off, Multiply(Add(viewport->Pos, viewport->Size), SCALE)));
    Gui::DebugRenderViewportThumbnail(window->DrawList, viewport,
                                      viewport_draw_bb);
  }
  Gui::Dummy(Multiply(bb_full.GetSize(), SCALE));
}

// Draw an arbitrary US keyboard layout to visualize translated keys
inline void Gui::DebugRenderKeyboardPreview(DrawList *draw_list) {
  const Vec2 key_size = Vec2(35.0f, 35.0f);
  const float key_rounding = 3.0f;
  const Vec2 key_face_size = Vec2(25.0f, 25.0f);
  const Vec2 key_face_pos = Vec2(5.0f, 3.0f);
  const float key_face_rounding = 2.0f;
  const Vec2 key_label_pos = Vec2(7.0f, 4.0f);
  const Vec2 key_step = Vec2(key_size.x - 1.0f, key_size.y - 1.0f);
  const float key_row_offset = 9.0f;

  Vec2 board_min = GetCursorScreenPos();
  Vec2 board_max =
      Vec2(board_min.x + 3 * key_step.x + 2 * key_row_offset + 10.0f,
           board_min.y + 3 * key_step.y + 10.0f);
  Vec2 start_pos = Vec2(board_min.x + 5.0f - key_step.x, board_min.y);

  struct KeyLayoutData {
    int Row, Col;
    const char *Label;
    Key Key;
  };
  const KeyLayoutData keys_to_display[] = {
      {0, 0, "", Key_Tab}, {0, 1, "Q", Key_Q},        {0, 2, "W", Key_W},
      {0, 3, "E", Key_E},  {0, 4, "R", Key_R},        {1, 0, "", Key_CapsLock},
      {1, 1, "A", Key_A},  {1, 2, "S", Key_S},        {1, 3, "D", Key_D},
      {1, 4, "F", Key_F},  {2, 0, "", Key_LeftShift}, {2, 1, "Z", Key_Z},
      {2, 2, "X", Key_X},  {2, 3, "C", Key_C},        {2, 4, "V", Key_V}};

  // Elements rendered manually via DrawList API are not clipped
  // automatically. While not strictly necessary, here IsItemVisible() is used
  // to avoid rendering these shapes when they are out of view.
  Dummy(Subtract(board_max, board_min));
  if (!IsItemVisible())
    return;
  draw_list->PushClipRect(board_min, board_max, true);
  for (int n = 0; n < GUI_ARRAYSIZE(keys_to_display); n++) {
    const KeyLayoutData *key_data = &keys_to_display[n];
    Vec2 key_min = Vec2(start_pos.x + key_data->Col * key_step.x +
                            key_data->Row * key_row_offset,
                        start_pos.y + key_data->Row * key_step.y);
    Vec2 key_max = Add(key_min, key_size);
    draw_list->AddRectFilled(key_min, key_max, GUI_COL32(204, 204, 204, 255),
                             key_rounding);
    draw_list->AddRect(key_min, key_max, GUI_COL32(24, 24, 24, 255),
                       key_rounding);
    Vec2 face_min =
        Vec2(key_min.x + key_face_pos.x, key_min.y + key_face_pos.y);
    Vec2 face_max =
        Vec2(face_min.x + key_face_size.x, face_min.y + key_face_size.y);
    draw_list->AddRect(face_min, face_max, GUI_COL32(193, 193, 193, 255),
                       key_face_rounding, DrawFlags_None, 2.0f);
    draw_list->AddRectFilled(face_min, face_max, GUI_COL32(252, 252, 252, 255),
                             key_face_rounding);
    Vec2 label_min =
        Vec2(key_min.x + key_label_pos.x, key_min.y + key_label_pos.y);
    draw_list->AddText(label_min, GUI_COL32(64, 64, 64, 255), key_data->Label);
    if (IsKeyDown(key_data->Key))
      draw_list->AddRectFilled(key_min, key_max, GUI_COL32(255, 0, 0, 128),
                               key_rounding);
  }
  draw_list->PopClipRect();
}

// Helper tool to diagnose between text encoding issues and font loading issues.
// Pass your UTF-8 string and verify that there are correct.
inline void Gui::DebugTextEncoding(const char *str) {
  Text("Text: \"%s\"", str);
  if (!BeginTable("##DebugTextEncoding", 4,
                  TableFlags_Borders | TableFlags_RowBg |
                      TableFlags_SizingFixedFit | TableFlags_Resizable))
    return;
  TableSetupColumn("Offset");
  TableSetupColumn("UTF-8");
  TableSetupColumn("Glyph");
  TableSetupColumn("Codepoint");
  TableHeadersRow();
  for (const char *p = str; *p != 0;) {
    unsigned int c;
    const int c_utf8_len = TextCharFromUtf8(&c, p, NULL);
    TableNextColumn();
    Text("%d", (int)(p - str));
    TableNextColumn();
    for (int byte_index = 0; byte_index < c_utf8_len; byte_index++) {
      if (byte_index > 0)
        SameLine();
      Text("0x%02X", (int)(unsigned char)p[byte_index]);
    }
    TableNextColumn();
    if (GetFont()->FindGlyphNoFallback((Wchar)c))
      TextUnformatted(p, p + c_utf8_len);
    else
      TextUnformatted((c == GUI_UNICODE_CODEPOINT_INVALID) ? "[invalid]"
                                                           : "[missing]");
    TableNextColumn();
    Text("U+%04X", (int)c);
    p += c_utf8_len;
  }
  EndTable();
}

static void DebugFlashStyleColorStop() {
  Context &g = *GGui;
  if (g.DebugFlashStyleColorIdx != Col_COUNT)
    g.Style.Colors[g.DebugFlashStyleColorIdx] = g.DebugFlashStyleColorBackup;
  g.DebugFlashStyleColorIdx = Col_COUNT;
}

// Flash a given style color for some + inhibit modifications of this color via
// PushStyleColor() calls.
inline void Gui::DebugFlashStyleColor(Col idx) {
  Context &g = *GGui;
  DebugFlashStyleColorStop();
  g.DebugFlashStyleColorTime = 0.5f;
  g.DebugFlashStyleColorIdx = idx;
  g.DebugFlashStyleColorBackup = g.Style.Colors[idx];
}

void Gui::UpdateDebugToolFlashStyleColor() {
  Context &g = *GGui;
  if (g.DebugFlashStyleColorTime <= 0.0f)
    return;
  ColorConvertHSVtoRGB(cosf(g.DebugFlashStyleColorTime * 6.0f) * 0.5f + 0.5f,
                       0.5f, 0.5f, g.Style.Colors[g.DebugFlashStyleColorIdx].x,
                       g.Style.Colors[g.DebugFlashStyleColorIdx].y,
                       g.Style.Colors[g.DebugFlashStyleColorIdx].z);
  g.Style.Colors[g.DebugFlashStyleColorIdx].w = 1.0f;
  if ((g.DebugFlashStyleColorTime -= g.IO.DeltaTime) <= 0.0f)
    DebugFlashStyleColorStop();
}

// Avoid naming collision with gui_demo.cpp's HelpMarker() for unity builds.
static void MetricsHelpMarker(const char *desc) {
  Gui::TextDisabled("(?)");
  if (Gui::BeginItemTooltip()) {
    Gui::PushTextWrapPos(Gui::GetFontSize() * 35.0f);
    Gui::TextUnformatted(desc);
    Gui::PopTextWrapPos();
    Gui::EndTooltip();
  }
}

// [DEBUG] List fonts in a font atlas and display its texture
inline void Gui::ShowFontAtlas(FontAtlas *atlas) {
  for (Font *font : atlas->Fonts) {
    PushID(font);
    DebugNodeFont(font);
    PopID();
  }
  if (TreeNode("Font Atlas", "Font Atlas (%dx%d pixels)", atlas->TexWidth,
               atlas->TexHeight)) {
    Context &g = *GGui;
    MetricsConfig *cfg = &g.DebugMetricsConfig;
    Checkbox("Tint with Text Color",
             &cfg->ShowAtlasTintedWithTextColor); // Using text color ensure
                                                  // visibility of core atlas
                                                  // data, but will alter custom
                                                  // colored icons
    Vec4 tint_col = cfg->ShowAtlasTintedWithTextColor
                        ? GetStyleColorVec4(Col_Text)
                        : Vec4(1.0f, 1.0f, 1.0f, 1.0f);
    Vec4 border_col = GetStyleColorVec4(Col_Border);
    Image(atlas->TexID, Vec2((float)atlas->TexWidth, (float)atlas->TexHeight),
          Vec2(0.0f, 0.0f), Vec2(1.0f, 1.0f), tint_col, border_col);
    TreePop();
  }
}

inline void Gui::ShowMetricsWindow(bool *p_open) {
  Context &g = *GGui;
  IO &io = g.IO;
  MetricsConfig *cfg = &g.DebugMetricsConfig;
  if (cfg->ShowDebugLog)
    ShowDebugLogWindow(&cfg->ShowDebugLog);
  if (cfg->ShowIDStackTool)
    ShowIDStackToolWindow(&cfg->ShowIDStackTool);

  if (!Begin("Dear Gui Metrics/Debugger", p_open) ||
      GetCurrentWindow()->BeginCount > 1) {
    End();
    return;
  }

  // Basic info
  Text("Dear Gui %s", GetVersion());
  Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate,
       io.Framerate);
  Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices,
       io.MetricsRenderIndices, io.MetricsRenderIndices / 3);
  Text("%d visible windows, %d current allocations", io.MetricsRenderWindows,
       g.DebugAllocInfo.TotalAllocCount - g.DebugAllocInfo.TotalFreeCount);
  // SameLine(); if (SmallButton("GC")) { g.GcCompactAll = true; }

  Separator();

  // Debugging enums
  enum {
    WRT_OuterRect,
    WRT_OuterRectClipped,
    WRT_InnerRect,
    WRT_InnerClipRect,
    WRT_WorkRect,
    WRT_Content,
    WRT_ContentIdeal,
    WRT_ContentRegionRect,
    WRT_Count
  }; // Windows Rect Type
  const char *wrt_rects_names[WRT_Count] = {
      "OuterRect", "OuterRectClipped", "InnerRect",    "InnerClipRect",
      "WorkRect",  "Content",          "ContentIdeal", "ContentRegionRect"};
  enum {
    TRT_OuterRect,
    TRT_InnerRect,
    TRT_WorkRect,
    TRT_HostClipRect,
    TRT_InnerClipRect,
    TRT_BackgroundClipRect,
    TRT_ColumnsRect,
    TRT_ColumnsWorkRect,
    TRT_ColumnsClipRect,
    TRT_ColumnsContentHeadersUsed,
    TRT_ColumnsContentHeadersIdeal,
    TRT_ColumnsContentFrozen,
    TRT_ColumnsContentUnfrozen,
    TRT_Count
  }; // Tables Rect Type
  const char *trt_rects_names[TRT_Count] = {"OuterRect",
                                            "InnerRect",
                                            "WorkRect",
                                            "HostClipRect",
                                            "InnerClipRect",
                                            "BackgroundClipRect",
                                            "ColumnsRect",
                                            "ColumnsWorkRect",
                                            "ColumnsClipRect",
                                            "ColumnsContentHeadersUsed",
                                            "ColumnsContentHeadersIdeal",
                                            "ColumnsContentFrozen",
                                            "ColumnsContentUnfrozen"};
  if (cfg->ShowWindowsRectsType < 0)
    cfg->ShowWindowsRectsType = WRT_WorkRect;
  if (cfg->ShowTablesRectsType < 0)
    cfg->ShowTablesRectsType = TRT_WorkRect;

  struct Funcs {
    static Rect GetTableRect(Table *table, int rect_type, int n) {
      TableInstanceData *table_instance = TableGetInstanceData(
          table,
          table->InstanceCurrent); // Always using last submitted instance
      if (rect_type == TRT_OuterRect) {
        return table->OuterRect;
      } else if (rect_type == TRT_InnerRect) {
        return table->InnerRect;
      } else if (rect_type == TRT_WorkRect) {
        return table->WorkRect;
      } else if (rect_type == TRT_HostClipRect) {
        return table->HostClipRect;
      } else if (rect_type == TRT_InnerClipRect) {
        return table->InnerClipRect;
      } else if (rect_type == TRT_BackgroundClipRect) {
        return table->BgClipRect;
      } else if (rect_type == TRT_ColumnsRect) {
        TableColumn *c = &table->Columns[n];
        return Rect(c->MinX, table->InnerClipRect.Min.y, c->MaxX,
                    table->InnerClipRect.Min.y +
                        table_instance->LastOuterHeight);
      } else if (rect_type == TRT_ColumnsWorkRect) {
        TableColumn *c = &table->Columns[n];
        return Rect(c->WorkMinX, table->WorkRect.Min.y, c->WorkMaxX,
                    table->WorkRect.Max.y);
      } else if (rect_type == TRT_ColumnsClipRect) {
        TableColumn *c = &table->Columns[n];
        return c->ClipRect;
      } else if (rect_type == TRT_ColumnsContentHeadersUsed) {
        TableColumn *c = &table->Columns[n];
        return Rect(c->WorkMinX, table->InnerClipRect.Min.y,
                    c->ContentMaxXHeadersUsed,
                    table->InnerClipRect.Min.y +
                        table_instance->LastTopHeadersRowHeight);
      } // Note: y1/y2 not always accurate
      else if (rect_type == TRT_ColumnsContentHeadersIdeal) {
        TableColumn *c = &table->Columns[n];
        return Rect(c->WorkMinX, table->InnerClipRect.Min.y,
                    c->ContentMaxXHeadersIdeal,
                    table->InnerClipRect.Min.y +
                        table_instance->LastTopHeadersRowHeight);
      } else if (rect_type == TRT_ColumnsContentFrozen) {
        TableColumn *c = &table->Columns[n];
        return Rect(
            c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXFrozen,
            table->InnerClipRect.Min.y + table_instance->LastFrozenHeight);
      } else if (rect_type == TRT_ColumnsContentUnfrozen) {
        TableColumn *c = &table->Columns[n];
        return Rect(c->WorkMinX,
                    table->InnerClipRect.Min.y +
                        table_instance->LastFrozenHeight,
                    c->ContentMaxXUnfrozen, table->InnerClipRect.Max.y);
      }
      GUI_ASSERT(0);
      return Rect();
    }

    static Rect GetWindowRect(Window *window, int rect_type) {
      if (rect_type == WRT_OuterRect) {
        return window->Rect();
      } else if (rect_type == WRT_OuterRectClipped) {
        return window->OuterRectClipped;
      } else if (rect_type == WRT_InnerRect) {
        return window->InnerRect;
      } else if (rect_type == WRT_InnerClipRect) {
        return window->InnerClipRect;
      } else if (rect_type == WRT_WorkRect) {
        return window->WorkRect;
      } else if (rect_type == WRT_Content) {
        Vec2 min = Add(Subtract(window->InnerRect.Min, window->Scroll),
                       window->WindowPadding);
        return Rect(min, Add(min, window->ContentSize));
      } else if (rect_type == WRT_ContentIdeal) {
        Vec2 min = Add(Subtract(window->InnerRect.Min, window->Scroll),
                       window->WindowPadding);
        return Rect(min, Add(min, window->ContentSizeIdeal));
      } else if (rect_type == WRT_ContentRegionRect) {
        return window->ContentRegionRect;
      }
      GUI_ASSERT(0);
      return Rect();
    }
  };

  // Tools
  if (TreeNode("Tools")) {
    bool show_encoding_viewer = TreeNode("UTF-8 Encoding viewer");
    SameLine();
    MetricsHelpMarker(
        "You can also call Gui::DebugTextEncoding() from your code with a "
        "given string to test that your UTF-8 encoding settings are correct.");
    if (show_encoding_viewer) {
      static char buf[100] = "";
      SetNextItemWidth(-FLT_MIN);
      InputText("##Text", buf, GUI_ARRAYSIZE(buf));
      if (buf[0] != 0)
        DebugTextEncoding(buf);
      TreePop();
    }

    // The Item Picker tool is super useful to visually select an item and break
    // into the call-stack of where it was submitted.
    if (Checkbox("Show Item Picker", &g.DebugItemPickerActive) &&
        g.DebugItemPickerActive)
      DebugStartItemPicker();
    SameLine();
    MetricsHelpMarker(
        "Will call the GUI_DEBUG_BREAK() macro to break in debugger.\nWarning: "
        "If you don't have a debugger attached, this will probably crash.");

    Checkbox("Show Debug Log", &cfg->ShowDebugLog);
    SameLine();
    MetricsHelpMarker(
        "You can also call Gui::ShowDebugLogWindow() from your code.");

    Checkbox("Show ID Stack Tool", &cfg->ShowIDStackTool);
    SameLine();
    MetricsHelpMarker(
        "You can also call Gui::ShowIDStackToolWindow() from your code.");

    Checkbox("Show windows begin order", &cfg->ShowWindowsBeginOrder);
    Checkbox("Show windows rectangles", &cfg->ShowWindowsRects);
    SameLine();
    SetNextItemWidth(GetFontSize() * 12);
    cfg->ShowWindowsRects |=
        Combo("##show_windows_rect_type", &cfg->ShowWindowsRectsType,
              wrt_rects_names, WRT_Count, WRT_Count);
    if (cfg->ShowWindowsRects && g.NavWindow != NULL) {
      BulletText("'%s':", g.NavWindow->Name);
      Indent();
      for (int rect_n = 0; rect_n < WRT_Count; rect_n++) {
        Rect r = Funcs::GetWindowRect(g.NavWindow, rect_n);
        Text("(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x,
             r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(),
             wrt_rects_names[rect_n]);
      }
      Unindent();
    }

    Checkbox("Show tables rectangles", &cfg->ShowTablesRects);
    SameLine();
    SetNextItemWidth(GetFontSize() * 12);
    cfg->ShowTablesRects |=
        Combo("##show_table_rects_type", &cfg->ShowTablesRectsType,
              trt_rects_names, TRT_Count, TRT_Count);
    if (cfg->ShowTablesRects && g.NavWindow != NULL) {
      for (int table_n = 0; table_n < g.Tables.GetMapSize(); table_n++) {
        Table *table = g.Tables.TryGetMapData(table_n);
        if (table == NULL || table->LastFrameActive < g.FrameCount - 1 ||
            (table->OuterWindow != g.NavWindow &&
             table->InnerWindow != g.NavWindow))
          continue;

        BulletText("Table 0x%08X (%d columns, in '%s')", table->ID,
                   table->ColumnsCount, table->OuterWindow->Name);
        if (IsItemHovered())
          GetForegroundDrawList()->AddRect(
              Subtract(table->OuterRect.Min, Vec2(1, 1)),
              Add(table->OuterRect.Max, Vec2(1, 1)),
              GUI_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
        Indent();
        char buf[128];
        for (int rect_n = 0; rect_n < TRT_Count; rect_n++) {
          if (rect_n >= TRT_ColumnsRect) {
            if (rect_n != TRT_ColumnsRect && rect_n != TRT_ColumnsClipRect)
              continue;
            for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
              Rect r = Funcs::GetTableRect(table, rect_n, column_n);
              FormatString(
                  buf, GUI_ARRAYSIZE(buf),
                  "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) Col %d %s",
                  r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(),
                  r.GetHeight(), column_n, trt_rects_names[rect_n]);
              Selectable(buf);
              if (IsItemHovered())
                GetForegroundDrawList()->AddRect(
                    Subtract(r.Min, Vec2(1, 1)), Add(r.Max, Vec2(1, 1)),
                    GUI_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
            }
          } else {
            Rect r = Funcs::GetTableRect(table, rect_n, -1);
            FormatString(buf, GUI_ARRAYSIZE(buf),
                         "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s",
                         r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(),
                         r.GetHeight(), trt_rects_names[rect_n]);
            Selectable(buf);
            if (IsItemHovered())
              GetForegroundDrawList()->AddRect(
                  Subtract(r.Min, Vec2(1, 1)), Add(r.Max, Vec2(1, 1)),
                  GUI_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
          }
        }
        Unindent();
      }
    }
    Checkbox(
        "Show groups rectangles",
        &g.DebugShowGroupRects); // Storing in context as this is used by group
                                 // code and prefers to be in hot-data

    Checkbox("Debug Begin/BeginChild return value",
             &io.ConfigDebugBeginReturnValueLoop);
    SameLine();
    MetricsHelpMarker("Some calls to Begin()/BeginChild() will return "
                      "false.\n\nWill cycle through window depths then repeat. "
                      "Windows should be flickering while running.");

    TreePop();
  }

  // Windows
  if (TreeNode("Windows", "Windows (%d)", g.Windows.Size)) {
    // SetNextItemOpen(true, Cond_Once);
    DebugNodeWindowsList(&g.Windows, "By display order");
    DebugNodeWindowsList(&g.WindowsFocusOrder, "By focus order (root windows)");
    if (TreeNode("By submission order (begin stack)")) {
      // Here we display windows in their submitted order/hierarchy, however
      // note that the Begin stack doesn't constitute a Parent<>Child
      // relationship!
      Vector<Window *> &temp_buffer = g.WindowsTempSortBuffer;
      temp_buffer.resize(0);
      for (Window *window : g.Windows)
        if (window->LastFrameActive + 1 >= g.FrameCount)
          temp_buffer.push_back(window);
      struct Func {
        static int GUI_CDECL WindowComparerByBeginOrder(const void *lhs,
                                                        const void *rhs) {
          return ((int)(*(const Window *const *)lhs)->BeginOrderWithinContext -
                  (*(const Window *const *)rhs)->BeginOrderWithinContext);
        }
      };
      Qsort(temp_buffer.Data, (size_t)temp_buffer.Size, sizeof(Window *),
            Func::WindowComparerByBeginOrder);
      DebugNodeWindowsListByBeginStackParent(temp_buffer.Data, temp_buffer.Size,
                                             NULL);
      TreePop();
    }

    TreePop();
  }

  // DrawLists
  int drawlist_count = 0;
  for (ViewportP *viewport : g.Viewports)
    drawlist_count += viewport->DrawDataP.CmdLists.Size;
  if (TreeNode("DrawLists", "DrawLists (%d)", drawlist_count)) {
    Checkbox("Show DrawCmd mesh when hovering", &cfg->ShowDrawCmdMesh);
    Checkbox("Show DrawCmd bounding boxes when hovering",
             &cfg->ShowDrawCmdBoundingBoxes);
    for (ViewportP *viewport : g.Viewports)
      for (DrawList *draw_list : viewport->DrawDataP.CmdLists)
        DebugNodeDrawList(NULL, viewport, draw_list, "DrawList");
    TreePop();
  }

  // Viewports
  if (TreeNode("Viewports", "Viewports (%d)", g.Viewports.Size)) {
    Indent(GetTreeNodeToLabelSpacing());
    RenderViewportsThumbnails();
    Unindent(GetTreeNodeToLabelSpacing());
    for (ViewportP *viewport : g.Viewports)
      DebugNodeViewport(viewport);
    TreePop();
  }

  // Details for Popups
  if (TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size)) {
    for (const PopupData &popup_data : g.OpenPopupStack) {
      // As it's difficult to interact with tree nodes while popups are open, we
      // display everything inline.
      Window *window = popup_data.Window;
      BulletText(
          "PopupID: %08x, Window: '%s' (%s%s), BackupNavWindow '%s', "
          "ParentWindow '%s'",
          popup_data.PopupId, window ? window->Name : "NULL",
          window && (window->Flags & WindowFlags_ChildWindow) ? "Child;" : "",
          window && (window->Flags & WindowFlags_ChildMenu) ? "Menu;" : "",
          popup_data.BackupNavWindow ? popup_data.BackupNavWindow->Name
                                     : "NULL",
          window && window->ParentWindow ? window->ParentWindow->Name : "NULL");
    }
    TreePop();
  }

  // Details for TabBars
  if (TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.GetAliveCount())) {
    for (int n = 0; n < g.TabBars.GetMapSize(); n++)
      if (TabBar *tab_bar = g.TabBars.TryGetMapData(n)) {
        PushID(tab_bar);
        DebugNodeTabBar(tab_bar, "TabBar");
        PopID();
      }
    TreePop();
  }

  // Details for Tables
  if (TreeNode("Tables", "Tables (%d)", g.Tables.GetAliveCount())) {
    for (int n = 0; n < g.Tables.GetMapSize(); n++)
      if (Table *table = g.Tables.TryGetMapData(n))
        DebugNodeTable(table);
    TreePop();
  }

  // Details for Fonts
  FontAtlas *atlas = g.IO.Fonts;
  if (TreeNode("Fonts", "Fonts (%d)", atlas->Fonts.Size)) {
    ShowFontAtlas(atlas);
    TreePop();
  }

  // Details for InputText
  if (TreeNode("InputText")) {
    DebugNodeInputTextState(&g.InputTextState);
    TreePop();
  }

  // Details for TypingSelect
  if (TreeNode("TypingSelect", "TypingSelect (%d)",
               g.TypingSelectState.SearchBuffer[0] != 0 ? 1 : 0)) {
    DebugNodeTypingSelectState(&g.TypingSelectState);
    TreePop();
  }

  // Details for Docking
#ifdef GUI_HAS_DOCK
  if (TreeNode("Docking")) {
    TreePop();
  }
#endif // #ifdef GUI_HAS_DOCK

  // Settings
  if (TreeNode("Settings")) {
    if (SmallButton("Clear"))
      ClearIniSettings();
    SameLine();
    if (SmallButton("Save to memory"))
      SaveIniSettingsToMemory();
    SameLine();
    if (SmallButton("Save to disk"))
      SaveIniSettingsToDisk(g.IO.IniFilename);
    SameLine();
    if (g.IO.IniFilename)
      Text("\"%s\"", g.IO.IniFilename);
    else
      TextUnformatted("<NULL>");
    Checkbox("io.ConfigDebugIniSettings", &io.ConfigDebugIniSettings);
    Text("SettingsDirtyTimer %.2f", g.SettingsDirtyTimer);
    if (TreeNode("SettingsHandlers", "Settings handlers: (%d)",
                 g.SettingsHandlers.Size)) {
      for (SettingsHandler &handler : g.SettingsHandlers)
        BulletText("\"%s\"", handler.TypeName);
      TreePop();
    }
    if (TreeNode("SettingsWindows", "Settings packed data: Windows: %d bytes",
                 g.SettingsWindows.size())) {
      for (WindowSettings *settings = g.SettingsWindows.begin();
           settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        DebugNodeWindowSettings(settings);
      TreePop();
    }

    if (TreeNode("SettingsTables", "Settings packed data: Tables: %d bytes",
                 g.SettingsTables.size())) {
      for (TableSettings *settings = g.SettingsTables.begin(); settings != NULL;
           settings = g.SettingsTables.next_chunk(settings))
        DebugNodeTableSettings(settings);
      TreePop();
    }

#ifdef GUI_HAS_DOCK
#endif // #ifdef GUI_HAS_DOCK

    if (TreeNode("SettingsIniData", "Settings unpacked data (.ini): %d bytes",
                 g.SettingsIniData.size())) {
      InputTextMultiline("##Ini", (char *)(void *)g.SettingsIniData.c_str(),
                         g.SettingsIniData.Buf.Size,
                         Vec2(-FLT_MIN, GetTextLineHeight() * 20),
                         InputTextFlags_ReadOnly);
      TreePop();
    }
    TreePop();
  }

  // Settings
  if (TreeNode("Memory allocations")) {
    DebugAllocInfo *info = &g.DebugAllocInfo;
    Text("%d current allocations",
         info->TotalAllocCount - info->TotalFreeCount);
    Text("Recent frames with allocations:");
    int buf_size = GUI_ARRAYSIZE(info->LastEntriesBuf);
    for (int n = buf_size - 1; n >= 0; n--) {
      DebugAllocEntry *entry =
          &info->LastEntriesBuf[(info->LastEntriesIdx - n + buf_size) %
                                buf_size];
      BulletText("Frame %06d: %+3d ( %2d malloc, %2d free )%s",
                 entry->FrameCount, entry->AllocCount - entry->FreeCount,
                 entry->AllocCount, entry->FreeCount,
                 (n == 0) ? " (most recent)" : "");
    }
    TreePop();
  }

  if (TreeNode("Inputs")) {
    Text("KEYBOARD/GAMEPAD/MOUSE KEYS");
    {
      // We iterate both legacy native range and named Key ranges, which is
      // a little odd but this allows displaying the data for old/new backends.
      // User code should never have to go through such hoops! You can generally
      // iterate between Key_NamedKey_BEGIN and Key_NamedKey_END.
      Indent();
#ifdef GUI_DISABLE_OBSOLETE_KEYIO
      struct funcs {
        static bool IsLegacyNativeDupe(Key) { return false; }
      };
#else
      struct funcs {
        static bool IsLegacyNativeDupe(Key key) {
          return key >= 0 && key < 512 && GetIO().KeyMap[key] != -1;
        }
      }; // Hide Native<>Key duplicates when both exists in the array
         // Text("Legacy raw:");      for (Key key = Key_KeysData_OFFSET;
         // key < Key_COUNT; key++) { if (io.KeysDown[key]) { SameLine();
         // Text("\"%s\" %d", GetKeyName(key), key); } }
#endif
      Text("Keys down:");
      for (Key key = Key_KeysData_OFFSET; key < Key_COUNT;
           key = (Key)(key + 1)) {
        if (funcs::IsLegacyNativeDupe(key) || !IsKeyDown(key))
          continue;
        SameLine();
        Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key);
        SameLine();
        Text("(%.02f)", GetKeyData(key)->DownDuration);
      }
      Text("Keys pressed:");
      for (Key key = Key_KeysData_OFFSET; key < Key_COUNT;
           key = (Key)(key + 1)) {
        if (funcs::IsLegacyNativeDupe(key) || !IsKeyPressed(key))
          continue;
        SameLine();
        Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key);
      }
      Text("Keys released:");
      for (Key key = Key_KeysData_OFFSET; key < Key_COUNT;
           key = (Key)(key + 1)) {
        if (funcs::IsLegacyNativeDupe(key) || !IsKeyReleased(key))
          continue;
        SameLine();
        Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key);
      }
      Text("Keys mods: %s%s%s%s", io.KeyCtrl ? "CTRL " : "",
           io.KeyShift ? "SHIFT " : "", io.KeyAlt ? "ALT " : "",
           io.KeySuper ? "SUPER " : "");
      Text("Chars queue:");
      for (int i = 0; i < io.InputQueueCharacters.Size; i++) {
        Wchar c = io.InputQueueCharacters[i];
        SameLine();
        Text("\'%c\' (0x%04X)", (c > ' ' && c <= 255) ? (char)c : '?', c);
      } // FIXME: We should convert 'c' to UTF-8 here but the functions are not
        // public.
      DebugRenderKeyboardPreview(GetWindowDrawList());
      Unindent();
    }

    Text("MOUSE STATE");
    {
      Indent();
      if (IsMousePosValid())
        Text("Mouse pos: (%g, %g)", io.MousePos.x, io.MousePos.y);
      else
        Text("Mouse pos: <INVALID>");
      Text("Mouse delta: (%g, %g)", io.MouseDelta.x, io.MouseDelta.y);
      int count = GUI_ARRAYSIZE(io.MouseDown);
      Text("Mouse down:");
      for (int i = 0; i < count; i++)
        if (IsMouseDown(i)) {
          SameLine();
          Text("b%d (%.02f secs)", i, io.MouseDownDuration[i]);
        }
      Text("Mouse clicked:");
      for (int i = 0; i < count; i++)
        if (IsMouseClicked(i)) {
          SameLine();
          Text("b%d (%d)", i, io.MouseClickedCount[i]);
        }
      Text("Mouse released:");
      for (int i = 0; i < count; i++)
        if (IsMouseReleased(i)) {
          SameLine();
          Text("b%d", i);
        }
      Text("Mouse wheel: %.1f", io.MouseWheel);
      Text("MouseStationaryTimer: %.2f", g.MouseStationaryTimer);
      Text("Mouse source: %s", GetMouseSourceName(io.MouseSource));
      Text("Pen Pressure: %.1f", io.PenPressure); // Note: currently unused
      Unindent();
    }

    Text("MOUSE WHEELING");
    {
      Indent();
      Text("WheelingWindow: '%s'",
           g.WheelingWindow ? g.WheelingWindow->Name : "NULL");
      Text("WheelingWindowReleaseTimer: %.2f", g.WheelingWindowReleaseTimer);
      Text("WheelingAxisAvg[] = { %.3f, %.3f }, Main Axis: %s",
           g.WheelingAxisAvg.x, g.WheelingAxisAvg.y,
           (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y)   ? "X"
           : (g.WheelingAxisAvg.x < g.WheelingAxisAvg.y) ? "Y"
                                                         : "<none>");
      Unindent();
    }

    Text("KEY OWNERS");
    {
      Indent();
      if (BeginChild("##owners",
                     Vec2(-FLT_MIN, GetTextLineHeightWithSpacing() * 6),
                     ChildFlags_FrameStyle | ChildFlags_ResizeY,
                     WindowFlags_NoSavedSettings))
        for (Key key = Key_NamedKey_BEGIN; key < Key_NamedKey_END;
             key = (Key)(key + 1)) {
          KeyOwnerData *owner_data = GetKeyOwnerData(&g, key);
          if (owner_data->OwnerCurr == KeyOwner_None)
            continue;
          Text("%s: 0x%08X%s", GetKeyName(key), owner_data->OwnerCurr,
               owner_data->LockUntilRelease ? " LockUntilRelease"
               : owner_data->LockThisFrame  ? " LockThisFrame"
                                            : "");
          DebugLocateItemOnHover(owner_data->OwnerCurr);
        }
      EndChild();
      Unindent();
    }
    Text("SHORTCUT ROUTING");
    {
      Indent();
      if (BeginChild("##routes",
                     Vec2(-FLT_MIN, GetTextLineHeightWithSpacing() * 6),
                     ChildFlags_FrameStyle | ChildFlags_ResizeY,
                     WindowFlags_NoSavedSettings))
        for (Key key = Key_NamedKey_BEGIN; key < Key_NamedKey_END;
             key = (Key)(key + 1)) {
          KeyRoutingTable *rt = &g.KeysRoutingTable;
          for (KeyRoutingIndex idx = rt->Index[key - Key_NamedKey_BEGIN];
               idx != -1;) {
            char key_chord_name[64];
            KeyRoutingData *routing_data = &rt->Entries[idx];
            GetKeyChordName(key | routing_data->Mods, key_chord_name,
                            GUI_ARRAYSIZE(key_chord_name));
            Text("%s: 0x%08X", key_chord_name, routing_data->RoutingCurr);
            DebugLocateItemOnHover(routing_data->RoutingCurr);
            idx = routing_data->NextEntryIndex;
          }
        }
      EndChild();
      Text("(ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: 0x%X)",
           g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask);
      Unindent();
    }
    TreePop();
  }

  if (TreeNode("Internal state")) {
    Text("WINDOWING");
    Indent();
    Text("HoveredWindow: '%s'",
         g.HoveredWindow ? g.HoveredWindow->Name : "NULL");
    Text("HoveredWindow->Root: '%s'",
         g.HoveredWindow ? g.HoveredWindow->RootWindow->Name : "NULL");
    Text("HoveredWindowUnderMovingWindow: '%s'",
         g.HoveredWindowUnderMovingWindow
             ? g.HoveredWindowUnderMovingWindow->Name
             : "NULL");
    Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");
    Unindent();

    Text("ITEMS");
    Indent();
    Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s",
         g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer,
         g.ActiveIdAllowOverlap, GetInputSourceName(g.ActiveIdSource));
    DebugLocateItemOnHover(g.ActiveId);
    Text("ActiveIdWindow: '%s'",
         g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");
    Text("ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: %X",
         g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask);
    Text("HoveredId: 0x%08X (%.2f sec), AllowOverlap: %d",
         g.HoveredIdPreviousFrame, g.HoveredIdTimer,
         g.HoveredIdAllowOverlap); // Not displaying g.HoveredId as it is update
                                   // mid-frame
    Text("HoverItemDelayId: 0x%08X, Timer: %.2f, ClearTimer: %.2f",
         g.HoverItemDelayId, g.HoverItemDelayTimer, g.HoverItemDelayClearTimer);
    Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)",
         g.DragDropActive, g.DragDropPayload.SourceId,
         g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
    DebugLocateItemOnHover(g.DragDropPayload.SourceId);
    Unindent();

    Text("NAV,FOCUS");
    Indent();
    Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");
    Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
    DebugLocateItemOnHover(g.NavId);
    Text("NavInputSource: %s", GetInputSourceName(g.NavInputSource));
    Text("NavLastValidSelectionUserData = %" GUI_PRId64 " (0x%" GUI_PRIX64 ")",
         g.NavLastValidSelectionUserData, g.NavLastValidSelectionUserData);
    Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
    Text("NavActivateId/DownId/PressedId: %08X/%08X/%08X", g.NavActivateId,
         g.NavActivateDownId, g.NavActivatePressedId);
    Text("NavActivateFlags: %04X", g.NavActivateFlags);
    Text("NavDisableHighlight: %d, NavDisableMouseHover: %d",
         g.NavDisableHighlight, g.NavDisableMouseHover);
    Text("NavFocusScopeId = 0x%08X", g.NavFocusScopeId);
    Text("NavWindowingTarget: '%s'",
         g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL");
    Unindent();

    TreePop();
  }

  // Overlay: Display windows Rectangles and Begin Order
  if (cfg->ShowWindowsRects || cfg->ShowWindowsBeginOrder) {
    for (Window *window : g.Windows) {
      if (!window->WasActive)
        continue;
      DrawList *draw_list = GetForegroundDrawList(window);
      if (cfg->ShowWindowsRects) {
        Rect r = Funcs::GetWindowRect(window, cfg->ShowWindowsRectsType);
        draw_list->AddRect(r.Min, r.Max, GUI_COL32(255, 0, 128, 255));
      }
      if (cfg->ShowWindowsBeginOrder &&
          !(window->Flags & WindowFlags_ChildWindow)) {
        char buf[32];
        FormatString(buf, GUI_ARRAYSIZE(buf), "%d",
                     window->BeginOrderWithinContext);
        float font_size = GetFontSize();
        draw_list->AddRectFilled(window->Pos,
                                 Add(window->Pos, Vec2(font_size, font_size)),
                                 GUI_COL32(200, 100, 100, 255));
        draw_list->AddText(window->Pos, GUI_COL32(255, 255, 255, 255), buf);
      }
    }
  }

  // Overlay: Display Tables Rectangles
  if (cfg->ShowTablesRects) {
    for (int table_n = 0; table_n < g.Tables.GetMapSize(); table_n++) {
      Table *table = g.Tables.TryGetMapData(table_n);
      if (table == NULL || table->LastFrameActive < g.FrameCount - 1)
        continue;
      DrawList *draw_list = GetForegroundDrawList(table->OuterWindow);
      if (cfg->ShowTablesRectsType >= TRT_ColumnsRect) {
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
          Rect r =
              Funcs::GetTableRect(table, cfg->ShowTablesRectsType, column_n);
          U32 col = (table->HoveredColumnBody == column_n)
                        ? GUI_COL32(255, 255, 128, 255)
                        : GUI_COL32(255, 0, 128, 255);
          float thickness =
              (table->HoveredColumnBody == column_n) ? 3.0f : 1.0f;
          draw_list->AddRect(r.Min, r.Max, col, 0.0f, 0, thickness);
        }
      } else {
        Rect r = Funcs::GetTableRect(table, cfg->ShowTablesRectsType, -1);
        draw_list->AddRect(r.Min, r.Max, GUI_COL32(255, 0, 128, 255));
      }
    }
  }

#ifdef GUI_HAS_DOCK
  // Overlay: Display Docking info
  if (show_docking_nodes && g.IO.KeyCtrl) {
  }
#endif // #ifdef GUI_HAS_DOCK

  End();
}

// [DEBUG] Display contents of Columns
inline void Gui::DebugNodeColumns(OldColumns *columns) {
  if (!TreeNode((void *)(uintptr_t)columns->ID,
                "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID,
                columns->Count, columns->Flags))
    return;
  BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)",
             columns->OffMaxX - columns->OffMinX, columns->OffMinX,
             columns->OffMaxX);
  for (OldColumnData &column : columns->Columns)
    BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)",
               (int)columns->Columns.index_from_ptr(&column), column.OffsetNorm,
               GetColumnOffsetFromNorm(columns, column.OffsetNorm));
  TreePop();
}

static void FormatTextureIDForDebugDisplay(char *buf, int buf_size,
                                           TextureID tex_id) {
  if (sizeof(tex_id) >= sizeof(void *))
    FormatString(buf, buf_size, "0x%p", (void *)*(intptr_t *)(void *)&tex_id);
  else
    FormatString(buf, buf_size, "0x%04X", *(int *)(void *)&tex_id);
}

// [DEBUG] Display contents of DrawList
inline void Gui::DebugNodeDrawList(Window *window, ViewportP *viewport,
                                   const DrawList *draw_list,
                                   const char *label) {
  Context &g = *GGui;
  GUI_UNUSED(viewport); // Used in docking branch
  MetricsConfig *cfg = &g.DebugMetricsConfig;
  int cmd_count = draw_list->CmdBuffer.Size;
  if (cmd_count > 0 && draw_list->CmdBuffer.back().ElemCount == 0 &&
      draw_list->CmdBuffer.back().UserCallback == NULL)
    cmd_count--;
  bool node_open =
      TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label,
               draw_list->_OwnerName ? draw_list->_OwnerName : "",
               draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, cmd_count);
  if (draw_list == GetWindowDrawList()) {
    SameLine();
    TextColored(
        Vec4(1.0f, 0.4f, 0.4f, 1.0f),
        "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we
                                // don't have the data double-buffered)
    if (node_open)
      TreePop();
    return;
  }

  DrawList *fg_draw_list = GetForegroundDrawList(
      window); // Render additional visuals into the top-most draw list
  if (window && IsItemHovered() && fg_draw_list)
    fg_draw_list->AddRect(window->Pos, Add(window->Pos, window->Size),
                          GUI_COL32(255, 255, 0, 255));
  if (!node_open)
    return;

  if (window && !window->WasActive)
    TextDisabled("Warning: owning Window is inactive. This DrawList is not "
                 "being rendered!");

  for (const DrawCmd *pcmd = draw_list->CmdBuffer.Data;
       pcmd < draw_list->CmdBuffer.Data + cmd_count; pcmd++) {
    if (pcmd->UserCallback) {
      BulletText("Callback %p, user_data %p", pcmd->UserCallback,
                 pcmd->UserCallbackData);
      continue;
    }

    char texid_desc[20];
    FormatTextureIDForDebugDisplay(texid_desc, GUI_ARRAYSIZE(texid_desc),
                                   pcmd->TextureId);
    char buf[300];
    FormatString(
        buf, GUI_ARRAYSIZE(buf),
        "DrawCmd:%5d tris, Tex %s, ClipRect (%4.0f,%4.0f)-(%4.0f,%4.0f)",
        pcmd->ElemCount / 3, texid_desc, pcmd->ClipRect.x, pcmd->ClipRect.y,
        pcmd->ClipRect.z, pcmd->ClipRect.w);
    bool pcmd_node_open =
        TreeNode((void *)(pcmd - draw_list->CmdBuffer.begin()), "%s", buf);
    if (IsItemHovered() &&
        (cfg->ShowDrawCmdMesh || cfg->ShowDrawCmdBoundingBoxes) && fg_draw_list)
      DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd,
                                             cfg->ShowDrawCmdMesh,
                                             cfg->ShowDrawCmdBoundingBoxes);
    if (!pcmd_node_open)
      continue;

    // Calculate approximate coverage area (touched pixel count)
    // This will be in pixels squared as long there's no post-scaling happening
    // to the renderer output.
    const DrawIdx *idx_buffer =
        (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
    const DrawVert *vtx_buffer = draw_list->VtxBuffer.Data + pcmd->VtxOffset;
    float total_area = 0.0f;
    for (unsigned int idx_n = pcmd->IdxOffset;
         idx_n < pcmd->IdxOffset + pcmd->ElemCount;) {
      Vec2 triangle[3];
      for (int n = 0; n < 3; n++, idx_n++)
        triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos;
      total_area += TriangleArea(triangle[0], triangle[1], triangle[2]);
    }

    // Display vertex information summary. Hover to get all triangles drawn in
    // wire-frame
    FormatString(
        buf, GUI_ARRAYSIZE(buf),
        "Mesh: ElemCount: %d, VtxOffset: +%d, IdxOffset: +%d, Area: ~%0.f px",
        pcmd->ElemCount, pcmd->VtxOffset, pcmd->IdxOffset, total_area);
    Selectable(buf);
    if (IsItemHovered() && fg_draw_list)
      DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd,
                                             true, false);

    // Display individual triangles/vertices. Hover on to get the corresponding
    // triangle highlighted.
    ListClipper clipper;
    clipper.Begin(pcmd->ElemCount /
                  3); // Manually coarse clip our print out of individual
                      // vertices to save CPU, only items that may be visible.
    while (clipper.Step())
      for (int prim = clipper.DisplayStart,
               idx_i = pcmd->IdxOffset + clipper.DisplayStart * 3;
           prim < clipper.DisplayEnd; prim++) {
        char *buf_p = buf, *buf_end = buf + GUI_ARRAYSIZE(buf);
        Vec2 triangle[3];
        for (int n = 0; n < 3; n++, idx_i++) {
          const DrawVert &v =
              vtx_buffer[idx_buffer ? idx_buffer[idx_i] : idx_i];
          triangle[n] = v.pos;
          buf_p += FormatString(
              buf_p, buf_end - buf_p,
              "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n",
              (n == 0) ? "Vert:" : "     ", idx_i, v.pos.x, v.pos.y, v.uv.x,
              v.uv.y, v.col);
        }

        Selectable(buf, false);
        if (fg_draw_list && IsItemHovered()) {
          DrawListFlags backup_flags = fg_draw_list->Flags;
          fg_draw_list->Flags &=
              ~DrawListFlags_AntiAliasedLines; // Disable AA on triangle
                                               // outlines is more readable
                                               // for very large and thin
                                               // triangles.
          fg_draw_list->AddPolyline(triangle, 3, GUI_COL32(255, 255, 0, 255),
                                    DrawFlags_Closed, 1.0f);
          fg_draw_list->Flags = backup_flags;
        }
      }
    TreePop();
  }
  TreePop();
}

// [DEBUG] Display mesh/aabb of a DrawCmd
inline void Gui::DebugNodeDrawCmdShowMeshAndBoundingBox(
    DrawList *out_draw_list, const DrawList *draw_list, const DrawCmd *draw_cmd,
    bool show_mesh, bool show_aabb) {
  GUI_ASSERT(show_mesh || show_aabb);

  // Draw wire-frame version of all triangles
  Rect clip_rect = draw_cmd->ClipRect;
  Rect vtxs_rect(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
  DrawListFlags backup_flags = out_draw_list->Flags;
  out_draw_list->Flags &=
      ~DrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is
                                       // more readable for very large and
                                       // thin triangles.
  for (unsigned int idx_n = draw_cmd->IdxOffset,
                    idx_end = draw_cmd->IdxOffset + draw_cmd->ElemCount;
       idx_n < idx_end;) {
    DrawIdx *idx_buffer =
        (draw_list->IdxBuffer.Size > 0)
            ? draw_list->IdxBuffer.Data
            : NULL; // We don't hold on those pointers past iterations as
                    // ->AddPolyline() may invalidate them if
                    // out_draw_list==draw_list
    DrawVert *vtx_buffer = draw_list->VtxBuffer.Data + draw_cmd->VtxOffset;

    Vec2 triangle[3];
    for (int n = 0; n < 3; n++, idx_n++)
      vtxs_rect.Add(
          (triangle[n] =
               vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos));
    if (show_mesh)
      out_draw_list->AddPolyline(triangle, 3, GUI_COL32(255, 255, 0, 255),
                                 DrawFlags_Closed,
                                 1.0f); // In yellow: mesh triangles
  }
  // Draw bounding boxes
  if (show_aabb) {
    out_draw_list->AddRect(
        Trunc(clip_rect.Min), Trunc(clip_rect.Max),
        GUI_COL32(255, 0, 255,
                  255)); // In pink: clipping rectangle submitted to GPU
    out_draw_list->AddRect(
        Trunc(vtxs_rect.Min), Trunc(vtxs_rect.Max),
        GUI_COL32(0, 255, 255, 255)); // In cyan: bounding box of triangles
  }
  out_draw_list->Flags = backup_flags;
}

// [DEBUG] Display details for a single font, called by ShowStyleEditor().
inline void Gui::DebugNodeFont(Font *font) {
  bool opened =
      TreeNode(font, "Font: \"%s\"\n%.2f px, %d glyphs, %d file(s)",
               font->ConfigData ? font->ConfigData[0].Name : "", font->FontSize,
               font->Glyphs.Size, font->ConfigDataCount);
  SameLine();
  if (SmallButton("Set as default"))
    GetIO().FontDefault = font;
  if (!opened)
    return;

  // Display preview text
  PushFont(font);
  Text("The quick brown fox jumps over the lazy dog");
  PopFont();

  // Display details
  SetNextItemWidth(GetFontSize() * 8);
  DragFloat("Font scale", &font->Scale, 0.005f, 0.3f, 2.0f, "%.1f");
  SameLine();
  MetricsHelpMarker(
      "Note than the default embedded font is NOT meant to be scaled.\n\n"
      "Font are currently rendered into bitmaps at a given size at the time of "
      "building the atlas. "
      "You may oversample them to get some flexibility with scaling. "
      "You can also render at multiple sizes and select which one to use at "
      "runtime.\n\n"
      "(Glimmer of hope: the atlas system will be rewritten in the future to "
      "make scaling more flexible.)");
  Text("Ascent: %f, Descent: %f, Height: %f", font->Ascent, font->Descent,
       font->Ascent - font->Descent);
  char c_str[5];
  Text("Fallback character: '%s' (U+%04X)",
       TextCharToUtf8(c_str, font->FallbackChar), font->FallbackChar);
  Text("Ellipsis character: '%s' (U+%04X)",
       TextCharToUtf8(c_str, font->EllipsisChar), font->EllipsisChar);
  const int surface_sqrt = (int)Sqrt((float)font->MetricsTotalSurface);
  Text("Texture Area: about %d px ~%dx%d px", font->MetricsTotalSurface,
       surface_sqrt, surface_sqrt);
  for (int config_i = 0; config_i < font->ConfigDataCount; config_i++)
    if (font->ConfigData)
      if (const FontConfig *cfg = &font->ConfigData[config_i])
        BulletText("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d, "
                   "Offset: (%.1f,%.1f)",
                   config_i, cfg->Name, cfg->OversampleH, cfg->OversampleV,
                   cfg->PixelSnapH, cfg->GlyphOffset.x, cfg->GlyphOffset.y);

  // Display all glyphs of the fonts in separate pages of 256 characters
  if (TreeNode("Glyphs", "Glyphs (%d)", font->Glyphs.Size)) {
    DrawList *draw_list = GetWindowDrawList();
    const U32 glyph_col = GetColorU32(Col_Text);
    const float cell_size = font->FontSize * 1;
    const float cell_spacing = GetStyle().ItemSpacing.y;
    for (unsigned int base = 0; base <= GUI_UNICODE_CODEPOINT_MAX;
         base += 256) {
      // Skip ahead if a large bunch of glyphs are not present in the font (test
      // in chunks of 4k) This is only a small optimization to reduce the number
      // of iterations when GUI_UNICODE_MAX_CODEPOINT is large // (if
      //  Wchar==Wchar32 we will do at least about 272 queries here)
      if (!(base & 4095) && font->IsGlyphRangeUnused(base, base + 4095)) {
        base += 4096 - 256;
        continue;
      }

      int count = 0;
      for (unsigned int n = 0; n < 256; n++)
        if (font->FindGlyphNoFallback((Wchar)(base + n)))
          count++;
      if (count <= 0)
        continue;
      if (!TreeNode((void *)(intptr_t)base, "U+%04X..U+%04X (%d %s)", base,
                    base + 255, count, count > 1 ? "glyphs" : "glyph"))
        continue;

      // Draw a 16x16 grid of glyphs
      Vec2 base_pos = GetCursorScreenPos();
      for (unsigned int n = 0; n < 256; n++) {
        // We use Font::RenderChar as a shortcut because we don't have UTF-8
        // conversion functions available here and thus cannot easily generate a
        // zero-terminated UTF-8 encoded string.
        Vec2 cell_p1(base_pos.x + (n % 16) * (cell_size + cell_spacing),
                     base_pos.y + (n / 16) * (cell_size + cell_spacing));
        Vec2 cell_p2(cell_p1.x + cell_size, cell_p1.y + cell_size);
        const FontGlyph *glyph = font->FindGlyphNoFallback((Wchar)(base + n));
        draw_list->AddRect(cell_p1, cell_p2,
                           glyph ? GUI_COL32(255, 255, 255, 100)
                                 : GUI_COL32(255, 255, 255, 50));
        if (!glyph)
          continue;
        font->RenderChar(draw_list, cell_size, cell_p1, glyph_col,
                         (Wchar)(base + n));
        if (IsMouseHoveringRect(cell_p1, cell_p2) && BeginTooltip()) {
          DebugNodeFontGlyph(font, glyph);
          EndTooltip();
        }
      }
      Dummy(Vec2((cell_size + cell_spacing) * 16,
                 (cell_size + cell_spacing) * 16));
      TreePop();
    }
    TreePop();
  }
  TreePop();
}

// [DEBUG] Display contents of Storage

// [DEBUG] Display contents of TabBar

inline void Gui::DebugNodeWindow(Window *window, const char *label) {
  if (window == NULL) {
    BulletText("%s: NULL", label);
    return;
  }

  Context &g = *GGui;
  const bool is_active = window->WasActive;
  TreeNodeFlags tree_node_flags =
      (window == g.NavWindow) ? TreeNodeFlags_Selected : TreeNodeFlags_None;
  if (!is_active) {
    PushStyleColor(Col_Text, GetStyleColorVec4(Col_TextDisabled));
  }
  const bool open = TreeNodeEx(label, tree_node_flags, "%s '%s'%s", label,
                               window->Name, is_active ? "" : " *Inactive*");
  if (!is_active) {
    PopStyleColor();
  }
  if (IsItemHovered() && is_active)
    GetForegroundDrawList(window)->AddRect(window->Pos,
                                           Add(window->Pos, window->Size),
                                           GUI_COL32(255, 255, 0, 255));
  if (!open)
    return;

  if (window->MemoryCompacted)
    TextDisabled("Note: some memory buffers have been compacted/freed.");

  WindowFlags flags = window->Flags;
  DebugNodeDrawList(window, window->Viewport, window->DrawList, "DrawList");
  BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), ContentSize (%.1f,%.1f) "
             "Ideal (%.1f,%.1f)",
             window->Pos.x, window->Pos.y, window->Size.x, window->Size.y,
             window->ContentSize.x, window->ContentSize.y,
             window->ContentSizeIdeal.x, window->ContentSizeIdeal.y);
  BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags,
             (flags & WindowFlags_ChildWindow) ? "Child " : "",
             (flags & WindowFlags_Tooltip) ? "Tooltip " : "",
             (flags & WindowFlags_Popup) ? "Popup " : "",
             (flags & WindowFlags_Modal) ? "Modal " : "",
             (flags & WindowFlags_ChildMenu) ? "ChildMenu " : "",
             (flags & WindowFlags_NoSavedSettings) ? "NoSavedSettings " : "",
             (flags & WindowFlags_NoMouseInputs) ? "NoMouseInputs" : "",
             (flags & WindowFlags_NoNavInputs) ? "NoNavInputs" : "",
             (flags & WindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "");
  BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f) Scrollbar:%s%s", window->Scroll.x,
             window->ScrollMax.x, window->Scroll.y, window->ScrollMax.y,
             window->ScrollbarX ? "X" : "", window->ScrollbarY ? "Y" : "");
  BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d",
             window->Active, window->WasActive, window->WriteAccessed,
             (window->Active || window->WasActive)
                 ? window->BeginOrderWithinContext
                 : -1);
  BulletText("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d",
             window->Appearing, window->Hidden,
             window->HiddenFramesCanSkipItems,
             window->HiddenFramesCannotSkipItems, window->SkipItems);
  for (int layer = 0; layer < NavLayer_COUNT; layer++) {
    Rect r = window->NavRectRel[layer];
    if (r.Min.x >= r.Max.y && r.Min.y >= r.Max.y)
      BulletText("NavLastIds[%d]: 0x%08X", layer, window->NavLastIds[layer]);
    else
      BulletText("NavLastIds[%d]: 0x%08X at +(%.1f,%.1f)(%.1f,%.1f)", layer,
                 window->NavLastIds[layer], r.Min.x, r.Min.y, r.Max.x, r.Max.y);
    DebugLocateItemOnHover(window->NavLastIds[layer]);
  }
  const Vec2 *pr = window->NavPreferredScoringPosRel;
  for (int layer = 0; layer < NavLayer_COUNT; layer++)
    BulletText("NavPreferredScoringPosRel[%d] = {%.1f,%.1f)", layer,
               (pr[layer].x == FLT_MAX ? -99999.0f : pr[layer].x),
               (pr[layer].y == FLT_MAX
                    ? -99999.0f
                    : pr[layer].y)); // Display as 99999.0f so it looks neater.
  BulletText("NavLayersActiveMask: %X, NavLastChildNavWindow: %s",
             window->DC.NavLayersActiveMask,
             window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name
                                           : "NULL");
  if (window->RootWindow != window) {
    DebugNodeWindow(window->RootWindow, "RootWindow");
  }
  if (window->ParentWindow != NULL) {
    DebugNodeWindow(window->ParentWindow, "ParentWindow");
  }
  if (window->DC.ChildWindows.Size > 0) {
    DebugNodeWindowsList(&window->DC.ChildWindows, "ChildWindows");
  }
  if (window->ColumnsStorage.Size > 0 &&
      TreeNode("Columns", "Columns sets (%d)", window->ColumnsStorage.Size)) {
    for (OldColumns &columns : window->ColumnsStorage)
      DebugNodeColumns(&columns);
    TreePop();
  }
  DebugNodeStorage(&window->StateStorage, "Storage");
  TreePop();
}

// FIXME-OPT: This is technically suboptimal, but it is simpler this way.

//-----------------------------------------------------------------------------
// [SECTION] DEBUG LOG WINDOW
//-----------------------------------------------------------------------------

inline void Gui::DebugLog(const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  DebugLogV(fmt, args);
  va_end(args);
}

inline void Gui::DebugLogV(const char *fmt, va_list args) {
  Context &g = *GGui;
  const int old_size = g.DebugLogBuf.size();
  g.DebugLogBuf.appendf("[%05d] ", g.FrameCount);
  g.DebugLogBuf.appendfv(fmt, args);
  g.DebugLogIndex.append(g.DebugLogBuf.c_str(), old_size, g.DebugLogBuf.size());
  if (g.DebugLogFlags & DebugLogFlags_OutputToTTY)
    GUI_DEBUG_PRINTF("%s", g.DebugLogBuf.begin() + old_size);
#ifdef GUI_ENABLE_TEST_ENGINE
  if (g.DebugLogFlags & DebugLogFlags_OutputToTestEngine)
    GUI_TEST_ENGINE_LOG("%s", g.DebugLogBuf.begin() + old_size);
#endif
}

inline void Gui::ShowDebugLogWindow(bool *p_open) {
  Context &g = *GGui;
  if (!(g.NextWindowData.Flags & NextWindowDataFlags_HasSize))
    SetNextWindowSize(Vec2(0.0f, GetFontSize() * 12.0f), Cond_FirstUseEver);
  if (!Begin("Dear Gui Debug Log", p_open) ||
      GetCurrentWindow()->BeginCount > 1) {
    End();
    return;
  }

  CheckboxFlags("All", &g.DebugLogFlags, DebugLogFlags_EventMask_);
  SameLine();
  CheckboxFlags("ActiveId", &g.DebugLogFlags, DebugLogFlags_EventActiveId);
  SameLine();
  CheckboxFlags("Focus", &g.DebugLogFlags, DebugLogFlags_EventFocus);
  SameLine();
  CheckboxFlags("Popup", &g.DebugLogFlags, DebugLogFlags_EventPopup);
  SameLine();
  CheckboxFlags("Nav", &g.DebugLogFlags, DebugLogFlags_EventNav);
  SameLine();
  if (CheckboxFlags("Clipper", &g.DebugLogFlags, DebugLogFlags_EventClipper)) {
    g.DebugLogClipperAutoDisableFrames = 2;
  }
  if (IsItemHovered())
    SetTooltip("Clipper log auto-disabled after 2 frames");
  // SameLine(); CheckboxFlags("Selection", &g.DebugLogFlags,
  // DebugLogFlags_EventSelection);
  SameLine();
  CheckboxFlags("IO", &g.DebugLogFlags, DebugLogFlags_EventIO);

  if (SmallButton("Clear")) {
    g.DebugLogBuf.clear();
    g.DebugLogIndex.clear();
  }
  SameLine();
  if (SmallButton("Copy"))
    SetClipboardText(g.DebugLogBuf.c_str());
  BeginChild("##log", Vec2(0.0f, 0.0f), ChildFlags_Border,
             WindowFlags_AlwaysVerticalScrollbar |
                 WindowFlags_AlwaysHorizontalScrollbar);

  const DebugLogFlags backup_log_flags = g.DebugLogFlags;
  g.DebugLogFlags &= ~DebugLogFlags_EventClipper;

  ListClipper clipper;
  clipper.Begin(g.DebugLogIndex.size());
  while (clipper.Step())
    for (int line_no = clipper.DisplayStart; line_no < clipper.DisplayEnd;
         line_no++) {
      const char *line_begin =
          g.DebugLogIndex.get_line_begin(g.DebugLogBuf.c_str(), line_no);
      const char *line_end =
          g.DebugLogIndex.get_line_end(g.DebugLogBuf.c_str(), line_no);
      TextUnformatted(line_begin, line_end); // Display line
      Rect text_rect = g.LastItemData.Rect;
      if (IsItemHovered())
        for (const char *p = line_begin; p <= line_end - 10;
             p++) // Search for 0x???????? identifiers
        {
          ID id = 0;
          if (p[0] != '0' || (p[1] != 'x' && p[1] != 'X') ||
              sscanf(p + 2, "%X", &id) != 1)
            continue;
          Vec2 p0 = CalcTextSize(line_begin, p);
          Vec2 p1 = CalcTextSize(p, p + 10);
          g.LastItemData.Rect =
              Rect(Add(text_rect.Min, Vec2(p0.x, 0.0f)),
                   Add(text_rect.Min, Vec2(p0.x + p1.x, p1.y)));
          if (IsMouseHoveringRect(g.LastItemData.Rect.Min,
                                  g.LastItemData.Rect.Max, true))
            DebugLocateItemOnHover(id);
          p += 10;
        }
    }
  g.DebugLogFlags = backup_log_flags;
  if (GetScrollY() >= GetScrollMaxY())
    SetScrollHereY(1.0f);
  EndChild();

  End();
}

//-----------------------------------------------------------------------------
// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)
//-----------------------------------------------------------------------------

// Draw a small cross at current CursorPos in current window's DrawList

// Draw a 10px wide rectangle around CurposPos.x using Line Y1/Y2 in current
// window's DrawList
inline void Gui::DebugDrawLineExtents(U32 col) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  float curr_x = window->DC.CursorPos.x;
  float line_y1 = (window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y
                                         : window->DC.CursorPos.y);
  float line_y2 = line_y1 + (window->DC.IsSameLine ? window->DC.PrevLineSize.y
                                                   : window->DC.CurrLineSize.y);
  window->DrawList->AddLine(Vec2(curr_x - 5.0f, line_y1),
                            Vec2(curr_x + 5.0f, line_y1), col, 1.0f);
  window->DrawList->AddLine(Vec2(curr_x - 0.5f, line_y1),
                            Vec2(curr_x - 0.5f, line_y2), col, 1.0f);
  window->DrawList->AddLine(Vec2(curr_x - 5.0f, line_y2),
                            Vec2(curr_x + 5.0f, line_y2), col, 1.0f);
}

// Draw last item rect in ForegroundDrawList (so it is always visible)

// [DEBUG] Locate item position/rectangle given an ID.
static const U32 DEBUG_LOCATE_ITEM_COLOR = GUI_COL32(0, 255, 0, 255); // Green

inline void Gui::DebugLocateItemOnHover(ID target_id) {
  if (target_id == 0 ||
      !IsItemHovered(HoveredFlags_AllowWhenBlockedByActiveItem |
                     HoveredFlags_AllowWhenBlockedByPopup))
    return;
  Context &g = *GGui;
  DebugLocateItem(target_id);
  GetForegroundDrawList(g.CurrentWindow)
      ->AddRect(Subtract(g.LastItemData.Rect.Min, Vec2(3.0f, 3.0f)),
                Add(g.LastItemData.Rect.Max, Vec2(3.0f, 3.0f)),
                DEBUG_LOCATE_ITEM_COLOR);
}

inline void Gui::DebugLocateItemResolveWithLastItem() {
  Context &g = *GGui;
  LastItemData item_data = g.LastItemData;
  g.DebugLocateId = 0;
  DrawList *draw_list = GetForegroundDrawList(g.CurrentWindow);
  Rect r = item_data.Rect;
  r.Expand(3.0f);
  Vec2 p1 = g.IO.MousePos;
  Vec2 p2 = Vec2((p1.x < r.Min.x)   ? r.Min.x
                 : (p1.x > r.Max.x) ? r.Max.x
                                    : p1.x,
                 (p1.y < r.Min.y)   ? r.Min.y
                 : (p1.y > r.Max.y) ? r.Max.y
                                    : p1.y);
  draw_list->AddRect(r.Min, r.Max, DEBUG_LOCATE_ITEM_COLOR);
  draw_list->AddLine(p1, p2, DEBUG_LOCATE_ITEM_COLOR);
}

// [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to
// visually select an item and break into its call-stack.
void Gui::UpdateDebugToolItemPicker() {
  Context &g = *GGui;
  g.DebugItemPickerBreakId = 0;
  if (!g.DebugItemPickerActive)
    return;

  const ID hovered_id = g.HoveredIdPreviousFrame;
  SetMouseCursor(MouseCursor_Hand);
  if (IsKeyPressed(Key_Escape))
    g.DebugItemPickerActive = false;
  const bool change_mapping = g.IO.KeyMods == (Mod_Ctrl | Mod_Shift);
  if (!change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) &&
      hovered_id) {
    g.DebugItemPickerBreakId = hovered_id;
    g.DebugItemPickerActive = false;
  }
  for (int mouse_button = 0; mouse_button < 3; mouse_button++)
    if (change_mapping && IsMouseClicked(mouse_button))
      g.DebugItemPickerMouseButton = (U8)mouse_button;
  SetNextWindowBgAlpha(0.70f);
  if (!BeginTooltip())
    return;
  Text("HoveredId: 0x%08X", hovered_id);
  Text("Press ESC to abort picking.");
  const char *mouse_button_names[] = {"Left", "Right", "Middle"};
  if (change_mapping)
    Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.");
  else
    TextColored(GetStyleColorVec4(hovered_id ? Col_Text : Col_TextDisabled),
                "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)",
                mouse_button_names[g.DebugItemPickerMouseButton]);
  EndTooltip();
}

// [DEBUG] ID Stack Tool: update queries. Called by NewFrame()
void Gui::UpdateDebugToolStackQueries() {
  Context &g = *GGui;
  IDStackTool *tool = &g.DebugIDStackTool;

  // Clear hook when id stack tool is not visible
  g.DebugHookIdInfo = 0;
  if (g.FrameCount != tool->LastActiveFrame + 1)
    return;

  // Update queries. The steps are: -1: query Stack, >= 0: query each stack item
  // We can only perform 1 ID Info query every frame. This is designed so the
  // GetID() tests are cheap and constant-time
  const ID query_id =
      g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId;
  if (tool->QueryId != query_id) {
    tool->QueryId = query_id;
    tool->StackLevel = -1;
    tool->Results.resize(0);
  }
  if (query_id == 0)
    return;

  // Advance to next stack level when we got our result, or after 2 frames (in
  // case we never get a result)
  int stack_level = tool->StackLevel;
  if (stack_level >= 0 && stack_level < tool->Results.Size)
    if (tool->Results[stack_level].QuerySuccess ||
        tool->Results[stack_level].QueryFrameCount > 2)
      tool->StackLevel++;

  // Update hook
  stack_level = tool->StackLevel;
  if (stack_level == -1)
    g.DebugHookIdInfo = query_id;
  if (stack_level >= 0 && stack_level < tool->Results.Size) {
    g.DebugHookIdInfo = tool->Results[stack_level].ID;
    tool->Results[stack_level].QueryFrameCount++;
  }
}

// [DEBUG] ID Stack tool: hooks called by GetID() family functions
inline void Gui::DebugHookIdInfo(ID id, DataType data_type, const void *data_id,
                                 const void *data_id_end) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  IDStackTool *tool = &g.DebugIDStackTool;

  // Step 0: stack query
  // This assumes that the ID was computed with the current ID stack, which
  // tends to be the case for our widget.
  if (tool->StackLevel == -1) {
    tool->StackLevel++;
    tool->Results.resize(window->IDStack.Size + 1, StackLevelInfo());
    for (int n = 0; n < window->IDStack.Size + 1; n++)
      tool->Results[n].ID =
          (n < window->IDStack.Size) ? window->IDStack[n] : id;
    return;
  }

  // Step 1+: query for individual level
  GUI_ASSERT(tool->StackLevel >= 0);
  if (tool->StackLevel != window->IDStack.Size)
    return;
  StackLevelInfo *info = &tool->Results[tool->StackLevel];
  GUI_ASSERT(info->ID == id && info->QueryFrameCount > 0);

  switch (data_type) {
  case DataType_S32:
    FormatString(info->Desc, GUI_ARRAYSIZE(info->Desc), "%d",
                 (int)(intptr_t)data_id);
    break;
  case DataType_String:
    FormatString(info->Desc, GUI_ARRAYSIZE(info->Desc), "%.*s",
                 data_id_end
                     ? (int)((const char *)data_id_end - (const char *)data_id)
                     : (int)strlen((const char *)data_id),
                 (const char *)data_id);
    break;
  case DataType_Pointer:
    FormatString(info->Desc, GUI_ARRAYSIZE(info->Desc), "(void*)0x%p", data_id);
    break;
  case DataType_ID:
    if (info->Desc[0] !=
        0) // PushOverrideID() is often used to avoid hashing twice, which would
           // lead to 2 calls to DebugHookIdInfo(). We prioritize the first one.
      return;
    FormatString(info->Desc, GUI_ARRAYSIZE(info->Desc), "0x%08X [override]",
                 id);
    break;
  default:
    GUI_ASSERT(0);
  }
  info->QuerySuccess = true;
  info->DataType = data_type;
}

static int StackToolFormatLevelInfo(IDStackTool *tool, int n,
                                    bool format_for_ui, char *buf,
                                    size_t buf_size) {
  StackLevelInfo *info = &tool->Results[n];
  Window *window =
      (info->Desc[0] == 0 && n == 0) ? Gui::FindWindowByID(info->ID) : NULL;
  if (window) // Source: window name (because the root ID don't call GetID() and
              // so doesn't get hooked)
    return FormatString(buf, buf_size, format_for_ui ? "\"%s\" [window]" : "%s",
                        window->Name);
  if (info->QuerySuccess) // Source: GetID() hooks (prioritize over ItemInfo()
                          // because we frequently use patterns like:
                          // PushID(str), Button("") where they both have same
                          // id)
    return FormatString(
        buf, buf_size,
        (format_for_ui && info->DataType == DataType_String) ? "\"%s\"" : "%s",
        info->Desc);
  if (tool->StackLevel <
      tool->Results
          .Size) // Only start using fallback below when all queries are done,
                 // so during queries we don't flickering ??? markers.
    return (*buf = 0);
#ifdef GUI_ENABLE_TEST_ENGINE
  if (const char *label = TestEngine_FindItemDebugLabel(
          GGui, info->ID)) // Source: TestEngine's ItemInfo()
    return FormatString(buf, buf_size, format_for_ui ? "??? \"%s\"" : "%s",
                        label);
#endif
  return FormatString(buf, buf_size, "???");
}

// ID Stack Tool: Display UI
inline void Gui::ShowIDStackToolWindow(bool *p_open) {
  Context &g = *GGui;
  if (!(g.NextWindowData.Flags & NextWindowDataFlags_HasSize))
    SetNextWindowSize(Vec2(0.0f, GetFontSize() * 8.0f), Cond_FirstUseEver);
  if (!Begin("Dear Gui ID Stack Tool", p_open) ||
      GetCurrentWindow()->BeginCount > 1) {
    End();
    return;
  }

  // Display hovered/active status
  IDStackTool *tool = &g.DebugIDStackTool;
  const ID hovered_id = g.HoveredIdPreviousFrame;
  const ID active_id = g.ActiveId;
#ifdef GUI_ENABLE_TEST_ENGINE
  Text("HoveredId: 0x%08X (\"%s\"), ActiveId:  0x%08X (\"%s\")", hovered_id,
       hovered_id ? TestEngine_FindItemDebugLabel(&g, hovered_id) : "",
       active_id,
       active_id ? TestEngine_FindItemDebugLabel(&g, active_id) : "");
#else
  Text("HoveredId: 0x%08X, ActiveId:  0x%08X", hovered_id, active_id);
#endif
  SameLine();
  MetricsHelpMarker(
      "Hover an item with the mouse to display elements of the ID Stack "
      "leading to the item's final ID.\nEach level of the stack correspond to "
      "a PushID() call.\nAll levels of the stack are hashed together to make "
      "the final ID of a widget (ID displayed at the bottom level of the "
      "stack).\nRead FAQ entry about the ID stack for details.");

  // CTRL+C to copy path
  const float time_since_copy = (float)g.Time - tool->CopyToClipboardLastTime;
  Checkbox("Ctrl+C: copy path to clipboard", &tool->CopyToClipboardOnCtrlC);
  SameLine();
  TextColored((time_since_copy >= 0.0f && time_since_copy < 0.75f &&
               Fmod(time_since_copy, 0.25f) < 0.25f * 0.5f)
                  ? Vec4(1.f, 1.f, 0.3f, 1.f)
                  : Vec4(),
              "*COPIED*");
  if (tool->CopyToClipboardOnCtrlC && IsKeyDown(Mod_Ctrl) &&
      IsKeyPressed(Key_C)) {
    tool->CopyToClipboardLastTime = (float)g.Time;
    char *p = g.TempBuffer.Data;
    char *p_end = p + g.TempBuffer.Size;
    for (int stack_n = 0; stack_n < tool->Results.Size && p + 3 < p_end;
         stack_n++) {
      *p++ = '/';
      char level_desc[256];
      StackToolFormatLevelInfo(tool, stack_n, false, level_desc,
                               GUI_ARRAYSIZE(level_desc));
      for (int n = 0; level_desc[n] && p + 2 < p_end; n++) {
        if (level_desc[n] == '/')
          *p++ = '\\';
        *p++ = level_desc[n];
      }
    }
    *p = '\0';
    SetClipboardText(g.TempBuffer.Data);
  }

  // Display decorated stack
  tool->LastActiveFrame = g.FrameCount;
  if (tool->Results.Size > 0 && BeginTable("##table", 3, TableFlags_Borders)) {
    const float id_width = CalcTextSize("0xDDDDDDDD").x;
    TableSetupColumn("Seed", TableColumnFlags_WidthFixed, id_width);
    TableSetupColumn("PushID", TableColumnFlags_WidthStretch);
    TableSetupColumn("Result", TableColumnFlags_WidthFixed, id_width);
    TableHeadersRow();
    for (int n = 0; n < tool->Results.Size; n++) {
      StackLevelInfo *info = &tool->Results[n];
      TableNextColumn();
      Text("0x%08X", (n > 0) ? tool->Results[n - 1].ID : 0);
      TableNextColumn();
      StackToolFormatLevelInfo(tool, n, true, g.TempBuffer.Data,
                               g.TempBuffer.Size);
      TextUnformatted(g.TempBuffer.Data);
      TableNextColumn();
      Text("0x%08X", info->ID);
      if (n == tool->Results.Size - 1)
        TableSetBgColor(TableBgTarget_CellBg, GetColorU32(Col_Header));
    }
    EndTable();
  }
  End();
}

#else

void Gui::ShowMetricsWindow(bool *) {}
void Gui::ShowFontAtlas(FontAtlas *) {}
void Gui::DebugNodeColumns(OldColumns *) {}
void Gui::DebugNodeDrawList(Window *, ViewportP *, const DrawList *,
                            const char *) {}
void Gui::DebugNodeDrawCmdShowMeshAndBoundingBox(DrawList *, const DrawList *,
                                                 const DrawCmd *, bool, bool) {}
void Gui::DebugNodeFont(Font *) {}
void Gui::DebugNodeStorage(Storage *, const char *) {}
void Gui::DebugNodeTabBar(TabBar *, const char *) {}
void Gui::DebugNodeWindow(Window *, const char *) {}
void Gui::DebugNodeWindowSettings(WindowSettings *) {}
void Gui::DebugNodeWindowsList(Vector<Window *> *, const char *) {}
void Gui::DebugNodeViewport(ViewportP *) {}

void Gui::DebugLog(const char *, ...) {}
void Gui::DebugLogV(const char *, va_list) {}
void Gui::ShowDebugLogWindow(bool *) {}
void Gui::ShowIDStackToolWindow(bool *) {}
void Gui::DebugHookIdInfo(ID, DataType, const void *, const void *) {}
void Gui::UpdateDebugToolItemPicker() {}
void Gui::UpdateDebugToolStackQueries() {}
void Gui::UpdateDebugToolFlashStyleColor() {}

#endif // #ifndef GUI_DISABLE_DEBUG_TOOLS

//-----------------------------------------------------------------------------

// Include gui_user.inl at the end of gui.cpp to access private
// data/functions that aren't exposed. Prefer just including gui_internal.hpp
// from your code rather than using this define. If a declaration is missing
// from gui_internal.hpp add it or request it on the github.
#ifdef GUI_INCLUDE_GUI_USER_INL
#include "gui_user.inl"
#endif

//-----------------------------------------------------------------------------

#endif // #ifndef GUI_DISABLE
// dear gui, v1.90.1 WIP
// (drawing and font code)

/*

Index of this file:

// [SECTION] STB libraries implementation
// [SECTION] Style functions
// [SECTION] DrawList
// [SECTION] DrawListSplitter
// [SECTION] DrawData
// [SECTION] Helpers ShadeVertsXXX functions
// [SECTION] FontConfig
// [SECTION] FontAtlas
// [SECTION] FontAtlas glyph ranges helpers
// [SECTION] FontGlyphRangesBuilder
// [SECTION] Font
// [SECTION] Gui Internal Render Helpers
// [SECTION] Decompression code
// [SECTION] Default font data (ProggyClean.ttf)

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef GUI_DEFINE_MATH_OPERATORS
#define GUI_DEFINE_MATH_OPERATORS
#endif
#ifndef GUI_DISABLE
#ifdef GUI_ENABLE_FREETYPE
#include "misc/freetype/gui_freetype.hpp"
#endif

#include <stdio.h> // vsnprintf, sscanf, printf

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning(disable : 4127) // condition expression is constant
#pragma warning(disable : 4505) // unreferenced local function has been removed
                                // (stb stuff)
#pragma warning(                                                               \
    disable : 4996) // 'This function or variable may be unsafe': strcpy,
                    // strdup, sprintf, vsnprintf, sscanf, fopen
#pragma warning(                                                               \
    disable : 26451) // [Static Analyzer] Arithmetic overflow : Using operator
                     // 'xxx' on a 4 byte value and then casting the result to a
                     // 8 byte value. Cast the value to the wider type before
                     // calling operator 'xxx' to avoid overflow(io.2).
#pragma warning(disable : 26812) // [Static Analyzer] The enum type 'xxx' is
                                 // unscoped. Prefer 'enum class' over 'enum'
                                 // (Enum.3). [MSVC Static Analyzer)
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored                                               \
    "-Wunknown-warning-option" // warning: unknown warning group 'xxx' // not
                               // all warnings are known by all Clang versions
                               // and they tend to be rename-happy.. so ignoring
                               // warnings triggers new warnings on some
                               // configuration. Great!
#endif
#pragma clang diagnostic ignored                                               \
    "-Wunknown-pragmas" // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored                                               \
    "-Wold-style-cast" // warning: use of old-style cast // yes, they are more
                       // terse.
#pragma clang diagnostic ignored                                               \
    "-Wfloat-equal" // warning: comparing floating point with == or != is unsafe
                    // // storing and comparing against same constants ok.
#pragma clang diagnostic ignored                                               \
    "-Wglobal-constructors" // warning: declaration requires a global destructor
                            // // similar to above, not sure what the exact
                            // difference is.
#pragma clang diagnostic ignored                                               \
    "-Wsign-conversion" // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored                                               \
    "-Wzero-as-null-pointer-constant" // warning: zero as null pointer constant
                                      // // some standard header variations use
                                      // #define NULL 0
#pragma clang diagnostic ignored                                               \
    "-Wcomma" // warning: possible misuse of comma operator here
#pragma clang diagnostic ignored                                               \
    "-Wreserved-id-macro" // warning: macro name is a reserved identifier
#pragma clang diagnostic ignored                                               \
    "-Wdouble-promotion" // warning: implicit conversion from 'float' to
                         // 'double' when passing argument to function  // using
                         // printf() is a misery with this as C++ va_arg
                         // ellipsis changes float to double.
#pragma clang diagnostic ignored                                               \
    "-Wimplicit-int-float-conversion" // warning: implicit conversion from 'xxx'
                                      // to 'float' may lose precision
#pragma clang diagnostic ignored                                               \
    "-Wreserved-identifier" // warning: identifier '_Xxx' is reserved because it
                            // starts with '_' followed by a capital letter
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored                                                 \
    "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored                                                 \
    "-Wunused-function" // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored                                                 \
    "-Wdouble-promotion" // warning: implicit conversion from 'float' to
                         // 'double' when passing argument to function
#pragma GCC diagnostic ignored                                                 \
    "-Wconversion" // warning: conversion to 'xxxx' from 'xxxx' may alter its
                   // value
#pragma GCC diagnostic ignored                                                 \
    "-Wstack-protector" // warning: stack protector not protecting local
                        // variables: variable length buffer
#pragma GCC diagnostic ignored                                                 \
    "-Wclass-memaccess" // [__GNUC__ >= 8] warning: 'memset/memcpy'
                        // clearing/writing an object of type 'xxxx' with no
                        // trivial copy-assignment; use assignment or
                        // value-initialization instead
#endif

//-------------------------------------------------------------------------
// [SECTION] STB libraries implementation (for stb_truetype and stb_rect_pack)
//-------------------------------------------------------------------------

// Compile time options:
// #define GUI_STB_NAMESPACE          Stb
// #define GUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
// #define GUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
// #define GUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
// #define GUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

#ifdef GUI_STB_NAMESPACE
namespace GUI_STB_NAMESPACE {
#endif

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(                                                               \
    disable : 4456) // declaration of 'xx' hides previous local declaration
#pragma warning(                                                               \
    disable : 6011) // (stb_rectpack) Dereferencing NULL pointer 'cur->next'.
#pragma warning(                                                               \
    disable : 6385) // (stb_truetype) Reading invalid data from 'buffer':  the
                    // readable size is '_Old_3`kernel_width' bytes, but '3'
                    // bytes may be read.
#pragma warning(                                                               \
    disable : 28182) // (stb_rectpack) Dereferencing NULL pointer. 'cur'
                     // contains the same NULL value as 'cur->next' did.
#endif

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#pragma clang diagnostic ignored                                               \
    "-Wcast-qual" // warning: cast from 'const xxxx *' to 'xxx *' drops const
                  // qualifier
#endif

#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored                                                 \
    "-Wtype-limits" // warning: comparison is always true due to limited range
                    // of data type [-Wtype-limits]
#pragma GCC diagnostic ignored                                                 \
    "-Wcast-qual" // warning: cast from type 'const xxxx *' to type 'xxxx *'
                  // casts away qualifiers
#endif

#ifndef STB_RECT_PACK_IMPLEMENTATION // in case the user already have an
                                     // implementation in the _same_ compilation
                                     // unit (e.g. unity builds)
#ifndef GUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION // in case the user already
                                                 // have an implementation in
                                                 // another compilation unit
#define STBRP_STATIC
#define STBRP_ASSERT(x)                                                        \
  do {                                                                         \
    GUI_ASSERT(x);                                                             \
  } while (0)
#define STBRP_SORT Qsort
#define STB_RECT_PACK_IMPLEMENTATION
#endif
#ifdef GUI_STB_RECT_PACK_FILENAME
#include GUI_STB_RECT_PACK_FILENAME
#else
#include "rectpack.hpp"
#endif
#endif

#ifdef GUI_ENABLE_STB_TRUETYPE
#ifndef STB_TRUETYPE_IMPLEMENTATION // in case the user already have an
                                    // implementation in the _same_ compilation
                                    // unit (e.g. unity builds)
#ifndef GUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION // in case the user already
                                                // have an implementation in
                                                // another compilation unit
#define STBTT_malloc(x, u) ((void)(u), GUI_ALLOC(x))
#define STBTT_free(x, u) ((void)(u), GUI_FREE(x))
#define STBTT_assert(x)                                                        \
  do {                                                                         \
    GUI_ASSERT(x);                                                             \
  } while (0)
#define STBTT_fmod(x, y) Fmod(x, y)
#define STBTT_sqrt(x) Sqrt(x)
#define STBTT_pow(x, y) Pow(x, y)
#define STBTT_fabs(x) Fabs(x)
#define STBTT_ifloor(x) ((int)Floor(x))
#define STBTT_iceil(x) ((int)Ceil(x))
#define STBTT_STATIC
#define STB_TRUETYPE_IMPLEMENTATION
#else
#define STBTT_DEF extern
#endif
#ifdef GUI_STB_TRUETYPE_FILENAME
#include GUI_STB_TRUETYPE_FILENAME
#else
#include "truetype.hpp"
#endif
#endif
#endif // GUI_ENABLE_STB_TRUETYPE

#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#ifdef GUI_STB_NAMESPACE
} // namespaceStb
using namespace GUI_STB_NAMESPACE;
#endif

//-----------------------------------------------------------------------------
// [SECTION] Style functions
//-----------------------------------------------------------------------------

inline void Gui::StyleColorsDark(Style *dst) {
  Style *style = dst ? dst : &Gui::GetStyle();
  Vec4 *colors = style->Colors;

  colors[Col_Text] = Vec4(1.00f, 1.00f, 1.00f, 1.00f);
  colors[Col_TextDisabled] = Vec4(0.50f, 0.50f, 0.50f, 1.00f);
  colors[Col_WindowBg] = Vec4(0.06f, 0.06f, 0.06f, 0.94f);
  colors[Col_ChildBg] = Vec4(0.00f, 0.00f, 0.00f, 0.00f);
  colors[Col_PopupBg] = Vec4(0.08f, 0.08f, 0.08f, 0.94f);
  colors[Col_Border] = Vec4(0.43f, 0.43f, 0.50f, 0.50f);
  colors[Col_BorderShadow] = Vec4(0.00f, 0.00f, 0.00f, 0.00f);
  colors[Col_FrameBg] = Vec4(0.16f, 0.29f, 0.48f, 0.54f);
  colors[Col_FrameBgHovered] = Vec4(0.26f, 0.59f, 0.98f, 0.40f);
  colors[Col_FrameBgActive] = Vec4(0.26f, 0.59f, 0.98f, 0.67f);
  colors[Col_TitleBg] = Vec4(0.04f, 0.04f, 0.04f, 1.00f);
  colors[Col_TitleBgActive] = Vec4(0.16f, 0.29f, 0.48f, 1.00f);
  colors[Col_TitleBgCollapsed] = Vec4(0.00f, 0.00f, 0.00f, 0.51f);
  colors[Col_MenuBarBg] = Vec4(0.14f, 0.14f, 0.14f, 1.00f);
  colors[Col_ScrollbarBg] = Vec4(0.02f, 0.02f, 0.02f, 0.53f);
  colors[Col_ScrollbarGrab] = Vec4(0.31f, 0.31f, 0.31f, 1.00f);
  colors[Col_ScrollbarGrabHovered] = Vec4(0.41f, 0.41f, 0.41f, 1.00f);
  colors[Col_ScrollbarGrabActive] = Vec4(0.51f, 0.51f, 0.51f, 1.00f);
  colors[Col_CheckMark] = Vec4(0.26f, 0.59f, 0.98f, 1.00f);
  colors[Col_SliderGrab] = Vec4(0.24f, 0.52f, 0.88f, 1.00f);
  colors[Col_SliderGrabActive] = Vec4(0.26f, 0.59f, 0.98f, 1.00f);
  colors[Col_Button] = Vec4(0.26f, 0.59f, 0.98f, 0.40f);
  colors[Col_ButtonHovered] = Vec4(0.26f, 0.59f, 0.98f, 1.00f);
  colors[Col_ButtonActive] = Vec4(0.06f, 0.53f, 0.98f, 1.00f);
  colors[Col_Header] = Vec4(0.26f, 0.59f, 0.98f, 0.31f);
  colors[Col_HeaderHovered] = Vec4(0.26f, 0.59f, 0.98f, 0.80f);
  colors[Col_HeaderActive] = Vec4(0.26f, 0.59f, 0.98f, 1.00f);
  colors[Col_Separator] = colors[Col_Border];
  colors[Col_SeparatorHovered] = Vec4(0.10f, 0.40f, 0.75f, 0.78f);
  colors[Col_SeparatorActive] = Vec4(0.10f, 0.40f, 0.75f, 1.00f);
  colors[Col_ResizeGrip] = Vec4(0.26f, 0.59f, 0.98f, 0.20f);
  colors[Col_ResizeGripHovered] = Vec4(0.26f, 0.59f, 0.98f, 0.67f);
  colors[Col_ResizeGripActive] = Vec4(0.26f, 0.59f, 0.98f, 0.95f);
  colors[Col_Tab] = Lerp(colors[Col_Header], colors[Col_TitleBgActive], 0.80f);
  colors[Col_TabHovered] = colors[Col_HeaderHovered];
  colors[Col_TabActive] =
      Lerp(colors[Col_HeaderActive], colors[Col_TitleBgActive], 0.60f);
  colors[Col_TabUnfocused] = Lerp(colors[Col_Tab], colors[Col_TitleBg], 0.80f);
  colors[Col_TabUnfocusedActive] =
      Lerp(colors[Col_TabActive], colors[Col_TitleBg], 0.40f);
  colors[Col_PlotLines] = Vec4(0.61f, 0.61f, 0.61f, 1.00f);
  colors[Col_PlotLinesHovered] = Vec4(1.00f, 0.43f, 0.35f, 1.00f);
  colors[Col_PlotHistogram] = Vec4(0.90f, 0.70f, 0.00f, 1.00f);
  colors[Col_PlotHistogramHovered] = Vec4(1.00f, 0.60f, 0.00f, 1.00f);
  colors[Col_TableHeaderBg] = Vec4(0.19f, 0.19f, 0.20f, 1.00f);
  colors[Col_TableBorderStrong] =
      Vec4(0.31f, 0.31f, 0.35f, 1.00f); // Prefer using Alpha=1.0 here
  colors[Col_TableBorderLight] =
      Vec4(0.23f, 0.23f, 0.25f, 1.00f); // Prefer using Alpha=1.0 here
  colors[Col_TableRowBg] = Vec4(0.00f, 0.00f, 0.00f, 0.00f);
  colors[Col_TableRowBgAlt] = Vec4(1.00f, 1.00f, 1.00f, 0.06f);
  colors[Col_TextSelectedBg] = Vec4(0.26f, 0.59f, 0.98f, 0.35f);
  colors[Col_DragDropTarget] = Vec4(1.00f, 1.00f, 0.00f, 0.90f);
  colors[Col_NavHighlight] = Vec4(0.26f, 0.59f, 0.98f, 1.00f);
  colors[Col_NavWindowingHighlight] = Vec4(1.00f, 1.00f, 1.00f, 0.70f);
  colors[Col_NavWindowingDimBg] = Vec4(0.80f, 0.80f, 0.80f, 0.20f);
  colors[Col_ModalWindowDimBg] = Vec4(0.80f, 0.80f, 0.80f, 0.35f);
}

inline void Gui::StyleColorsClassic(Style *dst) {
  Style *style = dst ? dst : &Gui::GetStyle();
  Vec4 *colors = style->Colors;

  colors[Col_Text] = Vec4(0.90f, 0.90f, 0.90f, 1.00f);
  colors[Col_TextDisabled] = Vec4(0.60f, 0.60f, 0.60f, 1.00f);
  colors[Col_WindowBg] = Vec4(0.00f, 0.00f, 0.00f, 0.85f);
  colors[Col_ChildBg] = Vec4(0.00f, 0.00f, 0.00f, 0.00f);
  colors[Col_PopupBg] = Vec4(0.11f, 0.11f, 0.14f, 0.92f);
  colors[Col_Border] = Vec4(0.50f, 0.50f, 0.50f, 0.50f);
  colors[Col_BorderShadow] = Vec4(0.00f, 0.00f, 0.00f, 0.00f);
  colors[Col_FrameBg] = Vec4(0.43f, 0.43f, 0.43f, 0.39f);
  colors[Col_FrameBgHovered] = Vec4(0.47f, 0.47f, 0.69f, 0.40f);
  colors[Col_FrameBgActive] = Vec4(0.42f, 0.41f, 0.64f, 0.69f);
  colors[Col_TitleBg] = Vec4(0.27f, 0.27f, 0.54f, 0.83f);
  colors[Col_TitleBgActive] = Vec4(0.32f, 0.32f, 0.63f, 0.87f);
  colors[Col_TitleBgCollapsed] = Vec4(0.40f, 0.40f, 0.80f, 0.20f);
  colors[Col_MenuBarBg] = Vec4(0.40f, 0.40f, 0.55f, 0.80f);
  colors[Col_ScrollbarBg] = Vec4(0.20f, 0.25f, 0.30f, 0.60f);
  colors[Col_ScrollbarGrab] = Vec4(0.40f, 0.40f, 0.80f, 0.30f);
  colors[Col_ScrollbarGrabHovered] = Vec4(0.40f, 0.40f, 0.80f, 0.40f);
  colors[Col_ScrollbarGrabActive] = Vec4(0.41f, 0.39f, 0.80f, 0.60f);
  colors[Col_CheckMark] = Vec4(0.90f, 0.90f, 0.90f, 0.50f);
  colors[Col_SliderGrab] = Vec4(1.00f, 1.00f, 1.00f, 0.30f);
  colors[Col_SliderGrabActive] = Vec4(0.41f, 0.39f, 0.80f, 0.60f);
  colors[Col_Button] = Vec4(0.35f, 0.40f, 0.61f, 0.62f);
  colors[Col_ButtonHovered] = Vec4(0.40f, 0.48f, 0.71f, 0.79f);
  colors[Col_ButtonActive] = Vec4(0.46f, 0.54f, 0.80f, 1.00f);
  colors[Col_Header] = Vec4(0.40f, 0.40f, 0.90f, 0.45f);
  colors[Col_HeaderHovered] = Vec4(0.45f, 0.45f, 0.90f, 0.80f);
  colors[Col_HeaderActive] = Vec4(0.53f, 0.53f, 0.87f, 0.80f);
  colors[Col_Separator] = Vec4(0.50f, 0.50f, 0.50f, 0.60f);
  colors[Col_SeparatorHovered] = Vec4(0.60f, 0.60f, 0.70f, 1.00f);
  colors[Col_SeparatorActive] = Vec4(0.70f, 0.70f, 0.90f, 1.00f);
  colors[Col_ResizeGrip] = Vec4(1.00f, 1.00f, 1.00f, 0.10f);
  colors[Col_ResizeGripHovered] = Vec4(0.78f, 0.82f, 1.00f, 0.60f);
  colors[Col_ResizeGripActive] = Vec4(0.78f, 0.82f, 1.00f, 0.90f);
  colors[Col_Tab] = Lerp(colors[Col_Header], colors[Col_TitleBgActive], 0.80f);
  colors[Col_TabHovered] = colors[Col_HeaderHovered];
  colors[Col_TabActive] =
      Lerp(colors[Col_HeaderActive], colors[Col_TitleBgActive], 0.60f);
  colors[Col_TabUnfocused] = Lerp(colors[Col_Tab], colors[Col_TitleBg], 0.80f);
  colors[Col_TabUnfocusedActive] =
      Lerp(colors[Col_TabActive], colors[Col_TitleBg], 0.40f);
  colors[Col_PlotLines] = Vec4(1.00f, 1.00f, 1.00f, 1.00f);
  colors[Col_PlotLinesHovered] = Vec4(0.90f, 0.70f, 0.00f, 1.00f);
  colors[Col_PlotHistogram] = Vec4(0.90f, 0.70f, 0.00f, 1.00f);
  colors[Col_PlotHistogramHovered] = Vec4(1.00f, 0.60f, 0.00f, 1.00f);
  colors[Col_TableHeaderBg] = Vec4(0.27f, 0.27f, 0.38f, 1.00f);
  colors[Col_TableBorderStrong] =
      Vec4(0.31f, 0.31f, 0.45f, 1.00f); // Prefer using Alpha=1.0 here
  colors[Col_TableBorderLight] =
      Vec4(0.26f, 0.26f, 0.28f, 1.00f); // Prefer using Alpha=1.0 here
  colors[Col_TableRowBg] = Vec4(0.00f, 0.00f, 0.00f, 0.00f);
  colors[Col_TableRowBgAlt] = Vec4(1.00f, 1.00f, 1.00f, 0.07f);
  colors[Col_TextSelectedBg] = Vec4(0.00f, 0.00f, 1.00f, 0.35f);
  colors[Col_DragDropTarget] = Vec4(1.00f, 1.00f, 0.00f, 0.90f);
  colors[Col_NavHighlight] = colors[Col_HeaderHovered];
  colors[Col_NavWindowingHighlight] = Vec4(1.00f, 1.00f, 1.00f, 0.70f);
  colors[Col_NavWindowingDimBg] = Vec4(0.80f, 0.80f, 0.80f, 0.20f);
  colors[Col_ModalWindowDimBg] = Vec4(0.20f, 0.20f, 0.20f, 0.35f);
}

// Those light colors are better suited with a thicker font than the default one
// + FrameBorder
inline void Gui::StyleColorsLight(Style *dst) {
  Style *style = dst ? dst : &Gui::GetStyle();
  Vec4 *colors = style->Colors;

  colors[Col_Text] = Vec4(0.00f, 0.00f, 0.00f, 1.00f);
  colors[Col_TextDisabled] = Vec4(0.60f, 0.60f, 0.60f, 1.00f);
  colors[Col_WindowBg] = Vec4(0.94f, 0.94f, 0.94f, 1.00f);
  colors[Col_ChildBg] = Vec4(0.00f, 0.00f, 0.00f, 0.00f);
  colors[Col_PopupBg] = Vec4(1.00f, 1.00f, 1.00f, 0.98f);
  colors[Col_Border] = Vec4(0.00f, 0.00f, 0.00f, 0.30f);
  colors[Col_BorderShadow] = Vec4(0.00f, 0.00f, 0.00f, 0.00f);
  colors[Col_FrameBg] = Vec4(1.00f, 1.00f, 1.00f, 1.00f);
  colors[Col_FrameBgHovered] = Vec4(0.26f, 0.59f, 0.98f, 0.40f);
  colors[Col_FrameBgActive] = Vec4(0.26f, 0.59f, 0.98f, 0.67f);
  colors[Col_TitleBg] = Vec4(0.96f, 0.96f, 0.96f, 1.00f);
  colors[Col_TitleBgActive] = Vec4(0.82f, 0.82f, 0.82f, 1.00f);
  colors[Col_TitleBgCollapsed] = Vec4(1.00f, 1.00f, 1.00f, 0.51f);
  colors[Col_MenuBarBg] = Vec4(0.86f, 0.86f, 0.86f, 1.00f);
  colors[Col_ScrollbarBg] = Vec4(0.98f, 0.98f, 0.98f, 0.53f);
  colors[Col_ScrollbarGrab] = Vec4(0.69f, 0.69f, 0.69f, 0.80f);
  colors[Col_ScrollbarGrabHovered] = Vec4(0.49f, 0.49f, 0.49f, 0.80f);
  colors[Col_ScrollbarGrabActive] = Vec4(0.49f, 0.49f, 0.49f, 1.00f);
  colors[Col_CheckMark] = Vec4(0.26f, 0.59f, 0.98f, 1.00f);
  colors[Col_SliderGrab] = Vec4(0.26f, 0.59f, 0.98f, 0.78f);
  colors[Col_SliderGrabActive] = Vec4(0.46f, 0.54f, 0.80f, 0.60f);
  colors[Col_Button] = Vec4(0.26f, 0.59f, 0.98f, 0.40f);
  colors[Col_ButtonHovered] = Vec4(0.26f, 0.59f, 0.98f, 1.00f);
  colors[Col_ButtonActive] = Vec4(0.06f, 0.53f, 0.98f, 1.00f);
  colors[Col_Header] = Vec4(0.26f, 0.59f, 0.98f, 0.31f);
  colors[Col_HeaderHovered] = Vec4(0.26f, 0.59f, 0.98f, 0.80f);
  colors[Col_HeaderActive] = Vec4(0.26f, 0.59f, 0.98f, 1.00f);
  colors[Col_Separator] = Vec4(0.39f, 0.39f, 0.39f, 0.62f);
  colors[Col_SeparatorHovered] = Vec4(0.14f, 0.44f, 0.80f, 0.78f);
  colors[Col_SeparatorActive] = Vec4(0.14f, 0.44f, 0.80f, 1.00f);
  colors[Col_ResizeGrip] = Vec4(0.35f, 0.35f, 0.35f, 0.17f);
  colors[Col_ResizeGripHovered] = Vec4(0.26f, 0.59f, 0.98f, 0.67f);
  colors[Col_ResizeGripActive] = Vec4(0.26f, 0.59f, 0.98f, 0.95f);
  colors[Col_Tab] = Lerp(colors[Col_Header], colors[Col_TitleBgActive], 0.90f);
  colors[Col_TabHovered] = colors[Col_HeaderHovered];
  colors[Col_TabActive] =
      Lerp(colors[Col_HeaderActive], colors[Col_TitleBgActive], 0.60f);
  colors[Col_TabUnfocused] = Lerp(colors[Col_Tab], colors[Col_TitleBg], 0.80f);
  colors[Col_TabUnfocusedActive] =
      Lerp(colors[Col_TabActive], colors[Col_TitleBg], 0.40f);
  colors[Col_PlotLines] = Vec4(0.39f, 0.39f, 0.39f, 1.00f);
  colors[Col_PlotLinesHovered] = Vec4(1.00f, 0.43f, 0.35f, 1.00f);
  colors[Col_PlotHistogram] = Vec4(0.90f, 0.70f, 0.00f, 1.00f);
  colors[Col_PlotHistogramHovered] = Vec4(1.00f, 0.45f, 0.00f, 1.00f);
  colors[Col_TableHeaderBg] = Vec4(0.78f, 0.87f, 0.98f, 1.00f);
  colors[Col_TableBorderStrong] =
      Vec4(0.57f, 0.57f, 0.64f, 1.00f); // Prefer using Alpha=1.0 here
  colors[Col_TableBorderLight] =
      Vec4(0.68f, 0.68f, 0.74f, 1.00f); // Prefer using Alpha=1.0 here
  colors[Col_TableRowBg] = Vec4(0.00f, 0.00f, 0.00f, 0.00f);
  colors[Col_TableRowBgAlt] = Vec4(0.30f, 0.30f, 0.30f, 0.09f);
  colors[Col_TextSelectedBg] = Vec4(0.26f, 0.59f, 0.98f, 0.35f);
  colors[Col_DragDropTarget] = Vec4(0.26f, 0.59f, 0.98f, 0.95f);
  colors[Col_NavHighlight] = colors[Col_HeaderHovered];
  colors[Col_NavWindowingHighlight] = Vec4(0.70f, 0.70f, 0.70f, 0.70f);
  colors[Col_NavWindowingDimBg] = Vec4(0.20f, 0.20f, 0.20f, 0.20f);
  colors[Col_ModalWindowDimBg] = Vec4(0.20f, 0.20f, 0.20f, 0.35f);
}

//-----------------------------------------------------------------------------
// [SECTION] DrawList
//-----------------------------------------------------------------------------

inline DrawListSharedData::DrawListSharedData() {
  memset(this, 0, sizeof(*this));
  for (int i = 0; i < GUI_ARRAYSIZE(ArcFastVtx); i++) {
    const float a = ((float)i * 2 * GUI_PI) / (float)GUI_ARRAYSIZE(ArcFastVtx);
    ArcFastVtx[i] = Vec2(Cos(a), Sin(a));
  }
  ArcFastRadiusCutoff = GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(
      GUI_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
}

inline void DrawListSharedData::SetCircleTessellationMaxError(float max_error) {
  if (CircleSegmentMaxError == max_error)
    return;

  GUI_ASSERT(max_error > 0.0f);
  CircleSegmentMaxError = max_error;
  for (int i = 0; i < GUI_ARRAYSIZE(CircleSegmentCounts); i++) {
    const float radius = (float)i;
    CircleSegmentCounts[i] =
        (U8)((i > 0) ? GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(
                           radius, CircleSegmentMaxError)
                     : GUI_DRAWLIST_ARCFAST_SAMPLE_MAX);
  }
  ArcFastRadiusCutoff = GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(
      GUI_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
}

// Initialize before use in a new frame. We always have a command ready in the
// buffer.
inline void DrawList::_ResetForNewFrame() {
  // Verify that the DrawCmd fields we want to memcmp() are contiguous in
  // memory.
  GUI_STATIC_ASSERT(offsetof(DrawCmd, ClipRect) == 0);
  GUI_STATIC_ASSERT(offsetof(DrawCmd, TextureId) == sizeof(Vec4));
  GUI_STATIC_ASSERT(offsetof(DrawCmd, VtxOffset) ==
                    sizeof(Vec4) + sizeof(TextureID));
  if (_Splitter._Count > 1)
    _Splitter.Merge(this);

  CmdBuffer.resize(0);
  IdxBuffer.resize(0);
  VtxBuffer.resize(0);
  Flags = _Data->InitialFlags;
  memset(&_CmdHeader, 0, sizeof(_CmdHeader));
  _VtxCurrentIdx = 0;
  _VtxWritePtr = NULL;
  _IdxWritePtr = NULL;
  _ClipRectStack.resize(0);
  _TextureIdStack.resize(0);
  _Path.resize(0);
  _Splitter.Clear();
  CmdBuffer.push_back(DrawCmd());
  _FringeScale = 1.0f;
}

inline void DrawList::AddDrawCmd() {
  DrawCmd draw_cmd;
  draw_cmd.ClipRect =
      _CmdHeader.ClipRect; // Same as calling DrawCmd_HeaderCopy()
  draw_cmd.TextureId = _CmdHeader.TextureId;
  draw_cmd.VtxOffset = _CmdHeader.VtxOffset;
  draw_cmd.IdxOffset = IdxBuffer.Size;

  GUI_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z &&
             draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
  CmdBuffer.push_back(draw_cmd);
}

// Pop trailing draw command (used before merging or presenting to user)
// Note that this leaves the DrawList in a state unfit for further commands,
// as most code assume that CmdBuffer.Size > 0 && CmdBuffer.back().UserCallback
// == NULL

inline void DrawList::AddCallback(DrawCallback callback, void *callback_data) {
  GUI_ASSERT_PARANOID(CmdBuffer.Size > 0);
  DrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  GUI_ASSERT(curr_cmd->UserCallback == NULL);
  if (curr_cmd->ElemCount != 0) {
    AddDrawCmd();
    curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  }
  curr_cmd->UserCallback = callback;
  curr_cmd->UserCallbackData = callback_data;

  AddDrawCmd(); // Force a new command after us (see comment below)
}

// Compare ClipRect, TextureId and VtxOffset with a single memcmp()
#define DrawCmd_HeaderSize (offsetof(DrawCmd, VtxOffset) + sizeof(unsigned int))
#define DrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)                                \
  (memcmp(CMD_LHS, CMD_RHS,                                                    \
          DrawCmd_HeaderSize)) // Compare ClipRect, TextureId, VtxOffset
#define DrawCmd_HeaderCopy(CMD_DST, CMD_SRC)                                   \
  (memcpy(CMD_DST, CMD_SRC,                                                    \
          DrawCmd_HeaderSize)) // Copy ClipRect, TextureId, VtxOffset
#define DrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)                           \
  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)

// Try to merge two last draw commands
inline void DrawList::_TryMergeDrawCmds() {
  GUI_ASSERT_PARANOID(CmdBuffer.Size > 0);
  DrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  DrawCmd *prev_cmd = curr_cmd - 1;
  if (DrawCmd_HeaderCompare(curr_cmd, prev_cmd) == 0 &&
      DrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) &&
      curr_cmd->UserCallback == NULL && prev_cmd->UserCallback == NULL) {
    prev_cmd->ElemCount += curr_cmd->ElemCount;
    CmdBuffer.pop_back();
  }
}

// Our scheme may appears a bit unusual, basically we want the most-common calls
// AddLine AddRect etc. to not have to perform any check so we always have a
// command ready in the stack. The cost of figuring out if a new command has to
// be added or if we can merge is paid in those Update** functions only.
inline void DrawList::_OnChangedClipRect() {
  // If current command is used with different settings we need to add a new
  // command
  GUI_ASSERT_PARANOID(CmdBuffer.Size > 0);
  DrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  if (curr_cmd->ElemCount != 0 &&
      memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(Vec4)) != 0) {
    AddDrawCmd();
    return;
  }
  GUI_ASSERT(curr_cmd->UserCallback == NULL);

  // Try to merge with previous command if it matches, else use current command
  DrawCmd *prev_cmd = curr_cmd - 1;
  if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 &&
      DrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 &&
      DrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) &&
      prev_cmd->UserCallback == NULL) {
    CmdBuffer.pop_back();
    return;
  }

  curr_cmd->ClipRect = _CmdHeader.ClipRect;
}

inline void DrawList::_OnChangedTextureID() {
  // If current command is used with different settings we need to add a new
  // command
  GUI_ASSERT_PARANOID(CmdBuffer.Size > 0);
  DrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId) {
    AddDrawCmd();
    return;
  }
  GUI_ASSERT(curr_cmd->UserCallback == NULL);

  // Try to merge with previous command if it matches, else use current command
  DrawCmd *prev_cmd = curr_cmd - 1;
  if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 &&
      DrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 &&
      DrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) &&
      prev_cmd->UserCallback == NULL) {
    CmdBuffer.pop_back();
    return;
  }

  curr_cmd->TextureId = _CmdHeader.TextureId;
}

inline void DrawList::_OnChangedVtxOffset() {
  // We don't need to compare curr_cmd->VtxOffset != _CmdHeader.VtxOffset
  // because we know it'll be different at the time we call this.
  _VtxCurrentIdx = 0;
  GUI_ASSERT_PARANOID(CmdBuffer.Size > 0);
  DrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  // GUI_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349
  if (curr_cmd->ElemCount != 0) {
    AddDrawCmd();
    return;
  }
  GUI_ASSERT(curr_cmd->UserCallback == NULL);
  curr_cmd->VtxOffset = _CmdHeader.VtxOffset;
}

inline int DrawList::_CalcCircleAutoSegmentCount(float radius) const {
  // Automatic segment count
  const int radius_idx =
      (int)(radius + 0.999999f); // ceil to never reduce accuracy
  if (radius_idx >= 0 && radius_idx < GUI_ARRAYSIZE(_Data->CircleSegmentCounts))
    return _Data->CircleSegmentCounts[radius_idx]; // Use cached value
  else
    return GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius,
                                                 _Data->CircleSegmentMaxError);
}

// Render-level scissoring. This is passed down to your render function but not
// used for CPU-side coarse clipping. Prefer using higher-level
// Gui::PushClipRect() to affect logic (hit-testing and widget culling)
inline void DrawList::PushClipRect(const Vec2 &cr_min, const Vec2 &cr_max,
                                   bool intersect_with_current_clip_rect) {
  Vec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
  if (intersect_with_current_clip_rect) {
    Vec4 current = _CmdHeader.ClipRect;
    if (cr.x < current.x)
      cr.x = current.x;
    if (cr.y < current.y)
      cr.y = current.y;
    if (cr.z > current.z)
      cr.z = current.z;
    if (cr.w > current.w)
      cr.w = current.w;
  }
  cr.z = Max(cr.x, cr.z);
  cr.w = Max(cr.y, cr.w);

  _ClipRectStack.push_back(cr);
  _CmdHeader.ClipRect = cr;
  _OnChangedClipRect();
}

inline void DrawList::PushClipRectFullScreen() {
  PushClipRect(Vec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y),
               Vec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));
}

inline void DrawList::PopClipRect() {
  _ClipRectStack.pop_back();
  _CmdHeader.ClipRect = (_ClipRectStack.Size == 0)
                            ? _Data->ClipRectFullscreen
                            : _ClipRectStack.Data[_ClipRectStack.Size - 1];
  _OnChangedClipRect();
}

// Reserve space for a number of vertices and indices.
// You must finish filling your reserved data before calling PrimReserve()
// again, as it may reallocate or submit the intermediate results.
// PrimUnreserve() can be used to release unused allocations.
inline void DrawList::PrimReserve(int idx_count, int vtx_count) {
  // Large mesh support (when enabled)
  GUI_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
  if (sizeof(DrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) &&
      (Flags & DrawListFlags_AllowVtxOffset)) {
    // FIXME: In theory we should be testing that vtx_count <64k here.
    // In practice, RenderText() relies on reserving ahead for a worst case
    // scenario so it is currently useful for us to not make that check until we
    // rework the text functions to handle clipping and large horizontal lines
    // better.
    _CmdHeader.VtxOffset = VtxBuffer.Size;
    _OnChangedVtxOffset();
  }

  DrawCmd *draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  draw_cmd->ElemCount += idx_count;

  int vtx_buffer_old_size = VtxBuffer.Size;
  VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
  _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

  int idx_buffer_old_size = IdxBuffer.Size;
  IdxBuffer.resize(idx_buffer_old_size + idx_count);
  _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
}

// Release the a number of reserved vertices/indices from the end of the last
// reservation made with PrimReserve().
inline void DrawList::PrimUnreserve(int idx_count, int vtx_count) {
  GUI_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);

  DrawCmd *draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  draw_cmd->ElemCount -= idx_count;
  VtxBuffer.shrink(VtxBuffer.Size - vtx_count);
  IdxBuffer.shrink(IdxBuffer.Size - idx_count);
}

// Fully unrolled with inline call to keep our debug builds decently fast.
inline void DrawList::PrimRect(const Vec2 &a, const Vec2 &c, U32 col) {
  Vec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
  DrawIdx idx = (DrawIdx)_VtxCurrentIdx;
  _IdxWritePtr[0] = idx;
  _IdxWritePtr[1] = (DrawIdx)(idx + 1);
  _IdxWritePtr[2] = (DrawIdx)(idx + 2);
  _IdxWritePtr[3] = idx;
  _IdxWritePtr[4] = (DrawIdx)(idx + 2);
  _IdxWritePtr[5] = (DrawIdx)(idx + 3);
  _VtxWritePtr[0].pos = a;
  _VtxWritePtr[0].uv = uv;
  _VtxWritePtr[0].col = col;
  _VtxWritePtr[1].pos = b;
  _VtxWritePtr[1].uv = uv;
  _VtxWritePtr[1].col = col;
  _VtxWritePtr[2].pos = c;
  _VtxWritePtr[2].uv = uv;
  _VtxWritePtr[2].col = col;
  _VtxWritePtr[3].pos = d;
  _VtxWritePtr[3].uv = uv;
  _VtxWritePtr[3].col = col;
  _VtxWritePtr += 4;
  _VtxCurrentIdx += 4;
  _IdxWritePtr += 6;
}

// On AddPolyline() and AddConvexPolyFilled() we intentionally avoid using
// Vec2 and superfluous function calls to optimize debug/non-inlined builds.
// - Those macros expects l-values and need to be used as their own statement.
// - Those macros are intentionally not surrounded by the 'do {} while (0)'
// idiom because even that translates to runtime with debug compilers.
#define GUI_NORMALIZE2F_OVER_ZERO(VX, VY)                                      \
  {                                                                            \
    float d2 = VX * VX + VY * VY;                                              \
    if (d2 > 0.0f) {                                                           \
      float inv_len = Rsqrt(d2);                                               \
      VX *= inv_len;                                                           \
      VY *= inv_len;                                                           \
    }                                                                          \
  }                                                                            \
  (void)0
#define GUI_FIXNORMAL2F_MAX_INVLEN2 100.0f // 500.0f (see #4053, #3366)
#define GUI_FIXNORMAL2F(VX, VY)                                                \
  {                                                                            \
    float d2 = VX * VX + VY * VY;                                              \
    if (d2 > 0.000001f) {                                                      \
      float inv_len2 = 1.0f / d2;                                              \
      if (inv_len2 > GUI_FIXNORMAL2F_MAX_INVLEN2)                              \
        inv_len2 = GUI_FIXNORMAL2F_MAX_INVLEN2;                                \
      VX *= inv_len2;                                                          \
      VY *= inv_len2;                                                          \
    }                                                                          \
  }                                                                            \
  (void)0

// TODO: Thickness anti-aliased lines cap are missing their AA fringe.
// We avoid using the Vec2 math operators here to reduce cost to a minimum for
// debug/non-inlined builds.
inline void DrawList::AddPolyline(const Vec2 *points, const int points_count,
                                  U32 col, DrawFlags flags, float thickness) {
  if (points_count < 2 || (col & GUI_COL32_A_MASK) == 0)
    return;

  const bool closed = (flags & DrawFlags_Closed) != 0;
  const Vec2 opaque_uv = _Data->TexUvWhitePixel;
  const int count =
      closed ? points_count
             : points_count - 1; // The number of line segments we need to draw
  const bool thick_line = (thickness > _FringeScale);

  if (Flags & DrawListFlags_AntiAliasedLines) {
    // Anti-aliased stroke
    const float AA_SIZE = _FringeScale;
    const U32 col_trans = col & ~GUI_COL32_A_MASK;

    // Thicknesses <1.0 should behave like thickness 1.0
    thickness = Max(thickness, 1.0f);
    const int integer_thickness = (int)thickness;
    const float fractional_thickness = thickness - integer_thickness;

    // Do we want to draw this line using a texture?
    // - For now, only draw integer-width lines using textures to avoid issues
    // with the way scaling occurs, could be improved.
    // - If AA_SIZE is not 1.0f we cannot use the texture path.
    const bool use_texture =
        (Flags & DrawListFlags_AntiAliasedLinesUseTex) &&
        (integer_thickness < GUI_DRAWLIST_TEX_LINES_WIDTH_MAX) &&
        (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);

    // We should never hit this, because NewFrame() doesn't set
    // DrawListFlags_AntiAliasedLinesUseTex unless
    // FontAtlasFlags_NoBakedLines is off
    GUI_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags &
                                          FontAtlasFlags_NoBakedLines));

    const int idx_count =
        use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);
    const int vtx_count =
        use_texture ? (points_count * 2)
                    : (thick_line ? points_count * 4 : points_count * 3);
    PrimReserve(idx_count, vtx_count);

    // Temporary buffer
    // The first <points_count> items are normals at each line point, then after
    // that there are either 2 or 4 temp points for each line point
    _Data->TempBuffer.reserve_discard(points_count *
                                      ((use_texture || !thick_line) ? 3 : 5));
    Vec2 *temp_normals = _Data->TempBuffer.Data;
    Vec2 *temp_points = temp_normals + points_count;

    // Calculate normals (tangents) for each line segment
    for (int i1 = 0; i1 < count; i1++) {
      const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
      float dx = points[i2].x - points[i1].x;
      float dy = points[i2].y - points[i1].y;
      GUI_NORMALIZE2F_OVER_ZERO(dx, dy);
      temp_normals[i1].x = dy;
      temp_normals[i1].y = -dx;
    }
    if (!closed)
      temp_normals[points_count - 1] = temp_normals[points_count - 2];

    // If we are drawing a one-pixel-wide line without a texture, or a textured
    // line of any width, we only need 2 or 3 vertices per point
    if (use_texture || !thick_line) {
      // [PATH 1] Texture-based lines (thick or non-thick)
      // [PATH 2] Non texture-based lines (non-thick)

      // The width of the geometry we need to draw - this is essentially
      // <thickness> pixels for the line itself, plus "one pixel" for AA.
      // - In the texture-based path, we don't use AA_SIZE here because the +1
      // is tied to the generated texture
      //   (see FontAtlasBuildRenderLinesTexData() function), and so alternate
      //   values won't work without changes to that code.
      // - In the non texture-based paths, we would allow AA_SIZE to potentially
      // be != 1.0f with a patch (e.g. fringe_scale patch to
      //   allow scaling geometry while preserving one-screen-pixel AA fringe).
      const float half_draw_size =
          use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;

      // If line is not closed, the first and last points need to be generated
      // differently as there are no normals to blend
      if (!closed) {
        temp_points[0] =
            Add(points[0], Multiply(temp_normals[0], half_draw_size));
        temp_points[1] =
            Subtract(points[0], Multiply(temp_normals[0], half_draw_size));
        temp_points[(points_count - 1) * 2 + 0] =
            Add(points[points_count - 1],
                Multiply(temp_normals[points_count - 1], half_draw_size));
        temp_points[(points_count - 1) * 2 + 1] =
            Subtract(points[points_count - 1],
                     Multiply(temp_normals[points_count - 1], half_draw_size));
      }

      // Generate the indices to form a number of triangles for each line
      // segment, and the vertices for the line edges This takes points n and
      // n+1 and writes into n+1, with the first point in a closed line being
      // generated from the final one (as n+1 wraps)
      // FIXME-OPT: Merge the different loops, possibly remove the temporary
      // buffer.
      unsigned int idx1 =
          _VtxCurrentIdx; // Vertex index for start of line segment
      for (int i1 = 0; i1 < count;
           i1++) // i1 is the first point of the line segment
      {
        const int i2 =
            (i1 + 1) == points_count
                ? 0
                : i1 + 1; // i2 is the second point of the line segment
        const unsigned int idx2 =
            ((i1 + 1) == points_count)
                ? _VtxCurrentIdx
                : (idx1 +
                   (use_texture ? 2 : 3)); // Vertex index for end of segment

        // Average normals
        float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
        float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
        GUI_FIXNORMAL2F(dm_x, dm_y);
        dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of
                                // the AA area
        dm_y *= half_draw_size;

        // Add temporary vertexes for the outer edges
        Vec2 *out_vtx = &temp_points[i2 * 2];
        out_vtx[0].x = points[i2].x + dm_x;
        out_vtx[0].y = points[i2].y + dm_y;
        out_vtx[1].x = points[i2].x - dm_x;
        out_vtx[1].y = points[i2].y - dm_y;

        if (use_texture) {
          // Add indices for two triangles
          _IdxWritePtr[0] = (DrawIdx)(idx2 + 0);
          _IdxWritePtr[1] = (DrawIdx)(idx1 + 0);
          _IdxWritePtr[2] = (DrawIdx)(idx1 + 1); // Right tri
          _IdxWritePtr[3] = (DrawIdx)(idx2 + 1);
          _IdxWritePtr[4] = (DrawIdx)(idx1 + 1);
          _IdxWritePtr[5] = (DrawIdx)(idx2 + 0); // Left tri
          _IdxWritePtr += 6;
        } else {
          // Add indexes for four triangles
          _IdxWritePtr[0] = (DrawIdx)(idx2 + 0);
          _IdxWritePtr[1] = (DrawIdx)(idx1 + 0);
          _IdxWritePtr[2] = (DrawIdx)(idx1 + 2); // Right tri 1
          _IdxWritePtr[3] = (DrawIdx)(idx1 + 2);
          _IdxWritePtr[4] = (DrawIdx)(idx2 + 2);
          _IdxWritePtr[5] = (DrawIdx)(idx2 + 0); // Right tri 2
          _IdxWritePtr[6] = (DrawIdx)(idx2 + 1);
          _IdxWritePtr[7] = (DrawIdx)(idx1 + 1);
          _IdxWritePtr[8] = (DrawIdx)(idx1 + 0); // Left tri 1
          _IdxWritePtr[9] = (DrawIdx)(idx1 + 0);
          _IdxWritePtr[10] = (DrawIdx)(idx2 + 0);
          _IdxWritePtr[11] = (DrawIdx)(idx2 + 1); // Left tri 2
          _IdxWritePtr += 12;
        }

        idx1 = idx2;
      }

      // Add vertexes for each point on the line
      if (use_texture) {
        // If we're using textures we only need to emit the left/right edge
        // vertices
        Vec4 tex_uvs = _Data->TexUvLines[integer_thickness];
        /*if (fractional_thickness != 0.0f) // Currently always zero when
        use_texture==false!
        {
            const Vec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
            tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) *
        fractional_thickness; // inlined Lerp() tex_uvs.y = tex_uvs.y +
        (tex_uvs_1.y - tex_uvs.y) * fractional_thickness; tex_uvs.z = tex_uvs.z
        + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness; tex_uvs.w =
        tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
        }*/
        Vec2 tex_uv0(tex_uvs.x, tex_uvs.y);
        Vec2 tex_uv1(tex_uvs.z, tex_uvs.w);
        for (int i = 0; i < points_count; i++) {
          _VtxWritePtr[0].pos = temp_points[i * 2 + 0];
          _VtxWritePtr[0].uv = tex_uv0;
          _VtxWritePtr[0].col = col; // Left-side outer edge
          _VtxWritePtr[1].pos = temp_points[i * 2 + 1];
          _VtxWritePtr[1].uv = tex_uv1;
          _VtxWritePtr[1].col = col; // Right-side outer edge
          _VtxWritePtr += 2;
        }
      } else {
        // If we're not using a texture, we need the center vertex as well
        for (int i = 0; i < points_count; i++) {
          _VtxWritePtr[0].pos = points[i];
          _VtxWritePtr[0].uv = opaque_uv;
          _VtxWritePtr[0].col = col; // Center of line
          _VtxWritePtr[1].pos = temp_points[i * 2 + 0];
          _VtxWritePtr[1].uv = opaque_uv;
          _VtxWritePtr[1].col = col_trans; // Left-side outer edge
          _VtxWritePtr[2].pos = temp_points[i * 2 + 1];
          _VtxWritePtr[2].uv = opaque_uv;
          _VtxWritePtr[2].col = col_trans; // Right-side outer edge
          _VtxWritePtr += 3;
        }
      }
    } else {
      // [PATH 2] Non texture-based lines (thick): we need to draw the solid
      // line core and thus require four vertices per point
      const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;

      // If line is not closed, the first and last points need to be generated
      // differently as there are no normals to blend
      if (!closed) {
        const int points_last = points_count - 1;
        temp_points[0] =
            Add(points[0],
                Multiply(temp_normals[0], (half_inner_thickness + AA_SIZE)));
        temp_points[1] =
            Add(points[0], Multiply(temp_normals[0], (half_inner_thickness)));
        temp_points[2] = Subtract(
            points[0], Multiply(temp_normals[0], (half_inner_thickness)));
        temp_points[3] =
            Subtract(points[0], Multiply(temp_normals[0],
                                         (half_inner_thickness + AA_SIZE)));
        temp_points[points_last * 4 + 0] = Add(
            points[points_last], Multiply(temp_normals[points_last],
                                          (half_inner_thickness + AA_SIZE)));
        temp_points[points_last * 4 + 1] =
            Add(points[points_last],
                Multiply(temp_normals[points_last], (half_inner_thickness)));
        temp_points[points_last * 4 + 2] =
            Subtract(points[points_last], Multiply(temp_normals[points_last],
                                                   (half_inner_thickness)));
        temp_points[points_last * 4 + 3] = Subtract(
            points[points_last], Multiply(temp_normals[points_last],
                                          (half_inner_thickness + AA_SIZE)));
      }

      // Generate the indices to form a number of triangles for each line
      // segment, and the vertices for the line edges This takes points n and
      // n+1 and writes into n+1, with the first point in a closed line being
      // generated from the final one (as n+1 wraps)
      // FIXME-OPT: Merge the different loops, possibly remove the temporary
      // buffer.
      unsigned int idx1 =
          _VtxCurrentIdx; // Vertex index for start of line segment
      for (int i1 = 0; i1 < count;
           i1++) // i1 is the first point of the line segment
      {
        const int i2 =
            (i1 + 1) == points_count
                ? 0
                : (i1 + 1); // i2 is the second point of the line segment
        const unsigned int idx2 =
            (i1 + 1) == points_count
                ? _VtxCurrentIdx
                : (idx1 + 4); // Vertex index for end of segment

        // Average normals
        float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
        float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
        GUI_FIXNORMAL2F(dm_x, dm_y);
        float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
        float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
        float dm_in_x = dm_x * half_inner_thickness;
        float dm_in_y = dm_y * half_inner_thickness;

        // Add temporary vertices
        Vec2 *out_vtx = &temp_points[i2 * 4];
        out_vtx[0].x = points[i2].x + dm_out_x;
        out_vtx[0].y = points[i2].y + dm_out_y;
        out_vtx[1].x = points[i2].x + dm_in_x;
        out_vtx[1].y = points[i2].y + dm_in_y;
        out_vtx[2].x = points[i2].x - dm_in_x;
        out_vtx[2].y = points[i2].y - dm_in_y;
        out_vtx[3].x = points[i2].x - dm_out_x;
        out_vtx[3].y = points[i2].y - dm_out_y;

        // Add indexes
        _IdxWritePtr[0] = (DrawIdx)(idx2 + 1);
        _IdxWritePtr[1] = (DrawIdx)(idx1 + 1);
        _IdxWritePtr[2] = (DrawIdx)(idx1 + 2);
        _IdxWritePtr[3] = (DrawIdx)(idx1 + 2);
        _IdxWritePtr[4] = (DrawIdx)(idx2 + 2);
        _IdxWritePtr[5] = (DrawIdx)(idx2 + 1);
        _IdxWritePtr[6] = (DrawIdx)(idx2 + 1);
        _IdxWritePtr[7] = (DrawIdx)(idx1 + 1);
        _IdxWritePtr[8] = (DrawIdx)(idx1 + 0);
        _IdxWritePtr[9] = (DrawIdx)(idx1 + 0);
        _IdxWritePtr[10] = (DrawIdx)(idx2 + 0);
        _IdxWritePtr[11] = (DrawIdx)(idx2 + 1);
        _IdxWritePtr[12] = (DrawIdx)(idx2 + 2);
        _IdxWritePtr[13] = (DrawIdx)(idx1 + 2);
        _IdxWritePtr[14] = (DrawIdx)(idx1 + 3);
        _IdxWritePtr[15] = (DrawIdx)(idx1 + 3);
        _IdxWritePtr[16] = (DrawIdx)(idx2 + 3);
        _IdxWritePtr[17] = (DrawIdx)(idx2 + 2);
        _IdxWritePtr += 18;

        idx1 = idx2;
      }

      // Add vertices
      for (int i = 0; i < points_count; i++) {
        _VtxWritePtr[0].pos = temp_points[i * 4 + 0];
        _VtxWritePtr[0].uv = opaque_uv;
        _VtxWritePtr[0].col = col_trans;
        _VtxWritePtr[1].pos = temp_points[i * 4 + 1];
        _VtxWritePtr[1].uv = opaque_uv;
        _VtxWritePtr[1].col = col;
        _VtxWritePtr[2].pos = temp_points[i * 4 + 2];
        _VtxWritePtr[2].uv = opaque_uv;
        _VtxWritePtr[2].col = col;
        _VtxWritePtr[3].pos = temp_points[i * 4 + 3];
        _VtxWritePtr[3].uv = opaque_uv;
        _VtxWritePtr[3].col = col_trans;
        _VtxWritePtr += 4;
      }
    }
    _VtxCurrentIdx += (DrawIdx)vtx_count;
  } else {
    // [PATH 4] Non texture-based, Non anti-aliased lines
    const int idx_count = count * 6;
    const int vtx_count = count * 4; // FIXME-OPT: Not sharing edges
    PrimReserve(idx_count, vtx_count);

    for (int i1 = 0; i1 < count; i1++) {
      const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
      const Vec2 &p1 = points[i1];
      const Vec2 &p2 = points[i2];

      float dx = p2.x - p1.x;
      float dy = p2.y - p1.y;
      GUI_NORMALIZE2F_OVER_ZERO(dx, dy);
      dx *= (thickness * 0.5f);
      dy *= (thickness * 0.5f);

      _VtxWritePtr[0].pos.x = p1.x + dy;
      _VtxWritePtr[0].pos.y = p1.y - dx;
      _VtxWritePtr[0].uv = opaque_uv;
      _VtxWritePtr[0].col = col;
      _VtxWritePtr[1].pos.x = p2.x + dy;
      _VtxWritePtr[1].pos.y = p2.y - dx;
      _VtxWritePtr[1].uv = opaque_uv;
      _VtxWritePtr[1].col = col;
      _VtxWritePtr[2].pos.x = p2.x - dy;
      _VtxWritePtr[2].pos.y = p2.y + dx;
      _VtxWritePtr[2].uv = opaque_uv;
      _VtxWritePtr[2].col = col;
      _VtxWritePtr[3].pos.x = p1.x - dy;
      _VtxWritePtr[3].pos.y = p1.y + dx;
      _VtxWritePtr[3].uv = opaque_uv;
      _VtxWritePtr[3].col = col;
      _VtxWritePtr += 4;

      _IdxWritePtr[0] = (DrawIdx)(_VtxCurrentIdx);
      _IdxWritePtr[1] = (DrawIdx)(_VtxCurrentIdx + 1);
      _IdxWritePtr[2] = (DrawIdx)(_VtxCurrentIdx + 2);
      _IdxWritePtr[3] = (DrawIdx)(_VtxCurrentIdx);
      _IdxWritePtr[4] = (DrawIdx)(_VtxCurrentIdx + 2);
      _IdxWritePtr[5] = (DrawIdx)(_VtxCurrentIdx + 3);
      _IdxWritePtr += 6;
      _VtxCurrentIdx += 4;
    }
  }
}

// - We intentionally avoid using Vec2 and its math operators here to reduce
// cost to a minimum for debug/non-inlined builds.
// - Filled shapes must always use clockwise winding order. The anti-aliasing
// fringe depends on it. Counter-clockwise shapes will have "inward"
// anti-aliasing.
inline void DrawList::AddConvexPolyFilled(const Vec2 *points,
                                          const int points_count, U32 col) {
  if (points_count < 3 || (col & GUI_COL32_A_MASK) == 0)
    return;

  const Vec2 uv = _Data->TexUvWhitePixel;

  if (Flags & DrawListFlags_AntiAliasedFill) {
    // Anti-aliased Fill
    const float AA_SIZE = _FringeScale;
    const U32 col_trans = col & ~GUI_COL32_A_MASK;
    const int idx_count = (points_count - 2) * 3 + points_count * 6;
    const int vtx_count = (points_count * 2);
    PrimReserve(idx_count, vtx_count);

    // Add indexes for fill
    unsigned int vtx_inner_idx = _VtxCurrentIdx;
    unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
    for (int i = 2; i < points_count; i++) {
      _IdxWritePtr[0] = (DrawIdx)(vtx_inner_idx);
      _IdxWritePtr[1] = (DrawIdx)(vtx_inner_idx + ((i - 1) << 1));
      _IdxWritePtr[2] = (DrawIdx)(vtx_inner_idx + (i << 1));
      _IdxWritePtr += 3;
    }

    // Compute normals
    _Data->TempBuffer.reserve_discard(points_count);
    Vec2 *temp_normals = _Data->TempBuffer.Data;
    for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++) {
      const Vec2 &p0 = points[i0];
      const Vec2 &p1 = points[i1];
      float dx = p1.x - p0.x;
      float dy = p1.y - p0.y;
      GUI_NORMALIZE2F_OVER_ZERO(dx, dy);
      temp_normals[i0].x = dy;
      temp_normals[i0].y = -dx;
    }

    for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++) {
      // Average normals
      const Vec2 &n0 = temp_normals[i0];
      const Vec2 &n1 = temp_normals[i1];
      float dm_x = (n0.x + n1.x) * 0.5f;
      float dm_y = (n0.y + n1.y) * 0.5f;
      GUI_FIXNORMAL2F(dm_x, dm_y);
      dm_x *= AA_SIZE * 0.5f;
      dm_y *= AA_SIZE * 0.5f;

      // Add vertices
      _VtxWritePtr[0].pos.x = (points[i1].x - dm_x);
      _VtxWritePtr[0].pos.y = (points[i1].y - dm_y);
      _VtxWritePtr[0].uv = uv;
      _VtxWritePtr[0].col = col; // Inner
      _VtxWritePtr[1].pos.x = (points[i1].x + dm_x);
      _VtxWritePtr[1].pos.y = (points[i1].y + dm_y);
      _VtxWritePtr[1].uv = uv;
      _VtxWritePtr[1].col = col_trans; // Outer
      _VtxWritePtr += 2;

      // Add indexes for fringes
      _IdxWritePtr[0] = (DrawIdx)(vtx_inner_idx + (i1 << 1));
      _IdxWritePtr[1] = (DrawIdx)(vtx_inner_idx + (i0 << 1));
      _IdxWritePtr[2] = (DrawIdx)(vtx_outer_idx + (i0 << 1));
      _IdxWritePtr[3] = (DrawIdx)(vtx_outer_idx + (i0 << 1));
      _IdxWritePtr[4] = (DrawIdx)(vtx_outer_idx + (i1 << 1));
      _IdxWritePtr[5] = (DrawIdx)(vtx_inner_idx + (i1 << 1));
      _IdxWritePtr += 6;
    }
    _VtxCurrentIdx += (DrawIdx)vtx_count;
  } else {
    // Non Anti-aliased Fill
    const int idx_count = (points_count - 2) * 3;
    const int vtx_count = points_count;
    PrimReserve(idx_count, vtx_count);
    for (int i = 0; i < vtx_count; i++) {
      _VtxWritePtr[0].pos = points[i];
      _VtxWritePtr[0].uv = uv;
      _VtxWritePtr[0].col = col;
      _VtxWritePtr++;
    }
    for (int i = 2; i < points_count; i++) {
      _IdxWritePtr[0] = (DrawIdx)(_VtxCurrentIdx);
      _IdxWritePtr[1] = (DrawIdx)(_VtxCurrentIdx + i - 1);
      _IdxWritePtr[2] = (DrawIdx)(_VtxCurrentIdx + i);
      _IdxWritePtr += 3;
    }
    _VtxCurrentIdx += (DrawIdx)vtx_count;
  }
}

inline void DrawList::_PathArcToFastEx(const Vec2 &center, float radius,
                                       int a_min_sample, int a_max_sample,
                                       int a_step) {
  if (radius < 0.5f) {
    _Path.push_back(center);
    return;
  }

  // Calculate arc auto segment step size
  if (a_step <= 0)
    a_step =
        GUI_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);

  // Make sure we never do steps larger than one quarter of the circle
  a_step = Clamp(a_step, 1, GUI_DRAWLIST_ARCFAST_TABLE_SIZE / 4);

  const int sample_range = Abs(a_max_sample - a_min_sample);
  const int a_next_step = a_step;

  int samples = sample_range + 1;
  bool extra_max_sample = false;
  if (a_step > 1) {
    samples = sample_range / a_step + 1;
    const int overstep = sample_range % a_step;

    if (overstep > 0) {
      extra_max_sample = true;
      samples++;

      // When we have overstep to avoid awkwardly looking one long line and one
      // tiny one at the end, distribute first step range evenly between them by
      // reducing first step size.
      if (sample_range > 0)
        a_step -= (a_step - overstep) / 2;
    }
  }

  _Path.resize(_Path.Size + samples);
  Vec2 *out_ptr = _Path.Data + (_Path.Size - samples);

  int sample_index = a_min_sample;
  if (sample_index < 0 || sample_index >= GUI_DRAWLIST_ARCFAST_SAMPLE_MAX) {
    sample_index = sample_index % GUI_DRAWLIST_ARCFAST_SAMPLE_MAX;
    if (sample_index < 0)
      sample_index += GUI_DRAWLIST_ARCFAST_SAMPLE_MAX;
  }

  if (a_max_sample >= a_min_sample) {
    for (int a = a_min_sample; a <= a_max_sample;
         a += a_step, sample_index += a_step, a_step = a_next_step) {
      // a_step is clamped to GUI_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have
      // guaranteed that it will not wrap over range twice or more
      if (sample_index >= GUI_DRAWLIST_ARCFAST_SAMPLE_MAX)
        sample_index -= GUI_DRAWLIST_ARCFAST_SAMPLE_MAX;

      const Vec2 s = _Data->ArcFastVtx[sample_index];
      out_ptr->x = center.x + s.x * radius;
      out_ptr->y = center.y + s.y * radius;
      out_ptr++;
    }
  } else {
    for (int a = a_min_sample; a >= a_max_sample;
         a -= a_step, sample_index -= a_step, a_step = a_next_step) {
      // a_step is clamped to GUI_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have
      // guaranteed that it will not wrap over range twice or more
      if (sample_index < 0)
        sample_index += GUI_DRAWLIST_ARCFAST_SAMPLE_MAX;

      const Vec2 s = _Data->ArcFastVtx[sample_index];
      out_ptr->x = center.x + s.x * radius;
      out_ptr->y = center.y + s.y * radius;
      out_ptr++;
    }
  }

  if (extra_max_sample) {
    int normalized_max_sample = a_max_sample % GUI_DRAWLIST_ARCFAST_SAMPLE_MAX;
    if (normalized_max_sample < 0)
      normalized_max_sample += GUI_DRAWLIST_ARCFAST_SAMPLE_MAX;

    const Vec2 s = _Data->ArcFastVtx[normalized_max_sample];
    out_ptr->x = center.x + s.x * radius;
    out_ptr->y = center.y + s.y * radius;
    out_ptr++;
  }

  GUI_ASSERT_PARANOID(_Path.Data + _Path.Size == out_ptr);
}

inline void DrawList::_PathArcToN(const Vec2 &center, float radius, float a_min,
                                  float a_max, int num_segments) {
  if (radius < 0.5f) {
    _Path.push_back(center);
    return;
  }

  // Note that we are adding a point at both a_min and a_max.
  // If you are trying to draw a full closed circle you don't want the
  // overlapping points!
  _Path.reserve(_Path.Size + (num_segments + 1));
  for (int i = 0; i <= num_segments; i++) {
    const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
    _Path.push_back(
        Vec2(center.x + Cos(a) * radius, center.y + Sin(a) * radius));
  }
}

// 0: East, 3: South, 6: West, 9: North, 12: East
inline void DrawList::PathArcToFast(const Vec2 &center, float radius,
                                    int a_min_of_12, int a_max_of_12) {
  if (radius < 0.5f) {
    _Path.push_back(center);
    return;
  }
  _PathArcToFastEx(center, radius,
                   a_min_of_12 * GUI_DRAWLIST_ARCFAST_SAMPLE_MAX / 12,
                   a_max_of_12 * GUI_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
}

inline void DrawList::PathArcTo(const Vec2 &center, float radius, float a_min,
                                float a_max, int num_segments) {
  if (radius < 0.5f) {
    _Path.push_back(center);
    return;
  }

  if (num_segments > 0) {
    _PathArcToN(center, radius, a_min, a_max, num_segments);
    return;
  }

  // Automatic segment count
  if (radius <= _Data->ArcFastRadiusCutoff) {
    const bool a_is_reverse = a_max < a_min;

    // We are going to use precomputed values for mid samples.
    // Determine first and last sample in lookup table that belong to the arc.
    const float a_min_sample_f =
        GUI_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (GUI_PI * 2.0f);
    const float a_max_sample_f =
        GUI_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (GUI_PI * 2.0f);

    const int a_min_sample =
        a_is_reverse ? (int)Floor(a_min_sample_f) : (int)Ceil(a_min_sample_f);
    const int a_max_sample =
        a_is_reverse ? (int)Ceil(a_max_sample_f) : (int)Floor(a_max_sample_f);
    const int a_mid_samples = a_is_reverse
                                  ? Max(a_min_sample - a_max_sample, 0)
                                  : Max(a_max_sample - a_min_sample, 0);

    const float a_min_segment_angle =
        a_min_sample * GUI_PI * 2.0f / GUI_DRAWLIST_ARCFAST_SAMPLE_MAX;
    const float a_max_segment_angle =
        a_max_sample * GUI_PI * 2.0f / GUI_DRAWLIST_ARCFAST_SAMPLE_MAX;
    const bool a_emit_start = Abs(a_min_segment_angle - a_min) >= 1e-5f;
    const bool a_emit_end = Abs(a_max - a_max_segment_angle) >= 1e-5f;

    _Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) +
                                (a_emit_end ? 1 : 0)));
    if (a_emit_start)
      _Path.push_back(
          Vec2(center.x + Cos(a_min) * radius, center.y + Sin(a_min) * radius));
    if (a_mid_samples > 0)
      _PathArcToFastEx(center, radius, a_min_sample, a_max_sample, 0);
    if (a_emit_end)
      _Path.push_back(
          Vec2(center.x + Cos(a_max) * radius, center.y + Sin(a_max) * radius));
  } else {
    const float arc_length = Abs(a_max - a_min);
    const int circle_segment_count = _CalcCircleAutoSegmentCount(radius);
    const int arc_segment_count =
        Max((int)Ceil(circle_segment_count * arc_length / (GUI_PI * 2.0f)),
            (int)(2.0f * GUI_PI / arc_length));
    _PathArcToN(center, radius, a_min, a_max, arc_segment_count);
  }
}

inline void DrawList::PathEllipticalArcTo(const Vec2 &center, float radius_x,
                                          float radius_y, float rot,
                                          float a_min, float a_max,
                                          int num_segments) {
  if (num_segments <= 0)
    num_segments = _CalcCircleAutoSegmentCount(
        Max(radius_x, radius_y)); // A bit pessimistic, maybe there's a better
                                  // computation to do here.

  _Path.reserve(_Path.Size + (num_segments + 1));

  const float cos_rot = Cos(rot);
  const float sin_rot = Sin(rot);
  for (int i = 0; i <= num_segments; i++) {
    const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
    Vec2 point(Cos(a) * radius_x, Sin(a) * radius_y);
    const float rel_x = (point.x * cos_rot) - (point.y * sin_rot);
    const float rel_y = (point.x * sin_rot) + (point.y * cos_rot);
    point.x = rel_x + center.x;
    point.y = rel_y + center.y;
    _Path.push_back(point);
  }
}

// Closely mimics BezierCubicClosestPointCasteljau() in gui.cpp
static void PathBezierCubicCurveToCasteljau(Vector<Vec2> *path, float x1,
                                            float y1, float x2, float y2,
                                            float x3, float y3, float x4,
                                            float y4, float tess_tol,
                                            int level) {
  float dx = x4 - x1;
  float dy = y4 - y1;
  float d2 = (x2 - x4) * dy - (y2 - y4) * dx;
  float d3 = (x3 - x4) * dy - (y3 - y4) * dx;
  d2 = (d2 >= 0) ? d2 : -d2;
  d3 = (d3 >= 0) ? d3 : -d3;
  if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy)) {
    path->push_back(Vec2(x4, y4));
  } else if (level < 10) {
    float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;
    float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;
    float x34 = (x3 + x4) * 0.5f, y34 = (y3 + y4) * 0.5f;
    float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
    float x234 = (x23 + x34) * 0.5f, y234 = (y23 + y34) * 0.5f;
    float x1234 = (x123 + x234) * 0.5f, y1234 = (y123 + y234) * 0.5f;
    PathBezierCubicCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, x1234,
                                    y1234, tess_tol, level + 1);
    PathBezierCubicCurveToCasteljau(path, x1234, y1234, x234, y234, x34, y34,
                                    x4, y4, tess_tol, level + 1);
  }
}

static void PathBezierQuadraticCurveToCasteljau(Vector<Vec2> *path, float x1,
                                                float y1, float x2, float y2,
                                                float x3, float y3,
                                                float tess_tol, int level) {
  float dx = x3 - x1, dy = y3 - y1;
  float det = (x2 - x3) * dy - (y2 - y3) * dx;
  if (det * det * 4.0f < tess_tol * (dx * dx + dy * dy)) {
    path->push_back(Vec2(x3, y3));
  } else if (level < 10) {
    float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;
    float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;
    float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
    PathBezierQuadraticCurveToCasteljau(path, x1, y1, x12, y12, x123, y123,
                                        tess_tol, level + 1);
    PathBezierQuadraticCurveToCasteljau(path, x123, y123, x23, y23, x3, y3,
                                        tess_tol, level + 1);
  }
}

inline void DrawList::PathBezierCubicCurveTo(const Vec2 &p2, const Vec2 &p3,
                                             const Vec2 &p4, int num_segments) {
  Vec2 p1 = _Path.back();
  if (num_segments == 0) {
    GUI_ASSERT(_Data->CurveTessellationTol > 0.0f);
    PathBezierCubicCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y,
                                    p4.x, p4.y, _Data->CurveTessellationTol,
                                    0); // Auto-tessellated
  } else {
    float t_step = 1.0f / (float)num_segments;
    for (int i_step = 1; i_step <= num_segments; i_step++)
      _Path.push_back(BezierCubicCalc(p1, p2, p3, p4, t_step * i_step));
  }
}

inline void DrawList::PathBezierQuadraticCurveTo(const Vec2 &p2, const Vec2 &p3,
                                                 int num_segments) {
  Vec2 p1 = _Path.back();
  if (num_segments == 0) {
    GUI_ASSERT(_Data->CurveTessellationTol > 0.0f);
    PathBezierQuadraticCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x,
                                        p3.y, _Data->CurveTessellationTol,
                                        0); // Auto-tessellated
  } else {
    float t_step = 1.0f / (float)num_segments;
    for (int i_step = 1; i_step <= num_segments; i_step++)
      _Path.push_back(BezierQuadraticCalc(p1, p2, p3, t_step * i_step));
  }
}

static inline DrawFlags FixRectCornerFlags(DrawFlags flags) {
  /*
  GUI_STATIC_ASSERT(DrawFlags_RoundCornersTopLeft == (1 << 4));
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
  // Obsoleted in 1.82 (from February 2021). This code was stripped/simplified
and mostly commented in 1.90 (from September 2023)
  // - Legacy Support for hard coded ~0 (used to be a suggested equivalent to
DrawCornerFlags_All) if (flags == ~0)                    { return
DrawFlags_RoundCornersAll; }
  // - Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old
flags combinations). Read details in older version of this code. if (flags >=
0x01 && flags <= 0x0F) { return (flags << 4); }
  // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace
with DrawFlags_RoundCornersNone or use 'float rounding = 0.0f' #endif
  */
  // If this assert triggers, please update your code replacing hardcoded values
  // with new DrawFlags_RoundCorners* values. Note that DrawFlags_Closed (==
  // 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc.
  // anyway. See details in 1.82 Changelog as well as 2021/03/12 and 2023/09/08
  // entries in "API BREAKING CHANGES" section.
  GUI_ASSERT((flags & 0x0F) == 0 &&
             "Misuse of legacy hardcoded DrawCornerFlags values!");

  if ((flags & DrawFlags_RoundCornersMask_) == 0)
    flags |= DrawFlags_RoundCornersAll;

  return flags;
}

inline void DrawList::PathRect(const Vec2 &a, const Vec2 &b, float rounding,
                               DrawFlags flags) {
  if (rounding >= 0.5f) {
    flags = FixRectCornerFlags(flags);
    rounding = Min(rounding,
                   Fabs(b.x - a.x) *
                           (((flags & DrawFlags_RoundCornersTop) ==
                             DrawFlags_RoundCornersTop) ||
                                    ((flags & DrawFlags_RoundCornersBottom) ==
                                     DrawFlags_RoundCornersBottom)
                                ? 0.5f
                                : 1.0f) -
                       1.0f);
    rounding =
        Min(rounding,
            Fabs(b.y - a.y) * (((flags & DrawFlags_RoundCornersLeft) ==
                                DrawFlags_RoundCornersLeft) ||
                                       ((flags & DrawFlags_RoundCornersRight) ==
                                        DrawFlags_RoundCornersRight)
                                   ? 0.5f
                                   : 1.0f) -
                1.0f);
  }
  if (rounding < 0.5f ||
      (flags & DrawFlags_RoundCornersMask_) == DrawFlags_RoundCornersNone) {
    PathLineTo(a);
    PathLineTo(Vec2(b.x, a.y));
    PathLineTo(b);
    PathLineTo(Vec2(a.x, b.y));
  } else {
    const float rounding_tl =
        (flags & DrawFlags_RoundCornersTopLeft) ? rounding : 0.0f;
    const float rounding_tr =
        (flags & DrawFlags_RoundCornersTopRight) ? rounding : 0.0f;
    const float rounding_br =
        (flags & DrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;
    const float rounding_bl =
        (flags & DrawFlags_RoundCornersBottomLeft) ? rounding : 0.0f;
    PathArcToFast(Vec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6,
                  9);
    PathArcToFast(Vec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9,
                  12);
    PathArcToFast(Vec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0,
                  3);
    PathArcToFast(Vec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3,
                  6);
  }
}

inline void DrawList::AddLine(const Vec2 &p1, const Vec2 &p2, U32 col,
                              float thickness) {
  if ((col & GUI_COL32_A_MASK) == 0)
    return;
  PathLineTo(Add(p1, Vec2(0.5f, 0.5f)));
  PathLineTo(Add(p2, Vec2(0.5f, 0.5f)));
  PathStroke(col, 0, thickness);
}

// p_min = upper-left, p_max = lower-right
// Note we don't render 1 pixels sized rectangles properly.
inline void DrawList::AddRect(const Vec2 &p_min, const Vec2 &p_max, U32 col,
                              float rounding, DrawFlags flags,
                              float thickness) {
  if ((col & GUI_COL32_A_MASK) == 0)
    return;
  if (Flags & DrawListFlags_AntiAliasedLines)
    PathRect(Add(p_min, Vec2(0.50f, 0.50f)),
             Subtract(p_max, Vec2(0.50f, 0.50f)), rounding, flags);
  else
    PathRect(
        Add(p_min, Vec2(0.50f, 0.50f)), Subtract(p_max, Vec2(0.49f, 0.49f)),
        rounding,
        flags); // Better looking lower-right corner and rounded non-AA shapes.
  PathStroke(col, DrawFlags_Closed, thickness);
}

// p_min = upper-left, p_max = lower-right
inline void
DrawList::AddRectFilledMultiColor(const Vec2 &p_min, const Vec2 &p_max,
                                  U32 col_upr_left, U32 col_upr_right,
                                  U32 col_bot_right, U32 col_bot_left) {
  if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) &
       GUI_COL32_A_MASK) == 0)
    return;

  const Vec2 uv = _Data->TexUvWhitePixel;
  PrimReserve(6, 4);
  PrimWriteIdx((DrawIdx)(_VtxCurrentIdx));
  PrimWriteIdx((DrawIdx)(_VtxCurrentIdx + 1));
  PrimWriteIdx((DrawIdx)(_VtxCurrentIdx + 2));
  PrimWriteIdx((DrawIdx)(_VtxCurrentIdx));
  PrimWriteIdx((DrawIdx)(_VtxCurrentIdx + 2));
  PrimWriteIdx((DrawIdx)(_VtxCurrentIdx + 3));
  PrimWriteVtx(p_min, uv, col_upr_left);
  PrimWriteVtx(Vec2(p_max.x, p_min.y), uv, col_upr_right);
  PrimWriteVtx(p_max, uv, col_bot_right);
  PrimWriteVtx(Vec2(p_min.x, p_max.y), uv, col_bot_left);
}

inline void DrawList::AddCircle(const Vec2 &center, float radius, U32 col,
                                int num_segments, float thickness) {
  if ((col & GUI_COL32_A_MASK) == 0 || radius < 0.5f)
    return;

  if (num_segments <= 0) {
    // Use arc with automatic segment count
    _PathArcToFastEx(center, radius - 0.5f, 0, GUI_DRAWLIST_ARCFAST_SAMPLE_MAX,
                     0);
    _Path.Size--;
  } else {
    // Explicit segment count (still clamp to avoid drawing insanely tessellated
    // shapes)
    num_segments = Clamp(num_segments, 3, GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);

    // Because we are filling a closed shape we remove 1 from the count of
    // segments/points
    const float a_max =
        (GUI_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
    PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);
  }

  PathStroke(col, DrawFlags_Closed, thickness);
}

inline void DrawList::AddCircleFilled(const Vec2 &center, float radius, U32 col,
                                      int num_segments) {
  if ((col & GUI_COL32_A_MASK) == 0 || radius < 0.5f)
    return;

  if (num_segments <= 0) {
    // Use arc with automatic segment count
    _PathArcToFastEx(center, radius, 0, GUI_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
    _Path.Size--;
  } else {
    // Explicit segment count (still clamp to avoid drawing insanely tessellated
    // shapes)
    num_segments = Clamp(num_segments, 3, GUI_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);

    // Because we are filling a closed shape we remove 1 from the count of
    // segments/points
    const float a_max =
        (GUI_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
    PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
  }

  PathFillConvex(col);
}

// Guaranteed to honor 'num_segments'
inline void DrawList::AddNgon(const Vec2 &center, float radius, U32 col,
                              int num_segments, float thickness) {
  if ((col & GUI_COL32_A_MASK) == 0 || num_segments <= 2)
    return;

  // Because we are filling a closed shape we remove 1 from the count of
  // segments/points
  const float a_max =
      (GUI_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
  PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);
  PathStroke(col, DrawFlags_Closed, thickness);
}

// Guaranteed to honor 'num_segments'
inline void DrawList::AddNgonFilled(const Vec2 &center, float radius, U32 col,
                                    int num_segments) {
  if ((col & GUI_COL32_A_MASK) == 0 || num_segments <= 2)
    return;

  // Because we are filling a closed shape we remove 1 from the count of
  // segments/points
  const float a_max =
      (GUI_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
  PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
  PathFillConvex(col);
}

// Ellipse
inline void DrawList::AddEllipse(const Vec2 &center, float radius_x,
                                 float radius_y, U32 col, float rot,
                                 int num_segments, float thickness) {
  if ((col & GUI_COL32_A_MASK) == 0)
    return;

  if (num_segments <= 0)
    num_segments = _CalcCircleAutoSegmentCount(
        Max(radius_x, radius_y)); // A bit pessimistic, maybe there's a better
                                  // computation to do here.

  // Because we are filling a closed shape we remove 1 from the count of
  // segments/points
  const float a_max =
      GUI_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
  PathEllipticalArcTo(center, radius_x, radius_y, rot, 0.0f, a_max,
                      num_segments - 1);
  PathStroke(col, true, thickness);
}

inline void DrawList::AddEllipseFilled(const Vec2 &center, float radius_x,
                                       float radius_y, U32 col, float rot,
                                       int num_segments) {
  if ((col & GUI_COL32_A_MASK) == 0)
    return;

  if (num_segments <= 0)
    num_segments = _CalcCircleAutoSegmentCount(
        Max(radius_x, radius_y)); // A bit pessimistic, maybe there's a better
                                  // computation to do here.

  // Because we are filling a closed shape we remove 1 from the count of
  // segments/points
  const float a_max =
      GUI_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
  PathEllipticalArcTo(center, radius_x, radius_y, rot, 0.0f, a_max,
                      num_segments - 1);
  PathFillConvex(col);
}

// Cubic Bezier takes 4 controls points

// Quadratic Bezier takes 3 controls points

inline void DrawList::AddText(const Font *font, float font_size,
                              const Vec2 &pos, U32 col, const char *text_begin,
                              const char *text_end, float wrap_width,
                              const Vec4 *cpu_fine_clip_rect) {
  if ((col & GUI_COL32_A_MASK) == 0)
    return;

  if (text_end == NULL)
    text_end = text_begin + strlen(text_begin);
  if (text_begin == text_end)
    return;

  // Pull default font/size from the shared DrawListSharedData instance
  if (font == NULL)
    font = _Data->Font;
  if (font_size == 0.0f)
    font_size = _Data->FontSize;

  GUI_ASSERT(
      font->ContainerAtlas->TexID ==
      _CmdHeader.TextureId); // Use high-level Gui::PushFont() or low-level
                             // DrawList::PushTextureId() to change font.

  Vec4 clip_rect = _CmdHeader.ClipRect;
  if (cpu_fine_clip_rect) {
    clip_rect.x = Max(clip_rect.x, cpu_fine_clip_rect->x);
    clip_rect.y = Max(clip_rect.y, cpu_fine_clip_rect->y);
    clip_rect.z = Min(clip_rect.z, cpu_fine_clip_rect->z);
    clip_rect.w = Min(clip_rect.w, cpu_fine_clip_rect->w);
  }
  font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end,
                   wrap_width, cpu_fine_clip_rect != NULL);
}

inline void DrawList::AddImageRounded(TextureID user_texture_id,
                                      const Vec2 &p_min, const Vec2 &p_max,
                                      const Vec2 &uv_min, const Vec2 &uv_max,
                                      U32 col, float rounding,
                                      DrawFlags flags) {
  if ((col & GUI_COL32_A_MASK) == 0)
    return;

  flags = FixRectCornerFlags(flags);
  if (rounding < 0.5f ||
      (flags & DrawFlags_RoundCornersMask_) == DrawFlags_RoundCornersNone) {
    AddImage(user_texture_id, p_min, p_max, uv_min, uv_max, col);
    return;
  }

  const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
  if (push_texture_id)
    PushTextureID(user_texture_id);

  int vert_start_idx = VtxBuffer.Size;
  PathRect(p_min, p_max, rounding, flags);
  PathFillConvex(col);
  int vert_end_idx = VtxBuffer.Size;
  Gui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, p_min, p_max,
                          uv_min, uv_max, true);

  if (push_texture_id)
    PopTextureID();
}

//-----------------------------------------------------------------------------
// [SECTION] DrawListSplitter
//-----------------------------------------------------------------------------
// FIXME: This may be a little confusing, trying to be a little too
// low-level/optimal instead of just doing vector swap..
//-----------------------------------------------------------------------------

inline void DrawListSplitter::ClearFreeMemory() {
  for (int i = 0; i < _Channels.Size; i++) {
    if (i == _Current)
      memset(&_Channels[i], 0,
             sizeof(_Channels[i])); // Current channel is a copy of
                                    // CmdBuffer/IdxBuffer, don't destruct again
    _Channels[i]._CmdBuffer.clear();
    _Channels[i]._IdxBuffer.clear();
  }
  _Current = 0;
  _Count = 1;
  _Channels.clear();
}

inline void DrawListSplitter::Split(DrawList *draw_list, int channels_count) {
  GUI_UNUSED(draw_list);
  GUI_ASSERT(_Current == 0 && _Count <= 1 &&
             "Nested channel splitting is not supported. Please use separate "
             "instances of DrawListSplitter.");
  int old_channels_count = _Channels.Size;
  if (old_channels_count < channels_count) {
    _Channels.reserve(channels_count); // Avoid over reserving since this is
                                       // likely to stay stable
    _Channels.resize(channels_count);
  }
  _Count = channels_count;

  // Channels[] (24/32 bytes each) hold storage that we'll swap with
  // draw_list->_CmdBuffer/_IdxBuffer The content of Channels[0] at this point
  // doesn't matter. We clear it to make state tidy in a debugger but we don't
  // strictly need to. When we switch to the next channel, we'll copy
  // draw_list->_CmdBuffer/_IdxBuffer into Channels[0] and then Channels[1] into
  // draw_list->CmdBuffer/_IdxBuffer
  memset(&_Channels[0], 0, sizeof(DrawChannel));
  for (int i = 1; i < channels_count; i++) {
    if (i >= old_channels_count) {
      GUI_PLACEMENT_NEW(&_Channels[i]) DrawChannel();
    } else {
      _Channels[i]._CmdBuffer.resize(0);
      _Channels[i]._IdxBuffer.resize(0);
    }
  }
}

inline void DrawListSplitter::Merge(DrawList *draw_list) {
  // Note that we never use or rely on _Channels.Size because it is merely a
  // buffer that we never shrink back to 0 to keep all sub-buffers ready for
  // use.
  if (_Count <= 1)
    return;

  SetCurrentChannel(draw_list, 0);
  draw_list->_PopUnusedDrawCmd();

  // Calculate our final buffer sizes. Also fix the incorrect IdxOffset values
  // in each command.
  int new_cmd_buffer_count = 0;
  int new_idx_buffer_count = 0;
  DrawCmd *last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0)
                          ? &draw_list->CmdBuffer.back()
                          : NULL;
  int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;
  for (int i = 1; i < _Count; i++) {
    DrawChannel &ch = _Channels[i];
    if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 &&
        ch._CmdBuffer.back().UserCallback ==
            NULL) // Equivalent of PopUnusedDrawCmd()
      ch._CmdBuffer.pop_back();

    if (ch._CmdBuffer.Size > 0 && last_cmd != NULL) {
      // Do not include DrawCmd_AreSequentialIdxOffset() in the compare as we
      // rebuild IdxOffset values ourselves. Manipulating IdxOffset (e.g. by
      // reordering draw commands like done by
      // RenderDimmedBackgroundBehindWindow()) is not supported within a
      // splitter.
      DrawCmd *next_cmd = &ch._CmdBuffer[0];
      if (DrawCmd_HeaderCompare(last_cmd, next_cmd) == 0 &&
          last_cmd->UserCallback == NULL && next_cmd->UserCallback == NULL) {
        // Merge previous channel last draw command with current channel first
        // draw command if matching.
        last_cmd->ElemCount += next_cmd->ElemCount;
        idx_offset += next_cmd->ElemCount;
        ch._CmdBuffer.erase(
            ch._CmdBuffer.Data); // FIXME-OPT: Improve for multiple merges.
      }
    }
    if (ch._CmdBuffer.Size > 0)
      last_cmd = &ch._CmdBuffer.back();
    new_cmd_buffer_count += ch._CmdBuffer.Size;
    new_idx_buffer_count += ch._IdxBuffer.Size;
    for (int cmd_n = 0; cmd_n < ch._CmdBuffer.Size; cmd_n++) {
      ch._CmdBuffer.Data[cmd_n].IdxOffset = idx_offset;
      idx_offset += ch._CmdBuffer.Data[cmd_n].ElemCount;
    }
  }
  draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);
  draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);

  // Write commands and indices in order (they are fairly small structures, we
  // don't copy vertices only indices)
  DrawCmd *cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size -
                       new_cmd_buffer_count;
  DrawIdx *idx_write = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size -
                       new_idx_buffer_count;
  for (int i = 1; i < _Count; i++) {
    DrawChannel &ch = _Channels[i];
    if (int sz = ch._CmdBuffer.Size) {
      memcpy(cmd_write, ch._CmdBuffer.Data, sz * sizeof(DrawCmd));
      cmd_write += sz;
    }
    if (int sz = ch._IdxBuffer.Size) {
      memcpy(idx_write, ch._IdxBuffer.Data, sz * sizeof(DrawIdx));
      idx_write += sz;
    }
  }
  draw_list->_IdxWritePtr = idx_write;

  // Ensure there's always a non-callback draw command trailing the
  // command-buffer
  if (draw_list->CmdBuffer.Size == 0 ||
      draw_list->CmdBuffer.back().UserCallback != NULL)
    draw_list->AddDrawCmd();

  // If current command is used with different settings we need to add a new
  // command
  DrawCmd *curr_cmd = &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
  if (curr_cmd->ElemCount == 0)
    DrawCmd_HeaderCopy(
        curr_cmd,
        &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
  else if (DrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
    draw_list->AddDrawCmd();

  _Count = 1;
}

inline void DrawListSplitter::SetCurrentChannel(DrawList *draw_list, int idx) {
  GUI_ASSERT(idx >= 0 && idx < _Count);
  if (_Current == idx)
    return;

  // Overwrite Vector (12/16 bytes), four times. This is merely a silly
  // optimization instead of doing .swap()
  memcpy(&_Channels.Data[_Current]._CmdBuffer, &draw_list->CmdBuffer,
         sizeof(draw_list->CmdBuffer));
  memcpy(&_Channels.Data[_Current]._IdxBuffer, &draw_list->IdxBuffer,
         sizeof(draw_list->IdxBuffer));
  _Current = idx;
  memcpy(&draw_list->CmdBuffer, &_Channels.Data[idx]._CmdBuffer,
         sizeof(draw_list->CmdBuffer));
  memcpy(&draw_list->IdxBuffer, &_Channels.Data[idx]._IdxBuffer,
         sizeof(draw_list->IdxBuffer));
  draw_list->_IdxWritePtr =
      draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size;

  // If current command is used with different settings we need to add a new
  // command
  DrawCmd *curr_cmd =
      (draw_list->CmdBuffer.Size == 0)
          ? NULL
          : &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
  if (curr_cmd == NULL)
    draw_list->AddDrawCmd();
  else if (curr_cmd->ElemCount == 0)
    DrawCmd_HeaderCopy(
        curr_cmd,
        &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
  else if (DrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
    draw_list->AddDrawCmd();
}

//-----------------------------------------------------------------------------
// [SECTION] DrawData
//-----------------------------------------------------------------------------

// Important: 'out_list' is generally going to be draw_data->CmdLists, but may
// be another temporary list as long at it is expected that the result will be
// later merged into draw_data->CmdLists[].
inline void Gui::AddDrawListToDrawDataEx(DrawData *draw_data,
                                         Vector<DrawList *> *out_list,
                                         DrawList *draw_list) {
  if (draw_list->CmdBuffer.Size == 0)
    return;
  if (draw_list->CmdBuffer.Size == 1 &&
      draw_list->CmdBuffer[0].ElemCount == 0 &&
      draw_list->CmdBuffer[0].UserCallback == NULL)
    return;

  // Draw list sanity check. Detect mismatch between PrimReserve() calls and
  // incrementing _VtxCurrentIdx, _VtxWritePtr etc. May trigger for you if you
  // are using PrimXXX functions incorrectly.
  GUI_ASSERT(draw_list->VtxBuffer.Size == 0 ||
             draw_list->_VtxWritePtr ==
                 draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
  GUI_ASSERT(draw_list->IdxBuffer.Size == 0 ||
             draw_list->_IdxWritePtr ==
                 draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
  if (!(draw_list->Flags & DrawListFlags_AllowVtxOffset))
    GUI_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);

  // Check that draw_list doesn't use more vertices than indexable (default
  // DrawIdx = unsigned short = 2 bytes = 64K vertices per DrawList = per
  // window) If this assert triggers because you are drawing lots of stuff
  // manually:
  // - First, make sure you are coarse clipping yourself and not trying to draw
  // many things outside visible bounds.
  //   Be mindful that the lower-level DrawList API doesn't filter vertices.
  //   Use the Metrics/Debugger window to inspect draw list contents.
  // - If you want large meshes with more than 64K vertices, you can either:
  //   (A) Handle the DrawCmd::VtxOffset value in your renderer backend, and
  //   set 'io.BackendFlags |= BackendFlags_RendererHasVtxOffset'.
  //       Most example backends already support this from 1.71. Pre-1.71
  //       backends won't. Some graphics API such as GL ES 1/2 don't have a way
  //       to offset the starting vertex so it is not supported for them.
  //   (B) Or handle 32-bit indices in your renderer backend, and uncomment
  //   '#define DrawIdx unsigned int' line in config.hpp.
  //       Most example backends already support this. For example, the OpenGL
  //       example code detect index size at compile-time:
  //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount,
  //         sizeof(DrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT,
  //         idx_buffer_offset);
  //       Your own engine or render API may use different parameters or
  //       function calls to specify index sizes. 2 and 4 bytes indices are
  //       generally supported by most graphics API.
  // - If for some reason neither of those solutions works for you, a workaround
  // is to call BeginChild()/EndChild() before reaching
  //   the 64K limit to split your draw commands in multiple draw lists.
  if (sizeof(DrawIdx) == 2)
    GUI_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) &&
               "Too many vertices in DrawList using 16-bit indices. Read "
               "comment above");

  // Add to output list + records state in DrawData
  out_list->push_back(draw_list);
  draw_data->CmdListsCount++;
  draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;
  draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;
}

inline void DrawData::AddDrawList(DrawList *draw_list) {
  GUI_ASSERT(CmdLists.Size == CmdListsCount);
  draw_list->_PopUnusedDrawCmd();
  Gui::AddDrawListToDrawDataEx(this, &CmdLists, draw_list);
}

// For backward compatibility: convert all buffers from indexed to de-indexed,
// in case you cannot render indexed. Note: this is slow and most likely a waste
// of resources. Always prefer indexed rendering!

// Helper to scale the ClipRect field of each DrawCmd.
// Use if your final output buffer is at a different scale than
// draw_data->DisplaySize, or if there is a difference between your window
// resolution and framebuffer resolution.

//-----------------------------------------------------------------------------
// [SECTION] Helpers ShadeVertsXXX functions
//-----------------------------------------------------------------------------

// Generic linear color gradient, write to RGB fields, leave A untouched.
inline void Gui::ShadeVertsLinearColorGradientKeepAlpha(
    DrawList *draw_list, int vert_start_idx, int vert_end_idx, Vec2 gradient_p0,
    Vec2 gradient_p1, U32 col0, U32 col1) {
  Vec2 gradient_extent = Subtract(gradient_p1, gradient_p0);
  float gradient_inv_length2 = 1.0f / LengthSqr(gradient_extent);
  DrawVert *vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
  DrawVert *vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
  const int col0_r = (int)(col0 >> GUI_COL32_R_SHIFT) & 0xFF;
  const int col0_g = (int)(col0 >> GUI_COL32_G_SHIFT) & 0xFF;
  const int col0_b = (int)(col0 >> GUI_COL32_B_SHIFT) & 0xFF;
  const int col_delta_r = ((int)(col1 >> GUI_COL32_R_SHIFT) & 0xFF) - col0_r;
  const int col_delta_g = ((int)(col1 >> GUI_COL32_G_SHIFT) & 0xFF) - col0_g;
  const int col_delta_b = ((int)(col1 >> GUI_COL32_B_SHIFT) & 0xFF) - col0_b;
  for (DrawVert *vert = vert_start; vert < vert_end; vert++) {
    float d = Dot(Subtract(vert->pos, gradient_p0), gradient_extent);
    float t = Clamp(d * gradient_inv_length2, 0.0f, 1.0f);
    int r = (int)(col0_r + col_delta_r * t);
    int g = (int)(col0_g + col_delta_g * t);
    int b = (int)(col0_b + col_delta_b * t);
    vert->col = (r << GUI_COL32_R_SHIFT) | (g << GUI_COL32_G_SHIFT) |
                (b << GUI_COL32_B_SHIFT) | (vert->col & GUI_COL32_A_MASK);
  }
}

// Distribute UV over (a, b) rectangle
inline void Gui::ShadeVertsLinearUV(DrawList *draw_list, int vert_start_idx,
                                    int vert_end_idx, const Vec2 &a,
                                    const Vec2 &b, const Vec2 &uv_a,
                                    const Vec2 &uv_b, bool clamp) {
  const Vec2 size = Subtract(b, a);
  const Vec2 uv_size = Subtract(uv_b, uv_a);
  const Vec2 scale = Vec2(size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,
                          size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);

  DrawVert *vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
  DrawVert *vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
  if (clamp) {
    const Vec2 min = Min(uv_a, uv_b);
    const Vec2 max = Max(uv_a, uv_b);
    for (DrawVert *vertex = vert_start; vertex < vert_end; ++vertex)
      vertex->uv =
          Clamp(Add(uv_a, Mul(Subtract(Vec2(vertex->pos.x, vertex->pos.y), a),
                              scale)),
                min, max);
  } else {
    for (DrawVert *vertex = vert_start; vertex < vert_end; ++vertex)
      vertex->uv = Add(
          uv_a, Mul(Subtract(Vec2(vertex->pos.x, vertex->pos.y), a), scale));
  }
}

inline void Gui::ShadeVertsTransformPos(DrawList *draw_list, int vert_start_idx,
                                        int vert_end_idx, const Vec2 &pivot_in,
                                        float cos_a, float sin_a,
                                        const Vec2 &pivot_out) {
  DrawVert *vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
  DrawVert *vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
  for (DrawVert *vertex = vert_start; vertex < vert_end; ++vertex)
    vertex->pos =
        Add(Rotate(Subtract(vertex->pos, pivot_in), cos_a, sin_a), pivot_out);
}

//-----------------------------------------------------------------------------
// [SECTION] FontConfig
//-----------------------------------------------------------------------------

inline FontConfig::FontConfig() {
  memset(this, 0, sizeof(*this));
  FontDataOwnedByAtlas = true;
  OversampleH = 2;
  OversampleV = 1;
  GlyphMaxAdvanceX = FLT_MAX;
  RasterizerMultiply = 1.0f;
  RasterizerDensity = 1.0f;
  EllipsisChar = (Wchar)-1;
}

//-----------------------------------------------------------------------------
// [SECTION] FontAtlas
//-----------------------------------------------------------------------------

// A work of art lies ahead! (. = white layer, X = black layer, others are
// blank) The 2x2 white texels on the top left are the ones we'll use everywhere
// in Dear Gui to render filled shapes. (This is used when io.MouseDrawCursor
// = true)
const int FONT_ATLAS_DEFAULT_TEX_DATA_W =
    122; // Actual texture will be 2 times that + 1 spacing.
const int FONT_ATLAS_DEFAULT_TEX_DATA_H = 27;
static const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS
    [FONT_ATLAS_DEFAULT_TEX_DATA_W * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] = {
        "..-         -XXXXXXX-    X    -           X           -XXXXXXX        "
        "  -          XXXXXXX-     XX          - XX       XX "
        "..-         -X.....X-   X.X   -          X.X          -X.....X        "
        "  -          X.....X-    X..X         -X..X     X..X"
        "---         -XXX.XXX-  X...X  -         X...X         -X....X         "
        "  -           X....X-    X..X         -X...X   X...X"
        "X           -  X.X  - X.....X -        X.....X        -X...X          "
        "  -            X...X-    X..X         - X...X X...X "
        "XX          -  X.X  -X.......X-       X.......X       -X..X.X         "
        "  -           X.X..X-    X..X         -  X...X...X  "
        "X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X        "
        "  -          X.X X.X-    X..XXX       -   X.....X   "
        "X..X        -  X.X  -   X.X   -          X.X          -XX   X.X       "
        "  -         X.X   XX-    X..X..XXX    -    X...X    "
        "X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X      "
        "  -        X.X      -    X..X..X..XX  -     X.X     "
        "X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X     "
        "  -       X.X       -    X..X..X..X.X -    X...X    "
        "X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X    "
        "  -      X.X        -XXX X..X..X..X..X-   X.....X   "
        "X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   "
        "XX-XX   X.X         -X..XX........X..X-  X...X...X  "
        "X.......X   -  X.X  -   X.X   -X.....................X-          X.X "
        "X.X-X.X X.X          -X...X...........X- X...X X...X "
        "X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           "
        "X.X..X-X..X.X           - X..............X-X...X   X...X"
        "X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            "
        "X...X-X...X            -  X.............X-X..X     X..X"
        "X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           "
        "X....X-X....X           -  X.............X- XX       XX "
        "X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          "
        "X.....X-X.....X          -   X............X--------------"
        "X...X..X    ---------   X.X   -          X.X          -          "
        "XXXXXXX-XXXXXXX          -   X...........X -             "
        "X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       "
        "-------------------------------------    X..........X -             "
        "X.X  X..X   -       -X.......X-       X.......X       -    XX         "
        "  XX    -           -    X..........X -             "
        "XX    X..X  -       - X.....X -        X.....X        -   X.X         "
        "  X.X   -           -     X........X  -             "
        "      X..X  -       -  X...X  -         X...X         -  X..X         "
        "  X..X  -           -     X........X  -             "
        "       XX   -       -   X.X   -          X.X          - "
        "X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  -             "
        "-------------       -    X    -           X           "
        "-X.....................X-           -------------------             "
        "                    ----------------------------------- "
        "X...XXXXXXXXXXXXX...X -                                           "
        "                                                      -  X..X         "
        "  X..X  -                                           "
        "                                                      -   X.X         "
        "  X.X   -                                           "
        "                                                      -    XX         "
        "  XX    -                                           "};

static const Vec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[MouseCursor_COUNT][3] = {
    // Pos ........ Size ......... Offset ......
    {Vec2(0, 3), Vec2(12, 19), Vec2(0, 0)},    // MouseCursor_Arrow
    {Vec2(13, 0), Vec2(7, 16), Vec2(1, 8)},    // MouseCursor_TextInput
    {Vec2(31, 0), Vec2(23, 23), Vec2(11, 11)}, // MouseCursor_ResizeAll
    {Vec2(21, 0), Vec2(9, 23), Vec2(4, 11)},   // MouseCursor_ResizeNS
    {Vec2(55, 18), Vec2(23, 9), Vec2(11, 4)},  // MouseCursor_ResizeEW
    {Vec2(73, 0), Vec2(17, 17), Vec2(8, 8)},   // MouseCursor_ResizeNESW
    {Vec2(55, 0), Vec2(17, 17), Vec2(8, 8)},   // MouseCursor_ResizeNWSE
    {Vec2(91, 0), Vec2(17, 22), Vec2(5, 0)},   // MouseCursor_Hand
    {Vec2(109, 0), Vec2(13, 15), Vec2(6, 7)},  // MouseCursor_NotAllowed
};

inline FontAtlas::FontAtlas() {
  memset(this, 0, sizeof(*this));
  TexGlyphPadding = 1;
  PackIdMouseCursors = PackIdLines = -1;
}

inline FontAtlas::~FontAtlas() {
  GUI_ASSERT(!Locked && "Cannot modify a locked FontAtlas between NewFrame() "
                        "and EndFrame/Render()!");
  Clear();
}

inline void FontAtlas::ClearInputData() {
  GUI_ASSERT(!Locked && "Cannot modify a locked FontAtlas between NewFrame() "
                        "and EndFrame/Render()!");
  for (FontConfig &font_cfg : ConfigData)
    if (font_cfg.FontData && font_cfg.FontDataOwnedByAtlas) {
      GUI_FREE(font_cfg.FontData);
      font_cfg.FontData = NULL;
    }

  // When clearing this we lose access to the font name and other information
  // used to build the font.
  for (Font *font : Fonts)
    if (font->ConfigData >= ConfigData.Data &&
        font->ConfigData < ConfigData.Data + ConfigData.Size) {
      font->ConfigData = NULL;
      font->ConfigDataCount = 0;
    }
  ConfigData.clear();
  CustomRects.clear();
  PackIdMouseCursors = PackIdLines = -1;
  // Important: we leave TexReady untouched
}

inline void FontAtlas::ClearTexData() {
  GUI_ASSERT(!Locked && "Cannot modify a locked FontAtlas between NewFrame() "
                        "and EndFrame/Render()!");
  if (TexPixelsAlpha8)
    GUI_FREE(TexPixelsAlpha8);
  if (TexPixelsRGBA32)
    GUI_FREE(TexPixelsRGBA32);
  TexPixelsAlpha8 = NULL;
  TexPixelsRGBA32 = NULL;
  TexPixelsUseColors = false;
  // Important: we leave TexReady untouched
}

inline void FontAtlas::ClearFonts() {
  GUI_ASSERT(!Locked && "Cannot modify a locked FontAtlas between NewFrame() "
                        "and EndFrame/Render()!");
  Fonts.clear_delete();
  TexReady = false;
}

inline void FontAtlas::GetTexDataAsRGBA32(unsigned char **out_pixels,
                                          int *out_width, int *out_height,
                                          int *out_bytes_per_pixel) {
  // Convert to RGBA32 format on demand
  // Although it is likely to be the most commonly used format, our font
  // rendering is 1 channel / 8 bpp
  if (!TexPixelsRGBA32) {
    unsigned char *pixels = NULL;
    GetTexDataAsAlpha8(&pixels, NULL, NULL);
    if (pixels) {
      TexPixelsRGBA32 =
          (unsigned int *)GUI_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);
      const unsigned char *src = pixels;
      unsigned int *dst = TexPixelsRGBA32;
      for (int n = TexWidth * TexHeight; n > 0; n--)
        *dst++ = GUI_COL32(255, 255, 255, (unsigned int)(*src++));
    }
  }

  *out_pixels = (unsigned char *)TexPixelsRGBA32;
  if (out_width)
    *out_width = TexWidth;
  if (out_height)
    *out_height = TexHeight;
  if (out_bytes_per_pixel)
    *out_bytes_per_pixel = 4;
}

inline Font *FontAtlas::AddFont(const FontConfig *font_cfg) {
  GUI_ASSERT(!Locked && "Cannot modify a locked FontAtlas between NewFrame() "
                        "and EndFrame/Render()!");
  GUI_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
  GUI_ASSERT(font_cfg->SizePixels > 0.0f);

  // Create new font
  if (!font_cfg->MergeMode)
    Fonts.push_back(GUI_NEW(Font));
  else
    GUI_ASSERT(
        !Fonts.empty() &&
        "Cannot use MergeMode for the first font"); // When using MergeMode make
                                                    // sure that a font has
                                                    // already been added
                                                    // before. You can use
                                                    // Gui::GetIO().Fonts->AddFontDefault()
                                                    // to add the default gui
                                                    // font.

  ConfigData.push_back(*font_cfg);
  FontConfig &new_font_cfg = ConfigData.back();
  if (new_font_cfg.DstFont == NULL)
    new_font_cfg.DstFont = Fonts.back();
  if (!new_font_cfg.FontDataOwnedByAtlas) {
    new_font_cfg.FontData = GUI_ALLOC(new_font_cfg.FontDataSize);
    new_font_cfg.FontDataOwnedByAtlas = true;
    memcpy(new_font_cfg.FontData, font_cfg->FontData,
           (size_t)new_font_cfg.FontDataSize);
  }

  if (new_font_cfg.DstFont->EllipsisChar == (Wchar)-1)
    new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;

  FontAtlasUpdateConfigDataPointers(this);

  // Invalidate texture
  TexReady = false;
  ClearTexData();
  return new_font_cfg.DstFont;
}

// Default font TTF is compressed with stb_compress then base85 encoded (see
// misc/fonts/binary_to_compressed_c.cpp for encoder)
static unsigned int stb_decompress_length(const unsigned char *input);
static unsigned int stb_decompress(unsigned char *output,
                                   const unsigned char *input,
                                   unsigned int length);
static const char *GetDefaultCompressedFontDataTTFBase85();
static unsigned int Decode85Byte(char c) { return c >= '\\' ? c - 36 : c - 35; }
static void Decode85(const unsigned char *src, unsigned char *dst) {
  while (*src) {
    unsigned int tmp =
        Decode85Byte(src[0]) +
        85 * (Decode85Byte(src[1]) +
              85 * (Decode85Byte(src[2]) +
                    85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));
    dst[0] = ((tmp >> 0) & 0xFF);
    dst[1] = ((tmp >> 8) & 0xFF);
    dst[2] = ((tmp >> 16) & 0xFF);
    dst[3] = ((tmp >> 24) & 0xFF); // We can't assume little-endianness.
    src += 5;
    dst += 4;
  }
}

// Load embedded ProggyClean.ttf at size 13, disable oversampling
inline Font *FontAtlas::AddFontDefault(const FontConfig *font_cfg_template) {
  FontConfig font_cfg = font_cfg_template ? *font_cfg_template : FontConfig();
  if (!font_cfg_template) {
    font_cfg.OversampleH = font_cfg.OversampleV = 1;
    font_cfg.PixelSnapH = true;
  }
  if (font_cfg.SizePixels <= 0.0f)
    font_cfg.SizePixels = 13.0f * 1.0f;
  if (font_cfg.Name[0] == '\0')
    FormatString(font_cfg.Name, GUI_ARRAYSIZE(font_cfg.Name),
                 "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);
  font_cfg.EllipsisChar = (Wchar)0x0085;
  font_cfg.GlyphOffset.y =
      1.0f *
      GUI_TRUNC(font_cfg.SizePixels / 13.0f); // Add +1 offset per 13 units

  const char *ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
  const Wchar *glyph_ranges = font_cfg.GlyphRanges != NULL
                                  ? font_cfg.GlyphRanges
                                  : GetGlyphRangesDefault();
  Font *font = AddFontFromMemoryCompressedBase85TTF(
      ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
  return font;
}

inline Font *FontAtlas::AddFontFromFileTTF(const char *filename,
                                           float size_pixels,
                                           const FontConfig *font_cfg_template,
                                           const Wchar *glyph_ranges) {
  GUI_ASSERT(!Locked && "Cannot modify a locked FontAtlas between NewFrame() "
                        "and EndFrame/Render()!");
  size_t data_size = 0;
  void *data = FileLoadToMemory(filename, "rb", &data_size, 0);
  if (!data) {
    GUI_ASSERT_USER_ERROR(0, "Could not load font file!");
    return NULL;
  }
  FontConfig font_cfg = font_cfg_template ? *font_cfg_template : FontConfig();
  if (font_cfg.Name[0] == '\0') {
    // Store a short copy of filename into into the font name for convenience
    const char *p;
    for (p = filename + strlen(filename);
         p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {
    }
    FormatString(font_cfg.Name, GUI_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p,
                 size_pixels);
  }
  return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg,
                              glyph_ranges);
}

// NB: Transfer ownership of 'ttf_data' to FontAtlas, unless
// font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be
// deleted after Build().
inline Font *FontAtlas::AddFontFromMemoryTTF(
    void *font_data, int font_data_size, float size_pixels,
    const FontConfig *font_cfg_template, const Wchar *glyph_ranges) {
  GUI_ASSERT(!Locked && "Cannot modify a locked FontAtlas between NewFrame() "
                        "and EndFrame/Render()!");
  FontConfig font_cfg = font_cfg_template ? *font_cfg_template : FontConfig();
  GUI_ASSERT(font_cfg.FontData == NULL);
  GUI_ASSERT(
      font_data_size > 100 &&
      "Incorrect value for font_data_size!"); // Heuristic to prevent
                                              // accidentally passing a wrong
                                              // value to font_data_size.
  font_cfg.FontData = font_data;
  font_cfg.FontDataSize = font_data_size;
  font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;
  if (glyph_ranges)
    font_cfg.GlyphRanges = glyph_ranges;
  return AddFont(&font_cfg);
}

inline Font *FontAtlas::AddFontFromMemoryCompressedTTF(
    const void *compressed_ttf_data, int compressed_ttf_size, float size_pixels,
    const FontConfig *font_cfg_template, const Wchar *glyph_ranges) {
  const unsigned int buf_decompressed_size =
      stb_decompress_length((const unsigned char *)compressed_ttf_data);
  unsigned char *buf_decompressed_data =
      (unsigned char *)GUI_ALLOC(buf_decompressed_size);
  stb_decompress(buf_decompressed_data,
                 (const unsigned char *)compressed_ttf_data,
                 (unsigned int)compressed_ttf_size);

  FontConfig font_cfg = font_cfg_template ? *font_cfg_template : FontConfig();
  GUI_ASSERT(font_cfg.FontData == NULL);
  font_cfg.FontDataOwnedByAtlas = true;
  return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size,
                              size_pixels, &font_cfg, glyph_ranges);
}

inline Font *FontAtlas::AddFontFromMemoryCompressedBase85TTF(
    const char *compressed_ttf_data_base85, float size_pixels,
    const FontConfig *font_cfg, const Wchar *glyph_ranges) {
  int compressed_ttf_size =
      (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
  void *compressed_ttf = GUI_ALLOC((size_t)compressed_ttf_size);
  Decode85((const unsigned char *)compressed_ttf_data_base85,
           (unsigned char *)compressed_ttf);
  Font *font = AddFontFromMemoryCompressedTTF(
      compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
  GUI_FREE(compressed_ttf);
  return font;
}

inline int FontAtlas::AddCustomRectRegular(int width, int height) {
  GUI_ASSERT(width > 0 && width <= 0xFFFF);
  GUI_ASSERT(height > 0 && height <= 0xFFFF);
  FontAtlasCustomRect r;
  r.Width = (unsigned short)width;
  r.Height = (unsigned short)height;
  CustomRects.push_back(r);
  return CustomRects.Size - 1; // Return index
}

inline int FontAtlas::AddCustomRectFontGlyph(Font *font, Wchar id, int width,
                                             int height, float advance_x,
                                             const Vec2 &offset) {
#ifdef GUI_USE_WCHAR32
  GUI_ASSERT(id <= GUI_UNICODE_CODEPOINT_MAX);
#endif
  GUI_ASSERT(font != NULL);
  GUI_ASSERT(width > 0 && width <= 0xFFFF);
  GUI_ASSERT(height > 0 && height <= 0xFFFF);
  FontAtlasCustomRect r;
  r.Width = (unsigned short)width;
  r.Height = (unsigned short)height;
  r.GlyphID = id;
  r.GlyphAdvanceX = advance_x;
  r.GlyphOffset = offset;
  r.Font = font;
  CustomRects.push_back(r);
  return CustomRects.Size - 1; // Return index
}

inline void FontAtlas::CalcCustomRectUV(const FontAtlasCustomRect *rect,
                                        Vec2 *out_uv_min,
                                        Vec2 *out_uv_max) const {
  GUI_ASSERT(TexWidth > 0 &&
             TexHeight > 0);    // Font atlas needs to be built before we can
                                // calculate UV coordinates
  GUI_ASSERT(rect->IsPacked()); // Make sure the rectangle has been packed
  *out_uv_min =
      Vec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);
  *out_uv_max = Vec2((float)(rect->X + rect->Width) * TexUvScale.x,
                     (float)(rect->Y + rect->Height) * TexUvScale.y);
}

inline bool FontAtlas::GetMouseCursorTexData(MouseCursor cursor_type,
                                             Vec2 *out_offset, Vec2 *out_size,
                                             Vec2 out_uv_border[2],
                                             Vec2 out_uv_fill[2]) {
  if (cursor_type <= MouseCursor_None || cursor_type >= MouseCursor_COUNT)
    return false;
  if (Flags & FontAtlasFlags_NoMouseCursors)
    return false;

  GUI_ASSERT(PackIdMouseCursors != -1);
  FontAtlasCustomRect *r = GetCustomRectByIndex(PackIdMouseCursors);
  Vec2 pos = Add(FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0],
                 Vec2((float)r->X, (float)r->Y));
  Vec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];
  *out_size = size;
  *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];
  out_uv_border[0] = Multiply((pos), TexUvScale);
  out_uv_border[1] = Multiply(Add(pos, size), TexUvScale);
  pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
  out_uv_fill[0] = Multiply((pos), TexUvScale);
  out_uv_fill[1] = Multiply(Add(pos, size), TexUvScale);
  return true;
}

inline bool FontAtlas::Build() {
  GUI_ASSERT(!Locked && "Cannot modify a locked FontAtlas between NewFrame() "
                        "and EndFrame/Render()!");

  // Default font is none are specified
  if (ConfigData.Size == 0)
    AddFontDefault();

  // Select builder
  // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely
  // to point to static data which
  //   may mess with some hot-reloading schemes. If you need to assign to this
  //   (for dynamic selection) AND are using a hot-reloading scheme that messes
  //   up static data, store your own instance of FontBuilderIO somewhere and
  //   point to it instead of pointing directly to return value of the
  //   GetBuilderXXX functions.
  const ::FontBuilderIO *builder_io = FontBuilderIO;
  if (builder_io == NULL) {
#ifdef GUI_ENABLE_FREETYPE
    builder_io = FreeType::GetBuilderForFreeType();
#elif defined(GUI_ENABLE_STB_TRUETYPE)
    builder_io = FontAtlasGetBuilderForStbTruetype();
#else
    GUI_ASSERT(0); // Invalid Build function
#endif
  }

  // Build
  return builder_io->FontBuilder_Build(this);
}

#ifdef GUI_ENABLE_STB_TRUETYPE
// Temporary data for one source font (multiple source fonts can be merged into
// one destination Font) (C++03 doesn't allow instancing Vector<> with
// function-local types so we declare the type here.)
struct FontBuildSrcData {
  stbtt_fontinfo FontInfo;
  stbtt_pack_range PackRange; // Hold the list of codepoints to pack
                              // (essentially points to Codepoints.Data)
  stbrp_rect *Rects; // Rectangle to pack. We first fill in their size and the
                     // packer will give us their position.
  stbtt_packedchar *PackedChars; // Output glyphs
  const Wchar *SrcRanges; // Ranges as requested by user (user is allowed to
                          // request too much, e.g. 0x0020..0xFFFF)
  int DstIndex;           // Index into atlas->Fonts[] and dst_tmp_array[]
  int GlyphsHighest;      // Highest requested codepoint
  int GlyphsCount; // Glyph count (excluding missing glyphs and glyphs already
                   // set by an earlier source font)
  BitVector GlyphsSet; // Glyph bit map (random access, 1-bit per codepoint.
                       // This will be a maximum of 8KB)
  Vector<int>
      GlyphsList; // Glyph codepoints list (flattened version of GlyphsSet)
};

// Temporary data for one destination Font* (multiple source fonts can be
// merged into one destination Font)
struct FontBuildDstData {
  int SrcCount; // Number of source fonts targeting this destination font.
  int GlyphsHighest;
  int GlyphsCount;
  BitVector GlyphsSet; // This is used to resolve collision when multiple
                       // sources are merged into a same destination font.
};

static void UnpackBitVectorToFlatIndexList(const BitVector *in,
                                           Vector<int> *out) {
  GUI_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
  const U32 *it_begin = in->Storage.begin();
  const U32 *it_end = in->Storage.end();
  for (const U32 *it = it_begin; it < it_end; it++)
    if (U32 entries_32 = *it)
      for (U32 bit_n = 0; bit_n < 32; bit_n++)
        if (entries_32 & ((U32)1 << bit_n))
          out->push_back((int)(((it - it_begin) << 5) + bit_n));
}

static bool FontAtlasBuildWithStbTruetype(FontAtlas *atlas) {
  GUI_ASSERT(atlas->ConfigData.Size > 0);

  FontAtlasBuildInit(atlas);

  // Clear atlas
  atlas->TexID = (TextureID)NULL;
  atlas->TexWidth = atlas->TexHeight = 0;
  atlas->TexUvScale = Vec2(0.0f, 0.0f);
  atlas->TexUvWhitePixel = Vec2(0.0f, 0.0f);
  atlas->ClearTexData();

  // Temporary storage for building
  Vector<FontBuildSrcData> src_tmp_array;
  Vector<FontBuildDstData> dst_tmp_array;
  src_tmp_array.resize(atlas->ConfigData.Size);
  dst_tmp_array.resize(atlas->Fonts.Size);
  memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
  memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());

  // 1. Initialize font loading structure, check font data validity
  for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++) {
    FontBuildSrcData &src_tmp = src_tmp_array[src_i];
    FontConfig &cfg = atlas->ConfigData[src_i];
    GUI_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() ||
                               cfg.DstFont->ContainerAtlas == atlas));

    // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also
    // it makes casual debugging nicer than when storing indices)
    src_tmp.DstIndex = -1;
    for (int output_i = 0;
         output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
      if (cfg.DstFont == atlas->Fonts[output_i])
        src_tmp.DstIndex = output_i;
    if (src_tmp.DstIndex == -1) {
      GUI_ASSERT(src_tmp.DstIndex !=
                 -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
      return false;
    }
    // Initialize helper structure for font loading and verify that the TTF/OTF
    // data is correct
    const int font_offset =
        stbtt_GetFontOffsetForIndex((unsigned char *)cfg.FontData, cfg.FontNo);
    GUI_ASSERT(font_offset >= 0 &&
               "FontData is incorrect, or FontNo cannot be found.");
    if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char *)cfg.FontData,
                        font_offset)) {
      GUI_ASSERT(0 && "stbtt_InitFont(): failed to parse FontData. It is "
                      "correct and complete? Check FontDataSize.");
      return false;
    }

    // Measure highest codepoints
    FontBuildDstData &dst_tmp = dst_tmp_array[src_tmp.DstIndex];
    src_tmp.SrcRanges =
        cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
    for (const Wchar *src_range = src_tmp.SrcRanges;
         src_range[0] && src_range[1]; src_range += 2) {
      // Check for valid range. This may also help detect *some* dangling
      // pointers, because a common user error is to setup
      // FontConfig::GlyphRanges with a pointer to data that isn't persistent.
      GUI_ASSERT(src_range[0] <= src_range[1]);
      src_tmp.GlyphsHighest = Max(src_tmp.GlyphsHighest, (int)src_range[1]);
    }
    dst_tmp.SrcCount++;
    dst_tmp.GlyphsHighest = Max(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
  }

  // 2. For every requested codepoint, check for their presence in the font
  // data, and handle redundancy or overlaps between source fonts to avoid
  // unused glyphs.
  int total_glyphs_count = 0;
  for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
    FontBuildSrcData &src_tmp = src_tmp_array[src_i];
    FontBuildDstData &dst_tmp = dst_tmp_array[src_tmp.DstIndex];
    src_tmp.GlyphsSet.Create(src_tmp.GlyphsHighest + 1);
    if (dst_tmp.GlyphsSet.Storage.empty())
      dst_tmp.GlyphsSet.Create(dst_tmp.GlyphsHighest + 1);

    for (const Wchar *src_range = src_tmp.SrcRanges;
         src_range[0] && src_range[1]; src_range += 2)
      for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1];
           codepoint++) {
        if (dst_tmp.GlyphsSet.TestBit(
                codepoint)) // Don't overwrite existing glyphs. We could make
                            // this an option for MergeMode (e.g.
                            // MergeOverwrite==true)
          continue;
        if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo,
                                  codepoint)) // It is actually in the font?
          continue;

        // Add to avail set/counters
        src_tmp.GlyphsCount++;
        dst_tmp.GlyphsCount++;
        src_tmp.GlyphsSet.SetBit(codepoint);
        dst_tmp.GlyphsSet.SetBit(codepoint);
        total_glyphs_count++;
      }
  }

  // 3. Unpack our bit map into a flat list (we now have all the Unicode points
  // that we know are requested _and_ available _and_ not overlapping another)
  for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
    FontBuildSrcData &src_tmp = src_tmp_array[src_i];
    src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
    UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
    src_tmp.GlyphsSet.Clear();
    GUI_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
  }
  for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
    dst_tmp_array[dst_i].GlyphsSet.Clear();
  dst_tmp_array.clear();

  // Allocate packing character data and flag packed characters buffer as
  // non-packed (x0=y0=x1=y1=0) (We technically don't need to zero-clear
  // buf_rects, but let's do it for the sake of sanity)
  Vector<stbrp_rect> buf_rects;
  Vector<stbtt_packedchar> buf_packedchars;
  buf_rects.resize(total_glyphs_count);
  buf_packedchars.resize(total_glyphs_count);
  memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
  memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());

  // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
  int total_surface = 0;
  int buf_rects_out_n = 0;
  int buf_packedchars_out_n = 0;
  for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
    FontBuildSrcData &src_tmp = src_tmp_array[src_i];
    if (src_tmp.GlyphsCount == 0)
      continue;

    src_tmp.Rects = &buf_rects[buf_rects_out_n];
    src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
    buf_rects_out_n += src_tmp.GlyphsCount;
    buf_packedchars_out_n += src_tmp.GlyphsCount;

    // Convert our ranges in the format stb_truetype wants
    FontConfig &cfg = atlas->ConfigData[src_i];
    src_tmp.PackRange.font_size = cfg.SizePixels * cfg.RasterizerDensity;
    src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
    src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
    src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
    src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
    src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;
    src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;

    // Gather the sizes of all rectangles we will need to pack (this loop is
    // based on stbtt_PackFontRangesGatherRects)
    const float scale =
        (cfg.SizePixels > 0.0f)
            ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo,
                                        cfg.SizePixels * cfg.RasterizerDensity)
            : stbtt_ScaleForMappingEmToPixels(
                  &src_tmp.FontInfo, -cfg.SizePixels * cfg.RasterizerDensity);
    const int padding = atlas->TexGlyphPadding;
    for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++) {
      int x0, y0, x1, y1;
      const int glyph_index_in_font =
          stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
      GUI_ASSERT(glyph_index_in_font != 0);
      stbtt_GetGlyphBitmapBoxSubpixel(
          &src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH,
          scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);
      src_tmp.Rects[glyph_i].w =
          (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);
      src_tmp.Rects[glyph_i].h =
          (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);
      total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
    }
  }

  // We need a width for the skyline algorithm, any width!
  // The exact width doesn't really matter much, but some API/GPU have texture
  // size limitations and increasing width can decrease height. User can
  // override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use
  // a simple heuristic to select the width based on expected surface.
  const int surface_sqrt = (int)Sqrt((float)total_surface) + 1;
  atlas->TexHeight = 0;
  if (atlas->TexDesiredWidth > 0)
    atlas->TexWidth = atlas->TexDesiredWidth;
  else
    atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f)   ? 4096
                      : (surface_sqrt >= 2048 * 0.7f) ? 2048
                      : (surface_sqrt >= 1024 * 0.7f) ? 1024
                                                      : 512;

  // 5. Start packing
  // Pack our extra data rectangles first, so it will be on the upper-left
  // corner of our texture (UV will have small values).
  const int TEX_HEIGHT_MAX = 1024 * 32;
  stbtt_pack_context spc = {};
  stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0,
                  atlas->TexGlyphPadding, NULL);
  FontAtlasBuildPackCustomRects(atlas, spc.pack_info);

  // 6. Pack each source font. No rendering yet, we are working with rectangles
  // in an infinitely tall texture at this point.
  for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
    FontBuildSrcData &src_tmp = src_tmp_array[src_i];
    if (src_tmp.GlyphsCount == 0)
      continue;

    stbrp_pack_rects((stbrp_context *)spc.pack_info, src_tmp.Rects,
                     src_tmp.GlyphsCount);

    // Extend texture height and mark missing glyphs as non-packed so we won't
    // render them.
    // FIXME: We are not handling packing failure here (would happen if we got
    // off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
    for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
      if (src_tmp.Rects[glyph_i].was_packed)
        atlas->TexHeight = Max(atlas->TexHeight, src_tmp.Rects[glyph_i].y +
                                                     src_tmp.Rects[glyph_i].h);
  }

  // 7. Allocate texture
  atlas->TexHeight = (atlas->Flags & FontAtlasFlags_NoPowerOfTwoHeight)
                         ? (atlas->TexHeight + 1)
                         : UpperPowerOfTwo(atlas->TexHeight);
  atlas->TexUvScale = Vec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
  atlas->TexPixelsAlpha8 =
      (unsigned char *)GUI_ALLOC(atlas->TexWidth * atlas->TexHeight);
  memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
  spc.pixels = atlas->TexPixelsAlpha8;
  spc.height = atlas->TexHeight;

  // 8. Render/rasterize font characters into the texture
  for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
    FontConfig &cfg = atlas->ConfigData[src_i];
    FontBuildSrcData &src_tmp = src_tmp_array[src_i];
    if (src_tmp.GlyphsCount == 0)
      continue;

    stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo,
                                        &src_tmp.PackRange, 1, src_tmp.Rects);

    // Apply multiply operator
    if (cfg.RasterizerMultiply != 1.0f) {
      unsigned char multiply_table[256];
      FontAtlasBuildMultiplyCalcLookupTable(multiply_table,
                                            cfg.RasterizerMultiply);
      stbrp_rect *r = &src_tmp.Rects[0];
      for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
        if (r->was_packed)
          FontAtlasBuildMultiplyRectAlpha8(multiply_table,
                                           atlas->TexPixelsAlpha8, r->x, r->y,
                                           r->w, r->h, atlas->TexWidth * 1);
    }
    src_tmp.Rects = NULL;
  }

  // End packing
  stbtt_PackEnd(&spc);
  buf_rects.clear();

  // 9. Setup Font and glyphs for runtime
  for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
    // When merging fonts with MergeMode=true:
    // - We can have multiple input fonts writing into a same destination font.
    // - dst_font->ConfigData is != from cfg which is our source configuration.
    FontBuildSrcData &src_tmp = src_tmp_array[src_i];
    FontConfig &cfg = atlas->ConfigData[src_i];
    Font *dst_font = cfg.DstFont;

    const float font_scale =
        stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
    int unscaled_ascent, unscaled_descent, unscaled_line_gap;
    stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent,
                          &unscaled_descent, &unscaled_line_gap);

    const float ascent = Trunc(unscaled_ascent * font_scale +
                               ((unscaled_ascent > 0.0f) ? +1 : -1));
    const float descent = Trunc(unscaled_descent * font_scale +
                                ((unscaled_descent > 0.0f) ? +1 : -1));
    FontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
    const float font_off_x = cfg.GlyphOffset.x;
    const float font_off_y = cfg.GlyphOffset.y + GUI_ROUND(dst_font->Ascent);

    const float inv_rasterization_scale = 1.0f / cfg.RasterizerDensity;

    for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++) {
      // Register glyph
      const int codepoint = src_tmp.GlyphsList[glyph_i];
      const stbtt_packedchar &pc = src_tmp.PackedChars[glyph_i];
      stbtt_aligned_quad q;
      float unused_x = 0.0f, unused_y = 0.0f;
      stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth,
                          atlas->TexHeight, glyph_i, &unused_x, &unused_y, &q,
                          0);
      float x0 = q.x0 * inv_rasterization_scale + font_off_x;
      float y0 = q.y0 * inv_rasterization_scale + font_off_y;
      float x1 = q.x1 * inv_rasterization_scale + font_off_x;
      float y1 = q.y1 * inv_rasterization_scale + font_off_y;
      dst_font->AddGlyph(&cfg, (Wchar)codepoint, x0, y0, x1, y1, q.s0, q.t0,
                         q.s1, q.t1, pc.xadvance * inv_rasterization_scale);
    }
  }

  // Cleanup
  src_tmp_array.clear_destruct();

  FontAtlasBuildFinish(atlas);
  return true;
}

inline const FontBuilderIO *FontAtlasGetBuilderForStbTruetype() {
  static FontBuilderIO io;
  io.FontBuilder_Build = FontAtlasBuildWithStbTruetype;
  return &io;
}

#endif // GUI_ENABLE_STB_TRUETYPE

inline void FontAtlasBuildSetupFont(FontAtlas *atlas, Font *font,
                                    FontConfig *font_config, float ascent,
                                    float descent) {
  if (!font_config->MergeMode) {
    font->ClearOutputData();
    font->FontSize = font_config->SizePixels;
    GUI_ASSERT(font->ConfigData == font_config);
    font->ContainerAtlas = atlas;
    font->Ascent = ascent;
    font->Descent = descent;
  }
}

inline void FontAtlasBuildPackCustomRects(FontAtlas *atlas,
                                          void *stbrp_context_opaque) {
  stbrp_context *pack_context = (stbrp_context *)stbrp_context_opaque;
  GUI_ASSERT(pack_context != NULL);

  Vector<FontAtlasCustomRect> &user_rects = atlas->CustomRects;
  GUI_ASSERT(user_rects.Size >=
             1); // We expect at least the default custom rects to be
                 // registered, else something went wrong.
#ifdef __GNUC__
  if (user_rects.Size < 1) {
    __builtin_unreachable();
  } // Workaround for GCC bug if GUI_ASSERT() is defined to conditionally throw
    // (see #5343)
#endif

  Vector<stbrp_rect> pack_rects;
  pack_rects.resize(user_rects.Size);
  memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
  for (int i = 0; i < user_rects.Size; i++) {
    pack_rects[i].w = user_rects[i].Width;
    pack_rects[i].h = user_rects[i].Height;
  }
  stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
  for (int i = 0; i < pack_rects.Size; i++)
    if (pack_rects[i].was_packed) {
      user_rects[i].X = (unsigned short)pack_rects[i].x;
      user_rects[i].Y = (unsigned short)pack_rects[i].y;
      GUI_ASSERT(pack_rects[i].w == user_rects[i].Width &&
                 pack_rects[i].h == user_rects[i].Height);
      atlas->TexHeight =
          Max(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
    }
}

inline void FontAtlasBuildRender8bppRectFromString(
    FontAtlas *atlas, int x, int y, int w, int h, const char *in_str,
    char in_marker_char, unsigned char in_marker_pixel_value) {
  GUI_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
  GUI_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
  unsigned char *out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);
  for (int off_y = 0; off_y < h;
       off_y++, out_pixel += atlas->TexWidth, in_str += w)
    for (int off_x = 0; off_x < w; off_x++)
      out_pixel[off_x] =
          (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;
}

inline void FontAtlasBuildRender32bppRectFromString(
    FontAtlas *atlas, int x, int y, int w, int h, const char *in_str,
    char in_marker_char, unsigned int in_marker_pixel_value) {
  GUI_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
  GUI_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
  unsigned int *out_pixel = atlas->TexPixelsRGBA32 + x + (y * atlas->TexWidth);
  for (int off_y = 0; off_y < h;
       off_y++, out_pixel += atlas->TexWidth, in_str += w)
    for (int off_x = 0; off_x < w; off_x++)
      out_pixel[off_x] = (in_str[off_x] == in_marker_char)
                             ? in_marker_pixel_value
                             : GUI_COL32_BLACK_TRANS;
}

static void FontAtlasBuildRenderDefaultTexData(FontAtlas *atlas) {
  FontAtlasCustomRect *r =
      atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
  GUI_ASSERT(r->IsPacked());

  const int w = atlas->TexWidth;
  if (!(atlas->Flags & FontAtlasFlags_NoMouseCursors)) {
    // Render/copy pixels
    GUI_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 &&
               r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
    const int x_for_white = r->X;
    const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
    if (atlas->TexPixelsAlpha8 != NULL) {
      FontAtlasBuildRender8bppRectFromString(
          atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W,
          FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS,
          '.', 0xFF);
      FontAtlasBuildRender8bppRectFromString(
          atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W,
          FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS,
          'X', 0xFF);
    } else {
      FontAtlasBuildRender32bppRectFromString(
          atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W,
          FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS,
          '.', GUI_COL32_WHITE);
      FontAtlasBuildRender32bppRectFromString(
          atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W,
          FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS,
          'X', GUI_COL32_WHITE);
    }
  } else {
    // Render 4 white pixels
    GUI_ASSERT(r->Width == 2 && r->Height == 2);
    const int offset = (int)r->X + (int)r->Y * w;
    if (atlas->TexPixelsAlpha8 != NULL) {
      atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] =
          atlas->TexPixelsAlpha8[offset + w] =
              atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
    } else {
      atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] =
          atlas->TexPixelsRGBA32[offset + w] =
              atlas->TexPixelsRGBA32[offset + w + 1] = GUI_COL32_WHITE;
    }
  }
  atlas->TexUvWhitePixel = Vec2((r->X + 0.5f) * atlas->TexUvScale.x,
                                (r->Y + 0.5f) * atlas->TexUvScale.y);
}

static void FontAtlasBuildRenderLinesTexData(FontAtlas *atlas) {
  if (atlas->Flags & FontAtlasFlags_NoBakedLines)
    return;

  // This generates a triangular shape in the texture, with the various line
  // widths stacked on top of each other to allow interpolation between them
  FontAtlasCustomRect *r = atlas->GetCustomRectByIndex(atlas->PackIdLines);
  GUI_ASSERT(r->IsPacked());
  for (unsigned int n = 0; n < GUI_DRAWLIST_TEX_LINES_WIDTH_MAX + 1;
       n++) // +1 because of the zero-width row
  {
    // Each line consists of at least two empty pixels at the ends, with a line
    // of solid pixels in the middle
    unsigned int y = n;
    unsigned int line_width = n;
    unsigned int pad_left = (r->Width - line_width) / 2;
    unsigned int pad_right = r->Width - (pad_left + line_width);

    // Write each slice
    GUI_ASSERT(pad_left + line_width + pad_right == r->Width &&
               y < r->Height); // Make sure we're inside the texture bounds
                               // before we start writing pixels
    if (atlas->TexPixelsAlpha8 != NULL) {
      unsigned char *write_ptr =
          &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];
      for (unsigned int i = 0; i < pad_left; i++)
        *(write_ptr + i) = 0x00;

      for (unsigned int i = 0; i < line_width; i++)
        *(write_ptr + pad_left + i) = 0xFF;

      for (unsigned int i = 0; i < pad_right; i++)
        *(write_ptr + pad_left + line_width + i) = 0x00;
    } else {
      unsigned int *write_ptr =
          &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];
      for (unsigned int i = 0; i < pad_left; i++)
        *(write_ptr + i) = GUI_COL32(255, 255, 255, 0);

      for (unsigned int i = 0; i < line_width; i++)
        *(write_ptr + pad_left + i) = GUI_COL32_WHITE;

      for (unsigned int i = 0; i < pad_right; i++)
        *(write_ptr + pad_left + line_width + i) = GUI_COL32(255, 255, 255, 0);
    }

    // Calculate UVs for this line
    Vec2 uv0 = Multiply(Vec2((float)(r->X + pad_left - 1), (float)(r->Y + y)),
                        atlas->TexUvScale);
    Vec2 uv1 = Multiply(
        Vec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)),
        atlas->TexUvScale);
    float half_v =
        (uv0.y + uv1.y) * 0.5f; // Calculate a constant V in the middle of the
                                // row to avoid sampling artifacts
    atlas->TexUvLines[n] = Vec4(uv0.x, half_v, uv1.x, half_v);
  }
}

// Note: this is called / shared by both the stb_truetype and the FreeType
// builder
inline void FontAtlasBuildInit(FontAtlas *atlas) {
  // Round font size
  // - We started rounding in 1.90 WIP (18991) as our layout system currently
  // doesn't support non-rounded font size well yet.
  // - Note that using io.FontGlobalScale or SetWindowFontScale(), with are
  // legacy-ish, partially supported features, can still lead to unrounded
  // sizes.
  // - We may support it better later and remove this rounding.
  for (FontConfig &cfg : atlas->ConfigData)
    cfg.SizePixels = Trunc(cfg.SizePixels);

  // Register texture region for mouse cursors or standard white pixels
  if (atlas->PackIdMouseCursors < 0) {
    if (!(atlas->Flags & FontAtlasFlags_NoMouseCursors))
      atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(
          FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
    else
      atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);
  }

  // Register texture region for thick lines
  // The +2 here is to give space for the end caps, whilst height +1 is to
  // accommodate the fact we have a zero-width row
  if (atlas->PackIdLines < 0) {
    if (!(atlas->Flags & FontAtlasFlags_NoBakedLines))
      atlas->PackIdLines =
          atlas->AddCustomRectRegular(GUI_DRAWLIST_TEX_LINES_WIDTH_MAX + 2,
                                      GUI_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
  }
}

// This is called/shared by both the stb_truetype and the FreeType builder.
inline void FontAtlasBuildFinish(FontAtlas *atlas) {
  // Render into our custom data blocks
  GUI_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);
  FontAtlasBuildRenderDefaultTexData(atlas);
  FontAtlasBuildRenderLinesTexData(atlas);

  // Register custom rectangle glyphs
  for (int i = 0; i < atlas->CustomRects.Size; i++) {
    const FontAtlasCustomRect *r = &atlas->CustomRects[i];
    if (r->Font == NULL || r->GlyphID == 0)
      continue;

    // Will ignore FontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY,
    // GlyphExtraSpacing, PixelSnapH
    GUI_ASSERT(r->Font->ContainerAtlas == atlas);
    Vec2 uv0, uv1;
    atlas->CalcCustomRectUV(r, &uv0, &uv1);
    r->Font->AddGlyph(NULL, (Wchar)r->GlyphID, r->GlyphOffset.x,
                      r->GlyphOffset.y, r->GlyphOffset.x + r->Width,
                      r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y,
                      r->GlyphAdvanceX);
  }

  // Build all fonts lookup tables
  for (Font *font : atlas->Fonts)
    if (font->DirtyLookupTables)
      font->BuildLookupTable();

  atlas->TexReady = true;
}

// Retrieve list of range (2 int per range, values are inclusive)

static void UnpackAccumulativeOffsetsIntoRanges(
    int base_codepoint, const short *accumulative_offsets,
    int accumulative_offsets_count, Wchar *out_ranges) {
  for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2) {
    out_ranges[0] = out_ranges[1] =
        (Wchar)(base_codepoint + accumulative_offsets[n]);
    base_codepoint += accumulative_offsets[n];
  }
  out_ranges[0] = 0;
}

//-------------------------------------------------------------------------
// [SECTION] FontAtlas glyph ranges helpers
//-------------------------------------------------------------------------

inline const Wchar *FontAtlas::GetGlyphRangesChineseSimplifiedCommon() {
  // Store 2500 regularly used characters for Simplified Chinese.
  // Sourced from
  // https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
  // This table covers 97.97% of all characters used during the month in July,
  // 1987. You can use FontGlyphRangesBuilder to create your own ranges
  // derived from this, by merging existing ranges or adding new characters.
  // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00.
  // This encoding is designed to helps us compact the source code size.)
  static const short accumulative_offsets_from_0x4E00[] = {
      0,  1,   2,   4,   1,  1,   1,   1,   2,  1,   3,   2,   1,   2,  2,   1,
      1,  1,   1,   1,   5,  2,   1,   2,   3,  3,   3,   2,   2,   4,  1,   1,
      1,  2,   1,   5,   2,  3,   1,   2,   1,  2,   1,   1,   2,   1,  1,   2,
      2,  1,   4,   1,   1,  1,   1,   5,   10, 1,   2,   19,  2,   1,  2,   1,
      2,  1,   2,   1,   2,  1,   5,   1,   6,  3,   2,   1,   2,   2,  1,   1,
      1,  4,   8,   5,   1,  1,   4,   1,   1,  3,   1,   2,   1,   5,  1,   2,
      1,  1,   1,   10,  1,  1,   5,   2,   4,  6,   1,   4,   2,   2,  2,   12,
      2,  1,   1,   6,   1,  1,   1,   4,   1,  1,   4,   6,   5,   1,  4,   2,
      2,  4,   10,  7,   1,  1,   4,   2,   4,  2,   1,   4,   3,   6,  10,  12,
      5,  7,   2,   14,  2,  9,   1,   1,   6,  7,   10,  4,   7,   13, 1,   5,
      4,  8,   4,   1,   1,  2,   28,  5,   6,  1,   1,   5,   2,   5,  20,  2,
      2,  9,   8,   11,  2,  9,   17,  1,   8,  6,   8,   27,  4,   6,  9,   20,
      11, 27,  6,   68,  2,  2,   1,   1,   1,  2,   1,   2,   2,   7,  6,   11,
      3,  3,   1,   1,   3,  1,   2,   1,   1,  1,   1,   1,   3,   1,  1,   8,
      3,  4,   1,   5,   7,  2,   1,   4,   4,  8,   4,   2,   1,   2,  1,   1,
      4,  5,   6,   3,   6,  2,   12,  3,   1,  3,   9,   2,   4,   3,  4,   1,
      5,  3,   3,   1,   3,  7,   1,   5,   1,  1,   1,   1,   2,   3,  4,   5,
      2,  3,   2,   6,   1,  1,   2,   1,   7,  1,   7,   3,   4,   5,  15,  2,
      2,  1,   5,   3,   22, 19,  2,   1,   1,  1,   1,   2,   5,   1,  1,   1,
      6,  1,   1,   12,  8,  2,   9,   18,  22, 4,   1,   1,   5,   1,  16,  1,
      2,  7,   10,  15,  1,  1,   6,   2,   4,  1,   2,   4,   1,   6,  1,   1,
      3,  2,   4,   1,   6,  4,   5,   1,   2,  1,   1,   2,   1,   10, 3,   1,
      3,  2,   1,   9,   3,  2,   5,   7,   2,  19,  4,   3,   6,   1,  1,   1,
      1,  1,   4,   3,   2,  1,   1,   1,   2,  5,   3,   1,   1,   1,  2,   2,
      1,  1,   2,   1,   1,  2,   1,   3,   1,  1,   1,   3,   7,   1,  4,   1,
      1,  2,   1,   1,   2,  1,   2,   4,   4,  3,   8,   1,   1,   1,  2,   1,
      3,  5,   1,   3,   1,  3,   4,   6,   2,  2,   14,  4,   6,   6,  11,  9,
      1,  15,  3,   1,   28, 5,   2,   5,   5,  3,   1,   3,   4,   5,  4,   6,
      14, 3,   2,   3,   5,  21,  2,   7,   20, 10,  1,   2,   19,  2,  4,   28,
      28, 2,   3,   2,   1,  14,  4,   1,   26, 28,  42,  12,  40,  3,  52,  79,
      5,  14,  17,  3,   2,  2,   11,  3,   4,  6,   3,   1,   8,   2,  23,  4,
      5,  8,   10,  4,   2,  7,   3,   5,   1,  1,   6,   3,   1,   2,  2,   2,
      5,  28,  1,   1,   7,  7,   20,  5,   3,  29,  3,   17,  26,  1,  8,   4,
      27, 3,   6,   11,  23, 5,   3,   4,   6,  13,  24,  16,  6,   5,  10,  25,
      35, 7,   3,   2,   3,  3,   14,  3,   6,  2,   6,   1,   4,   2,  3,   8,
      2,  1,   1,   3,   3,  3,   4,   1,   1,  13,  2,   2,   4,   5,  2,   1,
      14, 14,  1,   2,   2,  1,   4,   5,   2,  3,   1,   14,  3,   12, 3,   17,
      2,  16,  5,   1,   2,  1,   8,   9,   3,  19,  4,   2,   2,   4,  17,  25,
      21, 20,  28,  75,  1,  10,  29,  103, 4,  1,   2,   1,   1,   4,  2,   4,
      1,  2,   3,   24,  2,  2,   2,   1,   1,  2,   1,   3,   8,   1,  1,   1,
      2,  1,   1,   3,   1,  1,   1,   6,   1,  5,   3,   1,   1,   1,  3,   4,
      1,  1,   5,   2,   1,  5,   6,   13,  9,  16,  1,   1,   1,   1,  3,   2,
      3,  2,   4,   5,   2,  5,   2,   2,   3,  7,   13,  7,   2,   2,  1,   1,
      1,  1,   2,   3,   3,  2,   1,   6,   4,  9,   2,   1,   14,  2,  14,  2,
      1,  18,  3,   4,   14, 4,   11,  41,  15, 23,  15,  23,  176, 1,  3,   4,
      1,  1,   1,   1,   5,  3,   1,   2,   3,  7,   3,   1,   1,   2,  1,   2,
      4,  4,   6,   2,   4,  1,   9,   7,   1,  10,  5,   8,   16,  29, 1,   1,
      2,  2,   3,   1,   3,  5,   2,   4,   5,  4,   1,   1,   2,   2,  3,   3,
      7,  1,   6,   10,  1,  17,  1,   44,  4,  6,   2,   1,   1,   6,  5,   4,
      2,  10,  1,   6,   9,  2,   8,   1,   24, 1,   2,   13,  7,   8,  8,   2,
      1,  4,   1,   3,   1,  3,   3,   5,   2,  5,   10,  9,   4,   9,  12,  2,
      1,  6,   1,   10,  1,  1,   7,   7,   4,  10,  8,   3,   1,   13, 4,   3,
      1,  6,   1,   3,   5,  2,   1,   2,   17, 16,  5,   2,   16,  6,  1,   4,
      2,  1,   3,   3,   6,  8,   5,   11,  11, 1,   3,   3,   2,   4,  6,   10,
      9,  5,   7,   4,   7,  4,   7,   1,   1,  4,   2,   1,   3,   6,  8,   7,
      1,  6,   11,  5,   5,  3,   24,  9,   4,  2,   7,   13,  5,   1,  8,   82,
      16, 61,  1,   1,   1,  4,   2,   2,   16, 10,  3,   8,   1,   1,  6,   4,
      2,  1,   3,   1,   1,  1,   4,   3,   8,  4,   2,   2,   1,   1,  1,   1,
      1,  6,   3,   5,   1,  1,   4,   6,   9,  2,   1,   1,   1,   2,  1,   7,
      2,  1,   6,   1,   5,  4,   4,   3,   1,  8,   1,   3,   3,   1,  3,   2,
      2,  2,   2,   3,   1,  6,   1,   2,   1,  2,   1,   3,   7,   1,  8,   2,
      1,  2,   1,   5,   2,  5,   3,   5,   10, 1,   2,   1,   1,   3,  2,   5,
      11, 3,   9,   3,   5,  1,   1,   5,   9,  1,   2,   1,   5,   7,  9,   9,
      8,  1,   3,   3,   3,  6,   8,   2,   3,  2,   1,   1,   32,  6,  1,   2,
      15, 9,   3,   7,   13, 1,   3,   10,  13, 2,   14,  1,   13,  10, 2,   1,
      3,  10,  4,   15,  2,  15,  15,  10,  1,  3,   9,   6,   9,   32, 25,  26,
      47, 7,   3,   2,   3,  1,   6,   3,   4,  3,   2,   8,   5,   4,  1,   9,
      4,  2,   2,   19,  10, 6,   2,   3,   8,  1,   2,   2,   4,   2,  1,   9,
      4,  4,   4,   6,   4,  8,   9,   2,   3,  1,   1,   1,   1,   3,  5,   5,
      1,  3,   8,   4,   6,  2,   1,   4,   12, 1,   5,   3,   7,   13, 2,   5,
      8,  1,   6,   1,   2,  5,   14,  6,   1,  5,   2,   4,   8,   15, 5,   1,
      23, 6,   62,  2,   10, 1,   1,   8,   1,  2,   2,   10,  4,   2,  2,   9,
      2,  1,   1,   3,   2,  3,   1,   5,   3,  3,   2,   1,   3,   8,  1,   1,
      1,  11,  3,   1,   1,  4,   3,   7,   1,  14,  1,   2,   3,   12, 5,   2,
      5,  1,   6,   7,   5,  7,   14,  11,  1,  3,   1,   8,   9,   12, 2,   1,
      11, 8,   4,   4,   2,  6,   10,  9,   13, 1,   1,   3,   1,   5,  1,   3,
      2,  4,   4,   1,   18, 2,   3,   14,  11, 4,   29,  4,   2,   7,  1,   3,
      13, 9,   2,   2,   5,  3,   5,   20,  7,  16,  8,   5,   72,  34, 6,   4,
      22, 12,  12,  28,  45, 36,  9,   7,   39, 9,   191, 1,   1,   1,  4,   11,
      8,  4,   9,   2,   3,  22,  1,   1,   1,  1,   4,   17,  1,   7,  7,   1,
      11, 31,  10,  2,   4,  8,   2,   3,   2,  1,   4,   2,   16,  4,  32,  2,
      3,  19,  13,  4,   9,  1,   5,   2,   14, 8,   1,   1,   3,   6,  19,  6,
      5,  1,   16,  6,   2,  10,  8,   5,   1,  2,   3,   1,   5,   5,  1,   11,
      6,  6,   1,   3,   3,  2,   6,   3,   8,  1,   1,   4,   10,  7,  5,   7,
      7,  5,   8,   9,   2,  1,   3,   4,   1,  1,   3,   1,   3,   3,  2,   6,
      16, 1,   4,   6,   3,  1,   10,  6,   1,  3,   15,  2,   9,   2,  10,  25,
      13, 9,   16,  6,   2,  2,   10,  11,  4,  3,   9,   1,   2,   6,  6,   5,
      4,  30,  40,  1,   10, 7,   12,  14,  33, 6,   3,   6,   7,   3,  1,   3,
      1,  11,  14,  4,   9,  5,   12,  11,  49, 18,  51,  31,  140, 31, 2,   2,
      1,  5,   1,   8,   1,  10,  1,   4,   4,  3,   24,  1,   10,  1,  3,   6,
      6,  16,  3,   4,   5,  2,   1,   4,   2,  57,  10,  6,   22,  2,  22,  3,
      7,  22,  6,   10,  11, 36,  18,  16,  33, 36,  2,   5,   5,   1,  1,   1,
      4,  10,  1,   4,   13, 2,   7,   5,   2,  9,   3,   4,   1,   7,  43,  3,
      7,  3,   9,   14,  7,  9,   1,   11,  1,  1,   3,   7,   4,   18, 13,  1,
      14, 1,   3,   6,   10, 73,  2,   2,   30, 6,   1,   11,  18,  19, 13,  22,
      3,  46,  42,  37,  89, 7,   3,   16,  34, 2,   2,   3,   9,   1,  7,   1,
      1,  1,   2,   2,   4,  10,  7,   3,   10, 3,   9,   5,   28,  9,  2,   6,
      13, 7,   3,   1,   3,  10,  2,   7,   2,  11,  3,   6,   21,  54, 85,  2,
      1,  4,   2,   2,   1,  39,  3,   21,  2,  2,   5,   1,   1,   1,  4,   1,
      1,  3,   4,   15,  1,  3,   2,   4,   4,  2,   3,   8,   2,   20, 1,   8,
      7,  13,  4,   1,   26, 6,   2,   9,   34, 4,   21,  52,  10,  4,  4,   1,
      5,  12,  2,   11,  1,  7,   2,   30,  12, 44,  2,   30,  1,   1,  3,   6,
      16, 9,   17,  39,  82, 2,   2,   24,  7,  1,   7,   3,   16,  9,  14,  44,
      2,  1,   2,   1,   2,  3,   5,   2,   4,  1,   6,   7,   5,   3,  2,   6,
      1,  11,  5,   11,  2,  1,   18,  19,  8,  1,   3,   24,  29,  2,  1,   3,
      5,  2,   2,   1,   13, 6,   5,   1,   46, 11,  3,   5,   1,   1,  5,   8,
      2,  10,  6,   12,  6,  3,   7,   11,  2,  4,   16,  13,  2,   5,  1,   1,
      2,  2,   5,   2,   28, 5,   2,   23,  10, 8,   4,   4,   22,  39, 95,  38,
      8,  14,  9,   5,   1,  13,  5,   4,   3,  13,  12,  11,  1,   9,  1,   27,
      37, 2,   5,   4,   4,  63,  211, 95,  2,  2,   2,   1,   3,   5,  2,   1,
      1,  2,   2,   1,   1,  1,   3,   2,   4,  1,   2,   1,   1,   5,  2,   2,
      1,  1,   2,   3,   1,  3,   1,   1,   1,  3,   1,   4,   2,   1,  3,   6,
      1,  1,   3,   7,   15, 5,   3,   2,   5,  3,   9,   11,  4,   2,  22,  1,
      6,  3,   8,   7,   1,  4,   28,  4,   16, 3,   3,   25,  4,   4,  27,  27,
      1,  4,   1,   2,   2,  7,   1,   3,   5,  2,   28,  8,   2,   14, 1,   8,
      6,  16,  25,  3,   3,  3,   14,  3,   3,  1,   1,   2,   1,   4,  6,   3,
      8,  4,   1,   1,   1,  2,   3,   6,   10, 6,   2,   3,   18,  3,  2,   5,
      5,  4,   3,   1,   5,  2,   5,   4,   23, 7,   6,   12,  6,   4,  17,  11,
      9,  5,   1,   1,   10, 5,   12,  1,   1,  11,  26,  33,  7,   3,  6,   1,
      17, 7,   1,   5,   12, 1,   11,  2,   4,  1,   8,   14,  17,  23, 1,   2,
      1,  7,   8,   16,  11, 9,   6,   5,   2,  6,   4,   16,  2,   8,  14,  1,
      11, 8,   9,   1,   1,  1,   9,   25,  4,  11,  19,  7,   2,   15, 2,   12,
      8,  52,  7,   5,   19, 2,   16,  4,   36, 8,   1,   16,  8,   24, 26,  4,
      6,  2,   9,   5,   4,  36,  3,   28,  12, 25,  15,  37,  27,  17, 12,  59,
      38, 5,   32,  127, 1,  2,   9,   17,  14, 4,   1,   2,   1,   1,  8,   11,
      50, 4,   14,  2,   19, 16,  4,   17,  5,  4,   5,   26,  12,  45, 2,   23,
      45, 104, 30,  12,  8,  3,   10,  2,   2,  3,   3,   1,   4,   20, 7,   2,
      9,  6,   15,  2,   20, 1,   3,   16,  4,  11,  15,  6,   134, 2,  5,   59,
      1,  2,   2,   2,   1,  9,   17,  3,   26, 137, 10,  211, 59,  1,  2,   4,
      1,  4,   1,   1,   1,  2,   6,   2,   3,  1,   1,   2,   3,   2,  3,   1,
      3,  4,   4,   2,   3,  3,   1,   4,   3,  1,   7,   2,   2,   3,  1,   2,
      1,  3,   3,   3,   2,  2,   3,   2,   1,  3,   14,  6,   1,   3,  2,   9,
      6,  15,  27,  9,   34, 145, 1,   1,   2,  1,   1,   1,   1,   2,  1,   1,
      1,  1,   2,   2,   2,  3,   1,   2,   1,  1,   1,   2,   3,   5,  8,   3,
      5,  2,   4,   1,   3,  2,   2,   2,   12, 4,   1,   1,   1,   10, 4,   5,
      1,  20,  4,   16,  1,  15,  9,   5,   12, 2,   9,   2,   5,   4,  2,   26,
      19, 7,   1,   26,  4,  30,  12,  15,  42, 1,   6,   8,   172, 1,  1,   4,
      2,  1,   1,   11,  2,  2,   4,   2,   1,  2,   1,   10,  8,   1,  2,   1,
      4,  5,   1,   2,   5,  1,   8,   4,   1,  3,   4,   2,   1,   6,  2,   1,
      3,  4,   1,   2,   1,  1,   1,   1,   12, 5,   7,   2,   4,   3,  1,   1,
      1,  3,   3,   6,   1,  2,   2,   3,   3,  3,   2,   1,   2,   12, 14,  11,
      6,  6,   4,   12,  2,  8,   1,   7,   10, 1,   35,  7,   4,   13, 15,  4,
      3,  23,  21,  28,  52, 5,   26,  5,   6,  1,   7,   10,  2,   7,  53,  3,
      2,  1,   1,   1,   2,  163, 532, 1,   10, 11,  1,   3,   3,   4,  8,   2,
      8,  6,   2,   2,   23, 22,  4,   2,   2,  4,   2,   1,   3,   1,  3,   3,
      5,  9,   8,   2,   1,  2,   8,   1,   10, 2,   12,  21,  20,  15, 105, 2,
      3,  1,   1,   3,   2,  3,   1,   1,   2,  5,   1,   4,   15,  11, 19,  1,
      1,  1,   1,   5,   4,  5,   1,   1,   2,  5,   3,   5,   12,  1,  2,   5,
      1,  11,  1,   1,   15, 9,   1,   4,   5,  3,   26,  8,   2,   1,  3,   1,
      1,  15,  19,  2,   12, 1,   2,   5,   2,  7,   2,   19,  2,   20, 6,   26,
      7,  5,   2,   2,   7,  34,  21,  13,  70, 2,   128, 1,   1,   2,  1,   1,
      2,  1,   1,   3,   2,  2,   2,   15,  1,  4,   1,   3,   4,   42, 10,  6,
      1,  49,  85,  8,   1,  2,   1,   1,   4,  4,   2,   3,   6,   1,  5,   7,
      4,  3,   211, 4,   1,  2,   1,   2,   5,  1,   2,   4,   2,   2,  6,   5,
      6,  10,  3,   4,   48, 100, 6,   2,   16, 296, 5,   27,  387, 2,  2,   3,
      7,  16,  8,   5,   38, 15,  39,  21,  9,  10,  3,   7,   59,  13, 27,  21,
      47, 5,   21,  6};
  static Wchar base_ranges[] = // not zero-terminated
      {
          0x0020, 0x00FF, // Basic Latin + Latin Supplement
          0x2000, 0x206F, // General Punctuation
          0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
          0x31F0, 0x31FF, // Katakana Phonetic Extensions
          0xFF00, 0xFFEF, // Half-width characters
          0xFFFD, 0xFFFD  // Invalid
      };
  static Wchar full_ranges[GUI_ARRAYSIZE(base_ranges) +
                           GUI_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 +
                           1] = {0};
  if (!full_ranges[0]) {
    memcpy(full_ranges, base_ranges, sizeof(base_ranges));
    UnpackAccumulativeOffsetsIntoRanges(
        0x4E00, accumulative_offsets_from_0x4E00,
        GUI_ARRAYSIZE(accumulative_offsets_from_0x4E00),
        full_ranges + GUI_ARRAYSIZE(base_ranges));
  }
  return &full_ranges[0];
}

inline const Wchar *FontAtlas::GetGlyphRangesJapanese() {
  // 2999 ideograms code points for Japanese
  // - 2136 Joyo (meaning "for regular use" or "for common use") Kanji code
  // points
  // - 863 Jinmeiyo (meaning "for personal name") Kanji code points
  // - Sourced from official information provided by the government agencies of
  // Japan:
  //   - List of Joyo Kanji by the Agency for Cultural Affairs
  //     -
  //     https://www.bunka.go.jp/kokugo_nihongo/sisaku/joho/joho/kijun/naikaku/kanji/
  //   - List of Jinmeiyo Kanji by the Ministry of Justice
  //     - http://www.moj.go.jp/MINJI/minji86.html
  //   - Available under the terms of the Creative Commons Attribution 4.0
  //   International (CC BY 4.0).
  //     - https://creativecommons.org/licenses/by/4.0/legalcode
  // - You can generate this code by the script at:
  //   - https://github.com/vaiorabbit/everyday_use_kanji
  // - References:
  //   - List of Joyo Kanji
  //     - (Wikipedia)
  //     https://en.wikipedia.org/wiki/List_of_j%C5%8Dy%C5%8D_kanji
  //   - List of Jinmeiyo Kanji
  //     - (Wikipedia) https://en.wikipedia.org/wiki/Jinmeiy%C5%8D_kanji
  // - Missing 1 Joyo Kanji: U+20B9F (Kun'yomi: Shikaru, On'yomi:
  // Shitsu,shichi), see https://github.com/ocornut/imgui/pull/3627 for details.
  // You can use FontGlyphRangesBuilder to create your own ranges derived from
  // this, by merging existing ranges or adding new characters. (Stored as
  // accumulative offsets from the initial unicode codepoint 0x4E00. This
  // encoding is designed to helps us compact the source code size.)
  static const short accumulative_offsets_from_0x4E00[] = {
      0,  1,  2,   4,  1,  1,  1,  1,   2,  1,  3,   3,  2,  2,   1,     5,
      3,  5,  7,   5,  6,  1,  2,  1,   7,  2,  6,   3,  1,  8,   1,     1,
      4,  1,  1,   18, 2,  11, 2,  6,   2,  1,  2,   1,  5,  1,   2,     1,
      3,  1,  2,   1,  2,  3,  3,  1,   1,  2,  3,   1,  1,  1,   12,    7,
      9,  1,  4,   5,  1,  1,  2,  1,   10, 1,  1,   9,  2,  2,   4,     5,
      6,  9,  3,   1,  1,  1,  1,  9,   3,  18, 5,   2,  2,  2,   2,     1,
      6,  3,  7,   1,  1,  1,  1,  2,   2,  4,  2,   1,  23, 2,   10,    4,
      3,  5,  2,   4,  10, 2,  4,  13,  1,  6,  1,   9,  3,  1,   1,     6,
      6,  7,  6,   3,  1,  2,  11, 3,   2,  2,  3,   2,  15, 2,   2,     5,
      4,  3,  6,   4,  1,  2,  5,  2,   12, 16, 6,   13, 9,  13,  2,     1,
      1,  7,  16,  4,  7,  1,  19, 1,   5,  1,  2,   2,  7,  7,   8,     2,
      6,  5,  4,   9,  18, 7,  4,  5,   9,  13, 11,  8,  15, 2,   1,     1,
      1,  2,  1,   2,  2,  1,  2,  2,   8,  2,  9,   3,  3,  1,   1,     4,
      4,  1,  1,   1,  4,  9,  1,  4,   3,  5,  5,   2,  7,  5,   3,     4,
      8,  2,  1,   13, 2,  3,  3,  1,   14, 1,  1,   4,  5,  1,   3,     6,
      1,  5,  2,   1,  1,  3,  3,  3,   3,  1,  1,   2,  7,  6,   6,     7,
      1,  4,  7,   6,  1,  1,  1,  1,   1,  12, 3,   3,  9,  5,   2,     6,
      1,  5,  6,   1,  2,  3,  18, 2,   4,  14, 4,   1,  3,  6,   1,     1,
      6,  3,  5,   5,  3,  2,  2,  2,   2,  12, 3,   1,  4,  2,   3,     2,
      3,  11, 1,   7,  4,  1,  2,  1,   3,  17, 1,   9,  1,  24,  1,     1,
      4,  2,  2,   4,  1,  2,  7,  1,   1,  1,  3,   1,  2,  2,   4,     15,
      1,  1,  2,   1,  1,  2,  1,  5,   2,  5,  20,  2,  5,  9,   1,     10,
      8,  7,  6,   1,  1,  1,  1,  1,   1,  6,  2,   1,  2,  8,   1,     1,
      1,  1,  5,   1,  1,  3,  1,  1,   1,  1,  3,   1,  1,  12,  4,     1,
      3,  1,  1,   1,  1,  1,  10, 3,   1,  7,  5,   13, 1,  2,   3,     4,
      6,  1,  1,   30, 2,  9,  9,  1,   15, 38, 11,  3,  1,  8,   24,    7,
      1,  9,  8,   10, 2,  1,  9,  31,  2,  13, 6,   2,  9,  4,   49,    5,
      2,  15, 2,   1,  10, 2,  1,  1,   1,  2,  2,   6,  15, 30,  35,    3,
      14, 18, 8,   1,  16, 10, 28, 12,  19, 45, 38,  1,  3,  2,   3,     13,
      2,  1,  7,   3,  6,  5,  3,  4,   3,  1,  5,   7,  8,  1,   5,     3,
      18, 5,  3,   6,  1,  21, 4,  24,  9,  24, 40,  3,  14, 3,   21,    3,
      2,  1,  2,   4,  2,  3,  1,  15,  15, 6,  5,   1,  1,  3,   1,     5,
      6,  1,  9,   7,  3,  3,  2,  1,   4,  3,  8,   21, 5,  16,  4,     5,
      2,  10, 11,  11, 3,  6,  3,  2,   9,  3,  6,   13, 1,  2,   1,     1,
      1,  1,  11,  12, 6,  6,  1,  4,   2,  6,  5,   2,  1,  1,   3,     3,
      6,  13, 3,   1,  1,  5,  1,  2,   3,  3,  14,  2,  1,  2,   2,     2,
      5,  1,  9,   5,  1,  1,  6,  12,  3,  12, 3,   4,  13, 2,   14,    2,
      8,  1,  17,  5,  1,  16, 4,  2,   2,  21, 8,   9,  6,  23,  20,    12,
      25, 19, 9,   38, 8,  3,  21, 40,  25, 33, 13,  4,  3,  1,   4,     1,
      2,  4,  1,   2,  5,  26, 2,  1,   1,  2,  1,   3,  6,  2,   1,     1,
      1,  1,  1,   1,  2,  3,  1,  1,   1,  9,  2,   3,  1,  1,   1,     3,
      6,  3,  2,   1,  1,  6,  6,  1,   8,  2,  2,   2,  1,  4,   1,     2,
      3,  2,  7,   3,  2,  4,  1,  2,   1,  2,  2,   1,  1,  1,   1,     1,
      3,  1,  2,   5,  4,  10, 9,  4,   9,  1,  1,   1,  1,  1,   1,     5,
      3,  2,  1,   6,  4,  9,  6,  1,   10, 2,  31,  17, 8,  3,   7,     5,
      40, 1,  7,   7,  1,  6,  5,  2,   10, 7,  8,   4,  15, 39,  25,    6,
      28, 47, 18,  10, 7,  1,  3,  1,   1,  2,  1,   1,  1,  3,   3,     3,
      1,  1,  1,   3,  4,  2,  1,  4,   1,  3,  6,   10, 7,  8,   6,     2,
      2,  1,  3,   3,  2,  5,  8,  7,   9,  12, 2,   15, 1,  1,   4,     1,
      2,  1,  1,   1,  3,  2,  1,  3,   3,  5,  6,   2,  3,  2,   10,    1,
      4,  2,  8,   1,  1,  1,  11, 6,   1,  21, 4,   16, 3,  1,   3,     1,
      4,  2,  3,   6,  5,  1,  3,  1,   1,  3,  3,   4,  6,  1,   1,     10,
      4,  2,  7,   10, 4,  7,  4,  2,   9,  4,  3,   1,  1,  1,   4,     1,
      8,  3,  4,   1,  3,  1,  6,  1,   4,  2,  1,   4,  7,  2,   1,     8,
      1,  4,  5,   1,  1,  2,  2,  4,   6,  2,  7,   1,  10, 1,   1,     3,
      4,  11, 10,  8,  21, 4,  6,  1,   3,  5,  2,   1,  2,  28,  5,     5,
      2,  3,  13,  1,  2,  3,  1,  4,   2,  1,  5,   20, 3,  8,   11,    1,
      3,  3,  3,   1,  8,  10, 9,  2,   10, 9,  2,   3,  1,  1,   2,     4,
      1,  8,  3,   6,  1,  7,  8,  6,   11, 1,  4,   29, 8,  4,   3,     1,
      2,  7,  13,  1,  4,  1,  6,  2,   6,  12, 12,  2,  20, 3,   2,     3,
      6,  4,  8,   9,  2,  7,  34, 5,   1,  18, 6,   1,  1,  4,   4,     5,
      7,  9,  1,   2,  2,  4,  3,  4,   1,  7,  2,   2,  2,  6,   2,     3,
      25, 5,  3,   6,  1,  4,  6,  7,   4,  2,  1,   4,  2,  13,  6,     4,
      4,  3,  1,   5,  3,  4,  4,  3,   2,  1,  1,   4,  1,  2,   1,     1,
      3,  1,  11,  1,  6,  3,  1,  7,   3,  6,  2,   8,  8,  6,   9,     3,
      4,  11, 3,   2,  10, 12, 2,  5,   11, 1,  6,   4,  5,  3,   1,     8,
      5,  4,  6,   6,  3,  5,  1,  1,   3,  2,  1,   2,  2,  6,   17,    12,
      1,  10, 1,   6,  12, 1,  6,  6,   19, 9,  6,   16, 1,  13,  4,     4,
      15, 7,  17,  6,  11, 9,  15, 12,  6,  7,  2,   1,  2,  2,   15,    9,
      3,  21, 4,   6,  49, 18, 7,  3,   2,  3,  1,   6,  8,  2,   2,     6,
      2,  9,  1,   3,  6,  4,  4,  1,   2,  16, 2,   5,  2,  1,   6,     2,
      3,  5,  3,   1,  2,  5,  1,  2,   1,  9,  3,   1,  8,  6,   4,     8,
      11, 3,  1,   1,  1,  1,  3,  1,   13, 8,  4,   1,  3,  2,   2,     1,
      4,  1,  11,  1,  5,  2,  1,  5,   2,  5,  8,   6,  1,  1,   7,     4,
      3,  8,  3,   2,  7,  2,  1,  5,   1,  5,  2,   4,  7,  6,   2,     8,
      5,  1,  11,  4,  5,  3,  6,  18,  1,  2,  13,  3,  3,  1,   21,    1,
      1,  4,  1,   4,  1,  1,  1,  8,   1,  2,  2,   7,  1,  2,   4,     2,
      2,  9,  2,   1,  1,  1,  4,  3,   6,  3,  12,  5,  1,  1,   1,     5,
      6,  3,  2,   4,  8,  2,  2,  4,   2,  7,  1,   8,  9,  5,   2,     3,
      2,  1,  3,   2,  13, 7,  14, 6,   5,  1,  1,   2,  1,  4,   2,     23,
      2,  1,  1,   6,  3,  1,  4,  1,   15, 3,  1,   7,  3,  9,   14,    1,
      3,  1,  4,   1,  1,  5,  8,  1,   3,  8,  3,   8,  15, 11,  4,     14,
      4,  4,  2,   5,  5,  1,  7,  1,   6,  14, 7,   7,  8,  5,   15,    4,
      8,  6,  5,   6,  2,  1,  13, 1,   20, 15, 11,  9,  2,  5,   6,     2,
      11, 2,  6,   2,  5,  1,  5,  8,   4,  13, 19,  25, 4,  1,   1,     11,
      1,  34, 2,   5,  9,  14, 6,  2,   2,  6,  1,   1,  14, 1,   3,     14,
      13, 1,  6,   12, 21, 14, 14, 6,   32, 17, 8,   32, 9,  28,  1,     2,
      4,  11, 8,   3,  1,  14, 2,  5,   15, 1,  1,   1,  1,  3,   6,     4,
      1,  3,  4,   11, 3,  1,  1,  11,  30, 1,  5,   1,  4,  1,   5,     8,
      1,  1,  3,   2,  4,  3,  17, 35,  2,  6,  12,  17, 3,  1,   6,     2,
      1,  1,  12,  2,  7,  3,  3,  2,   1,  16, 2,   8,  3,  6,   5,     4,
      7,  3,  3,   8,  1,  9,  8,  5,   1,  2,  1,   3,  2,  8,   1,     2,
      9,  12, 1,   1,  2,  3,  8,  3,   24, 12, 4,   3,  7,  5,   8,     3,
      3,  3,  3,   3,  3,  1,  23, 10,  3,  1,  2,   2,  6,  3,   1,     16,
      1,  16, 22,  3,  10, 4,  11, 6,   9,  7,  7,   3,  6,  2,   2,     2,
      4,  10, 2,   1,  1,  2,  8,  7,   1,  6,  4,   1,  3,  3,   3,     5,
      10, 12, 12,  2,  3,  12, 8,  15,  1,  1,  16,  6,  6,  1,   5,     9,
      11, 4,  11,  4,  2,  6,  12, 1,   17, 5,  13,  1,  4,  9,   5,     1,
      11, 2,  1,   8,  1,  5,  7,  28,  8,  3,  5,   10, 2,  17,  3,     38,
      22, 1,  2,   18, 12, 10, 4,  38,  18, 1,  4,   44, 19, 4,   1,     8,
      4,  1,  12,  1,  4,  31, 12, 1,   14, 7,  75,  7,  5,  10,  6,     6,
      13, 3,  2,   11, 11, 3,  2,  5,   28, 15, 6,   18, 18, 5,   6,     4,
      3,  16, 1,   7,  18, 7,  36, 3,   5,  3,  1,   7,  1,  9,   1,     10,
      7,  2,  4,   2,  6,  2,  9,  7,   4,  3,  32,  12, 3,  7,   10,    2,
      23, 16, 3,   1,  12, 3,  31, 4,   11, 1,  3,   8,  9,  5,   1,     30,
      15, 6,  12,  3,  2,  2,  11, 19,  9,  14, 2,   6,  2,  3,   19,    13,
      17, 5,  3,   3,  25, 3,  14, 1,   1,  1,  36,  1,  3,  2,   19,    3,
      13, 36, 9,   13, 31, 6,  4,  16,  34, 2,  5,   4,  2,  3,   3,     5,
      1,  1,  1,   4,  3,  1,  17, 3,   2,  3,  5,   3,  1,  3,   2,     3,
      5,  6,  3,   12, 11, 1,  3,  1,   2,  26, 7,   12, 7,  2,   14,    3,
      3,  7,  7,   11, 25, 25, 28, 16,  4,  36, 1,   2,  1,  6,   2,     1,
      9,  3,  27,  17, 4,  3,  4,  13,  4,  1,  3,   2,  2,  1,   10,    4,
      2,  4,  6,   3,  8,  2,  1,  18,  1,  1,  24,  2,  2,  4,   33,    2,
      3,  63, 7,   1,  6,  40, 7,  3,   4,  4,  2,   4,  15, 18,  1,     16,
      1,  1,  11,  2,  41, 14, 1,  3,   18, 13, 3,   2,  4,  16,  2,     17,
      7,  15, 24,  7,  18, 13, 44, 2,   2,  3,  6,   1,  1,  7,   5,     1,
      7,  1,  4,   3,  3,  5,  10, 8,   2,  3,  1,   8,  1,  1,   27,    4,
      2,  1,  12,  1,  2,  1,  10, 6,   1,  6,  7,   5,  2,  3,   7,     11,
      5,  11, 3,   6,  6,  2,  3,  15,  4,  9,  1,   1,  2,  1,   2,     11,
      2,  8,  12,  8,  5,  4,  2,  3,   1,  5,  2,   2,  1,  14,  1,     12,
      11, 4,  1,   11, 17, 17, 4,  3,   2,  5,  5,   7,  3,  1,   5,     9,
      9,  8,  2,   5,  6,  6,  13, 13,  2,  1,  2,   6,  1,  2,   2,     49,
      4,  9,  1,   2,  10, 16, 7,  8,   4,  3,  2,   23, 4,  58,  3,     29,
      1,  14, 19,  19, 11, 11, 2,  7,   5,  1,  3,   4,  6,  2,   18,    5,
      12, 12, 17,  17, 3,  3,  2,  4,   1,  6,  2,   3,  4,  3,   1,     1,
      1,  1,  5,   1,  1,  9,  1,  3,   1,  3,  6,   1,  8,  1,   1,     2,
      6,  4,  14,  3,  1,  4,  11, 4,   1,  3,  32,  1,  2,  4,   13,    4,
      1,  2,  4,   2,  1,  3,  1,  11,  1,  4,  2,   1,  4,  4,   6,     3,
      5,  1,  6,   5,  7,  6,  3,  23,  3,  5,  3,   5,  3,  3,   13,    3,
      9,  10, 1,   12, 10, 2,  3,  18,  13, 7,  160, 52, 4,  2,   2,     3,
      2,  14, 5,   4,  12, 4,  6,  4,   1,  20, 4,   11, 6,  2,   12,    27,
      1,  4,  1,   2,  2,  7,  4,  5,   2,  28, 3,   7,  25, 8,   3,     19,
      3,  6,  10,  2,  2,  1,  10, 2,   5,  4,  1,   3,  4,  1,   5,     3,
      2,  6,  9,   3,  6,  2,  16, 3,   3,  16, 4,   5,  5,  3,   2,     1,
      2,  16, 15,  8,  2,  6,  21, 2,   4,  1,  22,  5,  8,  1,   1,     21,
      11, 2,  1,   11, 11, 19, 13, 12,  4,  2,  3,   2,  3,  6,   1,     8,
      11, 1,  4,   2,  9,  5,  2,  1,   11, 2,  9,   1,  1,  2,   14,    31,
      9,  3,  4,   21, 14, 4,  8,  1,   7,  2,  2,   2,  5,  1,   4,     20,
      3,  3,  4,   10, 1,  11, 9,  8,   2,  1,  4,   5,  14, 12,  14,    2,
      17, 9,  6,   31, 4,  14, 1,  20,  13, 26, 5,   2,  7,  3,   6,     13,
      2,  4,  2,   19, 6,  2,  2,  18,  9,  3,  5,   12, 12, 14,  4,     6,
      2,  3,  6,   9,  5,  22, 4,  5,   25, 6,  4,   8,  5,  2,   6,     27,
      2,  35, 2,   16, 3,  7,  8,  8,   6,  6,  5,   9,  17, 2,   20,    6,
      19, 2,  13,  3,  1,  1,  1,  4,   17, 12, 2,   14, 7,  1,   4,     18,
      12, 38, 33,  2,  10, 1,  1,  2,   13, 14, 17,  11, 50, 6,   33,    20,
      26, 74, 16,  23, 45, 50, 13, 38,  33, 6,  6,   7,  4,  4,   2,     1,
      3,  2,  5,   8,  7,  8,  9,  3,   11, 21, 9,   13, 1,  3,   10,    6,
      7,  1,  2,   2,  18, 5,  5,  1,   9,  9,  2,   68, 9,  19,  13,    2,
      5,  1,  4,   4,  7,  4,  13, 3,   9,  10, 21,  17, 3,  26,  2,     1,
      5,  2,  4,   5,  4,  1,  7,  4,   7,  3,  4,   2,  1,  6,   1,     1,
      20, 4,  1,   9,  2,  2,  1,  3,   3,  2,  3,   2,  1,  1,   1,     20,
      2,  3,  1,   6,  2,  3,  6,  2,   4,  8,  1,   3,  2,  10,  3,     5,
      3,  4,  4,   3,  4,  16, 1,  6,   1,  10, 2,   4,  2,  1,   1,     2,
      10, 11, 2,   2,  3,  1,  24, 31,  4,  10, 10,  2,  5,  12,  16,    164,
      15, 4,  16,  7,  9,  15, 19, 17,  1,  2,  1,   1,  5,  1,   1,     1,
      1,  1,  3,   1,  4,  3,  1,  3,   1,  3,  1,   2,  1,  1,   3,     3,
      7,  2,  8,   1,  2,  2,  2,  1,   3,  4,  3,   7,  8,  12,  92,    2,
      10, 3,  1,   3,  14, 5,  25, 16,  42, 4,  7,   7,  4,  2,   21,    5,
      27, 26, 27,  21, 25, 30, 31, 2,   1,  5,  13,  3,  22, 5,   6,     6,
      11, 9,  12,  1,  5,  9,  7,  5,   5,  22, 60,  3,  5,  13,  1,     1,
      8,  1,  1,   3,  3,  2,  1,  9,   3,  3,  18,  4,  1,  2,   3,     7,
      6,  3,  1,   2,  3,  9,  1,  3,   1,  3,  2,   1,  3,  1,   1,     1,
      2,  1,  11,  3,  1,  6,  9,  1,   3,  2,  3,   1,  2,  1,   5,     1,
      1,  4,  3,   4,  1,  2,  2,  4,   4,  1,  7,   2,  1,  2,   2,     3,
      5,  13, 18,  3,  4,  14, 9,  9,   4,  16, 3,   7,  5,  8,   2,     6,
      48, 28, 3,   1,  1,  4,  2,  14,  8,  2,  9,   2,  1,  15,  2,     4,
      3,  2,  10,  16, 12, 8,  7,  1,   1,  3,  1,   1,  1,  2,   7,     4,
      1,  6,  4,   38, 39, 16, 23, 7,   15, 15, 3,   2,  12, 7,   21,    37,
      27, 6,  5,   4,  8,  2,  10, 8,   8,  6,  5,   1,  2,  1,   3,     24,
      1,  16, 17,  9,  23, 10, 17, 6,   1,  51, 55,  44, 13, 294, 9,     3,
      6,  2,  4,   2,  2,  15, 1,  1,   1,  13, 21,  17, 68, 14,  8,     9,
      4,  1,  4,   9,  3,  11, 7,  1,   1,  1,  5,   6,  3,  2,   1,     1,
      1,  2,  3,   8,  1,  2,  2,  4,   1,  5,  5,   2,  1,  4,   3,     7,
      13, 4,  1,   4,  1,  3,  1,  1,   1,  5,  5,   10, 1,  6,   1,     5,
      2,  1,  5,   2,  4,  1,  4,  5,   7,  3,  18,  2,  9,  11,  32,    4,
      3,  3,  2,   4,  7,  11, 16, 9,   11, 8,  13,  38, 32, 8,   4,     2,
      1,  1,  2,   1,  2,  4,  4,  1,   1,  1,  4,   1,  21, 3,   11,    1,
      16, 1,  1,   6,  1,  3,  2,  4,   9,  8,  57,  7,  44, 1,   3,     3,
      13, 3,  10,  1,  1,  7,  5,  2,   7,  21, 47,  63, 3,  15,  4,     7,
      1,  16, 1,   1,  2,  8,  2,  3,   42, 15, 4,   1,  29, 7,   22,    10,
      3,  78, 16,  12, 20, 18, 4,  67,  11, 5,  1,   3,  15, 6,   21,    31,
      32, 27, 18,  13, 71, 35, 5,  142, 4,  10, 1,   2,  50, 19,  33,    16,
      35, 37, 16,  19, 27, 7,  1,  133, 19, 1,  4,   8,  7,  20,  1,     4,
      4,  1,  10,  3,  1,  6,  1,  2,   51, 5,  40,  15, 24, 43,  22928, 11,
      1,  13, 154, 70, 3,  1,  1,  7,   4,  10, 1,   2,  1,  1,   2,     1,
      2,  1,  2,   2,  1,  1,  2,  1,   1,  1,  1,   1,  2,  1,   1,     1,
      1,  1,  1,   1,  1,  1,  1,  1,   1,  1,  2,   1,  1,  1,   3,     2,
      1,  1,  1,   1,  2,  1,  1,
  };
  static Wchar base_ranges[] = // not zero-terminated
      {
          0x0020, 0x00FF, // Basic Latin + Latin Supplement
          0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
          0x31F0, 0x31FF, // Katakana Phonetic Extensions
          0xFF00, 0xFFEF, // Half-width characters
          0xFFFD, 0xFFFD  // Invalid
      };
  static Wchar full_ranges[GUI_ARRAYSIZE(base_ranges) +
                           GUI_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 +
                           1] = {0};
  if (!full_ranges[0]) {
    memcpy(full_ranges, base_ranges, sizeof(base_ranges));
    UnpackAccumulativeOffsetsIntoRanges(
        0x4E00, accumulative_offsets_from_0x4E00,
        GUI_ARRAYSIZE(accumulative_offsets_from_0x4E00),
        full_ranges + GUI_ARRAYSIZE(base_ranges));
  }
  return &full_ranges[0];
}

//-----------------------------------------------------------------------------
// [SECTION] FontGlyphRangesBuilder
//-----------------------------------------------------------------------------

inline void FontGlyphRangesBuilder::AddText(const char *text,
                                            const char *text_end) {
  while (text_end ? (text < text_end) : *text) {
    unsigned int c = 0;
    int c_len = TextCharFromUtf8(&c, text, text_end);
    text += c_len;
    if (c_len == 0)
      break;
    AddChar((Wchar)c);
  }
}

//-----------------------------------------------------------------------------
// [SECTION] Font
//-----------------------------------------------------------------------------

inline Font::Font() {
  FontSize = 0.0f;
  FallbackAdvanceX = 0.0f;
  FallbackChar = (Wchar)-1;
  EllipsisChar = (Wchar)-1;
  EllipsisWidth = EllipsisCharStep = 0.0f;
  EllipsisCharCount = 0;
  FallbackGlyph = NULL;
  ContainerAtlas = NULL;
  ConfigData = NULL;
  ConfigDataCount = 0;
  DirtyLookupTables = false;
  Scale = 1.0f;
  Ascent = Descent = 0.0f;
  MetricsTotalSurface = 0;
  memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
}

static Wchar FindFirstExistingGlyph(Font *font, const Wchar *candidate_chars,
                                    int candidate_chars_count) {
  for (int n = 0; n < candidate_chars_count; n++)
    if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)
      return candidate_chars[n];
  return (Wchar)-1;
}

inline void Font::BuildLookupTable() {
  int max_codepoint = 0;
  for (int i = 0; i != Glyphs.Size; i++)
    max_codepoint = Max(max_codepoint, (int)Glyphs[i].Codepoint);

  // Build lookup table
  GUI_ASSERT(Glyphs.Size > 0 && "Font has not loaded glyph!");
  GUI_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
  IndexAdvanceX.clear();
  IndexLookup.clear();
  DirtyLookupTables = false;
  memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
  GrowIndex(max_codepoint + 1);
  for (int i = 0; i < Glyphs.Size; i++) {
    int codepoint = (int)Glyphs[i].Codepoint;
    IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
    IndexLookup[codepoint] = (Wchar)i;

    // Mark 4K page as used
    const int page_n = codepoint / 4096;
    Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);
  }

  // Create a glyph to handle TAB
  // FIXME: Needs proper TAB handling but it needs to be contextualized (or we
  // could arbitrary say that each string starts at "column 0" ?)
  if (FindGlyph((Wchar)' ')) {
    if (Glyphs.back().Codepoint !=
        '\t') // So we can call this function multiple times (FIXME: Flaky)
      Glyphs.resize(Glyphs.Size + 1);
    FontGlyph &tab_glyph = Glyphs.back();
    tab_glyph = *FindGlyph((Wchar)' ');
    tab_glyph.Codepoint = '\t';
    tab_glyph.AdvanceX *= GUI_TABSIZE;
    IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
    IndexLookup[(int)tab_glyph.Codepoint] = (Wchar)(Glyphs.Size - 1);
  }

  // Mark special glyphs as not visible (note that AddGlyph already mark as
  // non-visible glyphs with zero-size polygons)
  SetGlyphVisible((Wchar)' ', false);
  SetGlyphVisible((Wchar)'\t', false);

  // Setup Fallback character
  const Wchar fallback_chars[] = {(Wchar)GUI_UNICODE_CODEPOINT_INVALID,
                                  (Wchar)'?', (Wchar)' '};
  FallbackGlyph = FindGlyphNoFallback(FallbackChar);
  if (FallbackGlyph == NULL) {
    FallbackChar = FindFirstExistingGlyph(this, fallback_chars,
                                          GUI_ARRAYSIZE(fallback_chars));
    FallbackGlyph = FindGlyphNoFallback(FallbackChar);
    if (FallbackGlyph == NULL) {
      FallbackGlyph = &Glyphs.back();
      FallbackChar = (Wchar)FallbackGlyph->Codepoint;
    }
  }
  FallbackAdvanceX = FallbackGlyph->AdvanceX;
  for (int i = 0; i < max_codepoint + 1; i++)
    if (IndexAdvanceX[i] < 0.0f)
      IndexAdvanceX[i] = FallbackAdvanceX;

  // Setup Ellipsis character. It is required for rendering elided text. We
  // prefer using U+2026 (horizontal ellipsis). However some old fonts may
  // contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis
  // character.
  // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of
  // this we are more likely to use three individual dots.
  const Wchar ellipsis_chars[] = {(Wchar)0x2026, (Wchar)0x0085};
  const Wchar dots_chars[] = {(Wchar)'.', (Wchar)0xFF0E};
  if (EllipsisChar == (Wchar)-1)
    EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars,
                                          GUI_ARRAYSIZE(ellipsis_chars));
  const Wchar dot_char =
      FindFirstExistingGlyph(this, dots_chars, GUI_ARRAYSIZE(dots_chars));
  if (EllipsisChar != (Wchar)-1) {
    EllipsisCharCount = 1;
    EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;
  } else if (dot_char != (Wchar)-1) {
    const FontGlyph *glyph = FindGlyph(dot_char);
    EllipsisChar = dot_char;
    EllipsisCharCount = 3;
    EllipsisCharStep = (glyph->X1 - glyph->X0) + 1.0f;
    EllipsisWidth = EllipsisCharStep * 3.0f - 1.0f;
  }
}

// API is designed this way to avoid exposing the 4K page size
// e.g. use with IsGlyphRangeUnused(0, 255)

inline void Font::GrowIndex(int new_size) {
  GUI_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
  if (new_size <= IndexLookup.Size)
    return;
  IndexAdvanceX.resize(new_size, -1.0f);
  IndexLookup.resize(new_size, (Wchar)-1);
}

// x0/y0/x1/y1 are offset from the character upper-left layout position, in
// pixels. Therefore x0/y0 are often fairly close to zero. Not to be mistaken
// with texture coordinates, which are held by u0/v0/u1/v1 in normalized format
// (0.0..1.0 on each texture axis). 'cfg' is not necessarily ==
// 'this->ConfigData' because multiple source fonts+configs can be used to build
// one target font.
inline void Font::AddGlyph(const FontConfig *cfg, Wchar codepoint, float x0,
                           float y0, float x1, float y1, float u0, float v0,
                           float u1, float v1, float advance_x) {
  if (cfg != NULL) {
    // Clamp & recenter if needed
    const float advance_x_original = advance_x;
    advance_x = Clamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);
    if (advance_x != advance_x_original) {
      float char_off_x = cfg->PixelSnapH
                             ? Trunc((advance_x - advance_x_original) * 0.5f)
                             : (advance_x - advance_x_original) * 0.5f;
      x0 += char_off_x;
      x1 += char_off_x;
    }

    // Snap to pixel
    if (cfg->PixelSnapH)
      advance_x = GUI_ROUND(advance_x);

    // Bake spacing
    advance_x += cfg->GlyphExtraSpacing.x;
  }

  Glyphs.resize(Glyphs.Size + 1);
  FontGlyph &glyph = Glyphs.back();
  glyph.Codepoint = (unsigned int)codepoint;
  glyph.Visible = (x0 != x1) && (y0 != y1);
  glyph.Colored = false;
  glyph.X0 = x0;
  glyph.Y0 = y0;
  glyph.X1 = x1;
  glyph.Y1 = y1;
  glyph.U0 = u0;
  glyph.V0 = v0;
  glyph.U1 = u1;
  glyph.V1 = v1;
  glyph.AdvanceX = advance_x;

  // Compute rough surface usage metrics (+1 to account for average padding,
  // +0.99 to round) We use (U1-U0)*TexWidth instead of X1-X0 to account for
  // oversampling.
  float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
  DirtyLookupTables = true;
  MetricsTotalSurface +=
      (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) *
      (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
}

inline void Font::AddRemapChar(Wchar dst, Wchar src, bool overwrite_dst) {
  GUI_ASSERT(
      IndexLookup.Size >
      0); // Currently this can only be called AFTER the font has been built,
          // aka after calling FontAtlas::GetTexDataAs*() function.
  unsigned int index_size = (unsigned int)IndexLookup.Size;

  if (dst < index_size && IndexLookup.Data[dst] == (Wchar)-1 &&
      !overwrite_dst) // 'dst' already exists
    return;
  if (src >= index_size &&
      dst >= index_size) // both 'dst' and 'src' don't exist -> no-op
    return;

  GrowIndex(dst + 1);
  IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (Wchar)-1;
  IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;
}

inline const FontGlyph *Font::FindGlyph(Wchar c) const {
  if (c >= (size_t)IndexLookup.Size)
    return FallbackGlyph;
  const Wchar i = IndexLookup.Data[c];
  if (i == (Wchar)-1)
    return FallbackGlyph;
  return &Glyphs.Data[i];
}

inline const FontGlyph *Font::FindGlyphNoFallback(Wchar c) const {
  if (c >= (size_t)IndexLookup.Size)
    return NULL;
  const Wchar i = IndexLookup.Data[c];
  if (i == (Wchar)-1)
    return NULL;
  return &Glyphs.Data[i];
}

// Wrapping skips upcoming blanks
static inline const char *CalcWordWrapNextLineStartA(const char *text,
                                                     const char *text_end) {
  while (text < text_end && CharIsBlankA(*text))
    text++;
  if (*text == '\n')
    text++;
  return text;
}

// Simple word-wrapping for English, not full-featured. Please submit failing
// cases! This will return the next location to wrap from. If no wrapping if
// necessary, this will fast-forward to e.g. text_end.
// FIXME: Much possible improvements (don't cut things like "word !", "word!!!"
// but cut within "word,,,,", more sensible support for punctuations, support
// for Unicode punctuations, etc.)
inline const char *Font::CalcWordWrapPositionA(float scale, const char *text,
                                               const char *text_end,
                                               float wrap_width) const {
  // For references, possible wrap point marked with ^
  //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
  //      ^    ^    ^   ^   ^__    ^    ^

  // List of hardcoded separators: .,;!?'"

  // Skip extra blanks after a line returns (that includes not counting them in
  // width computation) e.g. "Hello    world" --> "Hello" "World"

  // Cut words that cannot possibly fit within one line.
  // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr"
  // "opical" "fish"
  float line_width = 0.0f;
  float word_width = 0.0f;
  float blank_width = 0.0f;
  wrap_width /=
      scale; // We work with unscaled widths to avoid scaling every characters

  const char *word_end = text;
  const char *prev_word_end = NULL;
  bool inside_word = true;

  const char *s = text;
  GUI_ASSERT(text_end != NULL);
  while (s < text_end) {
    unsigned int c = (unsigned int)*s;
    const char *next_s;
    if (c < 0x80)
      next_s = s + 1;
    else
      next_s = s + TextCharFromUtf8(&c, s, text_end);

    if (c < 32) {
      if (c == '\n') {
        line_width = word_width = blank_width = 0.0f;
        inside_word = true;
        s = next_s;
        continue;
      }
      if (c == '\r') {
        s = next_s;
        continue;
      }
    }

    const float char_width =
        ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c]
                                     : FallbackAdvanceX);
    if (CharIsBlankW(c)) {
      if (inside_word) {
        line_width += blank_width;
        blank_width = 0.0f;
        word_end = s;
      }
      blank_width += char_width;
      inside_word = false;
    } else {
      word_width += char_width;
      if (inside_word) {
        word_end = next_s;
      } else {
        prev_word_end = word_end;
        line_width += word_width + blank_width;
        word_width = blank_width = 0.0f;
      }

      // Allow wrapping after punctuation.
      inside_word = (c != '.' && c != ',' && c != ';' && c != '!' && c != '?' &&
                     c != '\"');
    }

    // We ignore blank width at the end of the line (they can be skipped)
    if (line_width + word_width > wrap_width) {
      // Words that cannot possibly fit within an entire line will be cut
      // anywhere.
      if (word_width < wrap_width)
        s = prev_word_end ? prev_word_end : word_end;
      break;
    }

    s = next_s;
  }

  // Wrap_width is too small to fit anything. Force displaying 1 character to
  // minimize the height discontinuity. +1 may not be a character start point in
  // UTF-8 but it's ok because caller loops use (text >= word_wrap_eol).
  if (s == text && text < text_end)
    return s + 1;
  return s;
}

inline Vec2 Font::CalcTextSizeA(float size, float max_width, float wrap_width,
                                const char *text_begin, const char *text_end,
                                const char **remaining) const {
  if (!text_end)
    text_end =
        text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

  const float line_height = size;
  const float scale = size / FontSize;

  Vec2 text_size = Vec2(0, 0);
  float line_width = 0.0f;

  const bool word_wrap_enabled = (wrap_width > 0.0f);
  const char *word_wrap_eol = NULL;

  const char *s = text_begin;
  while (s < text_end) {
    if (word_wrap_enabled) {
      // Calculate how far we can render. Requires two passes on the string data
      // but keeps the code simple and not intrusive for what's essentially an
      // uncommon feature.
      if (!word_wrap_eol)
        word_wrap_eol =
            CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);

      if (s >= word_wrap_eol) {
        if (text_size.x < line_width)
          text_size.x = line_width;
        text_size.y += line_height;
        line_width = 0.0f;
        word_wrap_eol = NULL;
        s = CalcWordWrapNextLineStartA(
            s, text_end); // Wrapping skips upcoming blanks
        continue;
      }
    }

    // Decode and advance source
    const char *prev_s = s;
    unsigned int c = (unsigned int)*s;
    if (c < 0x80)
      s += 1;
    else
      s += TextCharFromUtf8(&c, s, text_end);

    if (c < 32) {
      if (c == '\n') {
        text_size.x = Max(text_size.x, line_width);
        text_size.y += line_height;
        line_width = 0.0f;
        continue;
      }
      if (c == '\r')
        continue;
    }

    const float char_width =
        ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c]
                                     : FallbackAdvanceX) *
        scale;
    if (line_width + char_width >= max_width) {
      s = prev_s;
      break;
    }

    line_width += char_width;
  }

  if (text_size.x < line_width)
    text_size.x = line_width;

  if (line_width > 0 || text_size.y == 0.0f)
    text_size.y += line_height;

  if (remaining)
    *remaining = s;

  return text_size;
}

// Note: as with every DrawList drawing function, this expects that the font
// atlas texture is bound.
inline void Font::RenderChar(DrawList *draw_list, float size, const Vec2 &pos,
                             U32 col, Wchar c) const {
  const FontGlyph *glyph = FindGlyph(c);
  if (!glyph || !glyph->Visible)
    return;
  if (glyph->Colored)
    col |= ~GUI_COL32_A_MASK;
  float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;
  float x = GUI_TRUNC(pos.x);
  float y = GUI_TRUNC(pos.y);
  draw_list->PrimReserve(6, 4);
  draw_list->PrimRectUV(Vec2(x + glyph->X0 * scale, y + glyph->Y0 * scale),
                        Vec2(x + glyph->X1 * scale, y + glyph->Y1 * scale),
                        Vec2(glyph->U0, glyph->V0), Vec2(glyph->U1, glyph->V1),
                        col);
}

// Note: as with every DrawList drawing function, this expects that the font
// atlas texture is bound.
inline void Font::RenderText(DrawList *draw_list, float size, const Vec2 &pos,
                             U32 col, const Vec4 &clip_rect,
                             const char *text_begin, const char *text_end,
                             float wrap_width, bool cpu_fine_clip) const {
  if (!text_end)
    text_end =
        text_begin +
        strlen(
            text_begin); // Gui:: functions generally already provides a valid
                         // text_end, so this is merely to handle direct calls.

  // Align to be pixel perfect
  float x = GUI_TRUNC(pos.x);
  float y = GUI_TRUNC(pos.y);
  if (y > clip_rect.w)
    return;

  const float start_x = x;
  const float scale = size / FontSize;
  const float line_height = FontSize * scale;
  const bool word_wrap_enabled = (wrap_width > 0.0f);

  // Fast-forward to first visible line
  const char *s = text_begin;
  if (y + line_height < clip_rect.y)
    while (y + line_height < clip_rect.y && s < text_end) {
      const char *line_end = (const char *)memchr(s, '\n', text_end - s);
      if (word_wrap_enabled) {
        // FIXME-OPT: This is not optimal as do first do a search for \n before
        // calling CalcWordWrapPositionA(). If the specs for
        // CalcWordWrapPositionA() were reworked to optionally return on \n we
        // could combine both. However it is still better than nothing
        // performing the fast-forward!
        s = CalcWordWrapPositionA(scale, s, line_end ? line_end : text_end,
                                  wrap_width);
        s = CalcWordWrapNextLineStartA(s, text_end);
      } else {
        s = line_end ? line_end + 1 : text_end;
      }
      y += line_height;
    }

  // For large text, scan for the last visible line in order to avoid
  // over-reserving in the call to PrimReserve() Note that very large horizontal
  // line will still be affected by the issue (e.g. a one megabyte string buffer
  // without a newline will likely crash atm)
  if (text_end - s > 10000 && !word_wrap_enabled) {
    const char *s_end = s;
    float y_end = y;
    while (y_end < clip_rect.w && s_end < text_end) {
      s_end = (const char *)memchr(s_end, '\n', text_end - s_end);
      s_end = s_end ? s_end + 1 : text_end;
      y_end += line_height;
    }
    text_end = s_end;
  }
  if (s == text_end)
    return;

  // Reserve vertices for remaining worse case (over-reserving is useful and
  // easily amortized)
  const int vtx_count_max = (int)(text_end - s) * 4;
  const int idx_count_max = (int)(text_end - s) * 6;
  const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
  draw_list->PrimReserve(idx_count_max, vtx_count_max);
  DrawVert *vtx_write = draw_list->_VtxWritePtr;
  DrawIdx *idx_write = draw_list->_IdxWritePtr;
  unsigned int vtx_index = draw_list->_VtxCurrentIdx;

  const U32 col_untinted = col | ~GUI_COL32_A_MASK;
  const char *word_wrap_eol = NULL;

  while (s < text_end) {
    if (word_wrap_enabled) {
      // Calculate how far we can render. Requires two passes on the string data
      // but keeps the code simple and not intrusive for what's essentially an
      // uncommon feature.
      if (!word_wrap_eol)
        word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end,
                                              wrap_width - (x - start_x));

      if (s >= word_wrap_eol) {
        x = start_x;
        y += line_height;
        word_wrap_eol = NULL;
        s = CalcWordWrapNextLineStartA(
            s, text_end); // Wrapping skips upcoming blanks
        continue;
      }
    }

    // Decode and advance source
    unsigned int c = (unsigned int)*s;
    if (c < 0x80)
      s += 1;
    else
      s += TextCharFromUtf8(&c, s, text_end);

    if (c < 32) {
      if (c == '\n') {
        x = start_x;
        y += line_height;
        if (y > clip_rect.w)
          break; // break out of main loop
        continue;
      }
      if (c == '\r')
        continue;
    }

    const FontGlyph *glyph = FindGlyph((Wchar)c);
    if (glyph == NULL)
      continue;

    float char_width = glyph->AdvanceX * scale;
    if (glyph->Visible) {
      // We don't do a second finer clipping test on the Y axis as we've already
      // skipped anything before clip_rect.y and exit once we pass clip_rect.w
      float x1 = x + glyph->X0 * scale;
      float x2 = x + glyph->X1 * scale;
      float y1 = y + glyph->Y0 * scale;
      float y2 = y + glyph->Y1 * scale;
      if (x1 <= clip_rect.z && x2 >= clip_rect.x) {
        // Render a character
        float u1 = glyph->U0;
        float v1 = glyph->V0;
        float u2 = glyph->U1;
        float v2 = glyph->V1;

        // CPU side clipping used to fit text in their frame when the frame is
        // too small. Only does clipping for axis aligned quads.
        if (cpu_fine_clip) {
          if (x1 < clip_rect.x) {
            u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
            x1 = clip_rect.x;
          }
          if (y1 < clip_rect.y) {
            v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
            y1 = clip_rect.y;
          }
          if (x2 > clip_rect.z) {
            u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
            x2 = clip_rect.z;
          }
          if (y2 > clip_rect.w) {
            v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
            y2 = clip_rect.w;
          }
          if (y1 >= y2) {
            x += char_width;
            continue;
          }
        }

        // Support for untinted glyphs
        U32 glyph_col = glyph->Colored ? col_untinted : col;

        // We are NOT calling PrimRectUV() here because non-inlined causes too
        // much overhead in a debug builds. Inlined here:
        {
          vtx_write[0].pos.x = x1;
          vtx_write[0].pos.y = y1;
          vtx_write[0].col = glyph_col;
          vtx_write[0].uv.x = u1;
          vtx_write[0].uv.y = v1;
          vtx_write[1].pos.x = x2;
          vtx_write[1].pos.y = y1;
          vtx_write[1].col = glyph_col;
          vtx_write[1].uv.x = u2;
          vtx_write[1].uv.y = v1;
          vtx_write[2].pos.x = x2;
          vtx_write[2].pos.y = y2;
          vtx_write[2].col = glyph_col;
          vtx_write[2].uv.x = u2;
          vtx_write[2].uv.y = v2;
          vtx_write[3].pos.x = x1;
          vtx_write[3].pos.y = y2;
          vtx_write[3].col = glyph_col;
          vtx_write[3].uv.x = u1;
          vtx_write[3].uv.y = v2;
          idx_write[0] = (DrawIdx)(vtx_index);
          idx_write[1] = (DrawIdx)(vtx_index + 1);
          idx_write[2] = (DrawIdx)(vtx_index + 2);
          idx_write[3] = (DrawIdx)(vtx_index);
          idx_write[4] = (DrawIdx)(vtx_index + 2);
          idx_write[5] = (DrawIdx)(vtx_index + 3);
          vtx_write += 4;
          vtx_index += 4;
          idx_write += 6;
        }
      }
    }
    x += char_width;
  }

  // Give back unused vertices (clipped ones, blanks) ~ this is essentially a
  // PrimUnreserve() action.
  draw_list->VtxBuffer.Size =
      (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()
  draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);
  draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -=
      (idx_expected_size - draw_list->IdxBuffer.Size);
  draw_list->_VtxWritePtr = vtx_write;
  draw_list->_IdxWritePtr = idx_write;
  draw_list->_VtxCurrentIdx = vtx_index;
}

//-----------------------------------------------------------------------------
// [SECTION] Gui Internal Render Helpers
//-----------------------------------------------------------------------------
// Vaguely redesigned to stop accessing Gui global state:
// - RenderArrow()
// - RenderBullet()
// - RenderCheckMark()
// - RenderArrowPointingAt()
// - RenderRectFilledRangeH()
// - RenderRectFilledWithHole()
//-----------------------------------------------------------------------------
// Function in need of a redesign (legacy mess)
// - RenderColorRectWithAlphaCheckerboard()
//-----------------------------------------------------------------------------

// Render an arrow aimed to be aligned with text (p_min is a position in the
// same space text would be positioned). To e.g. denote expanded/collapsed state
inline void Gui::RenderArrow(DrawList *draw_list, Vec2 pos, U32 col, Dir dir,
                             float scale) {
  const float h = draw_list->_Data->FontSize * 1.00f;
  float r = h * 0.40f * scale;
  Vec2 center = Add(pos, Vec2(h * 0.50f, h * 0.50f * scale));

  Vec2 a, b, c;
  switch (dir) {
  case Dir_Up:
  case Dir_Down:
    if (dir == Dir_Up)
      r = -r;
    a = Multiply(Vec2(+0.000f, +0.750f), r);
    b = Multiply(Vec2(-0.866f, -0.750f), r);
    c = Multiply(Vec2(+0.866f, -0.750f), r);
    break;
  case Dir_Left:
  case Dir_Right:
    if (dir == Dir_Left)
      r = -r;
    a = Multiply(Vec2(+0.750f, +0.000f), r);
    b = Multiply(Vec2(-0.750f, +0.866f), r);
    c = Multiply(Vec2(-0.750f, -0.866f), r);
    break;
  case Dir_None:
  case Dir_COUNT:
    GUI_ASSERT(0);
    break;
  }
  draw_list->AddTriangleFilled(Add(center, a), Add(center, b), Add(center, c),
                               col);
}

inline void Gui::RenderCheckMark(DrawList *draw_list, Vec2 pos, U32 col,
                                 float sz) {
  float thickness = Max(sz / 5.0f, 1.0f);
  sz -= thickness * 0.5f;
  pos = Add(pos, Vec2(thickness * 0.25f, thickness * 0.25f));

  float third = sz / 3.0f;
  float bx = pos.x + third;
  float by = pos.y + sz - third * 0.5f;
  draw_list->PathLineTo(Vec2(bx - third, by - third));
  draw_list->PathLineTo(Vec2(bx, by));
  draw_list->PathLineTo(Vec2(bx + third * 2.0f, by - third * 2.0f));
  draw_list->PathStroke(col, 0, thickness);
}

// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from
// base to tip. half_sz.y is length on each side.

static inline float Acos01(float x) {
  if (x <= 0.0f)
    return GUI_PI * 0.5f;
  if (x >= 1.0f)
    return 0.0f;
  return Acos(x);
  // return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x
  // + 1.5707963267948966f; // Cheap approximation, may be enough for what we
  // do.
}

// FIXME: Cleanup and move code to DrawList.
inline void Gui::RenderRectFilledRangeH(DrawList *draw_list, const Rect &rect,
                                        U32 col, float x_start_norm,
                                        float x_end_norm, float rounding) {
  if (x_end_norm == x_start_norm)
    return;
  if (x_start_norm > x_end_norm)
    Swap(x_start_norm, x_end_norm);

  Vec2 p0 = Vec2(Lerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);
  Vec2 p1 = Vec2(Lerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);
  if (rounding == 0.0f) {
    draw_list->AddRectFilled(p0, p1, col, 0.0f);
    return;
  }

  rounding = Clamp(
      Min((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) -
          1.0f,
      0.0f, rounding);
  const float inv_rounding = 1.0f / rounding;
  const float arc0_b = Acos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);
  const float arc0_e = Acos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);
  const float half_pi =
      GUI_PI * 0.5f; // We will == compare to this because we know this is the
                     // exact value Acos01 can return.
  const float x0 = Max(p0.x, rect.Min.x + rounding);
  if (arc0_b == arc0_e) {
    draw_list->PathLineTo(Vec2(x0, p1.y));
    draw_list->PathLineTo(Vec2(x0, p0.y));
  } else if (arc0_b == 0.0f && arc0_e == half_pi) {
    draw_list->PathArcToFast(Vec2(x0, p1.y - rounding), rounding, 3, 6); // BL
    draw_list->PathArcToFast(Vec2(x0, p0.y + rounding), rounding, 6, 9); // TR
  } else {
    draw_list->PathArcTo(Vec2(x0, p1.y - rounding), rounding, GUI_PI - arc0_e,
                         GUI_PI - arc0_b, 3); // BL
    draw_list->PathArcTo(Vec2(x0, p0.y + rounding), rounding, GUI_PI + arc0_b,
                         GUI_PI + arc0_e, 3); // TR
  }
  if (p1.x > rect.Min.x + rounding) {
    const float arc1_b = Acos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);
    const float arc1_e = Acos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);
    const float x1 = Min(p1.x, rect.Max.x - rounding);
    if (arc1_b == arc1_e) {
      draw_list->PathLineTo(Vec2(x1, p0.y));
      draw_list->PathLineTo(Vec2(x1, p1.y));
    } else if (arc1_b == 0.0f && arc1_e == half_pi) {
      draw_list->PathArcToFast(Vec2(x1, p0.y + rounding), rounding, 9,
                               12); // TR
      draw_list->PathArcToFast(Vec2(x1, p1.y - rounding), rounding, 0,
                               3); // BR
    } else {
      draw_list->PathArcTo(Vec2(x1, p0.y + rounding), rounding, -arc1_e,
                           -arc1_b, 3); // TR
      draw_list->PathArcTo(Vec2(x1, p1.y - rounding), rounding, +arc1_b,
                           +arc1_e, 3); // BR
    }
  }
  draw_list->PathFillConvex(col);
}

// Helper for ColorPicker4()
// NB: This is rather brittle and will show artifact when rounding this enabled
// if rounded corners overlap multiple cells. Caller currently responsible for
// avoiding that. Spent a non reasonable amount of time trying to getting this
// right for ColorButton with
// rounding+anti-aliasing+ColorEditFlags_HalfAlphaPreview flag + various
// grid sizes and offsets, and eventually gave up... probably more reasonable to
// disable rounding altogether.
// FIXME: uses Gui::GetColorU32

//-----------------------------------------------------------------------------
// [SECTION] Decompression code
//-----------------------------------------------------------------------------
// Compressed with stb_compress() then converted to a C array and encoded as
// base85. Use the program in misc/fonts/binary_to_compressed_c.cpp to create
// the array from a TTF file. The purpose of encoding as base85 instead of
// "0x00,0x01,..." style is only save on _source code_ size. Decompression from
// stb.h (public domain) by Sean Barrett
// https://github.com/nothings/stb/blob/master/stb.h
//-----------------------------------------------------------------------------

static unsigned int stb_decompress_length(const unsigned char *input) {
  return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
}

static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;
static const unsigned char *stb__barrier_in_b;
static unsigned char *stb__dout;
static void stb__match(const unsigned char *data, unsigned int length) {
  // INVERSE of memmove... write each byte before copying the next...
  GUI_ASSERT(stb__dout + length <= stb__barrier_out_e);
  if (stb__dout + length > stb__barrier_out_e) {
    stb__dout += length;
    return;
  }
  if (data < stb__barrier_out_b) {
    stb__dout = stb__barrier_out_e + 1;
    return;
  }
  while (length--)
    *stb__dout++ = *data++;
}

static void stb__lit(const unsigned char *data, unsigned int length) {
  GUI_ASSERT(stb__dout + length <= stb__barrier_out_e);
  if (stb__dout + length > stb__barrier_out_e) {
    stb__dout += length;
    return;
  }
  if (data < stb__barrier_in_b) {
    stb__dout = stb__barrier_out_e + 1;
    return;
  }
  memcpy(stb__dout, data, length);
  stb__dout += length;
}

#define stb__in2(x) ((i[x] << 8) + i[(x) + 1])
#define stb__in3(x) ((i[x] << 16) + stb__in2((x) + 1))
#define stb__in4(x) ((i[x] << 24) + stb__in3((x) + 1))

static const unsigned char *stb_decompress_token(const unsigned char *i) {
  if (*i >= 0x20) { // use fewer if's for cases that expand small
    if (*i >= 0x80)
      stb__match(stb__dout - i[1] - 1, i[0] - 0x80 + 1), i += 2;
    else if (*i >= 0x40)
      stb__match(stb__dout - (stb__in2(0) - 0x4000 + 1), i[2] + 1), i += 3;
    else /* *i >= 0x20 */
      stb__lit(i + 1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
  } else { // more ifs for cases that expand large, since overhead is amortized
    if (*i >= 0x18)
      stb__match(stb__dout - (stb__in3(0) - 0x180000 + 1), i[3] + 1), i += 4;
    else if (*i >= 0x10)
      stb__match(stb__dout - (stb__in3(0) - 0x100000 + 1), stb__in2(3) + 1),
          i += 5;
    else if (*i >= 0x08)
      stb__lit(i + 2, stb__in2(0) - 0x0800 + 1),
          i += 2 + (stb__in2(0) - 0x0800 + 1);
    else if (*i == 0x07)
      stb__lit(i + 3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
    else if (*i == 0x06)
      stb__match(stb__dout - (stb__in3(1) + 1), i[4] + 1), i += 5;
    else if (*i == 0x04)
      stb__match(stb__dout - (stb__in3(1) + 1), stb__in2(4) + 1), i += 6;
  }
  return i;
}

static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer,
                                unsigned int buflen) {
  const unsigned long ADLER_MOD = 65521;
  unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
  unsigned long blocklen = buflen % 5552;

  unsigned long i;
  while (buflen) {
    for (i = 0; i + 7 < blocklen; i += 8) {
      s1 += buffer[0], s2 += s1;
      s1 += buffer[1], s2 += s1;
      s1 += buffer[2], s2 += s1;
      s1 += buffer[3], s2 += s1;
      s1 += buffer[4], s2 += s1;
      s1 += buffer[5], s2 += s1;
      s1 += buffer[6], s2 += s1;
      s1 += buffer[7], s2 += s1;

      buffer += 8;
    }

    for (; i < blocklen; ++i)
      s1 += *buffer++, s2 += s1;

    s1 %= ADLER_MOD, s2 %= ADLER_MOD;
    buflen -= blocklen;
    blocklen = 5552;
  }
  return (unsigned int)(s2 << 16) + (unsigned int)s1;
}

static unsigned int stb_decompress(unsigned char *output,
                                   const unsigned char *i,
                                   unsigned int /*length*/) {
  if (stb__in4(0) != 0x57bC0000)
    return 0;
  if (stb__in4(4) != 0)
    return 0; // error! stream is > 4GB
  const unsigned int olen = stb_decompress_length(i);
  stb__barrier_in_b = i;
  stb__barrier_out_e = output + olen;
  stb__barrier_out_b = output;
  i += 16;

  stb__dout = output;
  for (;;) {
    const unsigned char *old_i = i;
    i = stb_decompress_token(i);
    if (i == old_i) {
      if (*i == 0x05 && i[1] == 0xfa) {
        GUI_ASSERT(stb__dout == output + olen);
        if (stb__dout != output + olen)
          return 0;
        if (stb_adler32(1, output, olen) != (unsigned int)stb__in4(2))
          return 0;
        return olen;
      } else {
        GUI_ASSERT(0); /* NOTREACHED */
        return 0;
      }
    }
    GUI_ASSERT(stb__dout <= output + olen);
    if (stb__dout > output + olen)
      return 0;
  }
}

//-----------------------------------------------------------------------------
// [SECTION] Default font data (ProggyClean.ttf)
//-----------------------------------------------------------------------------
// ProggyClean.ttf
// Copyright (c) 2004, 2005 Tristan Grimmer
// MIT license (see License.txt in
// http://www.upperbounds.net/download/ProggyClean.ttf.zip) Download and more
// information at http://upperbounds.net
//-----------------------------------------------------------------------------
// File: 'ProggyClean.ttf' (41208 bytes)
// Exported using misc/fonts/binary_to_compressed_c.cpp (with compression +
// base85 string encoding). The purpose of encoding as base85 instead of
// "0x00,0x01,..." style is only save on _source code_ size.
//-----------------------------------------------------------------------------
static const char proggy_clean_ttf_compressed_data_base85[11980 + 1] =
    "7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/"
    "e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';"
    "9Crc6tgXmKVeU2cD4Eo3R/"
    "2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/"
    "W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"
    "`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./"
    "L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"
    "i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//"
    "L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*"
    "oJMHRC`N"
    "kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^"
    "GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"
    "*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#("
    "&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"
    "tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/"
    "L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/"
    "Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"
    "ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%"
    "lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc."
    "x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/"
    "WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/"
    "-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"
    "CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/"
    "EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($"
    "5FNP&EQ(,)"
    "U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]"
    "O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"
    "'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/"
    "4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$"
    "x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"
    "_3YlQC7(p7q)&](`6_c)$/"
    "*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/"
    "EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"
    "Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+"
    "Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"
    "/oL?#h7gl85[qW/"
    "NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&"
    "O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"
    "%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&"
    "#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"
    "OQFKNX@QI'IoPp7nb,QU//"
    "MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-"
    "A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("
    "h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'"
    "9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"
    "o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;"
    ")f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"
    "j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$["
    "guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"
    "sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/"
    ":chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"
    "eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%"
    "#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"
    "M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/"
    "Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/"
    "6(^xtk%"
    "LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/"
    "NM_>hLbxfc$mj`,O;&%W2m`Zh:/"
    ")Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"
    "%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,"
    "UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"
    "Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/"
    "K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"
    "a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#"
    "FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("
    "$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/"
    "*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/"
    "c58Mo(3;knp0%)A7?-W+eI'o8)b<"
    "nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^"
    "V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"
    "7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//"
    "9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;"
    "D.(nc7/;"
    ")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<"
    "-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"
    "D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/"
    "LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/"
    "5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("
    "P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/"
    "V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO("
    "G0Sq7MVjJs"
    "bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/"
    "k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@"
    "Tm&Q"
    "h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//"
    ",]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%."
    "O=?2S]u*(m<-"
    "V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/"
    "9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"
    "sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/"
    "[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE="
    "68>K8r0=dSC%%(@p7"
    ".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/"
    "2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)"
    "Tq7VT9q^*^$$.:&N@@"
    "$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/"
    "(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/"
    "m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"
    "hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/"
    ",;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?"
    "XJN4Nm&+YF]u"
    "@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</"
    "xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"
    "w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#"
    "v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/"
    "$(vdfq7+ebA#"
    "u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)"
    "jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"
    "d=j.LQf./"
    "Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-"
    "r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"
    "6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/"
    "`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*"
    "BM9dM*hJMAo*c&#"
    "b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM."
    "rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"
    ":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/"
    ":p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/"
    "I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+"
    "tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@"
    "r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"
    "$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+"
    "J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"
    ":d[/"
    ";r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]"
    "2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"
    "7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K="
    "H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"
    "u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%"
    "Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT"
    "LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/"
    "Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'"
    "IM%L3I)X((e/dl2&8'<M"
    ":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/"
    "kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<"
    "b*t7ed;p*_m;4ExK#h@&]>"
    "_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,"
    ";s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"
    "hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<"
    "-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"
    "^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<"
    "LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"
    "+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/"
    "FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<"
    "2Len$b*aTX=-8QxN)k11IM1c^j%"
    "9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@"
    "g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"
    "CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/"
    "6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"
    "hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&"
    "#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"
    "8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/"
    "L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"
    "S(qw%sf/@%#B6;/"
    "U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci."
    "(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"
    "0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/"
    ");TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/"
    "ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"
    "+fsd;l#SafT/"
    "f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'"
    "fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"
    "M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/"
    "LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]"
    "u7-P=.-_:YJ]aS@V"
    "?6*C()dOp7:WL,b&3Rg/"
    ".cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-"
    "Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"
    "Yq[@>P)hI;*_F]u`Rb[.j8_Q/"
    "<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/"
    "Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"
    ">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?"
    "0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"
    "[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</"
    "R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'"
    "QG:`@I"
    "wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/"
    "6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$#"
    "#?M)c<$bgQ_'SY((-xkA#"
    "Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*"
    "7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"
    "MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;"
    "&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"
    "i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/"
    ",SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"
    "1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS["
    "0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"
    "iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:"
    "'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"
    "URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,["
    "R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"
    ";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/"
    "+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"
    "w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/"
    "X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#"
    "a9OA#"
    "d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&"
    "#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"
    "A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),"
    "#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
    "/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/"
    "E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@"
    "/=#eG8=#t8J5#`+78#4uI-#"
    "m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF."
    "#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
    "TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]"
    "PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"
    "GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&"
    "5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
    "O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#"
    "lLYI:xvD=#";

static const char *GetDefaultCompressedFontDataTTFBase85() {
  return proggy_clean_ttf_compressed_data_base85;
}

#endif // #ifndef GUI_DISABLE
// dear gui, v1.90.1 WIP
// (widgets code)

/*

Index of this file:

// [SECTION] Forward Declarations
// [SECTION] Widgets: Text, etc.
// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar,
Bullet, etc.)
// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine,
Separator, etc.)
// [SECTION] Widgets: ComboBox
// [SECTION] Data Type and Data Formatting Helpers
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
// [SECTION] Widgets: InputText, InputTextMultiline
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
// [SECTION] Widgets: Selectable
// [SECTION] Widgets: Typing-Select support
// [SECTION] Widgets: Multi-Select support
// [SECTION] Widgets: ListBox
// [SECTION] Widgets: PlotLines, PlotHistogram
// [SECTION] Widgets: Value helpers
// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef GUI_DEFINE_MATH_OPERATORS
#define GUI_DEFINE_MATH_OPERATORS
#endif

// System includes
#include <stdint.h> // intptr_t

//-------------------------------------------------------------------------
// Warnings
//-------------------------------------------------------------------------

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning(disable : 4127) // condition expression is constant
#pragma warning(                                                               \
    disable : 4996) // 'This function or variable may be unsafe': strcpy,
                    // strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning(disable : 5054) // operator '|': deprecated between enumerations
                                // of different types
#endif
#pragma warning(                                                               \
    disable : 26451) // [Static Analyzer] Arithmetic overflow : Using operator
                     // 'xxx' on a 4 byte value and then casting the result to a
                     // 8 byte value. Cast the value to the wider type before
                     // calling operator 'xxx' to avoid overflow(io.2).
#pragma warning(                                                               \
    disable : 26812) // [Static Analyzer] The enum type 'xxx' is unscoped.
                     // Prefer 'enum class' over 'enum' (Enum.3).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored                                               \
    "-Wunknown-warning-option" // warning: unknown warning group 'xxx' // not
                               // all warnings are known by all Clang versions
                               // and they tend to be rename-happy.. so ignoring
                               // warnings triggers new warnings on some
                               // configuration. Great!
#endif
#pragma clang diagnostic ignored                                               \
    "-Wunknown-pragmas" // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored                                               \
    "-Wold-style-cast" // warning: use of old-style cast // yes, they are more
                       // terse.
#pragma clang diagnostic ignored                                               \
    "-Wfloat-equal" // warning: comparing floating point with == or != is unsafe
                    // // storing and comparing against same constants
                    // (typically 0.0f) is ok.
#pragma clang diagnostic ignored                                               \
    "-Wformat-nonliteral" // warning: format string is not a string literal //
                          // passing non-literal to vsnformat(). yes, user
                          // passing incorrect format strings can crash the
                          // code.
#pragma clang diagnostic ignored                                               \
    "-Wsign-conversion" // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored                                               \
    "-Wzero-as-null-pointer-constant" // warning: zero as null pointer constant
                                      // // some standard header variations use
                                      // #define NULL 0
#pragma clang diagnostic ignored                                               \
    "-Wdouble-promotion" // warning: implicit conversion from 'float' to
                         // 'double' when passing argument to function  // using
                         // printf() is a misery with this as C++ va_arg
                         // ellipsis changes float to double.
#pragma clang diagnostic ignored                                               \
    "-Wenum-enum-conversion" // warning: bitwise operation between different
                             // enumeration types ('XXXFlags_' and
                             // 'XXXFlagsPrivate_')
#pragma clang diagnostic ignored                                               \
    "-Wdeprecated-enum-enum-conversion" // warning: bitwise operation between
                                        // different enumeration types
                                        // ('XXXFlags_' and 'XXXFlagsPrivate_')
                                        // is deprecated
#pragma clang diagnostic ignored                                               \
    "-Wimplicit-int-float-conversion" // warning: implicit conversion from 'xxx'
                                      // to 'float' may lose precision
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored                                                 \
    "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored                                                 \
    "-Wformat-nonliteral" // warning: format not a string literal, format string
                          // not checked
#pragma GCC diagnostic ignored                                                 \
    "-Wclass-memaccess" // [__GNUC__ >= 8] warning: 'memset/memcpy'
                        // clearing/writing an object of type 'xxxx' with no
                        // trivial copy-assignment; use assignment or
                        // value-initialization instead
#pragma GCC diagnostic ignored                                                 \
    "-Wdeprecated-enum-enum-conversion" // warning: bitwise operation between
                                        // different enumeration types
                                        // ('XXXFlags_' and 'XXXFlagsPrivate_')
                                        // is deprecated
#endif

//-------------------------------------------------------------------------
// Data
//-------------------------------------------------------------------------

// Widgets
static const float DRAGDROP_HOLD_TO_OPEN_TIMER =
    0.70f; // Time for drag-hold to activate items accepting the
           // ButtonFlags_PressedOnDragDropHold button behavior.
static const float DRAG_MOUSE_THRESHOLD_FACTOR =
    0.50f; // Multiplier for the default value of io.MouseDragThreshold to make
           // DragFloat/DragInt react faster to mouse drags.

// Those MIN/MAX values are not define because we need to point to them
static const signed char GUI_S8_MIN = -128;
static const signed char GUI_S8_MAX = 127;
static const unsigned char GUI_U8_MIN = 0;
static const unsigned char GUI_U8_MAX = 0xFF;
static const signed short GUI_S16_MIN = -32768;
static const signed short GUI_S16_MAX = 32767;
static const unsigned short GUI_U16_MIN = 0;
static const unsigned short GUI_U16_MAX = 0xFFFF;
static const S32 GUI_S32_MIN = INT_MIN; // (-2147483647 - 1), (0x80000000);
static const S32 GUI_S32_MAX = INT_MAX; // (2147483647), (0x7FFFFFFF)
static const U32 GUI_U32_MIN = 0;
static const U32 GUI_U32_MAX = UINT_MAX; // (0xFFFFFFFF)
#ifdef LLONG_MIN
static const S64 GUI_S64_MIN = LLONG_MIN; // (-9223372036854775807ll - 1ll);
static const S64 GUI_S64_MAX = LLONG_MAX; // (9223372036854775807ll);
#else
static const S64 GUI_S64_MIN = -9223372036854775807LL - 1;
static const S64 GUI_S64_MAX = 9223372036854775807LL;
#endif
static const U64 GUI_U64_MIN = 0;
#ifdef ULLONG_MAX
static const U64 GUI_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);
#else
static const U64 GUI_U64_MAX = (2ULL * 9223372036854775807LL + 1);
#endif

//-------------------------------------------------------------------------
// [SECTION] Forward Declarations
//-------------------------------------------------------------------------

// For InputTextEx()
static bool InputTextFilterCharacter(Context *ctx, unsigned int *p_char,
                                     InputTextFlags flags,
                                     InputTextCallback callback,
                                     void *user_data, InputSource input_source);
static int InputTextCalcTextLenAndLineCount(const char *text_begin,
                                            const char **out_text_end);
static Vec2 InputTextCalcTextSizeW(Context *ctx, const Wchar *text_begin,
                                   const Wchar *text_end,
                                   const Wchar **remaining = NULL,
                                   Vec2 *out_offset = NULL,
                                   bool stop_on_new_line = false);

//-------------------------------------------------------------------------
// [SECTION] Widgets: Text, etc.
//-------------------------------------------------------------------------
// - TextEx() [Internal]
// - TextUnformatted()
// - Text()
// - TextV()
// - TextColored()
// - TextColoredV()
// - TextDisabled()
// - TextDisabledV()
// - TextWrapped()
// - TextWrappedV()
// - LabelText()
// - LabelTextV()
// - BulletText()
// - BulletTextV()
//-------------------------------------------------------------------------

inline void Gui::TextEx(const char *text, const char *text_end,
                        TextFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;
  Context &g = *GGui;

  // Accept null ranges
  if (text == text_end)
    text = text_end = "";

  // Calculate length
  const char *text_begin = text;
  if (text_end == NULL)
    text_end = text + strlen(text); // FIXME-OPT

  const Vec2 text_pos(window->DC.CursorPos.x,
                      window->DC.CursorPos.y +
                          window->DC.CurrLineTextBaseOffset);
  const float wrap_pos_x = window->DC.TextWrapPos;
  const bool wrap_enabled = (wrap_pos_x >= 0.0f);
  if (text_end - text <= 2000 || wrap_enabled) {
    // Common case
    const float wrap_width =
        wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x)
                     : 0.0f;
    const Vec2 text_size =
        CalcTextSize(text_begin, text_end, false, wrap_width);

    Rect bb(text_pos, Add(text_pos, text_size));
    ItemSize(text_size, 0.0f);
    if (!ItemAdd(bb, 0))
      return;

    // Render (we don't hide text after ## in this end-user function)
    RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);
  } else {
    // Long text!
    // Perform manual coarse clipping to optimize for long multi-line text
    // - From this point we will only compute the width of lines that are
    // visible. Optimization only available when word-wrapping is disabled.
    // - We also don't vertically center the text within the line full height,
    // which is unlikely to matter because we are likely the biggest and only
    // item on the line.
    // - We use memchr(), pay attention that well optimized versions of those
    // str/mem functions are much faster than a casually written loop.
    const char *line = text;
    const float line_height = GetTextLineHeight();
    Vec2 text_size(0, 0);

    // Lines to skip (can't skip when logging text)
    Vec2 pos = text_pos;
    if (!g.LogEnabled) {
      int lines_skippable =
          (int)((window->ClipRect.Min.y - text_pos.y) / line_height);
      if (lines_skippable > 0) {
        int lines_skipped = 0;
        while (line < text_end && lines_skipped < lines_skippable) {
          const char *line_end =
              (const char *)memchr(line, '\n', text_end - line);
          if (!line_end)
            line_end = text_end;
          if ((flags & TextFlags_NoWidthForLargeClippedText) == 0)
            text_size.x = Max(text_size.x, CalcTextSize(line, line_end).x);
          line = line_end + 1;
          lines_skipped++;
        }
        pos.y += lines_skipped * line_height;
      }
    }

    // Lines to render
    if (line < text_end) {
      Rect line_rect(pos, Add(pos, Vec2(FLT_MAX, line_height)));
      while (line < text_end) {
        if (IsClippedEx(line_rect, 0))
          break;

        const char *line_end =
            (const char *)memchr(line, '\n', text_end - line);
        if (!line_end)
          line_end = text_end;
        text_size.x = Max(text_size.x, CalcTextSize(line, line_end).x);
        RenderText(pos, line, line_end, false);
        line = line_end + 1;
        line_rect.Min.y += line_height;
        line_rect.Max.y += line_height;
        pos.y += line_height;
      }

      // Count remaining lines
      int lines_skipped = 0;
      while (line < text_end) {
        const char *line_end =
            (const char *)memchr(line, '\n', text_end - line);
        if (!line_end)
          line_end = text_end;
        if ((flags & TextFlags_NoWidthForLargeClippedText) == 0)
          text_size.x = Max(text_size.x, CalcTextSize(line, line_end).x);
        line = line_end + 1;
        lines_skipped++;
      }
      pos.y += lines_skipped * line_height;
    }
    text_size.y = (Subtract(pos, text_pos)).y;

    Rect bb(text_pos, Add(text_pos, text_size));
    ItemSize(text_size, 0.0f);
    ItemAdd(bb, 0);
  }
}

inline void Gui::TextUnformatted(const char *text, const char *text_end) {
  TextEx(text, text_end, TextFlags_NoWidthForLargeClippedText);
}

inline void Gui::Text(const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  TextV(fmt, args);
  va_end(args);
}

inline void Gui::TextV(const char *fmt, va_list args) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;

  const char *text, *text_end;
  FormatStringToTempBufferV(&text, &text_end, fmt, args);
  TextEx(text, text_end, TextFlags_NoWidthForLargeClippedText);
}

inline void Gui::TextColored(const Vec4 &col, const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  TextColoredV(col, fmt, args);
  va_end(args);
}

inline void Gui::TextColoredV(const Vec4 &col, const char *fmt, va_list args) {
  PushStyleColor(Col_Text, col);
  TextV(fmt, args);
  PopStyleColor();
}

inline void Gui::TextDisabled(const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  TextDisabledV(fmt, args);
  va_end(args);
}

inline void Gui::TextDisabledV(const char *fmt, va_list args) {
  Context &g = *GGui;
  PushStyleColor(Col_Text, g.Style.Colors[Col_TextDisabled]);
  TextV(fmt, args);
  PopStyleColor();
}

inline void Gui::TextWrapped(const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  TextWrappedV(fmt, args);
  va_end(args);
}

inline void Gui::TextWrappedV(const char *fmt, va_list args) {
  Context &g = *GGui;
  const bool need_backup =
      (g.CurrentWindow->DC.TextWrapPos <
       0.0f); // Keep existing wrap position if one is already set
  if (need_backup)
    PushTextWrapPos(0.0f);
  TextV(fmt, args);
  if (need_backup)
    PopTextWrapPos();
}

inline void Gui::LabelText(const char *label, const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  LabelTextV(label, fmt, args);
  va_end(args);
}

// Add a label+text combo aligned to other label+value widgets
inline void Gui::LabelTextV(const char *label, const char *fmt, va_list args) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;

  Context &g = *GGui;
  const Style &style = g.Style;
  const float w = CalcItemWidth();

  const char *value_text_begin, *value_text_end;
  FormatStringToTempBufferV(&value_text_begin, &value_text_end, fmt, args);
  const Vec2 value_size = CalcTextSize(value_text_begin, value_text_end, false);
  const Vec2 label_size = CalcTextSize(label, NULL, true);

  const Vec2 pos = window->DC.CursorPos;
  const Rect value_bb(
      pos, Add(pos, Vec2(w, value_size.y + style.FramePadding.y * 2)));
  const Rect total_bb(
      pos, Add(pos, Vec2(w + (label_size.x > 0.0f
                                  ? style.ItemInnerSpacing.x + label_size.x
                                  : 0.0f),
                         Max(value_size.y, label_size.y) +
                             style.FramePadding.y * 2)));
  ItemSize(total_bb, style.FramePadding.y);
  if (!ItemAdd(total_bb, 0))
    return;

  // Render
  RenderTextClipped(Add(value_bb.Min, style.FramePadding), value_bb.Max,
                    value_text_begin, value_text_end, &value_size,
                    Vec2(0.0f, 0.0f));
  if (label_size.x > 0.0f)
    RenderText(Vec2(value_bb.Max.x + style.ItemInnerSpacing.x,
                    value_bb.Min.y + style.FramePadding.y),
               label);
}

inline void Gui::BulletText(const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  BulletTextV(fmt, args);
  va_end(args);
}

// Text with a little bullet aligned to the typical tree node.
inline void Gui::BulletTextV(const char *fmt, va_list args) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;

  Context &g = *GGui;
  const Style &style = g.Style;

  const char *text_begin, *text_end;
  FormatStringToTempBufferV(&text_begin, &text_end, fmt, args);
  const Vec2 label_size = CalcTextSize(text_begin, text_end, false);
  const Vec2 total_size =
      Vec2(g.FontSize + (label_size.x > 0.0f
                             ? (label_size.x + style.FramePadding.x * 2)
                             : 0.0f),
           label_size.y); // Empty text doesn't add padding
  Vec2 pos = window->DC.CursorPos;
  pos.y += window->DC.CurrLineTextBaseOffset;
  ItemSize(total_size, 0.0f);
  const Rect bb(pos, Add(pos, total_size));
  if (!ItemAdd(bb, 0))
    return;

  // Render
  U32 text_col = GetColorU32(Col_Text);
  RenderBullet(window->DrawList,
               Add(bb.Min, Vec2(style.FramePadding.x + g.FontSize * 0.5f,
                                g.FontSize * 0.5f)),
               text_col);
  RenderText(Add(bb.Min, Vec2(g.FontSize + style.FramePadding.x * 2, 0.0f)),
             text_begin, text_end, false);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Main
//-------------------------------------------------------------------------
// - ButtonBehavior() [Internal]
// - Button()
// - SmallButton()
// - InvisibleButton()
// - ArrowButton()
// - CloseButton() [Internal]
// - CollapseButton() [Internal]
// - GetWindowScrollbarID() [Internal]
// - GetWindowScrollbarRect() [Internal]
// - Scrollbar() [Internal]
// - ScrollbarEx() [Internal]
// - Image()
// - ImageButton()
// - Checkbox()
// - CheckboxFlagsT() [Internal]
// - CheckboxFlags()
// - RadioButton()
// - ProgressBar()
// - Bullet()
//-------------------------------------------------------------------------

// The ButtonBehavior() function is key to many interactions and used by
// many/most widgets. Because we handle so many cases (keyboard/gamepad
// navigation, drag and drop) and many specific behavior (via
// ButtonFlags_), this code is a little complex. By far the most common
// path is interacting with the Mouse using the default
// ButtonFlags_PressedOnClickRelease button behavior. See the series of
// events below and the corresponding state reported by dear gui:
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClickRelease:             return-value  IsItemHovered()
// IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse is outside bb)        -             -                - -
//   -                    - Frame N+1 (mouse moves inside bb)      - true - - -
//   - Frame N+2 (mouse button is down)       -             true true true -
//   true Frame N+3 (mouse button is down)       -             true true - - -
//   Frame N+4 (mouse moves outside bb)     -             -                true
//   -                  -                    - Frame N+5 (mouse moves inside bb)
//   -             true             true            -                  - - Frame
//   N+6 (mouse button is released)   true          true             - - true -
//   Frame N+7 (mouse button is released)   -             true             - -
//   -                    - Frame N+8 (mouse moves outside bb)     - - - - - -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClick:                    return-value  IsItemHovered()
// IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       true          true             true
//   true               -                    true Frame N+3 (mouse button is
//   down)       -             true             true            - - - Frame N+6
//   (mouse button is released)   -             true             - - true -
//   Frame N+7 (mouse button is released)   -             true             - -
//   -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnRelease:                  return-value  IsItemHovered()
// IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       -             true             - -
//   -                    true Frame N+3 (mouse button is down)       - true -
//   -                  -                    - Frame N+6 (mouse button is
//   released)   true          true             -               - - - Frame N+7
//   (mouse button is released)   -             true             - - - -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnDoubleClick:              return-value  IsItemHovered()
// IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse button is down)       -             true             - -
//   -                    true Frame N+1 (mouse button is down)       - true -
//   -                  -                    - Frame N+2 (mouse button is
//   released)   -             true             -               - - - Frame N+3
//   (mouse button is released)   -             true             - - - - Frame
//   N+4 (mouse button is down)       true          true             true true
//   -                    true Frame N+5 (mouse button is down)       - true
//   true            -                  -                    - Frame N+6 (mouse
//   button is released)   -             true             -               - true
//   - Frame N+7 (mouse button is released)   -             true             -
//   -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// Note that some combinations are supported,
// - PressedOnDragDropHold can generally be associated with any flag.
// - PressedOnDoubleClick can be associated by
// PressedOnClickRelease/PressedOnRelease, in which case the second release
// event won't be reported.
//------------------------------------------------------------------------------------------------------------------------------------------------
// The behavior of the return-value changes when ButtonFlags_Repeat is set:
//                                         Repeat+                  Repeat+
//                                         Repeat+             Repeat+
//                                         PressedOnClickRelease PressedOnClick
//                                         PressedOnRelease PressedOnDoubleClick
//-------------------------------------------------------------------------------------------------------------------------------------------------
//   Frame N+0 (mouse button is down)       -                        true - true
//   ...                                    -                        - - - Frame
//   N + RepeatDelay                  true                     true - true
//   ...                                    -                        - - - Frame
//   N + RepeatDelay + RepeatRate*N   true                     true - true
//-------------------------------------------------------------------------------------------------------------------------------------------------

inline bool Gui::ButtonBehavior(const Rect &bb, ID id, bool *out_hovered,
                                bool *out_held, ButtonFlags flags) {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();

  // Default only reacts to left mouse button
  if ((flags & ButtonFlags_MouseButtonMask_) == 0)
    flags |= ButtonFlags_MouseButtonDefault_;

  // Default behavior requires click + release inside bounding box
  if ((flags & ButtonFlags_PressedOnMask_) == 0)
    flags |= ButtonFlags_PressedOnDefault_;

  // Default behavior inherited from item flags
  // Note that _both_ ButtonFlags and ItemFlags are valid sources, so copy one
  // into the item_flags and only check that.
  ItemFlags item_flags =
      (g.LastItemData.ID == id ? g.LastItemData.InFlags : g.CurrentItemFlags);
  if (flags & ButtonFlags_AllowOverlap)
    item_flags |= ItemFlags_AllowOverlap;
  if (flags & ButtonFlags_Repeat)
    item_flags |= ItemFlags_ButtonRepeat;

  Window *backup_hovered_window = g.HoveredWindow;
  const bool flatten_hovered_children = (flags & ButtonFlags_FlattenChildren) &&
                                        g.HoveredWindow &&
                                        g.HoveredWindow->RootWindow == window;
  if (flatten_hovered_children)
    g.HoveredWindow = window;

#ifdef GUI_ENABLE_TEST_ENGINE
  // Alternate registration spot, for when caller didn't use ItemAdd()
  if (id != 0 && g.LastItemData.ID != id)
    GUI_TEST_ENGINE_ITEM_ADD(id, bb, NULL);
#endif

  bool pressed = false;
  bool hovered = ItemHoverable(bb, id, item_flags);

  // Special mode for Drag and Drop where holding button pressed for a long time
  // while dragging another item triggers the button
  if (g.DragDropActive && (flags & ButtonFlags_PressedOnDragDropHold) &&
      !(g.DragDropSourceFlags & DragDropFlags_SourceNoHoldToOpenOthers))
    if (IsItemHovered(HoveredFlags_AllowWhenBlockedByActiveItem)) {
      hovered = true;
      SetHoveredID(id);
      if (g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER &&
          g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER) {
        pressed = true;
        g.DragDropHoldJustPressedId = id;
        FocusWindow(window);
      }
    }

  if (flatten_hovered_children)
    g.HoveredWindow = backup_hovered_window;

  // Mouse handling
  const ID test_owner_id =
      (flags & ButtonFlags_NoTestKeyOwner) ? KeyOwner_Any : id;
  if (hovered) {
    // Poll mouse buttons
    // - 'mouse_button_clicked' is generally carried into ActiveIdMouseButton
    // when setting ActiveId.
    // - Technically we only need some values in one code path, but since this
    // is gated by hovered test this is fine.
    int mouse_button_clicked = -1;
    int mouse_button_released = -1;
    for (int button = 0; button < 3; button++)
      if (flags & (ButtonFlags_MouseButtonLeft
                   << button)) // Handle ButtonFlags_MouseButtonRight and
                               // ButtonFlags_MouseButtonMiddle here.
      {
        if (IsMouseClicked(button, test_owner_id) &&
            mouse_button_clicked == -1) {
          mouse_button_clicked = button;
        }
        if (IsMouseReleased(button, test_owner_id) &&
            mouse_button_released == -1) {
          mouse_button_released = button;
        }
      }

    // Process initial action
    if (!(flags & ButtonFlags_NoKeyModifiers) ||
        (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt)) {
      if (mouse_button_clicked != -1 && g.ActiveId != id) {
        if (!(flags & ButtonFlags_NoSetKeyOwner))
          SetKeyOwner(MouseButtonToKey(mouse_button_clicked), id);
        if (flags & (ButtonFlags_PressedOnClickRelease |
                     ButtonFlags_PressedOnClickReleaseAnywhere)) {
          SetActiveID(id, window);
          g.ActiveIdMouseButton = mouse_button_clicked;
          if (!(flags & ButtonFlags_NoNavFocus))
            SetFocusID(id, window);
          FocusWindow(window);
        }
        if ((flags & ButtonFlags_PressedOnClick) ||
            ((flags & ButtonFlags_PressedOnDoubleClick) &&
             g.IO.MouseClickedCount[mouse_button_clicked] == 2)) {
          pressed = true;
          if (flags & ButtonFlags_NoHoldingActiveId)
            ClearActiveID();
          else
            SetActiveID(id, window); // Hold on ID
          if (!(flags & ButtonFlags_NoNavFocus))
            SetFocusID(id, window);
          g.ActiveIdMouseButton = mouse_button_clicked;
          FocusWindow(window);
        }
      }
      if (flags & ButtonFlags_PressedOnRelease) {
        if (mouse_button_released != -1) {
          const bool has_repeated_at_least_once =
              (item_flags & ItemFlags_ButtonRepeat) &&
              g.IO.MouseDownDurationPrev[mouse_button_released] >=
                  g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior
          if (!has_repeated_at_least_once)
            pressed = true;
          if (!(flags & ButtonFlags_NoNavFocus))
            SetFocusID(id, window);
          ClearActiveID();
        }
      }

      // 'Repeat' mode acts when held regardless of _PressedOn flags (see table
      // above). Relies on repeat logic of IsMouseClicked() but we may as well
      // do it ourselves if we end up exposing finer RepeatDelay/RepeatRate
      // settings.
      if (g.ActiveId == id && (item_flags & ItemFlags_ButtonRepeat))
        if (g.IO.MouseDownDuration[g.ActiveIdMouseButton] > 0.0f &&
            IsMouseClicked(g.ActiveIdMouseButton, test_owner_id,
                           InputFlags_Repeat))
          pressed = true;
    }

    if (pressed)
      g.NavDisableHighlight = true;
  }

  // Gamepad/Keyboard navigation
  // We report navigated item as hovered but we don't set g.HoveredId to not
  // interfere with mouse.
  if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover &&
      (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))
    if (!(flags & ButtonFlags_NoHoveredOnFocus))
      hovered = true;
  if (g.NavActivateDownId == id) {
    bool nav_activated_by_code = (g.NavActivateId == id);
    bool nav_activated_by_inputs = (g.NavActivatePressedId == id);
    if (!nav_activated_by_inputs && (item_flags & ItemFlags_ButtonRepeat)) {
      // Avoid pressing multiple keys from triggering excessive amount of repeat
      // events
      const KeyData *key1 = GetKeyData(Key_Space);
      const KeyData *key2 = GetKeyData(Key_Enter);
      const KeyData *key3 = GetKeyData(Key_NavGamepadActivate);
      const float t1 =
          Max(Max(key1->DownDuration, key2->DownDuration), key3->DownDuration);
      nav_activated_by_inputs =
          CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1,
                                    g.IO.KeyRepeatDelay,
                                    g.IO.KeyRepeatRate) > 0;
    }
    if (nav_activated_by_code || nav_activated_by_inputs) {
      // Set active id so it can be queried by user via IsItemActive(),
      // equivalent of holding the mouse button.
      pressed = true;
      SetActiveID(id, window);
      g.ActiveIdSource = g.NavInputSource;
      if (!(flags & ButtonFlags_NoNavFocus))
        SetFocusID(id, window);
    }
  }

  // Process while held
  bool held = false;
  if (g.ActiveId == id) {
    if (g.ActiveIdSource == InputSource_Mouse) {
      if (g.ActiveIdIsJustActivated)
        g.ActiveIdClickOffset = Subtract(g.IO.MousePos, bb.Min);

      const int mouse_button = g.ActiveIdMouseButton;
      if (mouse_button == -1) {
        // Fallback for the rare situation were g.ActiveId was set
        // programmatically or from another widget (e.g. #6304).
        ClearActiveID();
      } else if (IsMouseDown(mouse_button, test_owner_id)) {
        held = true;
      } else {
        bool release_in =
            hovered && (flags & ButtonFlags_PressedOnClickRelease) != 0;
        bool release_anywhere =
            (flags & ButtonFlags_PressedOnClickReleaseAnywhere) != 0;
        if ((release_in || release_anywhere) && !g.DragDropActive) {
          // Report as pressed when releasing the mouse (this is the most common
          // path)
          bool is_double_click_release =
              (flags & ButtonFlags_PressedOnDoubleClick) &&
              g.IO.MouseReleased[mouse_button] &&
              g.IO.MouseClickedLastCount[mouse_button] == 2;
          bool is_repeating_already =
              (item_flags & ItemFlags_ButtonRepeat) &&
              g.IO.MouseDownDurationPrev[mouse_button] >=
                  g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
          bool is_button_avail_or_owned =
              TestKeyOwner(MouseButtonToKey(mouse_button), test_owner_id);
          if (!is_double_click_release && !is_repeating_already &&
              is_button_avail_or_owned)
            pressed = true;
        }
        ClearActiveID();
      }
      if (!(flags & ButtonFlags_NoNavFocus))
        g.NavDisableHighlight = true;
    } else if (g.ActiveIdSource == InputSource_Keyboard ||
               g.ActiveIdSource == InputSource_Gamepad) {
      // When activated using Nav, we hold on the ActiveID until activation
      // button is released
      if (g.NavActivateDownId != id)
        ClearActiveID();
    }
    if (pressed)
      g.ActiveIdHasBeenPressedBefore = true;
  }

  if (out_hovered)
    *out_hovered = hovered;
  if (out_held)
    *out_held = held;

  return pressed;
}

inline bool Gui::ButtonEx(const char *label, const Vec2 &size_arg,
                          ButtonFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  const Style &style = g.Style;
  const ID id = window->GetID(label);
  const Vec2 label_size = CalcTextSize(label, NULL, true);

  Vec2 pos = window->DC.CursorPos;
  if ((flags & ButtonFlags_AlignTextBaseLine) &&
      style.FramePadding.y <
          window->DC
              .CurrLineTextBaseOffset) // Try to vertically align buttons that
                                       // are smaller/have no padding so that
                                       // text baseline matches (bit hacky,
                                       // since it shouldn't be a flag)
    pos.y += window->DC.CurrLineTextBaseOffset - style.FramePadding.y;
  Vec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f,
                           label_size.y + style.FramePadding.y * 2.0f);

  const Rect bb(pos, Add(pos, size));
  ItemSize(size, style.FramePadding.y);
  if (!ItemAdd(bb, id))
    return false;

  bool hovered, held;
  bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

  // Render
  const U32 col = GetColorU32((held && hovered) ? Col_ButtonActive
                              : hovered         ? Col_ButtonHovered
                                                : Col_Button);
  RenderNavHighlight(bb, id);
  RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);

  if (g.LogEnabled)
    LogSetNextTextDecoration("[", "]");
  RenderTextClipped(Add(bb.Min, style.FramePadding),
                    Subtract(bb.Max, style.FramePadding), label, NULL,
                    &label_size, style.ButtonTextAlign, &bb);

  // Automatically close popups
  // if (pressed && !(flags & ButtonFlags_DontClosePopups) &&
  // (window->Flags & WindowFlags_Popup))
  //    CloseCurrentPopup();

  GUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
  return pressed;
}

inline bool Gui::Button(const char *label, const Vec2 &size_arg) {
  return ButtonEx(label, size_arg, ButtonFlags_None);
}

// Small buttons fits within text without additional vertical spacing.
inline bool Gui::SmallButton(const char *label) {
  Context &g = *GGui;
  float backup_padding_y = g.Style.FramePadding.y;
  g.Style.FramePadding.y = 0.0f;
  bool pressed = ButtonEx(label, Vec2(0, 0), ButtonFlags_AlignTextBaseLine);
  g.Style.FramePadding.y = backup_padding_y;
  return pressed;
}

// Tip: use Gui::PushID()/PopID() to push indices or pointers in the ID stack.
// Then you can keep 'str_id' empty or the same for all your buttons (instead of
// creating a string based on a non-string id)
inline bool Gui::InvisibleButton(const char *str_id, const Vec2 &size_arg,
                                 ButtonFlags flags) {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not
  // way to fallback using the label size.
  GUI_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);

  const ID id = window->GetID(str_id);
  Vec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);
  const Rect bb(window->DC.CursorPos, Add(window->DC.CursorPos, size));
  ItemSize(size);
  if (!ItemAdd(bb, id))
    return false;

  bool hovered, held;
  bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

  GUI_TEST_ENGINE_ITEM_INFO(id, str_id, g.LastItemData.StatusFlags);
  return pressed;
}

inline bool Gui::ArrowButtonEx(const char *str_id, Dir dir, Vec2 size,
                               ButtonFlags flags) {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  const ID id = window->GetID(str_id);
  const Rect bb(window->DC.CursorPos, Add(window->DC.CursorPos, size));
  const float default_size = GetFrameHeight();
  ItemSize(size, (size.y >= default_size) ? g.Style.FramePadding.y : -1.0f);
  if (!ItemAdd(bb, id))
    return false;

  bool hovered, held;
  bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

  // Render
  const U32 bg_col = GetColorU32((held && hovered) ? Col_ButtonActive
                                 : hovered         ? Col_ButtonHovered
                                                   : Col_Button);
  const U32 text_col = GetColorU32(Col_Text);
  RenderNavHighlight(bb, id);
  RenderFrame(bb.Min, bb.Max, bg_col, true, g.Style.FrameRounding);
  RenderArrow(window->DrawList,
              Add(bb.Min, Vec2(Max(0.0f, (size.x - g.FontSize) * 0.5f),
                               Max(0.0f, (size.y - g.FontSize) * 0.5f))),
              text_col, dir);

  GUI_TEST_ENGINE_ITEM_INFO(id, str_id, g.LastItemData.StatusFlags);
  return pressed;
}

inline bool Gui::ArrowButton(const char *str_id, Dir dir) {
  float sz = GetFrameHeight();
  return ArrowButtonEx(str_id, dir, Vec2(sz, sz), ButtonFlags_None);
}

// Button to close a window
inline bool Gui::CloseButton(ID id, const Vec2 &pos) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  // Tweak 1: Shrink hit-testing area if button covers an abnormally large
  // proportion of the visible region. That's in order to facilitate moving the
  // window away. (#3825) This may better be applied as a general hit-rect
  // reduction mechanism for all widgets to ensure the area to move window is
  // always accessible?
  const Rect bb(pos, Add(pos, Vec2(g.FontSize, g.FontSize)));
  Rect bb_interact = bb;
  const float area_to_visible_ratio =
      window->OuterRectClipped.GetArea() / bb.GetArea();
  if (area_to_visible_ratio < 1.5f)
    bb_interact.Expand(Trunc(Multiply(bb_interact.GetSize(), -0.25f)));

  // Tweak 2: We intentionally allow interaction when clipped so that a
  // mechanical Alt,Right,Activate sequence can always close a window. (this
  // isn't the common behavior of buttons, but it doesn't affect the user
  // because navigation tends to keep items visible in scrolling layer).
  bool is_clipped = !ItemAdd(bb_interact, id);

  bool hovered, held;
  bool pressed = ButtonBehavior(bb_interact, id, &hovered, &held);
  if (is_clipped)
    return pressed;

  // Render
  // FIXME: Clarify this mess
  U32 col = GetColorU32(held ? Col_ButtonActive : Col_ButtonHovered);
  Vec2 center = bb.GetCenter();
  if (hovered)
    window->DrawList->AddCircleFilled(center,
                                      Max(2.0f, g.FontSize * 0.5f + 1.0f), col);

  float cross_extent = g.FontSize * 0.5f * 0.7071f - 1.0f;
  U32 cross_col = GetColorU32(Col_Text);
  center = Subtract(center, Vec2(0.5f, 0.5f));
  window->DrawList->AddLine(Add(center, Vec2(+cross_extent, +cross_extent)),
                            Add(center, Vec2(-cross_extent, -cross_extent)),
                            cross_col, 1.0f);
  window->DrawList->AddLine(Add(center, Vec2(+cross_extent, -cross_extent)),
                            Add(center, Vec2(-cross_extent, +cross_extent)),
                            cross_col, 1.0f);

  return pressed;
}

inline bool Gui::CollapseButton(ID id, const Vec2 &pos) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  Rect bb(pos, Add(pos, Vec2(g.FontSize, g.FontSize)));
  bool is_clipped = !ItemAdd(bb, id);
  bool hovered, held;
  bool pressed = ButtonBehavior(bb, id, &hovered, &held, ButtonFlags_None);
  if (is_clipped)
    return pressed;

  // Render
  U32 bg_col = GetColorU32((held && hovered) ? Col_ButtonActive
                           : hovered         ? Col_ButtonHovered
                                             : Col_Button);
  U32 text_col = GetColorU32(Col_Text);
  if (hovered || held)
    window->DrawList->AddCircleFilled(Add(bb.GetCenter(), Vec2(0.0f, -0.5f)),
                                      g.FontSize * 0.5f + 1.0f, bg_col);
  RenderArrow(window->DrawList, bb.Min, text_col,
              window->Collapsed ? Dir_Right : Dir_Down, 1.0f);

  // Switch to moving the window after mouse is moved beyond the initial drag
  // threshold
  if (IsItemActive() && IsMouseDragging(0))
    StartMouseMovingWindow(window);

  return pressed;
}

// Return scrollbar rectangle, must only be called for corresponding axis if
// window->ScrollbarX/Y is set.
inline Rect Gui::GetWindowScrollbarRect(Window *window, Axis axis) {
  const Rect outer_rect = window->Rect();
  const Rect inner_rect = window->InnerRect;
  const float border_size = window->WindowBorderSize;
  const float scrollbar_size =
      window->ScrollbarSizes[axis ^
                             1]; // (ScrollbarSizes.x = width of Y scrollbar;
                                 // ScrollbarSizes.y = height of X scrollbar)
  GUI_ASSERT(scrollbar_size > 0.0f);
  if (axis == Axis_X)
    return Rect(
        inner_rect.Min.x,
        Max(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size),
        inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);
  else
    return Rect(
        Max(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size),
        inner_rect.Min.y, outer_rect.Max.x - border_size,
        inner_rect.Max.y - border_size);
}

inline void Gui::Scrollbar(Axis axis) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  const ID id = GetWindowScrollbarID(window, axis);

  // Calculate scrollbar bounding box
  Rect bb = GetWindowScrollbarRect(window, axis);
  DrawFlags rounding_corners = DrawFlags_RoundCornersNone;
  if (axis == Axis_X) {
    rounding_corners |= DrawFlags_RoundCornersBottomLeft;
    if (!window->ScrollbarY)
      rounding_corners |= DrawFlags_RoundCornersBottomRight;
  } else {
    if ((window->Flags & WindowFlags_NoTitleBar) &&
        !(window->Flags & WindowFlags_MenuBar))
      rounding_corners |= DrawFlags_RoundCornersTopRight;
    if (!window->ScrollbarX)
      rounding_corners |= DrawFlags_RoundCornersBottomRight;
  }
  float size_avail = window->InnerRect.Max[axis] - window->InnerRect.Min[axis];
  float size_contents =
      window->ContentSize[axis] + window->WindowPadding[axis] * 2.0f;
  S64 scroll = (S64)window->Scroll[axis];
  ScrollbarEx(bb, id, axis, &scroll, (S64)size_avail, (S64)size_contents,
              rounding_corners);
  window->Scroll[axis] = (float)scroll;
}

// Vertical/Horizontal scrollbar
// The entire piece of code below is rather confusing because:
// - We handle absolute seeking (when first clicking outside the grab) and
// relative manipulation (afterward or when clicking inside the grab)
// - We store values as normalized ratio and in a form that allows the window
// content to change while we are holding on a scrollbar
// - We handle both horizontal and vertical scrollbars, which makes the
// terminology not ideal. Still, the code should probably be made simpler..
inline bool Gui::ScrollbarEx(const Rect &bb_frame, ID id, Axis axis,
                             S64 *p_scroll_v, S64 size_avail_v,
                             S64 size_contents_v, DrawFlags flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return false;

  const float bb_frame_width = bb_frame.GetWidth();
  const float bb_frame_height = bb_frame.GetHeight();
  if (bb_frame_width <= 0.0f || bb_frame_height <= 0.0f)
    return false;

  // When we are too small, start hiding and disabling the grab (this reduce
  // visual noise on very small window and facilitate using the window resize
  // grab)
  float alpha = 1.0f;
  if ((axis == Axis_Y) &&
      bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0f)
    alpha = Saturate((bb_frame_height - g.FontSize) /
                     (g.Style.FramePadding.y * 2.0f));
  if (alpha <= 0.0f)
    return false;

  const Style &style = g.Style;
  const bool allow_interaction = (alpha >= 1.0f);

  Rect bb = bb_frame;
  bb.Expand(
      Vec2(-Clamp(GUI_TRUNC((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f),
           -Clamp(GUI_TRUNC((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));

  // V denote the main, longer axis of the scrollbar (= height for a vertical
  // scrollbar)
  const float scrollbar_size_v =
      (axis == Axis_X) ? bb.GetWidth() : bb.GetHeight();

  // Calculate the height of our grabbable box. It generally represent the
  // amount visible (vs the total scrollable amount) But we maintain a minimum
  // size in pixel to allow for the user to still aim inside.
  GUI_ASSERT(Max(size_contents_v, size_avail_v) >
             0.0f); // Adding this assert to check if the Max(XXX,1.0f) is
                    // still needed. PLEASE CONTACT ME if this triggers.
  const S64 win_size_v = Max(Max(size_contents_v, size_avail_v), (S64)1);
  const float grab_h_pixels =
      Clamp(scrollbar_size_v * ((float)size_avail_v / (float)win_size_v),
            style.GrabMinSize, scrollbar_size_v);
  const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

  // Handle input right away. None of the code of Begin() is relying on
  // scrolling position before calling Scrollbar().
  bool held = false;
  bool hovered = false;
  ItemAdd(bb_frame, id, NULL, ItemFlags_NoNav);
  ButtonBehavior(bb, id, &hovered, &held, ButtonFlags_NoNavFocus);

  const S64 scroll_max = Max((S64)1, size_contents_v - size_avail_v);
  float scroll_ratio = Saturate((float)*p_scroll_v / (float)scroll_max);
  float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) /
                      scrollbar_size_v; // Grab position in normalized space
  if (held && allow_interaction && grab_h_norm < 1.0f) {
    const float scrollbar_pos_v = bb.Min[axis];
    const float mouse_pos_v = g.IO.MousePos[axis];

    // Click position in scrollbar normalized space (0.0f->1.0f)
    const float clicked_v_norm =
        Saturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
    SetHoveredID(id);

    bool seek_absolute = false;
    if (g.ActiveIdIsJustActivated) {
      // On initial click calculate the distance between mouse and the center of
      // the grab
      seek_absolute = (clicked_v_norm < grab_v_norm ||
                       clicked_v_norm > grab_v_norm + grab_h_norm);
      if (seek_absolute)
        g.ScrollbarClickDeltaToGrabCenter = 0.0f;
      else
        g.ScrollbarClickDeltaToGrabCenter =
            clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
    }

    // Apply scroll (p_scroll_v will generally point on one member of
    // window->Scroll) It is ok to modify Scroll here because we are being
    // called in Begin() after the calculation of ContentSize and before setting
    // up our starting position
    const float scroll_v_norm =
        Saturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter -
                  grab_h_norm * 0.5f) /
                 (1.0f - grab_h_norm));
    *p_scroll_v = (S64)(scroll_v_norm * scroll_max);

    // Update values for rendering
    scroll_ratio = Saturate((float)*p_scroll_v / (float)scroll_max);
    grab_v_norm =
        scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

    // Update distance to grab now that we have seeked and saturated
    if (seek_absolute)
      g.ScrollbarClickDeltaToGrabCenter =
          clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
  }

  // Render
  const U32 bg_col = GetColorU32(Col_ScrollbarBg);
  const U32 grab_col = GetColorU32(held      ? Col_ScrollbarGrabActive
                                   : hovered ? Col_ScrollbarGrabHovered
                                             : Col_ScrollbarGrab,
                                   alpha);
  window->DrawList->AddRectFilled(bb_frame.Min, bb_frame.Max, bg_col,
                                  window->WindowRounding, flags);
  Rect grab_rect;
  if (axis == Axis_X)
    grab_rect =
        Rect(Lerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y,
             Lerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);
  else
    grab_rect = Rect(bb.Min.x, Lerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x,
                     Lerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);
  window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col,
                                  style.ScrollbarRounding);

  return held;
}

inline void Gui::Image(TextureID user_texture_id, const Vec2 &image_size,
                       const Vec2 &uv0, const Vec2 &uv1, const Vec4 &tint_col,
                       const Vec4 &border_col) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;

  const float border_size = (border_col.w > 0.0f) ? 1.0f : 0.0f;
  const Vec2 padding(border_size, border_size);
  const Rect bb(window->DC.CursorPos, Add(Add(window->DC.CursorPos, image_size),
                                          Multiply(padding, 2.0f)));
  ItemSize(bb);
  if (!ItemAdd(bb, 0))
    return;

  // Render
  if (border_size > 0.0f)
    window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f,
                              DrawFlags_None, border_size);
  window->DrawList->AddImage(user_texture_id, Add(bb.Min, padding),
                             Subtract(bb.Max, padding), uv0, uv1,
                             GetColorU32(tint_col));
}

// ImageButton() is flawed as 'id' is always derived from 'texture_id' (see
// #2464 #1390) We provide this internal helper to write your own variant while
// we figure out how to redesign the public ImageButton() API.
inline bool Gui::ImageButtonEx(ID id, TextureID texture_id,
                               const Vec2 &image_size, const Vec2 &uv0,
                               const Vec2 &uv1, const Vec4 &bg_col,
                               const Vec4 &tint_col, ButtonFlags flags) {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  const Vec2 padding = g.Style.FramePadding;
  const Rect bb(window->DC.CursorPos, Add(Add(window->DC.CursorPos, image_size),
                                          Multiply(padding, 2.0f)));
  ItemSize(bb);
  if (!ItemAdd(bb, id))
    return false;

  bool hovered, held;
  bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

  // Render
  const U32 col = GetColorU32((held && hovered) ? Col_ButtonActive
                              : hovered         ? Col_ButtonHovered
                                                : Col_Button);
  RenderNavHighlight(bb, id);
  RenderFrame(
      bb.Min, bb.Max, col, true,
      Clamp((float)Min(padding.x, padding.y), 0.0f, g.Style.FrameRounding));
  if (bg_col.w > 0.0f)
    window->DrawList->AddRectFilled(
        Add(bb.Min, padding), Subtract(bb.Max, padding), GetColorU32(bg_col));
  window->DrawList->AddImage(texture_id, Add(bb.Min, padding),
                             Subtract(bb.Max, padding), uv0, uv1,
                             GetColorU32(tint_col));

  return pressed;
}

// Note that ImageButton() adds style.FramePadding*2.0f to provided size. This
// is in order to facilitate fitting an image in a button.
inline bool Gui::ImageButton(const char *str_id, TextureID user_texture_id,
                             const Vec2 &image_size, const Vec2 &uv0,
                             const Vec2 &uv1, const Vec4 &bg_col,
                             const Vec4 &tint_col) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return false;

  return ImageButtonEx(window->GetID(str_id), user_texture_id, image_size, uv0,
                       uv1, bg_col, tint_col);
}

#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
// Legacy API obsoleted in 1.89. Two differences with new ImageButton()
// - new ImageButton() requires an explicit 'const char* str_id'    Old
// ImageButton() used opaque imTextureId (created issue with: multiple buttons
// with same image, transient texture id values, opaque computation of ID)
// - new ImageButton() always use style.FramePadding                Old
// ImageButton() had an override argument. If you need to change padding with
// new ImageButton() you can use PushStyleVar(StyleVar_FramePadding,
// value), consistent with other Button functions.
inline bool Gui::ImageButton(TextureID user_texture_id, const Vec2 &size,
                             const Vec2 &uv0, const Vec2 &uv1,
                             int frame_padding, const Vec4 &bg_col,
                             const Vec4 &tint_col) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return false;

  // Default to using texture ID as ID. User can still push string/integer
  // prefixes.
  PushID((void *)(intptr_t)user_texture_id);
  const ID id = window->GetID("#image");
  PopID();

  if (frame_padding >= 0)
    PushStyleVar(StyleVar_FramePadding,
                 Vec2((float)frame_padding, (float)frame_padding));
  bool ret =
      ImageButtonEx(id, user_texture_id, size, uv0, uv1, bg_col, tint_col);
  if (frame_padding >= 0)
    PopStyleVar();
  return ret;
}
#endif // #ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS

inline bool Gui::Checkbox(const char *label, bool *v) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  const Style &style = g.Style;
  const ID id = window->GetID(label);
  const Vec2 label_size = CalcTextSize(label, NULL, true);

  const float square_sz = GetFrameHeight();
  const Vec2 pos = window->DC.CursorPos;
  const Rect total_bb(
      pos,
      Add(pos, Vec2(square_sz + (label_size.x > 0.0f
                                     ? style.ItemInnerSpacing.x + label_size.x
                                     : 0.0f),
                    label_size.y + style.FramePadding.y * 2.0f)));
  ItemSize(total_bb, style.FramePadding.y);
  if (!ItemAdd(total_bb, id)) {
    GUI_TEST_ENGINE_ITEM_INFO(id, label,
                              g.LastItemData.StatusFlags |
                                  ItemStatusFlags_Checkable |
                                  (*v ? ItemStatusFlags_Checked : 0));
    return false;
  }

  bool hovered, held;
  bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
  if (pressed) {
    *v = !(*v);
    MarkItemEdited(id);
  }

  const Rect check_bb(pos, Add(pos, Vec2(square_sz, square_sz)));
  RenderNavHighlight(total_bb, id);
  RenderFrame(check_bb.Min, check_bb.Max,
              GetColorU32((held && hovered) ? Col_FrameBgActive
                          : hovered         ? Col_FrameBgHovered
                                            : Col_FrameBg),
              true, style.FrameRounding);
  U32 check_col = GetColorU32(Col_CheckMark);
  bool mixed_value = (g.LastItemData.InFlags & ItemFlags_MixedValue) != 0;
  if (mixed_value) {
    // Undocumented tristate/mixed/indeterminate checkbox (#2644)
    // This may seem awkwardly designed because the aim is to make
    // ItemFlags_MixedValue supported by all widgets (not just checkbox)
    Vec2 pad(Max(1.0f, GUI_TRUNC(square_sz / 3.6f)),
             Max(1.0f, GUI_TRUNC(square_sz / 3.6f)));
    window->DrawList->AddRectFilled(Add(check_bb.Min, pad),
                                    Subtract(check_bb.Max, pad), check_col,
                                    style.FrameRounding);
  } else if (*v) {
    const float pad = Max(1.0f, GUI_TRUNC(square_sz / 6.0f));
    RenderCheckMark(window->DrawList, Add(check_bb.Min, Vec2(pad, pad)),
                    check_col, square_sz - pad * 2.0f);
  }

  Vec2 label_pos = Vec2(check_bb.Max.x + style.ItemInnerSpacing.x,
                        check_bb.Min.y + style.FramePadding.y);
  if (g.LogEnabled)
    LogRenderedText(&label_pos, mixed_value ? "[~]" : *v ? "[x]" : "[ ]");
  if (label_size.x > 0.0f)
    RenderText(label_pos, label);

  GUI_TEST_ENGINE_ITEM_INFO(id, label,
                            g.LastItemData.StatusFlags |
                                ItemStatusFlags_Checkable |
                                (*v ? ItemStatusFlags_Checked : 0));
  return pressed;
}

template <typename T>
bool Gui::CheckboxFlagsT(const char *label, T *flags, T flags_value) {
  bool all_on = (*flags & flags_value) == flags_value;
  bool any_on = (*flags & flags_value) != 0;
  bool pressed;
  if (!all_on && any_on) {
    Context &g = *GGui;
    g.NextItemData.ItemFlags |= ItemFlags_MixedValue;
    pressed = Checkbox(label, &all_on);
  } else {
    pressed = Checkbox(label, &all_on);
  }
  if (pressed) {
    if (all_on)
      *flags |= flags_value;
    else
      *flags &= ~flags_value;
  }
  return pressed;
}

inline bool Gui::CheckboxFlags(const char *label, int *flags, int flags_value) {
  return CheckboxFlagsT(label, flags, flags_value);
}

inline bool Gui::CheckboxFlags(const char *label, unsigned int *flags,
                               unsigned int flags_value) {
  return CheckboxFlagsT(label, flags, flags_value);
}

inline bool Gui::CheckboxFlags(const char *label, S64 *flags, S64 flags_value) {
  return CheckboxFlagsT(label, flags, flags_value);
}

inline bool Gui::CheckboxFlags(const char *label, U64 *flags, U64 flags_value) {
  return CheckboxFlagsT(label, flags, flags_value);
}

inline bool Gui::RadioButton(const char *label, bool active) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  const Style &style = g.Style;
  const ID id = window->GetID(label);
  const Vec2 label_size = CalcTextSize(label, NULL, true);

  const float square_sz = GetFrameHeight();
  const Vec2 pos = window->DC.CursorPos;
  const Rect check_bb(pos, Add(pos, Vec2(square_sz, square_sz)));
  const Rect total_bb(
      pos,
      Add(pos, Vec2(square_sz + (label_size.x > 0.0f
                                     ? style.ItemInnerSpacing.x + label_size.x
                                     : 0.0f),
                    label_size.y + style.FramePadding.y * 2.0f)));
  ItemSize(total_bb, style.FramePadding.y);
  if (!ItemAdd(total_bb, id))
    return false;

  Vec2 center = check_bb.GetCenter();
  center.x = GUI_ROUND(center.x);
  center.y = GUI_ROUND(center.y);
  const float radius = (square_sz - 1.0f) * 0.5f;

  bool hovered, held;
  bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
  if (pressed)
    MarkItemEdited(id);

  RenderNavHighlight(total_bb, id);
  const int num_segment = window->DrawList->_CalcCircleAutoSegmentCount(radius);
  window->DrawList->AddCircleFilled(center, radius,
                                    GetColorU32((held && hovered)
                                                    ? Col_FrameBgActive
                                                : hovered ? Col_FrameBgHovered
                                                          : Col_FrameBg),
                                    num_segment);
  if (active) {
    const float pad = Max(1.0f, GUI_TRUNC(square_sz / 6.0f));
    window->DrawList->AddCircleFilled(center, radius - pad,
                                      GetColorU32(Col_CheckMark));
  }

  if (style.FrameBorderSize > 0.0f) {
    window->DrawList->AddCircle(Add(center, Vec2(1, 1)), radius,
                                GetColorU32(Col_BorderShadow), num_segment,
                                style.FrameBorderSize);
    window->DrawList->AddCircle(center, radius, GetColorU32(Col_Border),
                                num_segment, style.FrameBorderSize);
  }

  Vec2 label_pos = Vec2(check_bb.Max.x + style.ItemInnerSpacing.x,
                        check_bb.Min.y + style.FramePadding.y);
  if (g.LogEnabled)
    LogRenderedText(&label_pos, active ? "(x)" : "( )");
  if (label_size.x > 0.0f)
    RenderText(label_pos, label);

  GUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
  return pressed;
}

// FIXME: This would work nicely if it was a public template, e.g. 'template<T>
// RadioButton(const char* label, T* v, T v_button)', but I'm not sure how we
// would expose it..

// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified
// size
inline void Gui::ProgressBar(float fraction, const Vec2 &size_arg,
                             const char *overlay) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;

  Context &g = *GGui;
  const Style &style = g.Style;

  Vec2 pos = window->DC.CursorPos;
  Vec2 size = CalcItemSize(size_arg, CalcItemWidth(),
                           g.FontSize + style.FramePadding.y * 2.0f);
  Rect bb(pos, Add(pos, size));
  ItemSize(size, style.FramePadding.y);
  if (!ItemAdd(bb, 0))
    return;

  // Render
  fraction = Saturate(fraction);
  RenderFrame(bb.Min, bb.Max, GetColorU32(Col_FrameBg), true,
              style.FrameRounding);
  bb.Expand(Vec2(-style.FrameBorderSize, -style.FrameBorderSize));
  const Vec2 fill_br = Vec2(Lerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);
  RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(Col_PlotHistogram),
                         0.0f, fraction, style.FrameRounding);

  // Default displaying the fraction as percentage string, but user can override
  // it
  char overlay_buf[32];
  if (!overlay) {
    FormatString(overlay_buf, GUI_ARRAYSIZE(overlay_buf), "%.0f%%",
                 fraction * 100 + 0.01f);
    overlay = overlay_buf;
  }

  Vec2 overlay_size = CalcTextSize(overlay, NULL);
  if (overlay_size.x > 0.0f)
    RenderTextClipped(
        Vec2(Clamp(fill_br.x + style.ItemSpacing.x, bb.Min.x,
                   bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x),
             bb.Min.y),
        bb.Max, overlay, NULL, &overlay_size, Vec2(0.0f, 0.5f), &bb);
}

inline void Gui::Bullet() {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;

  Context &g = *GGui;
  const Style &style = g.Style;
  const float line_height =
      Max(Min(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2),
          g.FontSize);
  const Rect bb(window->DC.CursorPos,
                Add(window->DC.CursorPos, Vec2(g.FontSize, line_height)));
  ItemSize(bb);
  if (!ItemAdd(bb, 0)) {
    SameLine(0, style.FramePadding.x * 2);
    return;
  }

  // Render and stay on same line
  U32 text_col = GetColorU32(Col_Text);
  RenderBullet(window->DrawList,
               Add(bb.Min, Vec2(style.FramePadding.x + g.FontSize * 0.5f,
                                line_height * 0.5f)),
               text_col);
  SameLine(0, style.FramePadding.x * 2.0f);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Low-level Layout helpers
//-------------------------------------------------------------------------
// - Spacing()
// - Dummy()
// - NewLine()
// - AlignTextToFramePadding()
// - SeparatorEx() [Internal]
// - Separator()
// - SplitterBehavior() [Internal]
// - ShrinkWidths() [Internal]
//-------------------------------------------------------------------------

inline void Gui::Spacing() {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;
  ItemSize(Vec2(0, 0));
}

inline void Gui::Dummy(const Vec2 &size) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;

  const Rect bb(window->DC.CursorPos, Add(window->DC.CursorPos, size));
  ItemSize(size);
  ItemAdd(bb, 0);
}

inline void Gui::NewLine() {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;

  Context &g = *GGui;
  const LayoutType backup_layout_type = window->DC.LayoutType;
  window->DC.LayoutType = LayoutType_Vertical;
  window->DC.IsSameLine = false;
  if (window->DC.CurrLineSize.y >
      0.0f) // In the event that we are on a line with items that is smaller
            // that FontSize high, we will preserve its height.
    ItemSize(Vec2(0, 0));
  else
    ItemSize(Vec2(0.0f, g.FontSize));
  window->DC.LayoutType = backup_layout_type;
}

inline void Gui::AlignTextToFramePadding() {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;

  Context &g = *GGui;
  window->DC.CurrLineSize.y =
      Max(window->DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);
  window->DC.CurrLineTextBaseOffset =
      Max(window->DC.CurrLineTextBaseOffset, g.Style.FramePadding.y);
}

// Horizontal/vertical separating line
// FIXME: Surprisingly, this seemingly trivial widget is a victim of many
// different legacy/tricky layout issues. Note how thickness == 1.0f is handled
// specifically as not moving CursorPos by 'thickness', but other values are.
inline void Gui::SeparatorEx(SeparatorFlags flags, float thickness) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;

  Context &g = *GGui;
  GUI_ASSERT(IsPowerOfTwo(
      flags &
      (SeparatorFlags_Horizontal |
       SeparatorFlags_Vertical))); // Check that only 1 option is selected
  GUI_ASSERT(thickness > 0.0f);

  if (flags & SeparatorFlags_Vertical) {
    // Vertical separator, for menu bars (use current line height).
    float y1 = window->DC.CursorPos.y;
    float y2 = window->DC.CursorPos.y + window->DC.CurrLineSize.y;
    const Rect bb(Vec2(window->DC.CursorPos.x, y1),
                  Vec2(window->DC.CursorPos.x + thickness, y2));
    ItemSize(Vec2(thickness, 0.0f));
    if (!ItemAdd(bb, 0))
      return;

    // Draw
    window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(Col_Separator));
    if (g.LogEnabled)
      LogText(" |");
  } else if (flags & SeparatorFlags_Horizontal) {
    // Horizontal Separator
    float x1 = window->DC.CursorPos.x;
    float x2 = window->WorkRect.Max.x;

    // Preserve legacy behavior inside Columns()
    // Before Tables API happened, we relied on Separator() to span all columns
    // of a Columns() set. We currently don't need to provide the same feature
    // for tables because tables naturally have border features.
    OldColumns *columns = (flags & SeparatorFlags_SpanAllColumns)
                              ? window->DC.CurrentColumns
                              : NULL;
    if (columns) {
      x1 = window->Pos.x +
           window->DC.Indent.x; // Used to be Pos.x before 2023/10/03
      x2 = window->Pos.x + window->Size.x;
      PushColumnsBackground();
    }

    // We don't provide our width to the layout so that it doesn't get feed back
    // into AutoFit
    // FIXME: This prevents ->CursorMaxPos based bounding box evaluation from
    // working (e.g. TableEndCell)
    const float thickness_for_layout =
        (thickness == 1.0f)
            ? 0.0f
            : thickness; // FIXME: See 1.70/1.71 Separator() change: makes
                         // legacy 1-px separator not affect layout yet. Should
                         // change.
    const Rect bb(Vec2(x1, window->DC.CursorPos.y),
                  Vec2(x2, window->DC.CursorPos.y + thickness));
    ItemSize(Vec2(0.0f, thickness_for_layout));

    if (ItemAdd(bb, 0)) {
      // Draw
      window->DrawList->AddRectFilled(bb.Min, bb.Max,
                                      GetColorU32(Col_Separator));
      if (g.LogEnabled)
        LogRenderedText(&bb.Min, "--------------------------------\n");
    }
    if (columns) {
      PopColumnsBackground();
      columns->LineMinY = window->DC.CursorPos.y;
    }
  }
}

inline void Gui::Separator() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return;

  // Those flags should eventually be configurable by the user
  // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it
  // relates to SeparatorText() which is a decorated separator, not defaulting
  // to 1.0f.
  SeparatorFlags flags = (window->DC.LayoutType == LayoutType_Horizontal)
                             ? SeparatorFlags_Vertical
                             : SeparatorFlags_Horizontal;

  // Only applies to legacy Columns() api as they relied on Separator() a lot.
  if (window->DC.CurrentColumns)
    flags |= SeparatorFlags_SpanAllColumns;

  SeparatorEx(flags, 1.0f);
}

inline void Gui::SeparatorText(const char *label) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;

  // The SeparatorText() vs SeparatorTextEx() distinction is designed to be
  // considerate that we may want:
  // - allow separator-text to be draggable items (would require a stable ID + a
  // noticeable highlight)
  // - this high-level entry point to allow formatting? (which in turns may
  // require ID separate from formatted string)
  // - because of this we probably can't turn 'const char* label' into 'const
  // char* fmt, ...' Otherwise, we can decide that users wanting to drag this
  // would layout a dedicated drag-item, and then we can turn this into a format
  // function.
  SeparatorTextEx(0, label, FindRenderedTextEnd(label), 0.0f);
}

// Using 'hover_visibility_delay' allows us to hide the highlight and mouse
// cursor for a short time, which can be convenient to reduce visual noise.
inline bool Gui::SplitterBehavior(const Rect &bb, ID id, Axis axis,
                                  float *size1, float *size2, float min_size1,
                                  float min_size2, float hover_extend,
                                  float hover_visibility_delay, U32 bg_col) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  if (!ItemAdd(bb, id, NULL, ItemFlags_NoNav))
    return false;

  // FIXME: AFAIK the only leftover reason for passing
  // ButtonFlags_AllowOverlap here is to allow caller of SplitterBehavior()
  // to call SetItemAllowOverlap() after the item. Nowadays we would instead
  // want to use SetNextItemAllowOverlap() before the item.
  ButtonFlags button_flags = ButtonFlags_FlattenChildren;
#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS
  button_flags |= ButtonFlags_AllowOverlap;
#endif

  bool hovered, held;
  Rect bb_interact = bb;
  bb_interact.Expand(axis == Axis_Y ? Vec2(0.0f, hover_extend)
                                    : Vec2(hover_extend, 0.0f));
  ButtonBehavior(bb_interact, id, &hovered, &held, button_flags);
  if (hovered)
    g.LastItemData.StatusFlags |=
        ItemStatusFlags_HoveredRect; // for IsItemHovered(), because
                                     // bb_interact is larger than bb

  if (held || (hovered && g.HoveredIdPreviousFrame == id &&
               g.HoveredIdTimer >= hover_visibility_delay))
    SetMouseCursor(axis == Axis_Y ? MouseCursor_ResizeNS
                                  : MouseCursor_ResizeEW);

  Rect bb_render = bb;
  if (held) {
    float mouse_delta = (Subtract(
        Subtract(g.IO.MousePos, g.ActiveIdClickOffset), bb_interact.Min)[axis]);

    // Minimum pane size
    float size_1_maximum_delta = Max(0.0f, *size1 - min_size1);
    float size_2_maximum_delta = Max(0.0f, *size2 - min_size2);
    if (mouse_delta < -size_1_maximum_delta)
      mouse_delta = -size_1_maximum_delta;
    if (mouse_delta > size_2_maximum_delta)
      mouse_delta = size_2_maximum_delta;

    // Apply resize
    if (mouse_delta != 0.0f) {
      *size1 = Max(*size1 + mouse_delta, min_size1);
      *size2 = Max(*size2 - mouse_delta, min_size2);
      bb_render.Translate((axis == Axis_X) ? Vec2(mouse_delta, 0.0f)
                                           : Vec2(0.0f, mouse_delta));
      MarkItemEdited(id);
    }
  }

  // Render at new position
  if (bg_col & GUI_COL32_A_MASK)
    window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, bg_col, 0.0f);
  const U32 col =
      GetColorU32(held ? Col_SeparatorActive
                  : (hovered && g.HoveredIdTimer >= hover_visibility_delay)
                      ? Col_SeparatorHovered
                      : Col_Separator);
  window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, 0.0f);

  return held;
}

static int GUI_CDECL ShrinkWidthItemComparer(const void *lhs, const void *rhs) {
  const ShrinkWidthItem *a = (const ShrinkWidthItem *)lhs;
  const ShrinkWidthItem *b = (const ShrinkWidthItem *)rhs;
  if (int d = (int)(b->Width - a->Width))
    return d;
  return (b->Index - a->Index);
}

// Shrink excess width from a set of item, by removing width from the larger
// items first. Set items Width to -1.0f to disable shrinking this item.
inline void Gui::ShrinkWidths(ShrinkWidthItem *items, int count,
                              float width_excess) {
  if (count == 1) {
    if (items[0].Width >= 0.0f)
      items[0].Width = Max(items[0].Width - width_excess, 1.0f);
    return;
  }
  Qsort(items, (size_t)count, sizeof(ShrinkWidthItem), ShrinkWidthItemComparer);
  int count_same_width = 1;
  while (width_excess > 0.0f && count_same_width < count) {
    while (count_same_width < count &&
           items[0].Width <= items[count_same_width].Width)
      count_same_width++;
    float max_width_to_remove_per_item =
        (count_same_width < count && items[count_same_width].Width >= 0.0f)
            ? (items[0].Width - items[count_same_width].Width)
            : (items[0].Width - 1.0f);
    if (max_width_to_remove_per_item <= 0.0f)
      break;
    float width_to_remove_per_item =
        Min(width_excess / count_same_width, max_width_to_remove_per_item);
    for (int item_n = 0; item_n < count_same_width; item_n++)
      items[item_n].Width -= width_to_remove_per_item;
    width_excess -= width_to_remove_per_item * count_same_width;
  }

  // Round width and redistribute remainder
  // Ensure that e.g. the right-most tab of a shrunk tab-bar always reaches
  // exactly at the same distance from the right-most edge of the tab bar
  // separator.
  width_excess = 0.0f;
  for (int n = 0; n < count; n++) {
    float width_rounded = Trunc(items[n].Width);
    width_excess += items[n].Width - width_rounded;
    items[n].Width = width_rounded;
  }
  while (width_excess > 0.0f)
    for (int n = 0; n < count && width_excess > 0.0f; n++) {
      float width_to_add = Min(items[n].InitialWidth - items[n].Width, 1.0f);
      items[n].Width += width_to_add;
      width_excess -= width_to_add;
    }
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ComboBox
//-------------------------------------------------------------------------
// - CalcMaxPopupHeightFromItemCount() [Internal]
// - BeginCombo()
// - BeginComboPopup() [Internal]
// - EndCombo()
// - BeginComboPreview() [Internal]
// - EndComboPreview() [Internal]
// - Combo()
//-------------------------------------------------------------------------

static float CalcMaxPopupHeightFromItemCount(int items_count) {
  Context &g = *GGui;
  if (items_count <= 0)
    return FLT_MAX;
  return (g.FontSize + g.Style.ItemSpacing.y) * items_count -
         g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
}

inline bool Gui::BeginCombo(const char *label, const char *preview_value,
                            ComboFlags flags) {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();

  NextWindowDataFlags backup_next_window_data_flags = g.NextWindowData.Flags;
  g.NextWindowData
      .ClearFlags(); // We behave like Begin() and need to consume those values
  if (window->SkipItems)
    return false;

  const Style &style = g.Style;
  const ID id = window->GetID(label);
  GUI_ASSERT((flags & (ComboFlags_NoArrowButton | ComboFlags_NoPreview)) !=
             (ComboFlags_NoArrowButton |
              ComboFlags_NoPreview)); // Can't use both flags together
  if (flags & ComboFlags_WidthFitPreview)
    GUI_ASSERT((flags & (ComboFlags_NoPreview |
                         (ComboFlags)ComboFlags_CustomPreview)) == 0);

  const float arrow_size =
      (flags & ComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();
  const Vec2 label_size = CalcTextSize(label, NULL, true);
  const float preview_width =
      ((flags & ComboFlags_WidthFitPreview) && (preview_value != NULL))
          ? CalcTextSize(preview_value, NULL, true).x
          : 0.0f;
  const float w =
      (flags & ComboFlags_NoPreview)
          ? arrow_size
          : ((flags & ComboFlags_WidthFitPreview)
                 ? (arrow_size + preview_width + style.FramePadding.x * 2.0f)
                 : CalcItemWidth());
  const Rect bb(window->DC.CursorPos,
                Add(window->DC.CursorPos,
                    Vec2(w, label_size.y + style.FramePadding.y * 2.0f)));
  const Rect total_bb(
      bb.Min, Add(bb.Max, Vec2(label_size.x > 0.0f
                                   ? style.ItemInnerSpacing.x + label_size.x
                                   : 0.0f,
                               0.0f)));
  ItemSize(total_bb, style.FramePadding.y);
  if (!ItemAdd(total_bb, id, &bb))
    return false;

  // Open on click
  bool hovered, held;
  bool pressed = ButtonBehavior(bb, id, &hovered, &held);
  const ID popup_id = HashStr("##ComboPopup", 0, id);
  bool popup_open = IsPopupOpen(popup_id, PopupFlags_None);
  if (pressed && !popup_open) {
    OpenPopupEx(popup_id, PopupFlags_None);
    popup_open = true;
  }

  // Render shape
  const U32 frame_col = GetColorU32(hovered ? Col_FrameBgHovered : Col_FrameBg);
  const float value_x2 = Max(bb.Min.x, bb.Max.x - arrow_size);
  RenderNavHighlight(bb, id);
  if (!(flags & ComboFlags_NoPreview))
    window->DrawList->AddRectFilled(
        bb.Min, Vec2(value_x2, bb.Max.y), frame_col, style.FrameRounding,
        (flags & ComboFlags_NoArrowButton) ? DrawFlags_RoundCornersAll
                                           : DrawFlags_RoundCornersLeft);
  if (!(flags & ComboFlags_NoArrowButton)) {
    U32 bg_col =
        GetColorU32((popup_open || hovered) ? Col_ButtonHovered : Col_Button);
    U32 text_col = GetColorU32(Col_Text);
    window->DrawList->AddRectFilled(
        Vec2(value_x2, bb.Min.y), bb.Max, bg_col, style.FrameRounding,
        (w <= arrow_size) ? DrawFlags_RoundCornersAll
                          : DrawFlags_RoundCornersRight);
    if (value_x2 + arrow_size - style.FramePadding.x <= bb.Max.x)
      RenderArrow(window->DrawList,
                  Vec2(value_x2 + style.FramePadding.y,
                       bb.Min.y + style.FramePadding.y),
                  text_col, Dir_Down, 1.0f);
  }
  RenderFrameBorder(bb.Min, bb.Max, style.FrameRounding);

  // Custom preview
  if (flags & ComboFlags_CustomPreview) {
    g.ComboPreviewData.PreviewRect =
        Rect(bb.Min.x, bb.Min.y, value_x2, bb.Max.y);
    GUI_ASSERT(preview_value == NULL || preview_value[0] == 0);
    preview_value = NULL;
  }

  // Render preview and label
  if (preview_value != NULL && !(flags & ComboFlags_NoPreview)) {
    if (g.LogEnabled)
      LogSetNextTextDecoration("{", "}");
    RenderTextClipped(Add(bb.Min, style.FramePadding), Vec2(value_x2, bb.Max.y),
                      preview_value, NULL, NULL);
  }
  if (label_size.x > 0)
    RenderText(Vec2(bb.Max.x + style.ItemInnerSpacing.x,
                    bb.Min.y + style.FramePadding.y),
               label);

  if (!popup_open)
    return false;

  g.NextWindowData.Flags = backup_next_window_data_flags;
  return BeginComboPopup(popup_id, bb, flags);
}

inline bool Gui::BeginComboPopup(ID popup_id, const Rect &bb,
                                 ComboFlags flags) {
  Context &g = *GGui;
  if (!IsPopupOpen(popup_id, PopupFlags_None)) {
    g.NextWindowData.ClearFlags();
    return false;
  }

  // Set popup size
  float w = bb.GetWidth();
  if (g.NextWindowData.Flags & NextWindowDataFlags_HasSizeConstraint) {
    g.NextWindowData.SizeConstraintRect.Min.x =
        Max(g.NextWindowData.SizeConstraintRect.Min.x, w);
  } else {
    if ((flags & ComboFlags_HeightMask_) == 0)
      flags |= ComboFlags_HeightRegular;
    GUI_ASSERT(IsPowerOfTwo(flags & ComboFlags_HeightMask_)); // Only one
    int popup_max_height_in_items = -1;
    if (flags & ComboFlags_HeightRegular)
      popup_max_height_in_items = 8;
    else if (flags & ComboFlags_HeightSmall)
      popup_max_height_in_items = 4;
    else if (flags & ComboFlags_HeightLarge)
      popup_max_height_in_items = 20;
    Vec2 constraint_min(0.0f, 0.0f), constraint_max(FLT_MAX, FLT_MAX);
    if ((g.NextWindowData.Flags & NextWindowDataFlags_HasSize) == 0 ||
        g.NextWindowData.SizeVal.x <=
            0.0f) // Don't apply constraints if user specified a size
      constraint_min.x = w;
    if ((g.NextWindowData.Flags & NextWindowDataFlags_HasSize) == 0 ||
        g.NextWindowData.SizeVal.y <= 0.0f)
      constraint_max.y =
          CalcMaxPopupHeightFromItemCount(popup_max_height_in_items);
    SetNextWindowSizeConstraints(constraint_min, constraint_max);
  }

  // This is essentially a specialized version of BeginPopupEx()
  char name[16];
  FormatString(name, GUI_ARRAYSIZE(name), "##Combo_%02d",
               g.BeginPopupStack.Size); // Recycle windows based on depth

  // Set position given a custom constraint (peak into expected window size so
  // we can position it)
  // FIXME: This might be easier to express with an hypothetical
  // SetNextWindowPosConstraints() function?
  // FIXME: This might be moved to Begin() or at least around the same spot
  // where Tooltips and other Popups are calling FindBestWindowPosForPopupEx()?
  if (Window *popup_window = FindWindowByName(name))
    if (popup_window->WasActive) {
      // Always override 'AutoPosLastDirection' to not leave a chance for a past
      // value to affect us.
      Vec2 size_expected = CalcWindowNextAutoFitSize(popup_window);
      popup_window->AutoPosLastDirection =
          (flags & ComboFlags_PopupAlignLeft)
              ? Dir_Left
              : Dir_Down; // Left = "Below, Toward Left", Down = "Below,
                          // Toward Right (default)"
      Rect r_outer = GetPopupAllowedExtentRect(popup_window);
      Vec2 pos = FindBestWindowPosForPopupEx(
          bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection,
          r_outer, bb, PopupPositionPolicy_ComboBox);
      SetNextWindowPos(pos);
    }

  // We don't use BeginPopupEx() solely because we have a custom name string,
  // which we could make an argument to BeginPopupEx()
  WindowFlags window_flags = WindowFlags_AlwaysAutoResize | WindowFlags_Popup |
                             WindowFlags_NoTitleBar | WindowFlags_NoResize |
                             WindowFlags_NoSavedSettings | WindowFlags_NoMove;
  PushStyleVar(
      StyleVar_WindowPadding,
      Vec2(g.Style.FramePadding.x,
           g.Style.WindowPadding
               .y)); // Horizontally align ourselves with the framed text
  bool ret = Begin(name, NULL, window_flags);
  PopStyleVar();
  if (!ret) {
    EndPopup();
    GUI_ASSERT(
        0); // This should never happen as we tested for IsPopupOpen() above
    return false;
  }
  return true;
}

inline void Gui::EndCombo() { EndPopup(); }

// Call directly after the BeginCombo/EndCombo block. The preview is designed to
// only host non-interactive elements (Experimental, see GitHub issues: #1658,
// #4168)
inline bool Gui::BeginComboPreview() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  ComboPreviewData *preview_data = &g.ComboPreviewData;

  if (window->SkipItems ||
      !(g.LastItemData.StatusFlags & ItemStatusFlags_Visible))
    return false;
  GUI_ASSERT(g.LastItemData.Rect.Min.x == preview_data->PreviewRect.Min.x &&
             g.LastItemData.Rect.Min.y ==
                 preview_data->PreviewRect.Min
                     .y); // Didn't call after BeginCombo/EndCombo block or
                          // forgot to pass ComboFlags_CustomPreview flag?
  if (!window->ClipRect.Overlaps(
          preview_data->PreviewRect)) // Narrower test (optional)
    return false;

  // FIXME: This could be contained in a PushWorkRect() api
  preview_data->BackupCursorPos = window->DC.CursorPos;
  preview_data->BackupCursorMaxPos = window->DC.CursorMaxPos;
  preview_data->BackupCursorPosPrevLine = window->DC.CursorPosPrevLine;
  preview_data->BackupPrevLineTextBaseOffset =
      window->DC.PrevLineTextBaseOffset;
  preview_data->BackupLayout = window->DC.LayoutType;
  window->DC.CursorPos =
      Add(preview_data->PreviewRect.Min, g.Style.FramePadding);
  window->DC.CursorMaxPos = window->DC.CursorPos;
  window->DC.LayoutType = LayoutType_Horizontal;
  window->DC.IsSameLine = false;
  PushClipRect(preview_data->PreviewRect.Min, preview_data->PreviewRect.Max,
               true);

  return true;
}

// Getter for the old Combo() API: const char*[]
static const char *Items_ArrayGetter(void *data, int idx) {
  const char *const *items = (const char *const *)data;
  return items[idx];
}

// Getter for the old Combo() API: "item1\0item2\0item3\0"
static const char *Items_SingleStringGetter(void *data, int idx) {
  const char *items_separated_by_zeros = (const char *)data;
  int items_count = 0;
  const char *p = items_separated_by_zeros;
  while (*p) {
    if (idx == items_count)
      break;
    p += strlen(p) + 1;
    items_count++;
  }
  return *p ? p : NULL;
}

// Old API, prefer using BeginCombo() nowadays if you can.
inline bool Gui::Combo(const char *label, int *current_item,
                       const char *(*getter)(void *user_data, int idx),
                       void *user_data, int items_count,
                       int popup_max_height_in_items) {
  Context &g = *GGui;

  // Call the getter to obtain the preview string which is a parameter to
  // BeginCombo()
  const char *preview_value = NULL;
  if (*current_item >= 0 && *current_item < items_count)
    preview_value = getter(user_data, *current_item);

  // The old Combo() API exposed "popup_max_height_in_items". The new more
  // general BeginCombo() API doesn't have/need it, but we emulate it here.
  if (popup_max_height_in_items != -1 &&
      !(g.NextWindowData.Flags & NextWindowDataFlags_HasSizeConstraint))
    SetNextWindowSizeConstraints(Vec2(0, 0),
                                 Vec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(
                                                   popup_max_height_in_items)));

  if (!BeginCombo(label, preview_value, ComboFlags_None))
    return false;

  // Display items
  // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to
  // make sure our call to SetItemDefaultFocus() is processed)
  bool value_changed = false;
  for (int i = 0; i < items_count; i++) {
    const char *item_text = getter(user_data, i);
    if (item_text == NULL)
      item_text = "*Unknown item*";

    PushID(i);
    const bool item_selected = (i == *current_item);
    if (Selectable(item_text, item_selected) && *current_item != i) {
      value_changed = true;
      *current_item = i;
    }
    if (item_selected)
      SetItemDefaultFocus();
    PopID();
  }

  EndCombo();

  if (value_changed)
    MarkItemEdited(g.LastItemData.ID);

  return value_changed;
}

// Combo box helper allowing to pass an array of strings.
inline bool Gui::Combo(const char *label, int *current_item,
                       const char *const items[], int items_count,
                       int height_in_items) {
  const bool value_changed = Combo(label, current_item, Items_ArrayGetter,
                                   (void *)items, items_count, height_in_items);
  return value_changed;
}

// Combo box helper allowing to pass all items in a single string literal
// holding multiple zero-terminated items "item1\0item2\0"
inline bool Gui::Combo(const char *label, int *current_item,
                       const char *items_separated_by_zeros,
                       int height_in_items) {
  int items_count = 0;
  const char *p =
      items_separated_by_zeros; // FIXME-OPT: Avoid computing this, or at least
                                // only when combo is open
  while (*p) {
    p += strlen(p) + 1;
    items_count++;
  }
  bool value_changed =
      Combo(label, current_item, Items_SingleStringGetter,
            (void *)items_separated_by_zeros, items_count, height_in_items);
  return value_changed;
}

#ifndef GUI_DISABLE_OBSOLETE_FUNCTIONS

struct GetNameFromIndexOldToNewCallbackData {
  void *UserData;
  bool (*OldCallback)(void *, int, const char **);
};
static const char *GetNameFromIndexOldToNewCallback(void *user_data, int idx) {
  GetNameFromIndexOldToNewCallbackData *data =
      (GetNameFromIndexOldToNewCallbackData *)user_data;
  const char *s = NULL;
  data->OldCallback(data->UserData, idx, &s);
  return s;
}

inline bool Gui::ListBox(const char *label, int *current_item,
                         bool (*old_getter)(void *, int, const char **),
                         void *user_data, int items_count,
                         int height_in_items) {
  GetNameFromIndexOldToNewCallbackData old_to_new_data = {user_data,
                                                          old_getter};
  return ListBox(label, current_item, GetNameFromIndexOldToNewCallback,
                 &old_to_new_data, items_count, height_in_items);
}
inline bool Gui::Combo(const char *label, int *current_item,
                       bool (*old_getter)(void *, int, const char **),
                       void *user_data, int items_count,
                       int popup_max_height_in_items) {
  GetNameFromIndexOldToNewCallbackData old_to_new_data = {user_data,
                                                          old_getter};
  return Combo(label, current_item, GetNameFromIndexOldToNewCallback,
               &old_to_new_data, items_count, popup_max_height_in_items);
}

#endif

//-------------------------------------------------------------------------
// [SECTION] Data Type and Data Formatting Helpers [Internal]
//-------------------------------------------------------------------------
// - DataTypeGetInfo()
// - DataTypeFormatString()
// - DataTypeApplyOp()
// - DataTypeApplyOpFromText()
// - DataTypeCompare()
// - DataTypeClamp()
// - GetMinimumStepAtDecimalPrecision
// - RoundScalarWithFormat<>()
//-------------------------------------------------------------------------

static const DataTypeInfo GDataTypeInfo[] = {
    {sizeof(char), "S8", "%d", "%d"}, // DataType_S8
    {sizeof(unsigned char), "U8", "%u", "%u"},
    {sizeof(short), "S16", "%d", "%d"}, // DataType_S16
    {sizeof(unsigned short), "U16", "%u", "%u"},
    {sizeof(int), "S32", "%d", "%d"}, // DataType_S32
    {sizeof(unsigned int), "U32", "%u", "%u"},
#ifdef _MSC_VER
    {sizeof(S64), "S64", "%I64d", "%I64d"}, // DataType_S64
    {sizeof(U64), "U64", "%I64u", "%I64u"},
#else
    {sizeof(S64), "S64", "%lld", "%lld"}, // DataType_S64
    {sizeof(U64), "U64", "%llu", "%llu"},
#endif
    {sizeof(float), "float", "%.3f",
     "%f"}, // DataType_Float (float are promoted to double in va_arg)
    {sizeof(double), "double", "%f", "%lf"}, // DataType_Double
};
GUI_STATIC_ASSERT(GUI_ARRAYSIZE(GDataTypeInfo) == DataType_COUNT);

inline const DataTypeInfo *Gui::DataTypeGetInfo(DataType data_type) {
  GUI_ASSERT(data_type >= 0 && data_type < DataType_COUNT);
  return &GDataTypeInfo[data_type];
}

inline int Gui::DataTypeFormatString(char *buf, int buf_size,
                                     DataType data_type, const void *p_data,
                                     const char *format) {
  // Signedness doesn't matter when pushing integer arguments
  if (data_type == DataType_S32 || data_type == DataType_U32)
    return FormatString(buf, buf_size, format, *(const U32 *)p_data);
  if (data_type == DataType_S64 || data_type == DataType_U64)
    return FormatString(buf, buf_size, format, *(const U64 *)p_data);
  if (data_type == DataType_Float)
    return FormatString(buf, buf_size, format, *(const float *)p_data);
  if (data_type == DataType_Double)
    return FormatString(buf, buf_size, format, *(const double *)p_data);
  if (data_type == DataType_S8)
    return FormatString(buf, buf_size, format, *(const S8 *)p_data);
  if (data_type == DataType_U8)
    return FormatString(buf, buf_size, format, *(const U8 *)p_data);
  if (data_type == DataType_S16)
    return FormatString(buf, buf_size, format, *(const S16 *)p_data);
  if (data_type == DataType_U16)
    return FormatString(buf, buf_size, format, *(const U16 *)p_data);
  GUI_ASSERT(0);
  return 0;
}

inline void Gui::DataTypeApplyOp(DataType data_type, int op, void *output,
                                 const void *arg1, const void *arg2) {
  GUI_ASSERT(op == '+' || op == '-');
  switch (data_type) {
  case DataType_S8:
    if (op == '+') {
      *(S8 *)output = AddClampOverflow(*(const S8 *)arg1, *(const S8 *)arg2,
                                       GUI_S8_MIN, GUI_S8_MAX);
    }
    if (op == '-') {
      *(S8 *)output = SubClampOverflow(*(const S8 *)arg1, *(const S8 *)arg2,
                                       GUI_S8_MIN, GUI_S8_MAX);
    }
    return;
  case DataType_U8:
    if (op == '+') {
      *(U8 *)output = AddClampOverflow(*(const U8 *)arg1, *(const U8 *)arg2,
                                       GUI_U8_MIN, GUI_U8_MAX);
    }
    if (op == '-') {
      *(U8 *)output = SubClampOverflow(*(const U8 *)arg1, *(const U8 *)arg2,
                                       GUI_U8_MIN, GUI_U8_MAX);
    }
    return;
  case DataType_S16:
    if (op == '+') {
      *(S16 *)output = AddClampOverflow(*(const S16 *)arg1, *(const S16 *)arg2,
                                        GUI_S16_MIN, GUI_S16_MAX);
    }
    if (op == '-') {
      *(S16 *)output = SubClampOverflow(*(const S16 *)arg1, *(const S16 *)arg2,
                                        GUI_S16_MIN, GUI_S16_MAX);
    }
    return;
  case DataType_U16:
    if (op == '+') {
      *(U16 *)output = AddClampOverflow(*(const U16 *)arg1, *(const U16 *)arg2,
                                        GUI_U16_MIN, GUI_U16_MAX);
    }
    if (op == '-') {
      *(U16 *)output = SubClampOverflow(*(const U16 *)arg1, *(const U16 *)arg2,
                                        GUI_U16_MIN, GUI_U16_MAX);
    }
    return;
  case DataType_S32:
    if (op == '+') {
      *(S32 *)output = AddClampOverflow(*(const S32 *)arg1, *(const S32 *)arg2,
                                        GUI_S32_MIN, GUI_S32_MAX);
    }
    if (op == '-') {
      *(S32 *)output = SubClampOverflow(*(const S32 *)arg1, *(const S32 *)arg2,
                                        GUI_S32_MIN, GUI_S32_MAX);
    }
    return;
  case DataType_U32:
    if (op == '+') {
      *(U32 *)output = AddClampOverflow(*(const U32 *)arg1, *(const U32 *)arg2,
                                        GUI_U32_MIN, GUI_U32_MAX);
    }
    if (op == '-') {
      *(U32 *)output = SubClampOverflow(*(const U32 *)arg1, *(const U32 *)arg2,
                                        GUI_U32_MIN, GUI_U32_MAX);
    }
    return;
  case DataType_S64:
    if (op == '+') {
      *(S64 *)output = AddClampOverflow(*(const S64 *)arg1, *(const S64 *)arg2,
                                        GUI_S64_MIN, GUI_S64_MAX);
    }
    if (op == '-') {
      *(S64 *)output = SubClampOverflow(*(const S64 *)arg1, *(const S64 *)arg2,
                                        GUI_S64_MIN, GUI_S64_MAX);
    }
    return;
  case DataType_U64:
    if (op == '+') {
      *(U64 *)output = AddClampOverflow(*(const U64 *)arg1, *(const U64 *)arg2,
                                        GUI_U64_MIN, GUI_U64_MAX);
    }
    if (op == '-') {
      *(U64 *)output = SubClampOverflow(*(const U64 *)arg1, *(const U64 *)arg2,
                                        GUI_U64_MIN, GUI_U64_MAX);
    }
    return;
  case DataType_Float:
    if (op == '+') {
      *(float *)output = *(const float *)arg1 + *(const float *)arg2;
    }
    if (op == '-') {
      *(float *)output = *(const float *)arg1 - *(const float *)arg2;
    }
    return;
  case DataType_Double:
    if (op == '+') {
      *(double *)output = *(const double *)arg1 + *(const double *)arg2;
    }
    if (op == '-') {
      *(double *)output = *(const double *)arg1 - *(const double *)arg2;
    }
    return;
  case DataType_COUNT:
    break;
  }
  GUI_ASSERT(0);
}

// User can input math operators (e.g. +100) to edit a numerical values.
// NB: This is _not_ a full expression evaluator. We should probably add one and
// replace this dumb mess..
inline bool Gui::DataTypeApplyFromText(const char *buf, DataType data_type,
                                       void *p_data, const char *format) {
  while (CharIsBlankA(*buf))
    buf++;
  if (!buf[0])
    return false;

  // Copy the value in an opaque buffer so we can compare at the end of the
  // function if it changed at all.
  const DataTypeInfo *type_info = DataTypeGetInfo(data_type);
  DataTypeTempStorage data_backup;
  memcpy(&data_backup, p_data, type_info->Size);

  // Sanitize format
  // - For float/double we have to ignore format with precision (e.g. "%.2f")
  // because sscanf doesn't take them in, so force them into %f and %lf
  // - In theory could treat empty format as using default, but this would only
  // cover rare/bizarre case of using InputScalar() + integer + format string
  // without %.
  char format_sanitized[32];
  if (data_type == DataType_Float || data_type == DataType_Double)
    format = type_info->ScanFmt;
  else
    format = ParseFormatSanitizeForScanning(format, format_sanitized,
                                            GUI_ARRAYSIZE(format_sanitized));

  // Small types need a 32-bit buffer to receive the result from scanf()
  int v32 = 0;
  if (sscanf(buf, format, type_info->Size >= 4 ? p_data : &v32) < 1)
    return false;
  if (type_info->Size < 4) {
    if (data_type == DataType_S8)
      *(S8 *)p_data = (S8)Clamp(v32, (int)GUI_S8_MIN, (int)GUI_S8_MAX);
    else if (data_type == DataType_U8)
      *(U8 *)p_data = (U8)Clamp(v32, (int)GUI_U8_MIN, (int)GUI_U8_MAX);
    else if (data_type == DataType_S16)
      *(S16 *)p_data = (S16)Clamp(v32, (int)GUI_S16_MIN, (int)GUI_S16_MAX);
    else if (data_type == DataType_U16)
      *(U16 *)p_data = (U16)Clamp(v32, (int)GUI_U16_MIN, (int)GUI_U16_MAX);
    else
      GUI_ASSERT(0);
  }

  return memcmp(&data_backup, p_data, type_info->Size) != 0;
}

template <typename T> static int DataTypeCompareT(const T *lhs, const T *rhs) {
  if (*lhs < *rhs)
    return -1;
  if (*lhs > *rhs)
    return +1;
  return 0;
}

inline int Gui::DataTypeCompare(DataType data_type, const void *arg_1,
                                const void *arg_2) {
  switch (data_type) {
  case DataType_S8:
    return DataTypeCompareT<S8>((const S8 *)arg_1, (const S8 *)arg_2);
  case DataType_U8:
    return DataTypeCompareT<U8>((const U8 *)arg_1, (const U8 *)arg_2);
  case DataType_S16:
    return DataTypeCompareT<S16>((const S16 *)arg_1, (const S16 *)arg_2);
  case DataType_U16:
    return DataTypeCompareT<U16>((const U16 *)arg_1, (const U16 *)arg_2);
  case DataType_S32:
    return DataTypeCompareT<S32>((const S32 *)arg_1, (const S32 *)arg_2);
  case DataType_U32:
    return DataTypeCompareT<U32>((const U32 *)arg_1, (const U32 *)arg_2);
  case DataType_S64:
    return DataTypeCompareT<S64>((const S64 *)arg_1, (const S64 *)arg_2);
  case DataType_U64:
    return DataTypeCompareT<U64>((const U64 *)arg_1, (const U64 *)arg_2);
  case DataType_Float:
    return DataTypeCompareT<float>((const float *)arg_1, (const float *)arg_2);
  case DataType_Double:
    return DataTypeCompareT<double>((const double *)arg_1,
                                    (const double *)arg_2);
  case DataType_COUNT:
    break;
  }
  GUI_ASSERT(0);
  return 0;
}

template <typename T>
static bool DataTypeClampT(T *v, const T *v_min, const T *v_max) {
  // Clamp, both sides are optional, return true if modified
  if (v_min && *v < *v_min) {
    *v = *v_min;
    return true;
  }
  if (v_max && *v > *v_max) {
    *v = *v_max;
    return true;
  }
  return false;
}

inline bool Gui::DataTypeClamp(DataType data_type, void *p_data,
                               const void *p_min, const void *p_max) {
  switch (data_type) {
  case DataType_S8:
    return DataTypeClampT<S8>((S8 *)p_data, (const S8 *)p_min,
                              (const S8 *)p_max);
  case DataType_U8:
    return DataTypeClampT<U8>((U8 *)p_data, (const U8 *)p_min,
                              (const U8 *)p_max);
  case DataType_S16:
    return DataTypeClampT<S16>((S16 *)p_data, (const S16 *)p_min,
                               (const S16 *)p_max);
  case DataType_U16:
    return DataTypeClampT<U16>((U16 *)p_data, (const U16 *)p_min,
                               (const U16 *)p_max);
  case DataType_S32:
    return DataTypeClampT<S32>((S32 *)p_data, (const S32 *)p_min,
                               (const S32 *)p_max);
  case DataType_U32:
    return DataTypeClampT<U32>((U32 *)p_data, (const U32 *)p_min,
                               (const U32 *)p_max);
  case DataType_S64:
    return DataTypeClampT<S64>((S64 *)p_data, (const S64 *)p_min,
                               (const S64 *)p_max);
  case DataType_U64:
    return DataTypeClampT<U64>((U64 *)p_data, (const U64 *)p_min,
                               (const U64 *)p_max);
  case DataType_Float:
    return DataTypeClampT<float>((float *)p_data, (const float *)p_min,
                                 (const float *)p_max);
  case DataType_Double:
    return DataTypeClampT<double>((double *)p_data, (const double *)p_min,
                                  (const double *)p_max);
  case DataType_COUNT:
    break;
  }
  GUI_ASSERT(0);
  return false;
}

static float GetMinimumStepAtDecimalPrecision(int decimal_precision) {
  static const float min_steps[10] = {
      1.0f,     0.1f,      0.01f,      0.001f,      0.0001f,
      0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f};
  if (decimal_precision < 0)
    return FLT_MIN;
  return (decimal_precision < GUI_ARRAYSIZE(min_steps))
             ? min_steps[decimal_precision]
             : Pow(10.0f, (float)-decimal_precision);
}

template <typename TYPE>
TYPE Gui::RoundScalarWithFormatT(const char *format, DataType data_type,
                                 TYPE v) {
  GUI_UNUSED(data_type);
  GUI_ASSERT(data_type == DataType_Float || data_type == DataType_Double);
  const char *fmt_start = ParseFormatFindStart(format);
  if (fmt_start[0] != '%' ||
      fmt_start[1] ==
          '%') // Don't apply if the value is not visible in the format string
    return v;

  // Sanitize format
  char fmt_sanitized[32];
  ParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized,
                                 GUI_ARRAYSIZE(fmt_sanitized));
  fmt_start = fmt_sanitized;

  // Format value with our rounding, and read back
  char v_str[64];
  FormatString(v_str, GUI_ARRAYSIZE(v_str), fmt_start, v);
  const char *p = v_str;
  while (*p == ' ')
    p++;
  v = (TYPE)Atof(p);

  return v;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
//-------------------------------------------------------------------------
// - DragBehaviorT<>() [Internal]
// - DragBehavior() [Internal]
// - DragScalar()
// - DragScalarN()
// - DragFloat()
// - DragFloat2()
// - DragFloat3()
// - DragFloat4()
// - DragFloatRange2()
// - DragInt()
// - DragInt2()
// - DragInt3()
// - DragInt4()
// - DragIntRange2()
//-------------------------------------------------------------------------

// This is called by DragBehavior() when the widget is active (held by mouse or
// being manipulated with Nav controls)
template <typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool Gui::DragBehaviorT(DataType data_type, TYPE *v, float v_speed,
                        const TYPE v_min, const TYPE v_max, const char *format,
                        SliderFlags flags) {
  Context &g = *GGui;
  const Axis axis = (flags & SliderFlags_Vertical) ? Axis_Y : Axis_X;
  const bool is_clamped = (v_min < v_max);
  const bool is_logarithmic = (flags & SliderFlags_Logarithmic) != 0;
  const bool is_floating_point =
      (data_type == DataType_Float) || (data_type == DataType_Double);

  // Default tweak speed
  if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))
    v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

  // Inputs accumulates into g.DragCurrentAccum, which is flushed into the
  // current value as soon as it makes a difference with our precision settings
  float adjust_delta = 0.0f;
  if (g.ActiveIdSource == InputSource_Mouse && IsMousePosValid() &&
      IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold *
                                      DRAG_MOUSE_THRESHOLD_FACTOR)) {
    adjust_delta = g.IO.MouseDelta[axis];
    if (g.IO.KeyAlt)
      adjust_delta *= 1.0f / 100.0f;
    if (g.IO.KeyShift)
      adjust_delta *= 10.0f;
  } else if (g.ActiveIdSource == InputSource_Keyboard ||
             g.ActiveIdSource == InputSource_Gamepad) {
    const int decimal_precision =
        is_floating_point ? ParseFormatPrecision(format, 3) : 0;
    const bool tweak_slow = IsKeyDown((g.NavInputSource == InputSource_Gamepad)
                                          ? Key_NavGamepadTweakSlow
                                          : Key_NavKeyboardTweakSlow);
    const bool tweak_fast = IsKeyDown((g.NavInputSource == InputSource_Gamepad)
                                          ? Key_NavGamepadTweakFast
                                          : Key_NavKeyboardTweakFast);
    const float tweak_factor = tweak_slow   ? 1.0f / 1.0f
                               : tweak_fast ? 10.0f
                                            : 1.0f;
    adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;
    v_speed = Max(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
  }
  adjust_delta *= v_speed;

  // For vertical drag we currently assume that Up=higher value (like we do with
  // vertical sliders). This may become a parameter.
  if (axis == Axis_Y)
    adjust_delta = -adjust_delta;

  // For logarithmic use our range is effectively 0..1 so scale the delta into
  // that range
  if (is_logarithmic && (v_max - v_min < FLT_MAX) &&
      ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
    adjust_delta /= (float)(v_max - v_min);

  // Clear current value on activation
  // Avoid altering values and clamping when we are _already_ past the limits
  // and heading in the same direction, so e.g. if range is 0..255, current
  // value is 300 and we are pushing to the right side, keep the 300.
  bool is_just_activated = g.ActiveIdIsJustActivated;
  bool is_already_past_limits_and_pushing_outward =
      is_clamped && ((*v >= v_max && adjust_delta > 0.0f) ||
                     (*v <= v_min && adjust_delta < 0.0f));
  if (is_just_activated || is_already_past_limits_and_pushing_outward) {
    g.DragCurrentAccum = 0.0f;
    g.DragCurrentAccumDirty = false;
  } else if (adjust_delta != 0.0f) {
    g.DragCurrentAccum += adjust_delta;
    g.DragCurrentAccumDirty = true;
  }

  if (!g.DragCurrentAccumDirty)
    return false;

  TYPE v_cur = *v;
  FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

  float logarithmic_zero_epsilon =
      0.0f; // Only valid when is_logarithmic is true
  const float zero_deadzone_halfsize =
      0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
  if (is_logarithmic) {
    // When using logarithmic sliders, we need to clamp to avoid hitting zero,
    // but our choice of clamp value greatly affects slider precision. We
    // attempt to use the specified precision to estimate a good lower bound.
    const int decimal_precision =
        is_floating_point ? ParseFormatPrecision(format, 3) : 1;
    logarithmic_zero_epsilon = Pow(0.1f, (float)decimal_precision);

    // Convert to parametric space, apply delta, convert back
    float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(
        data_type, v_cur, v_min, v_max, is_logarithmic,
        logarithmic_zero_epsilon, zero_deadzone_halfsize);
    float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
    v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(
        data_type, v_new_parametric, v_min, v_max, is_logarithmic,
        logarithmic_zero_epsilon, zero_deadzone_halfsize);
    v_old_ref_for_accum_remainder = v_old_parametric;
  } else {
    v_cur += (SIGNEDTYPE)g.DragCurrentAccum;
  }

  // Round to user desired precision based on format string
  if (is_floating_point && !(flags & SliderFlags_NoRoundToFormat))
    v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);

  // Preserve remainder after rounding has been applied. This also allow slow
  // tweaking of values.
  g.DragCurrentAccumDirty = false;
  if (is_logarithmic) {
    // Convert to parametric space, apply delta, convert back
    float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(
        data_type, v_cur, v_min, v_max, is_logarithmic,
        logarithmic_zero_epsilon, zero_deadzone_halfsize);
    g.DragCurrentAccum -=
        (float)(v_new_parametric - v_old_ref_for_accum_remainder);
  } else {
    g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
  }

  // Lose zero sign for float/double
  if (v_cur == (TYPE)-0)
    v_cur = (TYPE)0;

  // Clamp values (+ handle overflow/wrap-around for integer types)
  if (*v != v_cur && is_clamped) {
    if (v_cur < v_min ||
        (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))
      v_cur = v_min;
    if (v_cur > v_max ||
        (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))
      v_cur = v_max;
  }

  // Apply result
  if (*v == v_cur)
    return false;
  *v = v_cur;
  return true;
}

inline bool Gui::DragBehavior(ID id, DataType data_type, void *p_v,
                              float v_speed, const void *p_min,
                              const void *p_max, const char *format,
                              SliderFlags flags) {
  // Read gui.cpp "API BREAKING CHANGES" section for 1.78 if you hit this
  // assert.
  GUI_ASSERT((flags == 1 || (flags & SliderFlags_InvalidMask_) == 0) &&
             "Invalid SliderFlags flags! Has the 'float power' argument "
             "been mistakenly cast to flags? Call function with "
             "SliderFlags_Logarithmic flags instead.");

  Context &g = *GGui;
  if (g.ActiveId == id) {
    // Those are the things we can do easily outside the DragBehaviorT<>
    // template, saves code generation.
    if (g.ActiveIdSource == InputSource_Mouse && !g.IO.MouseDown[0])
      ClearActiveID();
    else if ((g.ActiveIdSource == InputSource_Keyboard ||
              g.ActiveIdSource == InputSource_Gamepad) &&
             g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
      ClearActiveID();
  }
  if (g.ActiveId != id)
    return false;
  if ((g.LastItemData.InFlags & ItemFlags_ReadOnly) ||
      (flags & SliderFlags_ReadOnly))
    return false;

  switch (data_type) {
  case DataType_S8: {
    S32 v32 = (S32) * (S8 *)p_v;
    bool r = DragBehaviorT<S32, S32, float>(
        DataType_S32, &v32, v_speed, p_min ? *(const S8 *)p_min : GUI_S8_MIN,
        p_max ? *(const S8 *)p_max : GUI_S8_MAX, format, flags);
    if (r)
      *(S8 *)p_v = (S8)v32;
    return r;
  }
  case DataType_U8: {
    U32 v32 = (U32) * (U8 *)p_v;
    bool r = DragBehaviorT<U32, S32, float>(
        DataType_U32, &v32, v_speed, p_min ? *(const U8 *)p_min : GUI_U8_MIN,
        p_max ? *(const U8 *)p_max : GUI_U8_MAX, format, flags);
    if (r)
      *(U8 *)p_v = (U8)v32;
    return r;
  }
  case DataType_S16: {
    S32 v32 = (S32) * (S16 *)p_v;
    bool r = DragBehaviorT<S32, S32, float>(
        DataType_S32, &v32, v_speed, p_min ? *(const S16 *)p_min : GUI_S16_MIN,
        p_max ? *(const S16 *)p_max : GUI_S16_MAX, format, flags);
    if (r)
      *(S16 *)p_v = (S16)v32;
    return r;
  }
  case DataType_U16: {
    U32 v32 = (U32) * (U16 *)p_v;
    bool r = DragBehaviorT<U32, S32, float>(
        DataType_U32, &v32, v_speed, p_min ? *(const U16 *)p_min : GUI_U16_MIN,
        p_max ? *(const U16 *)p_max : GUI_U16_MAX, format, flags);
    if (r)
      *(U16 *)p_v = (U16)v32;
    return r;
  }
  case DataType_S32:
    return DragBehaviorT<S32, S32, float>(
        data_type, (S32 *)p_v, v_speed,
        p_min ? *(const S32 *)p_min : GUI_S32_MIN,
        p_max ? *(const S32 *)p_max : GUI_S32_MAX, format, flags);
  case DataType_U32:
    return DragBehaviorT<U32, S32, float>(
        data_type, (U32 *)p_v, v_speed,
        p_min ? *(const U32 *)p_min : GUI_U32_MIN,
        p_max ? *(const U32 *)p_max : GUI_U32_MAX, format, flags);
  case DataType_S64:
    return DragBehaviorT<S64, S64, double>(
        data_type, (S64 *)p_v, v_speed,
        p_min ? *(const S64 *)p_min : GUI_S64_MIN,
        p_max ? *(const S64 *)p_max : GUI_S64_MAX, format, flags);
  case DataType_U64:
    return DragBehaviorT<U64, S64, double>(
        data_type, (U64 *)p_v, v_speed,
        p_min ? *(const U64 *)p_min : GUI_U64_MIN,
        p_max ? *(const U64 *)p_max : GUI_U64_MAX, format, flags);
  case DataType_Float:
    return DragBehaviorT<float, float, float>(
        data_type, (float *)p_v, v_speed,
        p_min ? *(const float *)p_min : -FLT_MAX,
        p_max ? *(const float *)p_max : FLT_MAX, format, flags);
  case DataType_Double:
    return DragBehaviorT<double, double, double>(
        data_type, (double *)p_v, v_speed,
        p_min ? *(const double *)p_min : -DBL_MAX,
        p_max ? *(const double *)p_max : DBL_MAX, format, flags);
  case DataType_COUNT:
    break;
  }
  GUI_ASSERT(0);
  return false;
}

// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the
// data. For a Drag widget, p_min and p_max are optional. Read code of e.g.
// DragFloat(), DragInt() etc. or examples in 'Demo->Widgets->Data Types' to
// understand how to use this function directly.
inline bool Gui::DragScalar(const char *label, DataType data_type, void *p_data,
                            float v_speed, const void *p_min, const void *p_max,
                            const char *format, SliderFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  const Style &style = g.Style;
  const ID id = window->GetID(label);
  const float w = CalcItemWidth();

  const Vec2 label_size = CalcTextSize(label, NULL, true);
  const Rect frame_bb(window->DC.CursorPos,
                      Add(window->DC.CursorPos,
                          Vec2(w, label_size.y + style.FramePadding.y * 2.0f)));
  const Rect total_bb(
      frame_bb.Min,
      Add(frame_bb.Max,
          Vec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x
                                   : 0.0f,
               0.0f)));

  const bool temp_input_allowed = (flags & SliderFlags_NoInput) == 0;
  ItemSize(total_bb, style.FramePadding.y);
  if (!ItemAdd(total_bb, id, &frame_bb,
               temp_input_allowed ? ItemFlags_Inputable : 0))
    return false;

  // Default format string when passing NULL
  if (format == NULL)
    format = DataTypeGetInfo(data_type)->PrintFmt;

  const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);
  bool temp_input_is_active = temp_input_allowed && TempInputIsActive(id);
  if (!temp_input_is_active) {
    // Tabbing or CTRL-clicking on Drag turns it into an InputText
    const bool clicked = hovered && IsMouseClicked(0, id);
    const bool double_clicked = (hovered && g.IO.MouseClickedCount[0] == 2 &&
                                 TestKeyOwner(Key_MouseLeft, id));
    const bool make_active =
        (clicked || double_clicked || g.NavActivateId == id);
    if (make_active && (clicked || double_clicked))
      SetKeyOwner(Key_MouseLeft, id);
    if (make_active && temp_input_allowed)
      if ((clicked && g.IO.KeyCtrl) || double_clicked ||
          (g.NavActivateId == id &&
           (g.NavActivateFlags & ActivateFlags_PreferInput)))
        temp_input_is_active = true;

    // (Optional) simple click (without moving) turns Drag into an InputText
    if (g.IO.ConfigDragClickToInputText && temp_input_allowed &&
        !temp_input_is_active)
      if (g.ActiveId == id && hovered && g.IO.MouseReleased[0] &&
          !IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold *
                                           DRAG_MOUSE_THRESHOLD_FACTOR)) {
        g.NavActivateId = id;
        g.NavActivateFlags = ActivateFlags_PreferInput;
        temp_input_is_active = true;
      }

    if (make_active && !temp_input_is_active) {
      SetActiveID(id, window);
      SetFocusID(id, window);
      FocusWindow(window);
      g.ActiveIdUsingNavDirMask = (1 << Dir_Left) | (1 << Dir_Right);
    }
  }

  if (temp_input_is_active) {
    // Only clamp CTRL+Click input when SliderFlags_AlwaysClamp is set
    const bool is_clamp_input = (flags & SliderFlags_AlwaysClamp) != 0 &&
                                (p_min == NULL || p_max == NULL ||
                                 DataTypeCompare(data_type, p_min, p_max) < 0);
    return TempInputScalar(frame_bb, id, label, data_type, p_data, format,
                           is_clamp_input ? p_min : NULL,
                           is_clamp_input ? p_max : NULL);
  }

  // Draw frame
  const U32 frame_col = GetColorU32(g.ActiveId == id ? Col_FrameBgActive
                                    : hovered        ? Col_FrameBgHovered
                                                     : Col_FrameBg);
  RenderNavHighlight(frame_bb, id);
  RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

  // Drag behavior
  const bool value_changed =
      DragBehavior(id, data_type, p_data, v_speed, p_min, p_max, format, flags);
  if (value_changed)
    MarkItemEdited(id);

  // Display value using user-provided display format so user can add
  // prefix/suffix/decorations to the value.
  char value_buf[64];
  const char *value_buf_end =
      value_buf + DataTypeFormatString(value_buf, GUI_ARRAYSIZE(value_buf),
                                       data_type, p_data, format);
  if (g.LogEnabled)
    LogSetNextTextDecoration("{", "}");
  RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL,
                    Vec2(0.5f, 0.5f));

  if (label_size.x > 0.0f)
    RenderText(Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x,
                    frame_bb.Min.y + style.FramePadding.y),
               label);

  GUI_TEST_ENGINE_ITEM_INFO(
      id, label,
      g.LastItemData.StatusFlags |
          (temp_input_allowed ? ItemStatusFlags_Inputable : 0));
  return value_changed;
}

inline bool Gui::DragScalarN(const char *label, DataType data_type,
                             void *p_data, int components, float v_speed,
                             const void *p_min, const void *p_max,
                             const char *format, SliderFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  bool value_changed = false;
  BeginGroup();
  PushID(label);
  PushMultiItemsWidths(components, CalcItemWidth());
  size_t type_size = GDataTypeInfo[data_type].Size;
  for (int i = 0; i < components; i++) {
    PushID(i);
    if (i > 0)
      SameLine(0, g.Style.ItemInnerSpacing.x);
    value_changed |=
        DragScalar("", data_type, p_data, v_speed, p_min, p_max, format, flags);
    PopID();
    PopItemWidth();
    p_data = (void *)((char *)p_data + type_size);
  }
  PopID();

  const char *label_end = FindRenderedTextEnd(label);
  if (label != label_end) {
    SameLine(0, g.Style.ItemInnerSpacing.x);
    TextEx(label, label_end);
  }

  EndGroup();
  return value_changed;
}

inline bool Gui::DragFloat(const char *label, float *v, float v_speed,
                           float v_min, float v_max, const char *format,
                           SliderFlags flags) {
  return DragScalar(label, DataType_Float, v, v_speed, &v_min, &v_max, format,
                    flags);
}

inline bool Gui::DragFloat2(const char *label, float v[2], float v_speed,
                            float v_min, float v_max, const char *format,
                            SliderFlags flags) {
  return DragScalarN(label, DataType_Float, v, 2, v_speed, &v_min, &v_max,
                     format, flags);
}

inline bool Gui::DragFloat3(const char *label, float v[3], float v_speed,
                            float v_min, float v_max, const char *format,
                            SliderFlags flags) {
  return DragScalarN(label, DataType_Float, v, 3, v_speed, &v_min, &v_max,
                     format, flags);
}

inline bool Gui::DragFloat4(const char *label, float v[4], float v_speed,
                            float v_min, float v_max, const char *format,
                            SliderFlags flags) {
  return DragScalarN(label, DataType_Float, v, 4, v_speed, &v_min, &v_max,
                     format, flags);
}

// NB: You likely want to specify the SliderFlags_AlwaysClamp when using
// this.
inline bool Gui::DragFloatRange2(const char *label, float *v_current_min,
                                 float *v_current_max, float v_speed,
                                 float v_min, float v_max, const char *format,
                                 const char *format_max, SliderFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  PushID(label);
  BeginGroup();
  PushMultiItemsWidths(2, CalcItemWidth());

  float min_min = (v_min >= v_max) ? -FLT_MAX : v_min;
  float min_max =
      (v_min >= v_max) ? *v_current_max : Min(v_max, *v_current_max);
  SliderFlags min_flags =
      flags | ((min_min == min_max) ? SliderFlags_ReadOnly : 0);
  bool value_changed =
      DragScalar("##min", DataType_Float, v_current_min, v_speed, &min_min,
                 &min_max, format, min_flags);
  PopItemWidth();
  SameLine(0, g.Style.ItemInnerSpacing.x);

  float max_min =
      (v_min >= v_max) ? *v_current_min : Max(v_min, *v_current_min);
  float max_max = (v_min >= v_max) ? FLT_MAX : v_max;
  SliderFlags max_flags =
      flags | ((max_min == max_max) ? SliderFlags_ReadOnly : 0);
  value_changed |=
      DragScalar("##max", DataType_Float, v_current_max, v_speed, &max_min,
                 &max_max, format_max ? format_max : format, max_flags);
  PopItemWidth();
  SameLine(0, g.Style.ItemInnerSpacing.x);

  TextEx(label, FindRenderedTextEnd(label));
  EndGroup();
  PopID();

  return value_changed;
}

// NB: v_speed is float to allow adjusting the drag speed with more precision
inline bool Gui::DragInt(const char *label, int *v, float v_speed, int v_min,
                         int v_max, const char *format, SliderFlags flags) {
  return DragScalar(label, DataType_S32, v, v_speed, &v_min, &v_max, format,
                    flags);
}

inline bool Gui::DragInt2(const char *label, int v[2], float v_speed, int v_min,
                          int v_max, const char *format, SliderFlags flags) {
  return DragScalarN(label, DataType_S32, v, 2, v_speed, &v_min, &v_max, format,
                     flags);
}

inline bool Gui::DragInt3(const char *label, int v[3], float v_speed, int v_min,
                          int v_max, const char *format, SliderFlags flags) {
  return DragScalarN(label, DataType_S32, v, 3, v_speed, &v_min, &v_max, format,
                     flags);
}

inline bool Gui::DragInt4(const char *label, int v[4], float v_speed, int v_min,
                          int v_max, const char *format, SliderFlags flags) {
  return DragScalarN(label, DataType_S32, v, 4, v_speed, &v_min, &v_max, format,
                     flags);
}

// NB: You likely want to specify the SliderFlags_AlwaysClamp when using
// this.
inline bool Gui::DragIntRange2(const char *label, int *v_current_min,
                               int *v_current_max, float v_speed, int v_min,
                               int v_max, const char *format,
                               const char *format_max, SliderFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  PushID(label);
  BeginGroup();
  PushMultiItemsWidths(2, CalcItemWidth());

  int min_min = (v_min >= v_max) ? INT_MIN : v_min;
  int min_max = (v_min >= v_max) ? *v_current_max : Min(v_max, *v_current_max);
  SliderFlags min_flags =
      flags | ((min_min == min_max) ? SliderFlags_ReadOnly : 0);
  bool value_changed = DragInt("##min", v_current_min, v_speed, min_min,
                               min_max, format, min_flags);
  PopItemWidth();
  SameLine(0, g.Style.ItemInnerSpacing.x);

  int max_min = (v_min >= v_max) ? *v_current_min : Max(v_min, *v_current_min);
  int max_max = (v_min >= v_max) ? INT_MAX : v_max;
  SliderFlags max_flags =
      flags | ((max_min == max_max) ? SliderFlags_ReadOnly : 0);
  value_changed |= DragInt("##max", v_current_max, v_speed, max_min, max_max,
                           format_max ? format_max : format, max_flags);
  PopItemWidth();
  SameLine(0, g.Style.ItemInnerSpacing.x);

  TextEx(label, FindRenderedTextEnd(label));
  EndGroup();
  PopID();

  return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
//-------------------------------------------------------------------------
// - ScaleRatioFromValueT<> [Internal]
// - ScaleValueFromRatioT<> [Internal]
// - SliderBehaviorT<>() [Internal]
// - SliderBehavior() [Internal]
// - SliderScalar()
// - SliderScalarN()
// - SliderFloat()
// - SliderFloat2()
// - SliderFloat3()
// - SliderFloat4()
// - SliderAngle()
// - SliderInt()
// - SliderInt2()
// - SliderInt3()
// - SliderInt4()
// - VSliderScalar()
// - VSliderFloat()
// - VSliderInt()
//-------------------------------------------------------------------------

// Convert a value v in the output space of a slider into a parametric position
// on the slider itself (the logical opposite of ScaleValueFromRatioT)
template <typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
float Gui::ScaleRatioFromValueT(DataType data_type, TYPE v, TYPE v_min,
                                TYPE v_max, bool is_logarithmic,
                                float logarithmic_zero_epsilon,
                                float zero_deadzone_halfsize) {
  if (v_min == v_max)
    return 0.0f;
  GUI_UNUSED(data_type);

  const TYPE v_clamped =
      (v_min < v_max) ? Clamp(v, v_min, v_max) : Clamp(v, v_max, v_min);
  if (is_logarithmic) {
    bool flipped = v_max < v_min;

    if (flipped) // Handle the case where the range is backwards
      Swap(v_min, v_max);

    // Fudge min/max to avoid getting close to log(0)
    FLOATTYPE v_min_fudged = (Abs((FLOATTYPE)v_min) < logarithmic_zero_epsilon)
                                 ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon
                                                   : logarithmic_zero_epsilon)
                                 : (FLOATTYPE)v_min;
    FLOATTYPE v_max_fudged = (Abs((FLOATTYPE)v_max) < logarithmic_zero_epsilon)
                                 ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon
                                                   : logarithmic_zero_epsilon)
                                 : (FLOATTYPE)v_max;

    // Awkward special cases - we need ranges of the form (-100 .. 0) to convert
    // to (-100 .. -epsilon), not (-100 .. epsilon)
    if ((v_min == 0.0f) && (v_max < 0.0f))
      v_min_fudged = -logarithmic_zero_epsilon;
    else if ((v_max == 0.0f) && (v_min < 0.0f))
      v_max_fudged = -logarithmic_zero_epsilon;

    float result;
    if (v_clamped <= v_min_fudged)
      result =
          0.0f; // Workaround for values that are in-range but below our fudge
    else if (v_clamped >= v_max_fudged)
      result =
          1.0f; // Workaround for values that are in-range but above our fudge
    else if ((v_min * v_max) <
             0.0f) // Range crosses zero, so split into two portions
    {
      float zero_point_center =
          (-(float)v_min) /
          ((float)v_max -
           (float)v_min); // The zero point in parametric space.  There's an
                          // argument we should take the logarithmic nature into
                          // account when calculating this, but for now this
                          // should do (and the most common case of a
                          // symmetrical range works fine)
      float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
      float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
      if (v == 0.0f)
        result = zero_point_center; // Special case for exactly zero
      else if (v < 0.0f)
        result =
            (1.0f -
             (float)(Log(-(FLOATTYPE)v_clamped / logarithmic_zero_epsilon) /
                     Log(-v_min_fudged / logarithmic_zero_epsilon))) *
            zero_point_snap_L;
      else
        result = zero_point_snap_R +
                 ((float)(Log((FLOATTYPE)v_clamped / logarithmic_zero_epsilon) /
                          Log(v_max_fudged / logarithmic_zero_epsilon)) *
                  (1.0f - zero_point_snap_R));
    } else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
      result = 1.0f - (float)(Log(-(FLOATTYPE)v_clamped / -v_max_fudged) /
                              Log(-v_min_fudged / -v_max_fudged));
    else
      result = (float)(Log((FLOATTYPE)v_clamped / v_min_fudged) /
                       Log(v_max_fudged / v_min_fudged));

    return flipped ? (1.0f - result) : result;
  } else {
    // Linear slider
    return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) /
                   (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));
  }
}

// Convert a parametric position on a slider into a value v in the output space
// (the logical opposite of ScaleRatioFromValueT)
template <typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
TYPE Gui::ScaleValueFromRatioT(DataType data_type, float t, TYPE v_min,
                               TYPE v_max, bool is_logarithmic,
                               float logarithmic_zero_epsilon,
                               float zero_deadzone_halfsize) {
  // We special-case the extents because otherwise our logarithmic fudging can
  // lead to "mathematically correct" but non-intuitive behaviors like a
  // fully-left slider not actually reaching the minimum value. Also generally
  // simpler.
  if (t <= 0.0f || v_min == v_max)
    return v_min;
  if (t >= 1.0f)
    return v_max;

  TYPE result = (TYPE)0;
  if (is_logarithmic) {
    // Fudge min/max to avoid getting silly results close to zero
    FLOATTYPE v_min_fudged = (Abs((FLOATTYPE)v_min) < logarithmic_zero_epsilon)
                                 ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon
                                                   : logarithmic_zero_epsilon)
                                 : (FLOATTYPE)v_min;
    FLOATTYPE v_max_fudged = (Abs((FLOATTYPE)v_max) < logarithmic_zero_epsilon)
                                 ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon
                                                   : logarithmic_zero_epsilon)
                                 : (FLOATTYPE)v_max;

    const bool flipped = v_max < v_min; // Check if range is "backwards"
    if (flipped)
      Swap(v_min_fudged, v_max_fudged);

    // Awkward special case - we need ranges of the form (-100 .. 0) to convert
    // to (-100 .. -epsilon), not (-100 .. epsilon)
    if ((v_max == 0.0f) && (v_min < 0.0f))
      v_max_fudged = -logarithmic_zero_epsilon;

    float t_with_flip =
        flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for
                                  // us flipping the range

    if ((v_min * v_max) <
        0.0f) // Range crosses zero, so we have to do this in two parts
    {
      float zero_point_center =
          (-(float)Min(v_min, v_max)) /
          Abs((float)v_max -
              (float)v_min); // The zero point in parametric space
      float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
      float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
      if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
        result = (TYPE)0.0f; // Special case to make getting exactly zero
                             // possible (the epsilon prevents it otherwise)
      else if (t_with_flip < zero_point_center)
        result = (TYPE) -
                 (logarithmic_zero_epsilon *
                  Pow(-v_min_fudged / logarithmic_zero_epsilon,
                      (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
      else
        result = (TYPE)(logarithmic_zero_epsilon *
                        Pow(v_max_fudged / logarithmic_zero_epsilon,
                            (FLOATTYPE)((t_with_flip - zero_point_snap_R) /
                                        (1.0f - zero_point_snap_R))));
    } else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
      result = (TYPE) - (-v_max_fudged * Pow(-v_min_fudged / -v_max_fudged,
                                             (FLOATTYPE)(1.0f - t_with_flip)));
    else
      result = (TYPE)(v_min_fudged *
                      Pow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
  } else {
    // Linear slider
    const bool is_floating_point =
        (data_type == DataType_Float) || (data_type == DataType_Double);
    if (is_floating_point) {
      result = Lerp(v_min, v_max, t);
    } else if (t < 1.0) {
      // - For integer values we want the clicking position to match the grab
      // box so we round above
      //   This code is carefully tuned to work with large values (e.g. high
      //   ranges of U64) while preserving this property..
      // - Not doing a *1.0 multiply at the end of a range as it tends to be
      // lossy. While absolute aiming at a large s64/u64
      //   range is going to be imprecise anyway, with this check we at least
      //   make the edge values matches expected limits.
      FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
      result = (TYPE)((SIGNEDTYPE)v_min +
                      (SIGNEDTYPE)(v_new_off_f +
                                   (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));
    }
  }

  return result;
}

// FIXME: Try to move more of the code into shared SliderBehavior()
template <typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool Gui::SliderBehaviorT(const Rect &bb, ID id, DataType data_type, TYPE *v,
                          const TYPE v_min, const TYPE v_max,
                          const char *format, SliderFlags flags,
                          Rect *out_grab_bb) {
  Context &g = *GGui;
  const Style &style = g.Style;

  const Axis axis = (flags & SliderFlags_Vertical) ? Axis_Y : Axis_X;
  const bool is_logarithmic = (flags & SliderFlags_Logarithmic) != 0;
  const bool is_floating_point =
      (data_type == DataType_Float) || (data_type == DataType_Double);
  const float v_range_f =
      (float)(v_min < v_max ? v_max - v_min
                            : v_min - v_max); // We don't need high precision
                                              // for what we do with it.

  // Calculate bounds
  const float grab_padding = 2.0f; // FIXME: Should be part of style.
  const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
  float grab_sz = style.GrabMinSize;
  if (!is_floating_point &&
      v_range_f >= 0.0f) // v_range_f < 0 may happen on integer overflows
    grab_sz = Max(slider_sz / (v_range_f + 1),
                  style.GrabMinSize); // For integer sliders: if possible have
                                      // the grab size represent 1 unit
  grab_sz = Min(grab_sz, slider_sz);
  const float slider_usable_sz = slider_sz - grab_sz;
  const float slider_usable_pos_min =
      bb.Min[axis] + grab_padding + grab_sz * 0.5f;
  const float slider_usable_pos_max =
      bb.Max[axis] - grab_padding - grab_sz * 0.5f;

  float logarithmic_zero_epsilon =
      0.0f;                            // Only valid when is_logarithmic is true
  float zero_deadzone_halfsize = 0.0f; // Only valid when is_logarithmic is true
  if (is_logarithmic) {
    // When using logarithmic sliders, we need to clamp to avoid hitting zero,
    // but our choice of clamp value greatly affects slider precision. We
    // attempt to use the specified precision to estimate a good lower bound.
    const int decimal_precision =
        is_floating_point ? ParseFormatPrecision(format, 3) : 1;
    logarithmic_zero_epsilon = Pow(0.1f, (float)decimal_precision);
    zero_deadzone_halfsize =
        (style.LogSliderDeadzone * 0.5f) / Max(slider_usable_sz, 1.0f);
  }

  // Process interacting with the slider
  bool value_changed = false;
  if (g.ActiveId == id) {
    bool set_new_value = false;
    float clicked_t = 0.0f;
    if (g.ActiveIdSource == InputSource_Mouse) {
      if (!g.IO.MouseDown[0]) {
        ClearActiveID();
      } else {
        const float mouse_abs_pos = g.IO.MousePos[axis];
        if (g.ActiveIdIsJustActivated) {
          float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(
              data_type, *v, v_min, v_max, is_logarithmic,
              logarithmic_zero_epsilon, zero_deadzone_halfsize);
          if (axis == Axis_Y)
            grab_t = 1.0f - grab_t;
          const float grab_pos =
              Lerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
          const bool clicked_around_grab =
              (mouse_abs_pos >= grab_pos - grab_sz * 0.5f - 1.0f) &&
              (mouse_abs_pos <= grab_pos + grab_sz * 0.5f +
                                    1.0f); // No harm being extra generous here.
          g.SliderGrabClickOffset = (clicked_around_grab && is_floating_point)
                                        ? mouse_abs_pos - grab_pos
                                        : 0.0f;
        }
        if (slider_usable_sz > 0.0f)
          clicked_t = Saturate((mouse_abs_pos - g.SliderGrabClickOffset -
                                slider_usable_pos_min) /
                               slider_usable_sz);
        if (axis == Axis_Y)
          clicked_t = 1.0f - clicked_t;
        set_new_value = true;
      }
    } else if (g.ActiveIdSource == InputSource_Keyboard ||
               g.ActiveIdSource == InputSource_Gamepad) {
      if (g.ActiveIdIsJustActivated) {
        g.SliderCurrentAccum =
            0.0f; // Reset any stored nav delta upon activation
        g.SliderCurrentAccumDirty = false;
      }

      float input_delta = (axis == Axis_X) ? GetNavTweakPressedAmount(axis)
                                           : -GetNavTweakPressedAmount(axis);
      if (input_delta != 0.0f) {
        const bool tweak_slow =
            IsKeyDown((g.NavInputSource == InputSource_Gamepad)
                          ? Key_NavGamepadTweakSlow
                          : Key_NavKeyboardTweakSlow);
        const bool tweak_fast =
            IsKeyDown((g.NavInputSource == InputSource_Gamepad)
                          ? Key_NavGamepadTweakFast
                          : Key_NavKeyboardTweakFast);
        const int decimal_precision =
            is_floating_point ? ParseFormatPrecision(format, 3) : 0;
        if (decimal_precision > 0) {
          input_delta /=
              100.0f; // Gamepad/keyboard tweak speeds in % of slider bounds
          if (tweak_slow)
            input_delta /= 10.0f;
        } else {
          if ((v_range_f >= -100.0f && v_range_f <= 100.0f &&
               v_range_f != 0.0f) ||
              tweak_slow)
            input_delta =
                ((input_delta < 0.0f) ? -1.0f : +1.0f) /
                v_range_f; // Gamepad/keyboard tweak speeds in integer steps
          else
            input_delta /= 100.0f;
        }
        if (tweak_fast)
          input_delta *= 10.0f;

        g.SliderCurrentAccum += input_delta;
        g.SliderCurrentAccumDirty = true;
      }

      float delta = g.SliderCurrentAccum;
      if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated) {
        ClearActiveID();
      } else if (g.SliderCurrentAccumDirty) {
        clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(
            data_type, *v, v_min, v_max, is_logarithmic,
            logarithmic_zero_epsilon, zero_deadzone_halfsize);

        if ((clicked_t >= 1.0f && delta > 0.0f) ||
            (clicked_t <= 0.0f &&
             delta < 0.0f)) // This is to avoid applying the saturation when
                            // already past the limits
        {
          set_new_value = false;
          g.SliderCurrentAccum = 0.0f; // If pushing up against the limits,
                                       // don't continue to accumulate
        } else {
          set_new_value = true;
          float old_clicked_t = clicked_t;
          clicked_t = Saturate(clicked_t + delta);

          // Calculate what our "new" clicked_t will be, and thus how far we
          // actually moved the slider, and subtract this from the accumulator
          TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(
              data_type, clicked_t, v_min, v_max, is_logarithmic,
              logarithmic_zero_epsilon, zero_deadzone_halfsize);
          if (is_floating_point && !(flags & SliderFlags_NoRoundToFormat))
            v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
          float new_clicked_t =
              ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(
                  data_type, v_new, v_min, v_max, is_logarithmic,
                  logarithmic_zero_epsilon, zero_deadzone_halfsize);

          if (delta > 0)
            g.SliderCurrentAccum -= Min(new_clicked_t - old_clicked_t, delta);
          else
            g.SliderCurrentAccum -= Max(new_clicked_t - old_clicked_t, delta);
        }

        g.SliderCurrentAccumDirty = false;
      }
    }

    if (set_new_value)
      if ((g.LastItemData.InFlags & ItemFlags_ReadOnly) ||
          (flags & SliderFlags_ReadOnly))
        set_new_value = false;

    if (set_new_value) {
      TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(
          data_type, clicked_t, v_min, v_max, is_logarithmic,
          logarithmic_zero_epsilon, zero_deadzone_halfsize);

      // Round to user desired precision based on format string
      if (is_floating_point && !(flags & SliderFlags_NoRoundToFormat))
        v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);

      // Apply result
      if (*v != v_new) {
        *v = v_new;
        value_changed = true;
      }
    }
  }

  if (slider_sz < 1.0f) {
    *out_grab_bb = Rect(bb.Min, bb.Min);
  } else {
    // Output grab position so it can be displayed by the caller
    float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(
        data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon,
        zero_deadzone_halfsize);
    if (axis == Axis_Y)
      grab_t = 1.0f - grab_t;
    const float grab_pos =
        Lerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    if (axis == Axis_X)
      *out_grab_bb = Rect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding,
                          grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);
    else
      *out_grab_bb = Rect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f,
                          bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);
  }

  return value_changed;
}

// For 32-bit and larger types, slider bounds are limited to half the natural
// type range. So e.g. an integer Slider between INT_MAX-10 and INT_MAX will
// fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok. It
// would be possible to lift that limitation with some work but it doesn't seem
// to be worth it for sliders.
inline bool Gui::SliderBehavior(const Rect &bb, ID id, DataType data_type,
                                void *p_v, const void *p_min, const void *p_max,
                                const char *format, SliderFlags flags,
                                Rect *out_grab_bb) {
  // Read gui.cpp "API BREAKING CHANGES" section for 1.78 if you hit this
  // assert.
  GUI_ASSERT((flags == 1 || (flags & SliderFlags_InvalidMask_) == 0) &&
             "Invalid SliderFlags flag!  Has the 'float power' argument "
             "been mistakenly cast to flags? Call function with "
             "SliderFlags_Logarithmic flags instead.");

  switch (data_type) {
  case DataType_S8: {
    S32 v32 = (S32) * (S8 *)p_v;
    bool r = SliderBehaviorT<S32, S32, float>(
        bb, id, DataType_S32, &v32, *(const S8 *)p_min, *(const S8 *)p_max,
        format, flags, out_grab_bb);
    if (r)
      *(S8 *)p_v = (S8)v32;
    return r;
  }
  case DataType_U8: {
    U32 v32 = (U32) * (U8 *)p_v;
    bool r = SliderBehaviorT<U32, S32, float>(
        bb, id, DataType_U32, &v32, *(const U8 *)p_min, *(const U8 *)p_max,
        format, flags, out_grab_bb);
    if (r)
      *(U8 *)p_v = (U8)v32;
    return r;
  }
  case DataType_S16: {
    S32 v32 = (S32) * (S16 *)p_v;
    bool r = SliderBehaviorT<S32, S32, float>(
        bb, id, DataType_S32, &v32, *(const S16 *)p_min, *(const S16 *)p_max,
        format, flags, out_grab_bb);
    if (r)
      *(S16 *)p_v = (S16)v32;
    return r;
  }
  case DataType_U16: {
    U32 v32 = (U32) * (U16 *)p_v;
    bool r = SliderBehaviorT<U32, S32, float>(
        bb, id, DataType_U32, &v32, *(const U16 *)p_min, *(const U16 *)p_max,
        format, flags, out_grab_bb);
    if (r)
      *(U16 *)p_v = (U16)v32;
    return r;
  }
  case DataType_S32:
    GUI_ASSERT(*(const S32 *)p_min >= GUI_S32_MIN / 2 &&
               *(const S32 *)p_max <= GUI_S32_MAX / 2);
    return SliderBehaviorT<S32, S32, float>(
        bb, id, data_type, (S32 *)p_v, *(const S32 *)p_min, *(const S32 *)p_max,
        format, flags, out_grab_bb);
  case DataType_U32:
    GUI_ASSERT(*(const U32 *)p_max <= GUI_U32_MAX / 2);
    return SliderBehaviorT<U32, S32, float>(
        bb, id, data_type, (U32 *)p_v, *(const U32 *)p_min, *(const U32 *)p_max,
        format, flags, out_grab_bb);
  case DataType_S64:
    GUI_ASSERT(*(const S64 *)p_min >= GUI_S64_MIN / 2 &&
               *(const S64 *)p_max <= GUI_S64_MAX / 2);
    return SliderBehaviorT<S64, S64, double>(
        bb, id, data_type, (S64 *)p_v, *(const S64 *)p_min, *(const S64 *)p_max,
        format, flags, out_grab_bb);
  case DataType_U64:
    GUI_ASSERT(*(const U64 *)p_max <= GUI_U64_MAX / 2);
    return SliderBehaviorT<U64, S64, double>(
        bb, id, data_type, (U64 *)p_v, *(const U64 *)p_min, *(const U64 *)p_max,
        format, flags, out_grab_bb);
  case DataType_Float:
    GUI_ASSERT(*(const float *)p_min >= -FLT_MAX / 2.0f &&
               *(const float *)p_max <= FLT_MAX / 2.0f);
    return SliderBehaviorT<float, float, float>(
        bb, id, data_type, (float *)p_v, *(const float *)p_min,
        *(const float *)p_max, format, flags, out_grab_bb);
  case DataType_Double:
    GUI_ASSERT(*(const double *)p_min >= -DBL_MAX / 2.0f &&
               *(const double *)p_max <= DBL_MAX / 2.0f);
    return SliderBehaviorT<double, double, double>(
        bb, id, data_type, (double *)p_v, *(const double *)p_min,
        *(const double *)p_max, format, flags, out_grab_bb);
  case DataType_COUNT:
    break;
  }
  GUI_ASSERT(0);
  return false;
}

// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the
// data. For a slider, they are all required. Read code of e.g. SliderFloat(),
// SliderInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how
// to use this function directly.
inline bool Gui::SliderScalar(const char *label, DataType data_type,
                              void *p_data, const void *p_min,
                              const void *p_max, const char *format,
                              SliderFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  const Style &style = g.Style;
  const ID id = window->GetID(label);
  const float w = CalcItemWidth();

  const Vec2 label_size = CalcTextSize(label, NULL, true);
  const Rect frame_bb(window->DC.CursorPos,
                      Add(window->DC.CursorPos,
                          Vec2(w, label_size.y + style.FramePadding.y * 2.0f)));
  const Rect total_bb(
      frame_bb.Min,
      Add(frame_bb.Max,
          Vec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x
                                   : 0.0f,
               0.0f)));

  const bool temp_input_allowed = (flags & SliderFlags_NoInput) == 0;
  ItemSize(total_bb, style.FramePadding.y);
  if (!ItemAdd(total_bb, id, &frame_bb,
               temp_input_allowed ? ItemFlags_Inputable : 0))
    return false;

  // Default format string when passing NULL
  if (format == NULL)
    format = DataTypeGetInfo(data_type)->PrintFmt;

  const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);
  bool temp_input_is_active = temp_input_allowed && TempInputIsActive(id);
  if (!temp_input_is_active) {
    // Tabbing or CTRL-clicking on Slider turns it into an input box
    const bool clicked = hovered && IsMouseClicked(0, id);
    const bool make_active = (clicked || g.NavActivateId == id);
    if (make_active && clicked)
      SetKeyOwner(Key_MouseLeft, id);
    if (make_active && temp_input_allowed)
      if ((clicked && g.IO.KeyCtrl) ||
          (g.NavActivateId == id &&
           (g.NavActivateFlags & ActivateFlags_PreferInput)))
        temp_input_is_active = true;

    if (make_active && !temp_input_is_active) {
      SetActiveID(id, window);
      SetFocusID(id, window);
      FocusWindow(window);
      g.ActiveIdUsingNavDirMask |= (1 << Dir_Left) | (1 << Dir_Right);
    }
  }

  if (temp_input_is_active) {
    // Only clamp CTRL+Click input when SliderFlags_AlwaysClamp is set
    const bool is_clamp_input = (flags & SliderFlags_AlwaysClamp) != 0;
    return TempInputScalar(frame_bb, id, label, data_type, p_data, format,
                           is_clamp_input ? p_min : NULL,
                           is_clamp_input ? p_max : NULL);
  }

  // Draw frame
  const U32 frame_col = GetColorU32(g.ActiveId == id ? Col_FrameBgActive
                                    : hovered        ? Col_FrameBgHovered
                                                     : Col_FrameBg);
  RenderNavHighlight(frame_bb, id);
  RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true,
              g.Style.FrameRounding);

  // Slider behavior
  Rect grab_bb;
  const bool value_changed = SliderBehavior(
      frame_bb, id, data_type, p_data, p_min, p_max, format, flags, &grab_bb);
  if (value_changed)
    MarkItemEdited(id);

  // Render grab
  if (grab_bb.Max.x > grab_bb.Min.x)
    window->DrawList->AddRectFilled(
        grab_bb.Min, grab_bb.Max,
        GetColorU32(g.ActiveId == id ? Col_SliderGrabActive : Col_SliderGrab),
        style.GrabRounding);

  // Display value using user-provided display format so user can add
  // prefix/suffix/decorations to the value.
  char value_buf[64];
  const char *value_buf_end =
      value_buf + DataTypeFormatString(value_buf, GUI_ARRAYSIZE(value_buf),
                                       data_type, p_data, format);
  if (g.LogEnabled)
    LogSetNextTextDecoration("{", "}");
  RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL,
                    Vec2(0.5f, 0.5f));

  if (label_size.x > 0.0f)
    RenderText(Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x,
                    frame_bb.Min.y + style.FramePadding.y),
               label);

  GUI_TEST_ENGINE_ITEM_INFO(
      id, label,
      g.LastItemData.StatusFlags |
          (temp_input_allowed ? ItemStatusFlags_Inputable : 0));
  return value_changed;
}

// Add multiple sliders on 1 line for compact edition of multiple components
inline bool Gui::SliderScalarN(const char *label, DataType data_type, void *v,
                               int components, const void *v_min,
                               const void *v_max, const char *format,
                               SliderFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  bool value_changed = false;
  BeginGroup();
  PushID(label);
  PushMultiItemsWidths(components, CalcItemWidth());
  size_t type_size = GDataTypeInfo[data_type].Size;
  for (int i = 0; i < components; i++) {
    PushID(i);
    if (i > 0)
      SameLine(0, g.Style.ItemInnerSpacing.x);
    value_changed |=
        SliderScalar("", data_type, v, v_min, v_max, format, flags);
    PopID();
    PopItemWidth();
    v = (void *)((char *)v + type_size);
  }
  PopID();

  const char *label_end = FindRenderedTextEnd(label);
  if (label != label_end) {
    SameLine(0, g.Style.ItemInnerSpacing.x);
    TextEx(label, label_end);
  }

  EndGroup();
  return value_changed;
}

inline bool Gui::SliderFloat(const char *label, float *v, float v_min,
                             float v_max, const char *format,
                             SliderFlags flags) {
  return SliderScalar(label, DataType_Float, v, &v_min, &v_max, format, flags);
}

inline bool Gui::SliderFloat2(const char *label, float v[2], float v_min,
                              float v_max, const char *format,
                              SliderFlags flags) {
  return SliderScalarN(label, DataType_Float, v, 2, &v_min, &v_max, format,
                       flags);
}

inline bool Gui::SliderFloat3(const char *label, float v[3], float v_min,
                              float v_max, const char *format,
                              SliderFlags flags) {
  return SliderScalarN(label, DataType_Float, v, 3, &v_min, &v_max, format,
                       flags);
}

inline bool Gui::SliderFloat4(const char *label, float v[4], float v_min,
                              float v_max, const char *format,
                              SliderFlags flags) {
  return SliderScalarN(label, DataType_Float, v, 4, &v_min, &v_max, format,
                       flags);
}

inline bool Gui::SliderAngle(const char *label, float *v_rad,
                             float v_degrees_min, float v_degrees_max,
                             const char *format, SliderFlags flags) {
  if (format == NULL)
    format = "%.0f deg";
  float v_deg = (*v_rad) * 360.0f / (2 * GUI_PI);
  bool value_changed =
      SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, flags);
  *v_rad = v_deg * (2 * GUI_PI) / 360.0f;
  return value_changed;
}

inline bool Gui::SliderInt(const char *label, int *v, int v_min, int v_max,
                           const char *format, SliderFlags flags) {
  return SliderScalar(label, DataType_S32, v, &v_min, &v_max, format, flags);
}

inline bool Gui::SliderInt2(const char *label, int v[2], int v_min, int v_max,
                            const char *format, SliderFlags flags) {
  return SliderScalarN(label, DataType_S32, v, 2, &v_min, &v_max, format,
                       flags);
}

inline bool Gui::SliderInt3(const char *label, int v[3], int v_min, int v_max,
                            const char *format, SliderFlags flags) {
  return SliderScalarN(label, DataType_S32, v, 3, &v_min, &v_max, format,
                       flags);
}

inline bool Gui::SliderInt4(const char *label, int v[4], int v_min, int v_max,
                            const char *format, SliderFlags flags) {
  return SliderScalarN(label, DataType_S32, v, 4, &v_min, &v_max, format,
                       flags);
}

inline bool Gui::VSliderScalar(const char *label, const Vec2 &size,
                               DataType data_type, void *p_data,
                               const void *p_min, const void *p_max,
                               const char *format, SliderFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  const Style &style = g.Style;
  const ID id = window->GetID(label);

  const Vec2 label_size = CalcTextSize(label, NULL, true);
  const Rect frame_bb(window->DC.CursorPos, Add(window->DC.CursorPos, size));
  const Rect bb(
      frame_bb.Min,
      Add(frame_bb.Max,
          Vec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x
                                   : 0.0f,
               0.0f)));

  ItemSize(bb, style.FramePadding.y);
  if (!ItemAdd(frame_bb, id))
    return false;

  // Default format string when passing NULL
  if (format == NULL)
    format = DataTypeGetInfo(data_type)->PrintFmt;

  const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);
  const bool clicked = hovered && IsMouseClicked(0, id);
  if (clicked || g.NavActivateId == id) {
    if (clicked)
      SetKeyOwner(Key_MouseLeft, id);
    SetActiveID(id, window);
    SetFocusID(id, window);
    FocusWindow(window);
    g.ActiveIdUsingNavDirMask |= (1 << Dir_Up) | (1 << Dir_Down);
  }

  // Draw frame
  const U32 frame_col = GetColorU32(g.ActiveId == id ? Col_FrameBgActive
                                    : hovered        ? Col_FrameBgHovered
                                                     : Col_FrameBg);
  RenderNavHighlight(frame_bb, id);
  RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true,
              g.Style.FrameRounding);

  // Slider behavior
  Rect grab_bb;
  const bool value_changed =
      SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format,
                     flags | SliderFlags_Vertical, &grab_bb);
  if (value_changed)
    MarkItemEdited(id);

  // Render grab
  if (grab_bb.Max.y > grab_bb.Min.y)
    window->DrawList->AddRectFilled(
        grab_bb.Min, grab_bb.Max,
        GetColorU32(g.ActiveId == id ? Col_SliderGrabActive : Col_SliderGrab),
        style.GrabRounding);

  // Display value using user-provided display format so user can add
  // prefix/suffix/decorations to the value. For the vertical slider we allow
  // centered text to overlap the frame padding
  char value_buf[64];
  const char *value_buf_end =
      value_buf + DataTypeFormatString(value_buf, GUI_ARRAYSIZE(value_buf),
                                       data_type, p_data, format);
  RenderTextClipped(Vec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y),
                    frame_bb.Max, value_buf, value_buf_end, NULL,
                    Vec2(0.5f, 0.0f));
  if (label_size.x > 0.0f)
    RenderText(Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x,
                    frame_bb.Min.y + style.FramePadding.y),
               label);

  return value_changed;
}

inline bool Gui::VSliderFloat(const char *label, const Vec2 &size, float *v,
                              float v_min, float v_max, const char *format,
                              SliderFlags flags) {
  return VSliderScalar(label, size, DataType_Float, v, &v_min, &v_max, format,
                       flags);
}

inline bool Gui::VSliderInt(const char *label, const Vec2 &size, int *v,
                            int v_min, int v_max, const char *format,
                            SliderFlags flags) {
  return VSliderScalar(label, size, DataType_S32, v, &v_min, &v_max, format,
                       flags);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
//-------------------------------------------------------------------------
// - ParseFormatFindStart() [Internal]
// - ParseFormatFindEnd() [Internal]
// - ParseFormatTrimDecorations() [Internal]
// - ParseFormatSanitizeForPrinting() [Internal]
// - ParseFormatSanitizeForScanning() [Internal]
// - ParseFormatPrecision() [Internal]
// - TempInputTextScalar() [Internal]
// - InputScalar()
// - InputScalarN()
// - InputFloat()
// - InputFloat2()
// - InputFloat3()
// - InputFloat4()
// - InputInt()
// - InputInt2()
// - InputInt3()
// - InputInt4()
// - InputDouble()
//-------------------------------------------------------------------------

// We don't use strchr() because our strings are usually very short and often
// start with '%'

// Extract the format out of a format string with leading or trailing
// decorations
//  fmt = "blah blah"  -> return ""
//  fmt = "%.3f"       -> return fmt
//  fmt = "hello %.3f" -> return fmt + 6
//  fmt = "%.3f hello" -> return buf written with "%.3f"
inline const char *ParseFormatTrimDecorations(const char *fmt, char *buf,
                                              size_t buf_size) {
  const char *fmt_start = ParseFormatFindStart(fmt);
  if (fmt_start[0] != '%')
    return "";
  const char *fmt_end = ParseFormatFindEnd(fmt_start);
  if (fmt_end[0] ==
      0) // If we only have leading decoration, we don't need to copy the data.
    return fmt_start;
  Strncpy(buf, fmt_start, Min((size_t)(fmt_end - fmt_start) + 1, buf_size));
  return buf;
}

// Sanitize format
// - Zero terminate so extra characters after format (e.g. "%f123") don't
// confuse atof/atoi
// - stb_sprintf.h supports several new modifiers which format numbers in a way
// that also makes them incompatible atof/atoi.
inline void ParseFormatSanitizeForPrinting(const char *fmt_in, char *fmt_out,
                                           size_t fmt_out_size) {
  const char *fmt_end = ParseFormatFindEnd(fmt_in);
  GUI_UNUSED(fmt_out_size);
  GUI_ASSERT(
      (size_t)(fmt_end - fmt_in + 1) <
      fmt_out_size); // Format is too long, let us know if this happens to you!
  while (fmt_in < fmt_end) {
    char c = *fmt_in++;
    if (c != '\'' && c != '$' &&
        c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also
                  // supports '.
      *(fmt_out++) = c;
  }
  *fmt_out = 0; // Zero-terminate
}

// - For scanning we need to remove all width and precision fields and flags
// "%+3.7f" -> "%f". BUT don't strip types like "%I64d" which includes digits. !
// "%07I64d" -> "%I64d"
inline const char *ParseFormatSanitizeForScanning(const char *fmt_in,
                                                  char *fmt_out,
                                                  size_t fmt_out_size) {
  const char *fmt_end = ParseFormatFindEnd(fmt_in);
  const char *fmt_out_begin = fmt_out;
  GUI_UNUSED(fmt_out_size);
  GUI_ASSERT(
      (size_t)(fmt_end - fmt_in + 1) <
      fmt_out_size); // Format is too long, let us know if this happens to you!
  bool has_type = false;
  while (fmt_in < fmt_end) {
    char c = *fmt_in++;
    if (!has_type &&
        ((c >= '0' && c <= '9') || c == '.' || c == '+' || c == '#'))
      continue;
    has_type |= ((c >= 'a' && c <= 'z') ||
                 (c >= 'A' && c <= 'Z')); // Stop skipping digits
    if (c != '\'' && c != '$' &&
        c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also
                  // supports '.
      *(fmt_out++) = c;
  }
  *fmt_out = 0; // Zero-terminate
  return fmt_out_begin;
}

template <typename TYPE>
static const char *Atoi(const char *src, TYPE *output) {
  int negative = 0;
  if (*src == '-') {
    negative = 1;
    src++;
  }
  if (*src == '+') {
    src++;
  }
  TYPE v = 0;
  while (*src >= '0' && *src <= '9')
    v = (v * 10) + (*src++ - '0');
  *output = negative ? -v : v;
  return src;
}

// Parse display precision back from the display format string
// FIXME: This is still used by some navigation code path to infer a minimum
// tweak step, but we should aim to rework widgets so it isn't needed.
inline int ParseFormatPrecision(const char *fmt, int default_precision) {
  fmt = ParseFormatFindStart(fmt);
  if (fmt[0] != '%')
    return default_precision;
  fmt++;
  while (*fmt >= '0' && *fmt <= '9')
    fmt++;
  int precision = INT_MAX;
  if (*fmt == '.') {
    fmt = Atoi<int>(fmt + 1, &precision);
    if (precision < 0 || precision > 99)
      precision = default_precision;
  }
  if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation
    precision = -1;
  if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)
    precision = -1;
  return (precision == INT_MAX) ? default_precision : precision;
}

// Create text input in place of another active widget (e.g. used when doing a
// CTRL+Click on drag/slider widgets)
// FIXME: Facilitate using this in variety of other situations.
inline bool Gui::TempInputText(const Rect &bb, ID id, const char *label,
                               char *buf, int buf_size, InputTextFlags flags) {
  // On the first frame, g.TempInputTextId == 0, then on subsequent frames it
  // becomes == id. We clear ActiveID on the first frame to allow the
  // InputText() taking it back.
  Context &g = *GGui;
  const bool init = (g.TempInputId != id);
  if (init)
    ClearActiveID();

  g.CurrentWindow->DC.CursorPos = bb.Min;
  bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(),
                                   flags | InputTextFlags_MergedItem);
  if (init) {
    // First frame we started displaying the InputText widget, we expect it to
    // take the active id.
    GUI_ASSERT(g.ActiveId == id);
    g.TempInputId = g.ActiveId;
  }
  return value_changed;
}

// Note that Drag/Slider functions are only forwarding the min/max values
// clamping values if the SliderFlags_AlwaysClamp flag is set! This is
// intended: this way we allow CTRL+Click manual input to set a value out of
// bounds, for maximum flexibility. However this may not be ideal for all uses,
// as some user code may break on out of bound values.
inline bool Gui::TempInputScalar(const Rect &bb, ID id, const char *label,
                                 DataType data_type, void *p_data,
                                 const char *format, const void *p_clamp_min,
                                 const void *p_clamp_max) {
  // FIXME: May need to clarify display behavior if format doesn't contain %.
  // "%d" -> "%d" / "There are %d items" -> "%d" / "items" -> "%d" (fallback).
  // Also see #6405
  const DataTypeInfo *type_info = DataTypeGetInfo(data_type);
  char fmt_buf[32];
  char data_buf[32];
  format = ParseFormatTrimDecorations(format, fmt_buf, GUI_ARRAYSIZE(fmt_buf));
  if (format[0] == 0)
    format = type_info->PrintFmt;
  DataTypeFormatString(data_buf, GUI_ARRAYSIZE(data_buf), data_type, p_data,
                       format);
  StrTrimBlanks(data_buf);

  InputTextFlags flags = InputTextFlags_AutoSelectAll |
                         (InputTextFlags)InputTextFlags_NoMarkEdited;

  bool value_changed = false;
  if (TempInputText(bb, id, label, data_buf, GUI_ARRAYSIZE(data_buf), flags)) {
    // Backup old value
    size_t data_type_size = type_info->Size;
    DataTypeTempStorage data_backup;
    memcpy(&data_backup, p_data, data_type_size);

    // Apply new value (or operations) then clamp
    DataTypeApplyFromText(data_buf, data_type, p_data, format);
    if (p_clamp_min || p_clamp_max) {
      if (p_clamp_min && p_clamp_max &&
          DataTypeCompare(data_type, p_clamp_min, p_clamp_max) > 0)
        Swap(p_clamp_min, p_clamp_max);
      DataTypeClamp(data_type, p_data, p_clamp_min, p_clamp_max);
    }

    // Only mark as edited if new value is different
    value_changed = memcmp(&data_backup, p_data, data_type_size) != 0;
    if (value_changed)
      MarkItemEdited(id);
  }
  return value_changed;
}

// Note: p_data, p_step, p_step_fast are _pointers_ to a memory address holding
// the data. For an Input widget, p_step and p_step_fast are optional. Read code
// of e.g. InputFloat(), InputInt() etc. or examples in 'Demo->Widgets->Data
// Types' to understand how to use this function directly.
inline bool Gui::InputScalar(const char *label, DataType data_type,
                             void *p_data, const void *p_step,
                             const void *p_step_fast, const char *format,
                             InputTextFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  Style &style = g.Style;

  if (format == NULL)
    format = DataTypeGetInfo(data_type)->PrintFmt;

  char buf[64];
  DataTypeFormatString(buf, GUI_ARRAYSIZE(buf), data_type, p_data, format);

  flags |= InputTextFlags_AutoSelectAll |
           (InputTextFlags)
               InputTextFlags_NoMarkEdited; // We call MarkItemEdited()
                                            // ourselves by comparing the actual
                                            // data rather than the string.

  bool value_changed = false;
  if (p_step == NULL) {
    if (InputText(label, buf, GUI_ARRAYSIZE(buf), flags))
      value_changed = DataTypeApplyFromText(buf, data_type, p_data, format);
  } else {
    const float button_size = GetFrameHeight();

    BeginGroup(); // The only purpose of the group here is to allow the caller
                  // to query item data e.g. IsItemActive()
    PushID(label);
    SetNextItemWidth(Max(
        1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));
    if (InputText("", buf, GUI_ARRAYSIZE(buf),
                  flags)) // PushId(label) + "" gives us the expected ID from
                          // outside point of view
      value_changed = DataTypeApplyFromText(buf, data_type, p_data, format);
    GUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label,
                              g.LastItemData.StatusFlags |
                                  ItemStatusFlags_Inputable);

    // Step buttons
    const Vec2 backup_frame_padding = style.FramePadding;
    style.FramePadding.x = style.FramePadding.y;
    ButtonFlags button_flags = ButtonFlags_Repeat | ButtonFlags_DontClosePopups;
    if (flags & InputTextFlags_ReadOnly)
      BeginDisabled();
    SameLine(0, style.ItemInnerSpacing.x);
    if (ButtonEx("-", Vec2(button_size, button_size), button_flags)) {
      DataTypeApplyOp(data_type, '-', p_data, p_data,
                      g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);
      value_changed = true;
    }
    SameLine(0, style.ItemInnerSpacing.x);
    if (ButtonEx("+", Vec2(button_size, button_size), button_flags)) {
      DataTypeApplyOp(data_type, '+', p_data, p_data,
                      g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);
      value_changed = true;
    }
    if (flags & InputTextFlags_ReadOnly)
      EndDisabled();

    const char *label_end = FindRenderedTextEnd(label);
    if (label != label_end) {
      SameLine(0, style.ItemInnerSpacing.x);
      TextEx(label, label_end);
    }
    style.FramePadding = backup_frame_padding;

    PopID();
    EndGroup();
  }
  if (value_changed)
    MarkItemEdited(g.LastItemData.ID);

  return value_changed;
}

inline bool Gui::InputScalarN(const char *label, DataType data_type,
                              void *p_data, int components, const void *p_step,
                              const void *p_step_fast, const char *format,
                              InputTextFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  bool value_changed = false;
  BeginGroup();
  PushID(label);
  PushMultiItemsWidths(components, CalcItemWidth());
  size_t type_size = GDataTypeInfo[data_type].Size;
  for (int i = 0; i < components; i++) {
    PushID(i);
    if (i > 0)
      SameLine(0, g.Style.ItemInnerSpacing.x);
    value_changed |=
        InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);
    PopID();
    PopItemWidth();
    p_data = (void *)((char *)p_data + type_size);
  }
  PopID();

  const char *label_end = FindRenderedTextEnd(label);
  if (label != label_end) {
    SameLine(0.0f, g.Style.ItemInnerSpacing.x);
    TextEx(label, label_end);
  }

  EndGroup();
  return value_changed;
}

inline bool Gui::InputFloat(const char *label, float *v, float step,
                            float step_fast, const char *format,
                            InputTextFlags flags) {
  return InputScalar(
      label, DataType_Float, (void *)v, (void *)(step > 0.0f ? &step : NULL),
      (void *)(step_fast > 0.0f ? &step_fast : NULL), format, flags);
}

inline bool Gui::InputFloat2(const char *label, float v[2], const char *format,
                             InputTextFlags flags) {
  return InputScalarN(label, DataType_Float, v, 2, NULL, NULL, format, flags);
}

inline bool Gui::InputFloat3(const char *label, float v[3], const char *format,
                             InputTextFlags flags) {
  return InputScalarN(label, DataType_Float, v, 3, NULL, NULL, format, flags);
}

inline bool Gui::InputFloat4(const char *label, float v[4], const char *format,
                             InputTextFlags flags) {
  return InputScalarN(label, DataType_Float, v, 4, NULL, NULL, format, flags);
}

inline bool Gui::InputInt(const char *label, int *v, int step, int step_fast,
                          InputTextFlags flags) {
  // Hexadecimal input provided as a convenience but the flag name is awkward.
  // Typically you'd use InputText() to parse your own data, if you want to
  // handle prefixes.
  const char *format =
      (flags & InputTextFlags_CharsHexadecimal) ? "%08X" : "%d";
  return InputScalar(
      label, DataType_S32, (void *)v, (void *)(step > 0 ? &step : NULL),
      (void *)(step_fast > 0 ? &step_fast : NULL), format, flags);
}

inline bool Gui::InputInt2(const char *label, int v[2], InputTextFlags flags) {
  return InputScalarN(label, DataType_S32, v, 2, NULL, NULL, "%d", flags);
}

inline bool Gui::InputInt3(const char *label, int v[3], InputTextFlags flags) {
  return InputScalarN(label, DataType_S32, v, 3, NULL, NULL, "%d", flags);
}

inline bool Gui::InputInt4(const char *label, int v[4], InputTextFlags flags) {
  return InputScalarN(label, DataType_S32, v, 4, NULL, NULL, "%d", flags);
}

inline bool Gui::InputDouble(const char *label, double *v, double step,
                             double step_fast, const char *format,
                             InputTextFlags flags) {
  return InputScalar(
      label, DataType_Double, (void *)v, (void *)(step > 0.0 ? &step : NULL),
      (void *)(step_fast > 0.0 ? &step_fast : NULL), format, flags);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputText, InputTextMultiline, InputTextWithHint
//-------------------------------------------------------------------------
// - InputText()
// - InputTextWithHint()
// - InputTextMultiline()
// - InputTextGetCharInfo() [Internal]
// - InputTextReindexLines() [Internal]
// - InputTextReindexLinesRange() [Internal]
// - InputTextEx() [Internal]
// - DebugNodeInputTextState() [Internal]
//-------------------------------------------------------------------------

inline bool Gui::InputText(const char *label, char *buf, size_t buf_size,
                           InputTextFlags flags, ::InputTextCallback callback,
                           void *user_data) {
  GUI_ASSERT(!(flags & InputTextFlags_Multiline)); // call InputTextMultiline()
  return InputTextEx(label, NULL, buf, (int)buf_size, Vec2(0, 0), flags,
                     callback, user_data);
}

inline bool Gui::InputTextMultiline(const char *label, char *buf,
                                    size_t buf_size, const Vec2 &size,
                                    InputTextFlags flags,
                                    ::InputTextCallback callback,
                                    void *user_data) {
  return InputTextEx(label, NULL, buf, (int)buf_size, size,
                     flags | InputTextFlags_Multiline, callback, user_data);
}

inline bool Gui::InputTextWithHint(const char *label, const char *hint,
                                   char *buf, size_t buf_size,
                                   InputTextFlags flags,
                                   ::InputTextCallback callback,
                                   void *user_data) {
  GUI_ASSERT(
      !(flags & InputTextFlags_Multiline)); // call InputTextMultiline() or
                                            // InputTextEx() manually if
                                            // you need multi-line + hint.
  return InputTextEx(label, hint, buf, (int)buf_size, Vec2(0, 0), flags,
                     callback, user_data);
}

static int InputTextCalcTextLenAndLineCount(const char *text_begin,
                                            const char **out_text_end) {
  int line_count = 0;
  const char *s = text_begin;
  while (
      char c =
          *s++) // We are only matching for \n so we can ignore UTF-8 decoding
    if (c == '\n')
      line_count++;
  s--;
  if (s[0] != '\n' && s[0] != '\r')
    line_count++;
  *out_text_end = s;
  return line_count;
}

static Vec2 InputTextCalcTextSizeW(Context *ctx, const Wchar *text_begin,
                                   const Wchar *text_end,
                                   const Wchar **remaining, Vec2 *out_offset,
                                   bool stop_on_new_line) {
  Context &g = *ctx;
  Font *font = g.Font;
  const float line_height = g.FontSize;
  const float scale = line_height / font->FontSize;

  Vec2 text_size = Vec2(0, 0);
  float line_width = 0.0f;

  const Wchar *s = text_begin;
  while (s < text_end) {
    unsigned int c = (unsigned int)(*s++);
    if (c == '\n') {
      text_size.x = Max(text_size.x, line_width);
      text_size.y += line_height;
      line_width = 0.0f;
      if (stop_on_new_line)
        break;
      continue;
    }
    if (c == '\r')
      continue;

    const float char_width = font->GetCharAdvance((Wchar)c) * scale;
    line_width += char_width;
  }

  if (text_size.x < line_width)
    text_size.x = line_width;

  if (out_offset)
    *out_offset =
        Vec2(line_width,
             text_size.y + line_height); // offset allow for the possibility
                                         // of sitting after a trailing \n

  if (line_width > 0 ||
      text_size.y == 0.0f) // whereas size.y will ignore the trailing \n
    text_size.y += line_height;

  if (remaining)
    *remaining = s;

  return text_size;
}

// Wrapper for textedit.hpp to edit text (our wrapper is for: statically sized
// buffer, single-line, wchar characters. InputText converts between UTF-8 and
// wchar)

static int STB_TEXTEDIT_STRINGLEN(const InputTextState *obj) {
  return obj->CurLenW;
}
static Wchar STB_TEXTEDIT_GETCHAR(const InputTextState *obj, int idx) {
  GUI_ASSERT(idx <= obj->CurLenW);
  return obj->TextW[idx];
}
static float STB_TEXTEDIT_GETWIDTH(InputTextState *obj, int line_start_idx,
                                   int char_idx) {
  Wchar c = obj->TextW[line_start_idx + char_idx];
  if (c == '\n')
    return IMSTB_TEXTEDIT_GETWIDTH_NEWLINE;
  Context &g = *obj->Ctx;
  return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize);
}
static int STB_TEXTEDIT_KEYTOTEXT(int key) { return key >= 0x200000 ? 0 : key; }
static Wchar STB_TEXTEDIT_NEWLINE = '\n';
static void STB_TEXTEDIT_LAYOUTROW(StbTexteditRow *r, InputTextState *obj,
                                   int line_start_idx) {
  const Wchar *text = obj->TextW.Data;
  const Wchar *text_remaining = NULL;
  const Vec2 size =
      InputTextCalcTextSizeW(obj->Ctx, text + line_start_idx,
                             text + obj->CurLenW, &text_remaining, NULL, true);
  r->x0 = 0.0f;
  r->x1 = size.x;
  r->baseline_y_delta = size.y;
  r->ymin = 0.0f;
  r->ymax = size.y;
  r->num_chars = (int)(text_remaining - (text + line_start_idx));
}

static bool is_separator(unsigned int c) {
  return c == ',' || c == ';' || c == '(' || c == ')' || c == '{' || c == '}' ||
         c == '[' || c == ']' || c == '|' || c == '\n' || c == '\r' ||
         c == '.' || c == '!';
}

static int is_word_boundary_from_right(InputTextState *obj, int idx) {
  // When InputTextFlags_Password is set, we don't want actions such as
  // CTRL+Arrow to leak the fact that underlying data are blanks or
  // separators.
  if ((obj->Flags & InputTextFlags_Password) || idx <= 0)
    return 0;

  bool prev_white = CharIsBlankW(obj->TextW[idx - 1]);
  bool prev_separ = is_separator(obj->TextW[idx - 1]);
  bool curr_white = CharIsBlankW(obj->TextW[idx]);
  bool curr_separ = is_separator(obj->TextW[idx]);
  return ((prev_white || prev_separ) && !(curr_separ || curr_white)) ||
         (curr_separ && !prev_separ);
}
static int is_word_boundary_from_left(InputTextState *obj, int idx) {
  if ((obj->Flags & InputTextFlags_Password) || idx <= 0)
    return 0;

  bool prev_white = CharIsBlankW(obj->TextW[idx]);
  bool prev_separ = is_separator(obj->TextW[idx]);
  bool curr_white = CharIsBlankW(obj->TextW[idx - 1]);
  bool curr_separ = is_separator(obj->TextW[idx - 1]);
  return ((prev_white) && !(curr_separ || curr_white)) ||
         (curr_separ && !prev_separ);
}
static int STB_TEXTEDIT_MOVEWORDLEFT_IMPL(InputTextState *obj, int idx) {
  idx--;
  while (idx >= 0 && !is_word_boundary_from_right(obj, idx))
    idx--;
  return idx < 0 ? 0 : idx;
}
static int STB_TEXTEDIT_MOVEWORDRIGHT_MAC(InputTextState *obj, int idx) {
  idx++;
  int len = obj->CurLenW;
  while (idx < len && !is_word_boundary_from_left(obj, idx))
    idx++;
  return idx > len ? len : idx;
}
static int STB_TEXTEDIT_MOVEWORDRIGHT_WIN(InputTextState *obj, int idx) {
  idx++;
  int len = obj->CurLenW;
  while (idx < len && !is_word_boundary_from_right(obj, idx))
    idx++;
  return idx > len ? len : idx;
}
static int STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(InputTextState *obj, int idx) {
  Context &g = *obj->Ctx;
  if (g.IO.ConfigMacOSXBehaviors)
    return STB_TEXTEDIT_MOVEWORDRIGHT_MAC(obj, idx);
  else
    return STB_TEXTEDIT_MOVEWORDRIGHT_WIN(obj, idx);
}
#define STB_TEXTEDIT_MOVEWORDLEFT                                              \
  STB_TEXTEDIT_MOVEWORDLEFT_IMPL // They need to be #define for textedit.hpp
#define STB_TEXTEDIT_MOVEWORDRIGHT STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

static void STB_TEXTEDIT_DELETECHARS(InputTextState *obj, int pos, int n) {
  Wchar *dst = obj->TextW.Data + pos;

  // We maintain our buffer length in both UTF-8 and wchar formats
  obj->Edited = true;
  obj->CurLenA -= TextCountUtf8BytesFromStr(dst, dst + n);
  obj->CurLenW -= n;

  // Offset remaining text (FIXME-OPT: Use memmove)
  const Wchar *src = obj->TextW.Data + pos + n;
  while (Wchar c = *src++)
    *dst++ = c;
  *dst = '\0';
}

static bool STB_TEXTEDIT_INSERTCHARS(InputTextState *obj, int pos,
                                     const Wchar *new_text, int new_text_len) {
  const bool is_resizable = (obj->Flags & InputTextFlags_CallbackResize) != 0;
  const int text_len = obj->CurLenW;
  GUI_ASSERT(pos <= text_len);

  const int new_text_len_utf8 =
      TextCountUtf8BytesFromStr(new_text, new_text + new_text_len);
  if (!is_resizable &&
      (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA))
    return false;

  // Grow internal buffer if needed
  if (new_text_len + text_len + 1 > obj->TextW.Size) {
    if (!is_resizable)
      return false;
    GUI_ASSERT(text_len < obj->TextW.Size);
    obj->TextW.resize(text_len +
                      Clamp(new_text_len * 4, 32, Max(256, new_text_len)) + 1);
  }

  Wchar *text = obj->TextW.Data;
  if (pos != text_len)
    memmove(text + pos + new_text_len, text + pos,
            (size_t)(text_len - pos) * sizeof(Wchar));
  memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(Wchar));

  obj->Edited = true;
  obj->CurLenW += new_text_len;
  obj->CurLenA += new_text_len_utf8;
  obj->TextW[obj->CurLenW] = '\0';

  return true;
}

// We don't use an enum so we can build even with conflicting symbols (if
// another user of textedit.hpp leak their STB_TEXTEDIT_K_* symbols)
#define STB_TEXTEDIT_K_LEFT 0x200000  // keyboard input to move cursor left
#define STB_TEXTEDIT_K_RIGHT 0x200001 // keyboard input to move cursor right
#define STB_TEXTEDIT_K_UP 0x200002    // keyboard input to move cursor up
#define STB_TEXTEDIT_K_DOWN 0x200003  // keyboard input to move cursor down
#define STB_TEXTEDIT_K_LINESTART                                               \
  0x200004 // keyboard input to move cursor to start of line
#define STB_TEXTEDIT_K_LINEEND                                                 \
  0x200005 // keyboard input to move cursor to end of line
#define STB_TEXTEDIT_K_TEXTSTART                                               \
  0x200006 // keyboard input to move cursor to start of text
#define STB_TEXTEDIT_K_TEXTEND                                                 \
  0x200007 // keyboard input to move cursor to end of text
#define STB_TEXTEDIT_K_DELETE                                                  \
  0x200008 // keyboard input to delete selection or character under cursor
#define STB_TEXTEDIT_K_BACKSPACE                                               \
  0x200009 // keyboard input to delete selection or character left of cursor
#define STB_TEXTEDIT_K_UNDO 0x20000A // keyboard input to perform undo
#define STB_TEXTEDIT_K_REDO 0x20000B // keyboard input to perform redo
#define STB_TEXTEDIT_K_WORDLEFT                                                \
  0x20000C // keyboard input to move cursor left one word
#define STB_TEXTEDIT_K_WORDRIGHT                                               \
  0x20000D // keyboard input to move cursor right one word
#define STB_TEXTEDIT_K_PGUP 0x20000E // keyboard input to move cursor up a page
#define STB_TEXTEDIT_K_PGDOWN                                                  \
  0x20000F // keyboard input to move cursor down a page
#define STB_TEXTEDIT_K_SHIFT 0x400000

#define IMSTB_TEXTEDIT_IMPLEMENTATION
#define IMSTB_TEXTEDIT_memmove memmove
#include "textedit.hpp"

// stb_textedit internally allows for a single undo record to do addition and
// deletion, but somehow, calling the stb_textedit_paste() function creates
// two separate records, so we perform it manually. (FIXME: Report to
// nothings/stb?)
static void stb_textedit_replace(InputTextState *str, STB_TexteditState *state,
                                 const IMSTB_TEXTEDIT_CHARTYPE *text,
                                 int text_len) {
  stb_text_makeundo_replace(str, state, 0, str->CurLenW, text_len);
  STB_TEXTEDIT_DELETECHARS(str, 0, str->CurLenW);
  state->cursor = state->select_start = state->select_end = 0;
  if (text_len <= 0)
    return;
  if (STB_TEXTEDIT_INSERTCHARS(str, 0, text, text_len)) {
    state->cursor = state->select_start = state->select_end = text_len;
    state->has_preferred_x = 0;
    return;
  }
  GUI_ASSERT(0); // Failed to insert character, normally shouldn't happen
                 // because of how we currently use stb_textedit_replace()
}

inline void InputTextState::OnKeyPressed(int key) {
  stb_textedit_key(this, &Stb, key);
  CursorFollow = true;
  CursorAnimReset();
}

inline InputTextCallbackData::InputTextCallbackData() {
  memset(this, 0, sizeof(*this));
}

// Public API to manipulate UTF-8 text
// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are
// manipulating wchar)
// FIXME: The existence of this rarely exercised code path is a bit of a
// nuisance.
inline void InputTextCallbackData::DeleteChars(int pos, int bytes_count) {
  GUI_ASSERT(pos + bytes_count <= BufTextLen);
  char *dst = Buf + pos;
  const char *src = Buf + pos + bytes_count;
  while (char c = *src++)
    *dst++ = c;
  *dst = '\0';

  if (CursorPos >= pos + bytes_count)
    CursorPos -= bytes_count;
  else if (CursorPos >= pos)
    CursorPos = pos;
  SelectionStart = SelectionEnd = CursorPos;
  BufDirty = true;
  BufTextLen -= bytes_count;
}

inline void InputTextCallbackData::InsertChars(int pos, const char *new_text,
                                               const char *new_text_end) {
  // Accept null ranges
  if (new_text == new_text_end)
    return;

  const bool is_resizable = (Flags & InputTextFlags_CallbackResize) != 0;
  const int new_text_len =
      new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);
  if (new_text_len + BufTextLen >= BufSize) {
    if (!is_resizable)
      return;

    // Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8
    // buffer, hence the mildly similar code (until we remove the U16 buffer
    // altogether!)
    Context &g = *Ctx;
    InputTextState *edit_state = &g.InputTextState;
    GUI_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);
    GUI_ASSERT(Buf == edit_state->TextA.Data);
    int new_buf_size =
        BufTextLen + Clamp(new_text_len * 4, 32, Max(256, new_text_len)) + 1;
    edit_state->TextA.reserve(new_buf_size + 1);
    Buf = edit_state->TextA.Data;
    BufSize = edit_state->BufCapacityA = new_buf_size;
  }

  if (BufTextLen != pos)
    memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));
  memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));
  Buf[BufTextLen + new_text_len] = '\0';

  if (CursorPos >= pos)
    CursorPos += new_text_len;
  SelectionStart = SelectionEnd = CursorPos;
  BufDirty = true;
  BufTextLen += new_text_len;
}

// Return false to discard a character.
static bool InputTextFilterCharacter(Context *ctx, unsigned int *p_char,
                                     InputTextFlags flags,
                                     InputTextCallback callback,
                                     void *user_data,
                                     InputSource input_source) {
  GUI_ASSERT(input_source == InputSource_Keyboard ||
             input_source == InputSource_Clipboard);
  unsigned int c = *p_char;

  // Filter non-printable (NB: isprint is unreliable! see #2467)
  bool apply_named_filters = true;
  if (c < 0x20) {
    bool pass = false;
    pass |=
        (c == '\n') && (flags & InputTextFlags_Multiline) !=
                           0; // Note that an Enter KEY will emit \r and be
                              // ignored (we poll for KEY in InputText() code)
    pass |= (c == '\t') && (flags & InputTextFlags_AllowTabInput) != 0;
    if (!pass)
      return false;
    apply_named_filters = false; // Override named filters below so newline and
                                 // tabs can still be inserted.
  }

  if (input_source != InputSource_Clipboard) {
    // We ignore Ascii representation of delete (emitted from Backspace on OSX,
    // see #2578, #2817)
    if (c == 127)
      return false;

    // Filter private Unicode range. GLFW on OSX seems to send private
    // characters for special keys like arrow keys (FIXME)
    if (c >= 0xE000 && c <= 0xF8FF)
      return false;
  }

  // Filter Unicode ranges we are not handling in this build
  if (c > GUI_UNICODE_CODEPOINT_MAX)
    return false;

  // Generic named filters
  if (apply_named_filters &&
      (flags & (InputTextFlags_CharsDecimal | InputTextFlags_CharsHexadecimal |
                InputTextFlags_CharsUppercase | InputTextFlags_CharsNoBlank |
                InputTextFlags_CharsScientific))) {
    // The libc allows overriding locale, with e.g. 'setlocale(LC_NUMERIC,
    // "de_DE.UTF-8");' which affect the output/input of printf/scanf to use
    // e.g. ',' instead of '.'. The standard mandate that programs starts in the
    // "C" locale where the decimal point is '.'. We don't really intend to
    // provide widespread support for it, but out of empathy for people stuck
    // with using odd API, we support the bare minimum aka overriding the
    // decimal point. Change the default decimal_point with:
    //   Gui::GetIO()->PlatformLocaleDecimalPoint =
    //   *localeconv()->decimal_point;
    // Users of non-default decimal point (in particular ',') may be affected by
    // word-selection logic
    // (is_word_boundary_from_right/is_word_boundary_from_left) functions.
    Context &g = *ctx;
    const unsigned c_decimal_point =
        (unsigned int)g.IO.PlatformLocaleDecimalPoint;
    if (flags & (InputTextFlags_CharsDecimal | InputTextFlags_CharsScientific))
      if (c == '.' || c == ',')
        c = c_decimal_point;

    // Full-width -> half-width conversion for numeric fields
    // (https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)
    // While this is mostly convenient, this has the side-effect for uninformed
    // users accidentally inputting full-width characters that they may scratch
    // their head as to why it works in numerical fields vs in generic text
    // fields it would require support in the font.
    if (flags & (InputTextFlags_CharsDecimal | InputTextFlags_CharsScientific |
                 InputTextFlags_CharsHexadecimal))
      if (c >= 0xFF01 && c <= 0xFF5E)
        c = c - 0xFF01 + 0x21;

    // Allow 0-9 . - + * /
    if (flags & InputTextFlags_CharsDecimal)
      if (!(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') &&
          (c != '+') && (c != '*') && (c != '/'))
        return false;

    // Allow 0-9 . - + * / e E
    if (flags & InputTextFlags_CharsScientific)
      if (!(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') &&
          (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))
        return false;

    // Allow 0-9 a-F A-F
    if (flags & InputTextFlags_CharsHexadecimal)
      if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') &&
          !(c >= 'A' && c <= 'F'))
        return false;

    // Turn a-z into A-Z
    if (flags & InputTextFlags_CharsUppercase)
      if (c >= 'a' && c <= 'z')
        c += (unsigned int)('A' - 'a');

    if (flags & InputTextFlags_CharsNoBlank)
      if (CharIsBlankW(c))
        return false;

    *p_char = c;
  }

  // Custom callback filter
  if (flags & InputTextFlags_CallbackCharFilter) {
    Context &g = *GGui;
    InputTextCallbackData callback_data;
    callback_data.Ctx = &g;
    callback_data.EventFlag = InputTextFlags_CallbackCharFilter;
    callback_data.EventChar = (Wchar)c;
    callback_data.Flags = flags;
    callback_data.UserData = user_data;
    if (callback(&callback_data) != 0)
      return false;
    *p_char = callback_data.EventChar;
    if (!callback_data.EventChar)
      return false;
  }

  return true;
}

// Find the shortest single replacement we can make to get the new text from the
// old text. Important: needs to be run before TextW is rewritten with the new
// characters because calling STB_TEXTEDIT_GETCHAR() at the end.
// FIXME: Ideally we should transition toward (1) making
// InsertChars()/DeleteChars() update undo-stack (2) discourage (and keep
// reconcile) or obsolete (and remove reconcile) accessing buffer directly.
static void InputTextReconcileUndoStateAfterUserCallback(InputTextState *state,
                                                         const char *new_buf_a,
                                                         int new_length_a) {
  Context &g = *GGui;
  const Wchar *old_buf = state->TextW.Data;
  const int old_length = state->CurLenW;
  const int new_length =
      TextCountCharsFromUtf8(new_buf_a, new_buf_a + new_length_a);
  g.TempBuffer.reserve_discard((new_length + 1) * sizeof(Wchar));
  Wchar *new_buf = (Wchar *)(void *)g.TempBuffer.Data;
  TextStrFromUtf8(new_buf, new_length + 1, new_buf_a, new_buf_a + new_length_a);

  const int shorter_length = Min(old_length, new_length);
  int first_diff;
  for (first_diff = 0; first_diff < shorter_length; first_diff++)
    if (old_buf[first_diff] != new_buf[first_diff])
      break;
  if (first_diff == old_length && first_diff == new_length)
    return;

  int old_last_diff = old_length - 1;
  int new_last_diff = new_length - 1;
  for (; old_last_diff >= first_diff && new_last_diff >= first_diff;
       old_last_diff--, new_last_diff--)
    if (old_buf[old_last_diff] != new_buf[new_last_diff])
      break;

  const int insert_len = new_last_diff - first_diff + 1;
  const int delete_len = old_last_diff - first_diff + 1;
  if (insert_len > 0 || delete_len > 0)
    if (IMSTB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(
            &state->Stb.undostate, first_diff, delete_len, insert_len))
      for (int i = 0; i < delete_len; i++)
        p[i] = STB_TEXTEDIT_GETCHAR(state, first_diff + i);
}

// As InputText() retain textual data and we currently provide a path for user
// to not retain it (via local variables) we need some form of hook to reapply
// data back to user buffer on deactivation frame. (#4714) It would be more
// desirable that we discourage users from taking advantage of the "user not
// retaining data" trick, but that more likely be attractive when we do have
// _NoLiveEdit flag available.
inline void Gui::InputTextDeactivateHook(ID id) {
  Context &g = *GGui;
  InputTextState *state = &g.InputTextState;
  if (id == 0 || state->ID != id)
    return;
  g.InputTextDeactivatedState.ID = state->ID;
  if (state->Flags & InputTextFlags_ReadOnly) {
    g.InputTextDeactivatedState.TextA.resize(
        0); // In theory this data won't be used, but clear to be neat.
  } else {
    GUI_ASSERT(state->TextA.Data != 0);
    g.InputTextDeactivatedState.TextA.resize(state->CurLenA + 1);
    memcpy(g.InputTextDeactivatedState.TextA.Data, state->TextA.Data,
           state->CurLenA + 1);
  }
}

// Edit a string of text
// - buf_size account for the zero-terminator, so a buf_size of 6 can hold
// "Hello" but not "Hello!".
//   This is so we can easily call InputText() on static arrays using
//   ARRAYSIZE() and to match Note that in std::string world, capacity() would
//   omit 1 byte used by the zero-terminator.
// - When active, hold on a privately held copy of the text (and apply back to
// 'buf'). So changing 'buf' while the InputText is active has no effect.
// - If you want to use Gui::InputText() with std::string, see
// misc/cpp/gui_stdlib.hpp (FIXME: Rather confusing and messy function, among
// the worse part of our codebase, expecting to rewrite a V2 at some point..
// Partly because we are
//  doing UTF8 > U16 > UTF8 conversions on the go to easily interface with
//  stb_textedit. Ideally should stay in UTF-8 all the time. See
//  https://github.com/nothings/stb/issues/188)
inline bool Gui::InputTextEx(const char *label, const char *hint, char *buf,
                             int buf_size, const Vec2 &size_arg,
                             InputTextFlags flags, ::InputTextCallback callback,
                             void *callback_user_data) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  GUI_ASSERT(buf != NULL && buf_size >= 0);
  GUI_ASSERT(
      !((flags & InputTextFlags_CallbackHistory) &&
        (flags & InputTextFlags_Multiline))); // Can't use both together
                                              // (they both use up/down keys)
  GUI_ASSERT(
      !((flags & InputTextFlags_CallbackCompletion) &&
        (flags & InputTextFlags_AllowTabInput))); // Can't use both together
                                                  // (they both use tab key)

  Context &g = *GGui;
  IO &io = g.IO;
  const Style &style = g.Style;

  const bool RENDER_SELECTION_WHEN_INACTIVE = false;
  const bool is_multiline = (flags & InputTextFlags_Multiline) != 0;

  if (is_multiline) // Open group before calling GetID() because groups tracks
                    // id created within their scope (including the scrollbar)
    BeginGroup();
  const ID id = window->GetID(label);
  const Vec2 label_size = CalcTextSize(label, NULL, true);
  const Vec2 frame_size = CalcItemSize(
      size_arg, CalcItemWidth(),
      (is_multiline ? g.FontSize * 8.0f : label_size.y) +
          style.FramePadding.y *
              2.0f); // Arbitrary default of 8 lines high for multi-line
  const Vec2 total_size =
      Vec2(frame_size.x + (label_size.x > 0.0f
                               ? style.ItemInnerSpacing.x + label_size.x
                               : 0.0f),
           frame_size.y);

  const Rect frame_bb(window->DC.CursorPos,
                      Add(window->DC.CursorPos, frame_size));
  const Rect total_bb(frame_bb.Min, Add(frame_bb.Min, total_size));

  Window *draw_window = window;
  Vec2 inner_size = frame_size;
  LastItemData item_data_backup;
  if (is_multiline) {
    Vec2 backup_pos = window->DC.CursorPos;
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &frame_bb, ItemFlags_Inputable)) {
      EndGroup();
      return false;
    }
    item_data_backup = g.LastItemData;
    window->DC.CursorPos = backup_pos;

    // Prevent NavActivation from Tabbing when our widget accepts Tab inputs:
    // this allows cycling through widgets without stopping.
    if (g.NavActivateId == id &&
        (g.NavActivateFlags & ActivateFlags_FromTabbing) &&
        (flags & InputTextFlags_AllowTabInput))
      g.NavActivateId = 0;

    // Prevent NavActivate reactivating in BeginChild() when we are already
    // active.
    const ID backup_activate_id = g.NavActivateId;
    if (g.ActiveId == id) // Prevent reactivation
      g.NavActivateId = 0;

    // We reproduce the contents of BeginChildFrame() in order to provide
    // 'label' so our window internal data are easier to read/debug.
    PushStyleColor(Col_ChildBg, style.Colors[Col_FrameBg]);
    PushStyleVar(StyleVar_ChildRounding, style.FrameRounding);
    PushStyleVar(StyleVar_ChildBorderSize, style.FrameBorderSize);
    PushStyleVar(StyleVar_WindowPadding,
                 Vec2(0, 0)); // Ensure no clip rect so mouse hover can reach
                              // FramePadding edges
    bool child_visible =
        BeginChildEx(label, id, frame_bb.GetSize(), true, WindowFlags_NoMove);
    g.NavActivateId = backup_activate_id;
    PopStyleVar(3);
    PopStyleColor();
    if (!child_visible) {
      EndChild();
      EndGroup();
      return false;
    }
    draw_window = g.CurrentWindow; // Child window
    draw_window->DC.NavLayersActiveMaskNext |=
        (1 << draw_window->DC
                  .NavLayerCurrent); // This is to ensure that EndChild() will
                                     // display a navigation highlight so we can
                                     // "enter" into it.
    draw_window->DC.CursorPos =
        Add(draw_window->DC.CursorPos, style.FramePadding);
    inner_size.x -= draw_window->ScrollbarSizes.x;
  } else {
    // Support for internal InputTextFlags_MergedItem flag, which could be
    // redesigned as an ItemFlags if needed (with test performed in ItemAdd)
    ItemSize(total_bb, style.FramePadding.y);
    if (!(flags & InputTextFlags_MergedItem))
      if (!ItemAdd(total_bb, id, &frame_bb, ItemFlags_Inputable))
        return false;
  }
  const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);
  if (hovered)
    g.MouseCursor = MouseCursor_TextInput;

  // We are only allowed to access the state if we are already the active
  // widget.
  InputTextState *state = GetInputTextState(id);

  if (g.LastItemData.InFlags & ItemFlags_ReadOnly)
    flags |= InputTextFlags_ReadOnly;
  const bool is_readonly = (flags & InputTextFlags_ReadOnly) != 0;
  const bool is_password = (flags & InputTextFlags_Password) != 0;
  const bool is_undoable = (flags & InputTextFlags_NoUndoRedo) == 0;
  const bool is_resizable = (flags & InputTextFlags_CallbackResize) != 0;
  if (is_resizable)
    GUI_ASSERT(callback != NULL); // Must provide a callback if you set the
                                  // InputTextFlags_CallbackResize flag!

  const bool input_requested_by_nav =
      (g.ActiveId != id) &&
      ((g.NavActivateId == id) &&
       ((g.NavActivateFlags & ActivateFlags_PreferInput) ||
        (g.NavInputSource == InputSource_Keyboard)));

  const bool user_clicked = hovered && io.MouseClicked[0];
  const bool user_scroll_finish =
      is_multiline && state != NULL && g.ActiveId == 0 &&
      g.ActiveIdPreviousFrame == GetWindowScrollbarID(draw_window, Axis_Y);
  const bool user_scroll_active =
      is_multiline && state != NULL &&
      g.ActiveId == GetWindowScrollbarID(draw_window, Axis_Y);
  bool clear_active_id = false;
  bool select_all = false;

  float scroll_y = is_multiline ? draw_window->Scroll.y : FLT_MAX;

  const bool init_changed_specs =
      (state != NULL &&
       state->Stb.single_line !=
           !is_multiline); // state != NULL means its our state.
  const bool init_make_active =
      (user_clicked || user_scroll_finish || input_requested_by_nav);
  const bool init_state = (init_make_active || user_scroll_active);
  if ((init_state && g.ActiveId != id) || init_changed_specs) {
    // Access state even if we don't own it yet.
    state = &g.InputTextState;
    state->CursorAnimReset();

    // Backup state of deactivating item so they'll have a chance to do a write
    // to output buffer on the same frame they report IsItemDeactivatedAfterEdit
    // (#4714)
    InputTextDeactivateHook(state->ID);

    // Take a copy of the initial buffer value (both in original UTF-8 format
    // and converted to wchar) From the moment we focused we are ignoring the
    // content of 'buf' (unless we are in read-only mode)
    const int buf_len = (int)strlen(buf);
    state->InitialTextA.resize(
        buf_len + 1); // UTF-8. we use +1 to make sure that .Data is always
                      // pointing to at least an empty string.
    memcpy(state->InitialTextA.Data, buf, buf_len + 1);

    // Preserve cursor position and undo/redo stack if we come back to same
    // widget
    // FIXME: Since we reworked this on 2022/06, may want to differenciate
    // recycle_cursor vs recycle_undostate?
    bool recycle_state = (state->ID == id && !init_changed_specs);
    if (recycle_state && (state->CurLenA != buf_len ||
                          (state->TextAIsValid &&
                           strncmp(state->TextA.Data, buf, buf_len) != 0)))
      recycle_state = false;

    // Start edition
    const char *buf_end = NULL;
    state->ID = id;
    state->TextW.resize(
        buf_size +
        1); // wchar count <= UTF-8 count. we use +1 to make sure that .Data is
            // always pointing to at least an empty string.
    state->TextA.resize(0);
    state->TextAIsValid =
        false; // TextA is not valid yet (we will display buf until then)
    state->CurLenW =
        TextStrFromUtf8(state->TextW.Data, buf_size, buf, NULL, &buf_end);
    state->CurLenA =
        (int)(buf_end -
              buf); // We can't get the result fromStrncpy() above because it
                    // is not UTF-8 aware. Here we'll cut off malformed UTF-8.

    if (recycle_state) {
      // Recycle existing cursor/selection/undo stack but clamp position
      // Note a single mouse click will override the cursor/position immediately
      // by calling stb_textedit_click handler.
      state->CursorClamp();
    } else {
      state->ScrollX = 0.0f;
      stb_textedit_initialize_state(&state->Stb, !is_multiline);
    }

    if (!is_multiline) {
      if (flags & InputTextFlags_AutoSelectAll)
        select_all = true;
      if (input_requested_by_nav &&
          (!recycle_state ||
           !(g.NavActivateFlags & ActivateFlags_TryToPreserveState)))
        select_all = true;
      if (user_clicked && io.KeyCtrl)
        select_all = true;
    }

    if (flags & InputTextFlags_AlwaysOverwrite)
      state->Stb.insert_mode =
          1; // stb field name is indeed incorrect (see #2863)
  }

  const bool is_osx = io.ConfigMacOSXBehaviors;
  if (g.ActiveId != id && init_make_active) {
    GUI_ASSERT(state && state->ID == id);
    SetActiveID(id, window);
    SetFocusID(id, window);
    FocusWindow(window);
  }
  if (g.ActiveId == id) {
    // Declare some inputs, the other are registered and polled via Shortcut()
    // routing system.
    if (user_clicked)
      SetKeyOwner(Key_MouseLeft, id);
    g.ActiveIdUsingNavDirMask |= (1 << Dir_Left) | (1 << Dir_Right);
    if (is_multiline || (flags & InputTextFlags_CallbackHistory))
      g.ActiveIdUsingNavDirMask |= (1 << Dir_Up) | (1 << Dir_Down);
    SetKeyOwner(Key_Home, id);
    SetKeyOwner(Key_End, id);
    if (is_multiline) {
      SetKeyOwner(Key_PageUp, id);
      SetKeyOwner(Key_PageDown, id);
    }
    if (is_osx)
      SetKeyOwner(Mod_Alt, id);
    if (flags &
        (InputTextFlags_CallbackCompletion |
         InputTextFlags_AllowTabInput)) // Disable keyboard tabbing out as
                                        // we will use the \t character.
      SetShortcutRouting(Key_Tab, id);
  }

  // We have an edge case if ActiveId was set through another widget (e.g.
  // widget being swapped), clear id immediately (don't wait until the end of
  // the function)
  if (g.ActiveId == id && state == NULL)
    ClearActiveID();

  // Release focus when we click outside
  if (g.ActiveId == id && io.MouseClicked[0] && !init_state &&
      !init_make_active) //-V560
    clear_active_id = true;

  // Lock the decision of whether we are going to take the path displaying the
  // cursor or selection
  bool render_cursor = (g.ActiveId == id) || (state && user_scroll_active);
  bool render_selection = state && (state->HasSelection() || select_all) &&
                          (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
  bool value_changed = false;
  bool validated = false;

  // When read-only we always use the live data passed to the function
  // FIXME-OPT: Because our selection/cursor code currently needs the wide text
  // we need to convert it when active, which is not ideal :(
  if (is_readonly && state != NULL && (render_cursor || render_selection)) {
    const char *buf_end = NULL;
    state->TextW.resize(buf_size + 1);
    state->CurLenW = TextStrFromUtf8(state->TextW.Data, state->TextW.Size, buf,
                                     NULL, &buf_end);
    state->CurLenA = (int)(buf_end - buf);
    state->CursorClamp();
    render_selection &= state->HasSelection();
  }

  // Select the buffer to render.
  const bool buf_display_from_state =
      (render_cursor || render_selection || g.ActiveId == id) && !is_readonly &&
      state && state->TextAIsValid;
  const bool is_displaying_hint =
      (hint != NULL &&
       (buf_display_from_state ? state->TextA.Data : buf)[0] == 0);

  // Password pushes a temporary font with only a fallback glyph
  if (is_password && !is_displaying_hint) {
    const FontGlyph *glyph = g.Font->FindGlyph('*');
    Font *password_font = &g.InputTextPasswordFont;
    password_font->FontSize = g.Font->FontSize;
    password_font->Scale = g.Font->Scale;
    password_font->Ascent = g.Font->Ascent;
    password_font->Descent = g.Font->Descent;
    password_font->ContainerAtlas = g.Font->ContainerAtlas;
    password_font->FallbackGlyph = glyph;
    password_font->FallbackAdvanceX = glyph->AdvanceX;
    GUI_ASSERT(password_font->Glyphs.empty() &&
               password_font->IndexAdvanceX.empty() &&
               password_font->IndexLookup.empty());
    PushFont(password_font);
  }

  // Process mouse inputs and character inputs
  int backup_current_text_length = 0;
  if (g.ActiveId == id) {
    GUI_ASSERT(state != NULL);
    backup_current_text_length = state->CurLenA;
    state->Edited = false;
    state->BufCapacityA = buf_size;
    state->Flags = flags;

    // Although we are active we don't prevent mouse from hovering other
    // elements unless we are interacting right now with the widget. Down the
    // line we should have a cleaner library-wide concept of Selected vs Active.
    g.ActiveIdAllowOverlap = !io.MouseDown[0];

    // Edit in progress
    const float mouse_x =
        (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) +
        state->ScrollX;
    const float mouse_y =
        (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y)
                      : (g.FontSize * 0.5f));

    if (select_all) {
      state->SelectAll();
      state->SelectedAllMouseLock = true;
    } else if (hovered && io.MouseClickedCount[0] >= 2 && !io.KeyShift) {
      stb_textedit_click(state, &state->Stb, mouse_x, mouse_y);
      const int multiclick_count = (io.MouseClickedCount[0] - 2);
      if ((multiclick_count % 2) == 0) {
        // Double-click: Select word
        // We always use the "Mac" word advance for double-click select vs
        // CTRL+Right which use the platform dependent variant:
        // FIXME: There are likely many ways to improve this behavior, but
        // there's no "right" behavior (depends on use-case, software, OS)
        const bool is_bol =
            (state->Stb.cursor == 0) ||
            STB_TEXTEDIT_GETCHAR(state, state->Stb.cursor - 1) == '\n';
        if (STB_TEXT_HAS_SELECTION(&state->Stb) || !is_bol)
          state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);
        // state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
        if (!STB_TEXT_HAS_SELECTION(&state->Stb))
          stb_textedit_prep_selection_at_cursor(&state->Stb);
        state->Stb.cursor =
            STB_TEXTEDIT_MOVEWORDRIGHT_MAC(state, state->Stb.cursor);
        state->Stb.select_end = state->Stb.cursor;
        stb_textedit_clamp(state, &state->Stb);
      } else {
        // Triple-click: Select line
        const bool is_eol =
            STB_TEXTEDIT_GETCHAR(state, state->Stb.cursor) == '\n';
        state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART);
        state->OnKeyPressed(STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT);
        state->OnKeyPressed(STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT);
        if (!is_eol && is_multiline) {
          Swap(state->Stb.select_start, state->Stb.select_end);
          state->Stb.cursor = state->Stb.select_end;
        }
        state->CursorFollow = false;
      }
      state->CursorAnimReset();
    } else if (io.MouseClicked[0] && !state->SelectedAllMouseLock) {
      if (hovered) {
        if (io.KeyShift)
          stb_textedit_drag(state, &state->Stb, mouse_x, mouse_y);
        else
          stb_textedit_click(state, &state->Stb, mouse_x, mouse_y);
        state->CursorAnimReset();
      }
    } else if (io.MouseDown[0] && !state->SelectedAllMouseLock &&
               (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)) {
      stb_textedit_drag(state, &state->Stb, mouse_x, mouse_y);
      state->CursorAnimReset();
      state->CursorFollow = true;
    }
    if (state->SelectedAllMouseLock && !io.MouseDown[0])
      state->SelectedAllMouseLock = false;

    // We expect backends to emit a Tab key but some also emit a Tab character
    // which we ignore (#2467, #1336) (For Tab and Enter: Win32/SFML/Allegro are
    // sending both keys and chars, GLFW and SDL are only sending keys. For
    // Space they all send all threes)
    if ((flags & InputTextFlags_AllowTabInput) &&
        Shortcut(Key_Tab, id, InputFlags_Repeat) && !is_readonly) {
      unsigned int c = '\t'; // Insert TAB
      if (InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data,
                                   InputSource_Keyboard))
        state->OnKeyPressed((int)c);
    }

    // Process regular text input (before we check for Return because using some
    // IME will effectively send a Return?) We ignore CTRL inputs, but need to
    // allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_
    // Alt+Ctrl) to input certain characters.
    const bool ignore_char_inputs =
        (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);
    if (io.InputQueueCharacters.Size > 0) {
      if (!ignore_char_inputs && !is_readonly && !input_requested_by_nav)
        for (int n = 0; n < io.InputQueueCharacters.Size; n++) {
          // Insert character if they pass filtering
          unsigned int c = (unsigned int)io.InputQueueCharacters[n];
          if (c == '\t') // Skip Tab, see above.
            continue;
          if (InputTextFilterCharacter(&g, &c, flags, callback,
                                       callback_user_data,
                                       InputSource_Keyboard))
            state->OnKeyPressed((int)c);
        }

      // Consume characters
      io.InputQueueCharacters.resize(0);
    }
  }

  // Process other shortcuts/key-presses
  bool revert_edit = false;
  if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id) {
    GUI_ASSERT(state != NULL);

    const int row_count_per_page =
        Max((int)((inner_size.y - style.FramePadding.y) / g.FontSize), 1);
    state->Stb.row_count_per_page = row_count_per_page;

    const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);
    const bool is_wordmove_key_down =
        is_osx ? io.KeyAlt : io.KeyCtrl; // OS X style: Text editing cursor
                                         // movement using Alt instead of Ctrl
    const bool is_startend_key_down =
        is_osx && io.KeySuper && !io.KeyCtrl &&
        !io.KeyAlt; // OS X style: Line/Text Start and End using Cmd+Arrows
                    // instead of Home/End

    // Using Shortcut() with InputFlags_RouteFocused (default policy) to
    // allow routing operations for other code (e.g. calling window trying to
    // use CTRL+A and CTRL+B: formet would be handled by InputText) Otherwise we
    // could simply assume that we own the keys as we are active.
    const InputFlags f_repeat = InputFlags_Repeat;
    const bool is_cut = (Shortcut(Mod_Shortcut | Key_X, id, f_repeat) ||
                         Shortcut(Mod_Shift | Key_Delete, id, f_repeat)) &&
                        !is_readonly && !is_password &&
                        (!is_multiline || state->HasSelection());
    const bool is_copy = (Shortcut(Mod_Shortcut | Key_C, id) ||
                          Shortcut(Mod_Ctrl | Key_Insert, id)) &&
                         !is_password &&
                         (!is_multiline || state->HasSelection());
    const bool is_paste = (Shortcut(Mod_Shortcut | Key_V, id, f_repeat) ||
                           Shortcut(Mod_Shift | Key_Insert, id, f_repeat)) &&
                          !is_readonly;
    const bool is_undo = (Shortcut(Mod_Shortcut | Key_Z, id, f_repeat)) &&
                         !is_readonly && is_undoable;
    const bool is_redo = (Shortcut(Mod_Shortcut | Key_Y, id, f_repeat) ||
                          (is_osx && Shortcut(Mod_Shortcut | Mod_Shift | Key_Z,
                                              id, f_repeat))) &&
                         !is_readonly && is_undoable;
    const bool is_select_all = Shortcut(Mod_Shortcut | Key_A, id);

    // We allow validate/cancel with Nav source (gamepad) to makes it easier to
    // undo an accidental NavInput press with no keyboard wired, but otherwise
    // it isn't very useful.
    const bool nav_gamepad_active =
        (io.ConfigFlags & ConfigFlags_NavEnableGamepad) != 0 &&
        (io.BackendFlags & BackendFlags_HasGamepad) != 0;
    const bool is_enter_pressed =
        IsKeyPressed(Key_Enter, true) || IsKeyPressed(Key_KeypadEnter, true);
    const bool is_gamepad_validate =
        nav_gamepad_active && (IsKeyPressed(Key_NavGamepadActivate, false) ||
                               IsKeyPressed(Key_NavGamepadInput, false));
    const bool is_cancel =
        Shortcut(Key_Escape, id, f_repeat) ||
        (nav_gamepad_active && Shortcut(Key_NavGamepadCancel, id, f_repeat));

    // FIXME: Should use more Shortcut() and reduce
    // IsKeyPressed()+SetKeyOwner(), but requires modifiers combination to be
    // taken account of.
    if (IsKeyPressed(Key_LeftArrow)) {
      state->OnKeyPressed((is_startend_key_down   ? STB_TEXTEDIT_K_LINESTART
                           : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT
                                                  : STB_TEXTEDIT_K_LEFT) |
                          k_mask);
    } else if (IsKeyPressed(Key_RightArrow)) {
      state->OnKeyPressed((is_startend_key_down   ? STB_TEXTEDIT_K_LINEEND
                           : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT
                                                  : STB_TEXTEDIT_K_RIGHT) |
                          k_mask);
    } else if (IsKeyPressed(Key_UpArrow) && is_multiline) {
      if (io.KeyCtrl)
        SetScrollY(draw_window, Max(draw_window->Scroll.y - g.FontSize, 0.0f));
      else
        state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART
                                                  : STB_TEXTEDIT_K_UP) |
                            k_mask);
    } else if (IsKeyPressed(Key_DownArrow) && is_multiline) {
      if (io.KeyCtrl)
        SetScrollY(draw_window,
                   Min(draw_window->Scroll.y + g.FontSize, GetScrollMaxY()));
      else
        state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND
                                                  : STB_TEXTEDIT_K_DOWN) |
                            k_mask);
    } else if (IsKeyPressed(Key_PageUp) && is_multiline) {
      state->OnKeyPressed(STB_TEXTEDIT_K_PGUP | k_mask);
      scroll_y -= row_count_per_page * g.FontSize;
    } else if (IsKeyPressed(Key_PageDown) && is_multiline) {
      state->OnKeyPressed(STB_TEXTEDIT_K_PGDOWN | k_mask);
      scroll_y += row_count_per_page * g.FontSize;
    } else if (IsKeyPressed(Key_Home)) {
      state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask
                                     : STB_TEXTEDIT_K_LINESTART | k_mask);
    } else if (IsKeyPressed(Key_End)) {
      state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask
                                     : STB_TEXTEDIT_K_LINEEND | k_mask);
    } else if (IsKeyPressed(Key_Delete) && !is_readonly && !is_cut) {
      if (!state->HasSelection()) {
        // OSX doesn't seem to have Super+Delete to delete until end-of-line, so
        // we don't emulate that (as opposed to Super+Backspace)
        if (is_wordmove_key_down)
          state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
      }
      state->OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask);
    } else if (IsKeyPressed(Key_Backspace) && !is_readonly) {
      if (!state->HasSelection()) {
        if (is_wordmove_key_down)
          state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT);
        else if (is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl)
          state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT);
      }
      state->OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);
    } else if (is_enter_pressed || is_gamepad_validate) {
      // Determine if we turn Enter into a \n character
      bool ctrl_enter_for_new_line =
          (flags & InputTextFlags_CtrlEnterForNewLine) != 0;
      if (!is_multiline || is_gamepad_validate ||
          (ctrl_enter_for_new_line && !io.KeyCtrl) ||
          (!ctrl_enter_for_new_line && io.KeyCtrl)) {
        validated = true;
        if (io.ConfigInputTextEnterKeepActive && !is_multiline)
          state->SelectAll(); // No need to scroll
        else
          clear_active_id = true;
      } else if (!is_readonly) {
        unsigned int c = '\n'; // Insert new line
        if (InputTextFilterCharacter(&g, &c, flags, callback,
                                     callback_user_data, InputSource_Keyboard))
          state->OnKeyPressed((int)c);
      }
    } else if (is_cancel) {
      if (flags & InputTextFlags_EscapeClearsAll) {
        if (buf[0] != 0) {
          revert_edit = true;
        } else {
          render_cursor = render_selection = false;
          clear_active_id = true;
        }
      } else {
        clear_active_id = revert_edit = true;
        render_cursor = render_selection = false;
      }
    } else if (is_undo || is_redo) {
      state->OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);
      state->ClearSelection();
    } else if (is_select_all) {
      state->SelectAll();
      state->CursorFollow = true;
    } else if (is_cut || is_copy) {
      // Cut, Copy
      if (io.SetClipboardTextFn) {
        const int ib = state->HasSelection()
                           ? Min(state->Stb.select_start, state->Stb.select_end)
                           : 0;
        const int ie = state->HasSelection()
                           ? Max(state->Stb.select_start, state->Stb.select_end)
                           : state->CurLenW;
        const int clipboard_data_len =
            TextCountUtf8BytesFromStr(state->TextW.Data + ib,
                                      state->TextW.Data + ie) +
            1;
        char *clipboard_data =
            (char *)GUI_ALLOC(clipboard_data_len * sizeof(char));
        TextStrToUtf8(clipboard_data, clipboard_data_len,
                      state->TextW.Data + ib, state->TextW.Data + ie);
        SetClipboardText(clipboard_data);
        MemFree(clipboard_data);
      }
      if (is_cut) {
        if (!state->HasSelection())
          state->SelectAll();
        state->CursorFollow = true;
        stb_textedit_cut(state, &state->Stb);
      }
    } else if (is_paste) {
      if (const char *clipboard = GetClipboardText()) {
        // Filter pasted buffer
        const int clipboard_len = (int)strlen(clipboard);
        Wchar *clipboard_filtered =
            (Wchar *)GUI_ALLOC((clipboard_len + 1) * sizeof(Wchar));
        int clipboard_filtered_len = 0;
        for (const char *s = clipboard; *s != 0;) {
          unsigned int c;
          s += TextCharFromUtf8(&c, s, NULL);
          if (!InputTextFilterCharacter(&g, &c, flags, callback,
                                        callback_user_data,
                                        InputSource_Clipboard))
            continue;
          clipboard_filtered[clipboard_filtered_len++] = (Wchar)c;
        }
        clipboard_filtered[clipboard_filtered_len] = 0;
        if (clipboard_filtered_len >
            0) // If everything was filtered, ignore the pasting operation
        {
          stb_textedit_paste(state, &state->Stb, clipboard_filtered,
                             clipboard_filtered_len);
          state->CursorFollow = true;
        }
        MemFree(clipboard_filtered);
      }
    }

    // Update render selection flag after events have been handled, so selection
    // highlight can be displayed during the same frame.
    render_selection |= state->HasSelection() &&
                        (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
  }

  // Process callbacks and apply result back to user's buffer.
  const char *apply_new_text = NULL;
  int apply_new_text_length = 0;
  if (g.ActiveId == id) {
    GUI_ASSERT(state != NULL);
    if (revert_edit && !is_readonly) {
      if (flags & InputTextFlags_EscapeClearsAll) {
        // Clear input
        GUI_ASSERT(buf[0] != 0);
        apply_new_text = "";
        apply_new_text_length = 0;
        value_changed = true;
        IMSTB_TEXTEDIT_CHARTYPE empty_string;
        stb_textedit_replace(state, &state->Stb, &empty_string, 0);
      } else if (strcmp(buf, state->InitialTextA.Data) != 0) {
        // Restore initial value. Only return true if restoring to the initial
        // value changes the current buffer contents. Push records into the undo
        // stack so we can CTRL+Z the revert operation itself
        apply_new_text = state->InitialTextA.Data;
        apply_new_text_length = state->InitialTextA.Size - 1;
        value_changed = true;
        Vector<Wchar> w_text;
        if (apply_new_text_length > 0) {
          w_text.resize(
              TextCountCharsFromUtf8(apply_new_text,
                                     apply_new_text + apply_new_text_length) +
              1);
          TextStrFromUtf8(w_text.Data, w_text.Size, apply_new_text,
                          apply_new_text + apply_new_text_length);
        }
        stb_textedit_replace(state, &state->Stb, w_text.Data,
                             (apply_new_text_length > 0) ? (w_text.Size - 1)
                                                         : 0);
      }
    }

    // Apply ASCII value
    if (!is_readonly) {
      state->TextAIsValid = true;
      state->TextA.resize(state->TextW.Size * 4 + 1);
      TextStrToUtf8(state->TextA.Data, state->TextA.Size, state->TextW.Data,
                    NULL);
    }

    // When using 'InputTextFlags_EnterReturnsTrue' as a special case we
    // reapply the live buffer back to the input buffer before clearing
    // ActiveId, even though strictly speaking it wasn't modified on this frame.
    // If we didn't do that, code like InputInt() with
    // InputTextFlags_EnterReturnsTrue would fail. This also allows the
    // user to use InputText() with InputTextFlags_EnterReturnsTrue without
    // maintaining any user-side storage (please note that if you use this
    // property along InputTextFlags_CallbackResize you can end up with
    // your temporary string object unnecessarily allocating once a frame,
    // either store your string data, either if you don't then don't use
    // InputTextFlags_CallbackResize).
    const bool apply_edit_back_to_user_buffer =
        !revert_edit ||
        (validated && (flags & InputTextFlags_EnterReturnsTrue) != 0);
    if (apply_edit_back_to_user_buffer) {
      // Apply new value immediately - copy modified buffer back
      // Note that as soon as the input box is active, the in-widget value gets
      // priority over any underlying modification of the input buffer
      // FIXME: We actually always render 'buf' when calling DrawList->AddText,
      // making the comment above incorrect.
      // FIXME-OPT: CPU waste to do this every time the widget is active, should
      // mark dirty state from the stb_textedit callbacks.

      // User callback
      if ((flags &
           (InputTextFlags_CallbackCompletion | InputTextFlags_CallbackHistory |
            InputTextFlags_CallbackEdit | InputTextFlags_CallbackAlways)) !=
          0) {
        GUI_ASSERT(callback != NULL);

        // The reason we specify the usage semantic (Completion/History) is that
        // Completion needs to disable keyboard TABBING at the moment.
        InputTextFlags event_flag = 0;
        Key event_key = Key_None;
        if ((flags & InputTextFlags_CallbackCompletion) != 0 &&
            Shortcut(Key_Tab, id)) {
          event_flag = InputTextFlags_CallbackCompletion;
          event_key = Key_Tab;
        } else if ((flags & InputTextFlags_CallbackHistory) != 0 &&
                   IsKeyPressed(Key_UpArrow)) {
          event_flag = InputTextFlags_CallbackHistory;
          event_key = Key_UpArrow;
        } else if ((flags & InputTextFlags_CallbackHistory) != 0 &&
                   IsKeyPressed(Key_DownArrow)) {
          event_flag = InputTextFlags_CallbackHistory;
          event_key = Key_DownArrow;
        } else if ((flags & InputTextFlags_CallbackEdit) && state->Edited) {
          event_flag = InputTextFlags_CallbackEdit;
        } else if (flags & InputTextFlags_CallbackAlways) {
          event_flag = InputTextFlags_CallbackAlways;
        }

        if (event_flag) {
          InputTextCallbackData callback_data;
          callback_data.Ctx = &g;
          callback_data.EventFlag = event_flag;
          callback_data.Flags = flags;
          callback_data.UserData = callback_user_data;

          char *callback_buf = is_readonly ? buf : state->TextA.Data;
          callback_data.EventKey = event_key;
          callback_data.Buf = callback_buf;
          callback_data.BufTextLen = state->CurLenA;
          callback_data.BufSize = state->BufCapacityA;
          callback_data.BufDirty = false;

          // We have to convert from wchar-positions to UTF-8-positions, which
          // can be pretty slow (an incentive to ditch the Wchar buffer, see
          // https://github.com/nothings/stb/issues/188)
          Wchar *text = state->TextW.Data;
          const int utf8_cursor_pos = callback_data.CursorPos =
              TextCountUtf8BytesFromStr(text, text + state->Stb.cursor);
          const int utf8_selection_start = callback_data.SelectionStart =
              TextCountUtf8BytesFromStr(text, text + state->Stb.select_start);
          const int utf8_selection_end = callback_data.SelectionEnd =
              TextCountUtf8BytesFromStr(text, text + state->Stb.select_end);

          // Call user code
          callback(&callback_data);

          // Read back what user may have modified
          callback_buf =
              is_readonly
                  ? buf
                  : state->TextA.Data; // Pointer may have been invalidated by a
                                       // resize callback
          GUI_ASSERT(callback_data.Buf ==
                     callback_buf); // Invalid to modify those fields
          GUI_ASSERT(callback_data.BufSize == state->BufCapacityA);
          GUI_ASSERT(callback_data.Flags == flags);
          const bool buf_dirty = callback_data.BufDirty;
          if (callback_data.CursorPos != utf8_cursor_pos || buf_dirty) {
            state->Stb.cursor = TextCountCharsFromUtf8(
                callback_data.Buf, callback_data.Buf + callback_data.CursorPos);
            state->CursorFollow = true;
          }
          if (callback_data.SelectionStart != utf8_selection_start ||
              buf_dirty) {
            state->Stb.select_start =
                (callback_data.SelectionStart == callback_data.CursorPos)
                    ? state->Stb.cursor
                    : TextCountCharsFromUtf8(callback_data.Buf,
                                             callback_data.Buf +
                                                 callback_data.SelectionStart);
          }
          if (callback_data.SelectionEnd != utf8_selection_end || buf_dirty) {
            state->Stb.select_end =
                (callback_data.SelectionEnd == callback_data.SelectionStart)
                    ? state->Stb.select_start
                    : TextCountCharsFromUtf8(callback_data.Buf,
                                             callback_data.Buf +
                                                 callback_data.SelectionEnd);
          }
          if (buf_dirty) {
            GUI_ASSERT(!is_readonly);
            GUI_ASSERT(
                callback_data.BufTextLen ==
                (int)strlen(
                    callback_data.Buf)); // You need to maintain BufTextLen if
                                         // you change the text!
            InputTextReconcileUndoStateAfterUserCallback(
                state, callback_data.Buf,
                callback_data
                    .BufTextLen); // FIXME: Move the rest of this block
                                  // inside function and rename to
                                  // InputTextReconcileStateAfterUserCallback()
                                  // ?
            if (callback_data.BufTextLen > backup_current_text_length &&
                is_resizable)
              state->TextW.resize(
                  state->TextW.Size +
                  (callback_data.BufTextLen -
                   backup_current_text_length)); // Worse case scenario resize
            state->CurLenW = TextStrFromUtf8(
                state->TextW.Data, state->TextW.Size, callback_data.Buf, NULL);
            state->CurLenA =
                callback_data
                    .BufTextLen; // Assume correct length and valid UTF-8 from
                                 // user, saves us an extra strlen()
            state->CursorAnimReset();
          }
        }
      }

      // Will copy result string if modified
      if (!is_readonly && strcmp(state->TextA.Data, buf) != 0) {
        apply_new_text = state->TextA.Data;
        apply_new_text_length = state->CurLenA;
        value_changed = true;
      }
    }
  }

  // Handle reapplying final data on deactivation (see InputTextDeactivateHook()
  // for details)
  if (g.InputTextDeactivatedState.ID == id) {
    if (g.ActiveId != id && IsItemDeactivatedAfterEdit() && !is_readonly &&
        strcmp(g.InputTextDeactivatedState.TextA.Data, buf) != 0) {
      apply_new_text = g.InputTextDeactivatedState.TextA.Data;
      apply_new_text_length = g.InputTextDeactivatedState.TextA.Size - 1;
      value_changed = true;
      // GUI_DEBUG_LOG("InputText(): apply Deactivated data for 0x%08X:
      // \"%.*s\".\n", id, apply_new_text_length, apply_new_text);
    }
    g.InputTextDeactivatedState.ID = 0;
  }

  // Copy result to user buffer. This can currently only happen when (g.ActiveId
  // == id)
  if (apply_new_text != NULL) {
    // We cannot test for 'backup_current_text_length != apply_new_text_length'
    // here because we have no guarantee that the size of our owned buffer
    // matches the size of the string object held by the user, and by design we
    // allow InputText() to be used without any storage on user's side.
    GUI_ASSERT(apply_new_text_length >= 0);
    if (is_resizable) {
      InputTextCallbackData callback_data;
      callback_data.Ctx = &g;
      callback_data.EventFlag = InputTextFlags_CallbackResize;
      callback_data.Flags = flags;
      callback_data.Buf = buf;
      callback_data.BufTextLen = apply_new_text_length;
      callback_data.BufSize = Max(buf_size, apply_new_text_length + 1);
      callback_data.UserData = callback_user_data;
      callback(&callback_data);
      buf = callback_data.Buf;
      buf_size = callback_data.BufSize;
      apply_new_text_length = Min(callback_data.BufTextLen, buf_size - 1);
      GUI_ASSERT(apply_new_text_length <= buf_size);
    }
    // GUI_DEBUG_PRINT("InputText(\"%s\"): apply_new_text length %d\n", label,
    // apply_new_text_length);

    // If the underlying buffer resize was denied or not carried to the next
    // frame, apply_new_text_length+1 may be >= buf_size.
    Strncpy(buf, apply_new_text, Min(apply_new_text_length + 1, buf_size));
  }

  // Release active ID at the end of the function (so e.g. pressing Return still
  // does a final application of the value) Otherwise request text input ahead
  // for next frame.
  if (g.ActiveId == id && clear_active_id)
    ClearActiveID();
  else if (g.ActiveId == id)
    g.WantTextInputNextFrame = 1;

  // Render frame
  if (!is_multiline) {
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(Col_FrameBg), true,
                style.FrameRounding);
  }

  const Vec4 clip_rect(
      frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + inner_size.x,
      frame_bb.Min.y +
          inner_size.y); // Not using frame_bb.Max because we have adjusted size
  Vec2 draw_pos = is_multiline ? draw_window->DC.CursorPos
                               : Add(frame_bb.Min, style.FramePadding);
  Vec2 text_size(0.0f, 0.0f);

  // Set upper limit of single-line InputTextEx() at 2 million characters
  // strings. The current pathological worst case is a long line without any
  // carriage return, which would makes Font::RenderText() reserve too many
  // vertices and probably crash. Avoid it altogether. Note that we only use
  // this limit on single-line InputText(), so a pathologically large line on a
  // InputTextMultiline() would still crash.
  const int buf_display_max_length = 2 * 1024 * 1024;
  const char *buf_display =
      buf_display_from_state ? state->TextA.Data : buf; //-V595
  const char *buf_display_end =
      NULL; // We have specialized paths below for setting the length
  if (is_displaying_hint) {
    buf_display = hint;
    buf_display_end = hint + strlen(hint);
  }

  // Render text. We currently only render selection when the widget is active
  // or while scrolling.
  // FIXME: We could remove the '&& render_cursor' to keep rendering selection
  // when inactive.
  if (render_cursor || render_selection) {
    GUI_ASSERT(state != NULL);
    if (!is_displaying_hint)
      buf_display_end = buf_display + state->CurLenA;

    // Render text (with cursor and selection)
    // This is going to be messy. We need to:
    // - Display the text (this alone can be more easily clipped)
    // - Handle scrolling, highlight selection, display cursor (those all
    // requires some form of 1d->2d cursor position calculation)
    // - Measure text height (for scrollbar)
    // We are attempting to do most of that in **one main pass** to minimize the
    // computation cost (non-negligible for large amount of text) + 2nd pass for
    // selection rendering (we could merge them by an extra refactoring effort)
    // FIXME: This should occur on buf_display but we'd need to maintain
    // cursor/select_start/select_end for UTF-8.
    const Wchar *text_begin = state->TextW.Data;
    Vec2 cursor_offset, select_start_offset;

    {
      // Find lines numbers straddling 'cursor' (slot 0) and 'select_start'
      // (slot 1) positions.
      const Wchar *searches_input_ptr[2] = {NULL, NULL};
      int searches_result_line_no[2] = {-1000, -1000};
      int searches_remaining = 0;
      if (render_cursor) {
        searches_input_ptr[0] = text_begin + state->Stb.cursor;
        searches_result_line_no[0] = -1;
        searches_remaining++;
      }
      if (render_selection) {
        searches_input_ptr[1] =
            text_begin + Min(state->Stb.select_start, state->Stb.select_end);
        searches_result_line_no[1] = -1;
        searches_remaining++;
      }

      // Iterate all lines to find our line numbers
      // In multi-line mode, we never exit the loop until all lines are counted,
      // so add one extra to the searches_remaining counter.
      searches_remaining += is_multiline ? 1 : 0;
      int line_count = 0;
      // for (const Wchar* s = text_begin; (s = (const Wchar*)wcschr((const
      // wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this
      // when wchar_t are 16-bit
      for (const Wchar *s = text_begin; *s != 0; s++)
        if (*s == '\n') {
          line_count++;
          if (searches_result_line_no[0] == -1 && s >= searches_input_ptr[0]) {
            searches_result_line_no[0] = line_count;
            if (--searches_remaining <= 0)
              break;
          }
          if (searches_result_line_no[1] == -1 && s >= searches_input_ptr[1]) {
            searches_result_line_no[1] = line_count;
            if (--searches_remaining <= 0)
              break;
          }
        }
      line_count++;
      if (searches_result_line_no[0] == -1)
        searches_result_line_no[0] = line_count;
      if (searches_result_line_no[1] == -1)
        searches_result_line_no[1] = line_count;

      // Calculate 2d position by finding the beginning of the line and
      // measuring distance
      cursor_offset.x =
          InputTextCalcTextSizeW(&g, StrbolW(searches_input_ptr[0], text_begin),
                                 searches_input_ptr[0])
              .x;
      cursor_offset.y = searches_result_line_no[0] * g.FontSize;
      if (searches_result_line_no[1] >= 0) {
        select_start_offset.x =
            InputTextCalcTextSizeW(&g,
                                   StrbolW(searches_input_ptr[1], text_begin),
                                   searches_input_ptr[1])
                .x;
        select_start_offset.y = searches_result_line_no[1] * g.FontSize;
      }

      // Store text height (note that we haven't calculated text width at all,
      // see GitHub issues #383, #1224)
      if (is_multiline)
        text_size = Vec2(inner_size.x, line_count * g.FontSize);
    }

    // Scroll
    if (render_cursor && state->CursorFollow) {
      // Horizontal scroll in chunks of quarter width
      if (!(flags & InputTextFlags_NoHorizontalScroll)) {
        const float scroll_increment_x = inner_size.x * 0.25f;
        const float visible_width = inner_size.x - style.FramePadding.x;
        if (cursor_offset.x < state->ScrollX)
          state->ScrollX =
              GUI_TRUNC(Max(0.0f, cursor_offset.x - scroll_increment_x));
        else if (cursor_offset.x - visible_width >= state->ScrollX)
          state->ScrollX =
              GUI_TRUNC(cursor_offset.x - visible_width + scroll_increment_x);
      } else {
        state->ScrollX = 0.0f;
      }

      // Vertical scroll
      if (is_multiline) {
        // Test if cursor is vertically visible
        if (cursor_offset.y - g.FontSize < scroll_y)
          scroll_y = Max(0.0f, cursor_offset.y - g.FontSize);
        else if (cursor_offset.y -
                     (inner_size.y - style.FramePadding.y * 2.0f) >=
                 scroll_y)
          scroll_y =
              cursor_offset.y - inner_size.y + style.FramePadding.y * 2.0f;
        const float scroll_max_y = Max(
            (text_size.y + style.FramePadding.y * 2.0f) - inner_size.y, 0.0f);
        scroll_y = Clamp(scroll_y, 0.0f, scroll_max_y);
        draw_pos.y += (draw_window->Scroll.y -
                       scroll_y); // Manipulate cursor pos immediately avoid a
                                  // frame of lag
        draw_window->Scroll.y = scroll_y;
      }

      state->CursorFollow = false;
    }

    // Draw selection
    const Vec2 draw_scroll = Vec2(state->ScrollX, 0.0f);
    if (render_selection) {
      const Wchar *text_selected_begin =
          text_begin + Min(state->Stb.select_start, state->Stb.select_end);
      const Wchar *text_selected_end =
          text_begin + Max(state->Stb.select_start, state->Stb.select_end);

      U32 bg_color = GetColorU32(
          Col_TextSelectedBg,
          render_cursor ? 1.0f
                        : 0.6f); // FIXME: current code flow mandate that
                                 // render_cursor is always true here, we are
                                 // leaving the transparent one for tests.
      float bg_offy_up =
          is_multiline
              ? 0.0f
              : -1.0f; // FIXME: those offsets should be part of the style? they
                       // don't play so well with multi-line selection.
      float bg_offy_dn = is_multiline ? 0.0f : 2.0f;
      Vec2 rect_pos = Subtract(Add(draw_pos, select_start_offset), draw_scroll);
      for (const Wchar *p = text_selected_begin; p < text_selected_end;) {
        if (rect_pos.y > clip_rect.w + g.FontSize)
          break;
        if (rect_pos.y < clip_rect.y) {
          // p = (const Wchar*)wmemchr((const wchar_t*)p, '\n',
          // text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t
          // are 16-bit p = p ? p + 1 : text_selected_end;
          while (p < text_selected_end)
            if (*p++ == '\n')
              break;
        } else {
          Vec2 rect_size =
              InputTextCalcTextSizeW(&g, p, text_selected_end, &p, NULL, true);
          if (rect_size.x <= 0.0f)
            rect_size.x =
                GUI_TRUNC(g.Font->GetCharAdvance((Wchar)' ') *
                          0.50f); // So we can see selected empty lines
          Rect rect(Add(rect_pos, Vec2(0.0f, bg_offy_up - g.FontSize)),
                    Add(rect_pos, Vec2(rect_size.x, bg_offy_dn)));
          rect.ClipWith(clip_rect);
          if (rect.Overlaps(clip_rect))
            draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);
        }
        rect_pos.x = draw_pos.x - draw_scroll.x;
        rect_pos.y += g.FontSize;
      }
    }

    // We test for 'buf_display_max_length' as a way to avoid some pathological
    // cases (e.g. single-line 1 MB string) which would make DrawList crash.
    if (is_multiline ||
        (buf_display_end - buf_display) < buf_display_max_length) {
      U32 col = GetColorU32(is_displaying_hint ? Col_TextDisabled : Col_Text);
      draw_window->DrawList->AddText(
          g.Font, g.FontSize, Subtract(draw_pos, draw_scroll), col, buf_display,
          buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);
    }

    // Draw blinking cursor
    if (render_cursor) {
      state->CursorAnim += io.DeltaTime;
      bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) ||
                               (state->CursorAnim <= 0.0f) ||
                               Fmod(state->CursorAnim, 1.20f) <= 0.80f;
      Vec2 cursor_screen_pos =
          Trunc(Subtract(Add(draw_pos, cursor_offset), draw_scroll));
      Rect cursor_screen_rect(
          cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f,
          cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);
      if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))
        draw_window->DrawList->AddLine(cursor_screen_rect.Min,
                                       cursor_screen_rect.GetBL(),
                                       GetColorU32(Col_Text));

      // Notify OS of text input position for advanced IME (-1 x offset so that
      // Windows IME can cover our cursor. Bit of an extra nicety.)
      if (!is_readonly) {
        g.PlatformImeData.WantVisible = true;
        g.PlatformImeData.InputPos =
            Vec2(cursor_screen_pos.x - 1.0f, cursor_screen_pos.y - g.FontSize);
        g.PlatformImeData.InputLineHeight = g.FontSize;
      }
    }
  } else {
    // Render text only (no selection, no cursor)
    if (is_multiline)
      text_size =
          Vec2(inner_size.x,
               InputTextCalcTextLenAndLineCount(buf_display, &buf_display_end) *
                   g.FontSize); // We don't need width
    else if (!is_displaying_hint && g.ActiveId == id)
      buf_display_end = buf_display + state->CurLenA;
    else if (!is_displaying_hint)
      buf_display_end = buf_display + strlen(buf_display);

    if (is_multiline ||
        (buf_display_end - buf_display) < buf_display_max_length) {
      U32 col = GetColorU32(is_displaying_hint ? Col_TextDisabled : Col_Text);
      draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos, col,
                                     buf_display, buf_display_end, 0.0f,
                                     is_multiline ? NULL : &clip_rect);
    }
  }

  if (is_password && !is_displaying_hint)
    PopFont();

  if (is_multiline) {
    // For focus requests to work on our multiline we need to ensure our child
    // ItemAdd() call specifies the ItemFlags_Inputable (ref issue
    // #4761)...
    Dummy(Vec2(text_size.x, text_size.y + style.FramePadding.y));
    g.NextItemData.ItemFlags |= ItemFlags_Inputable | ItemFlags_NoTabStop;
    EndChild();
    item_data_backup.StatusFlags |=
        (g.LastItemData.StatusFlags & ItemStatusFlags_HoveredWindow);

    // ...and then we need to undo the group overriding last item data, which
    // gets a bit messy as EndGroup() tries to forward scrollbar being active...
    // FIXME: This quite messy/tricky, should attempt to get rid of the child
    // window.
    EndGroup();
    if (g.LastItemData.ID == 0) {
      g.LastItemData.ID = id;
      g.LastItemData.InFlags = item_data_backup.InFlags;
      g.LastItemData.StatusFlags = item_data_backup.StatusFlags;
    }
  }

  // Log as text
  if (g.LogEnabled && (!is_password || is_displaying_hint)) {
    LogSetNextTextDecoration("{", "}");
    LogRenderedText(&draw_pos, buf_display, buf_display_end);
  }

  if (label_size.x > 0)
    RenderText(Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x,
                    frame_bb.Min.y + style.FramePadding.y),
               label);

  if (value_changed && !(flags & InputTextFlags_NoMarkEdited))
    MarkItemEdited(id);

  GUI_TEST_ENGINE_ITEM_INFO(
      id, label, g.LastItemData.StatusFlags | ItemStatusFlags_Inputable);
  if ((flags & InputTextFlags_EnterReturnsTrue) != 0)
    return validated;
  else
    return value_changed;
}

inline void Gui::DebugNodeInputTextState(InputTextState *state) {
#ifndef GUI_DISABLE_DEBUG_TOOLS
  Context &g = *GGui;
  STB_TexteditState *stb_state = &state->Stb;
  StbUndoState *undo_state = &stb_state->undostate;
  Text("ID: 0x%08X, ActiveID: 0x%08X", state->ID, g.ActiveId);
  DebugLocateItemOnHover(state->ID);
  Text("CurLenW: %d, CurLenA: %d, Cursor: %d, Selection: %d..%d",
       state->CurLenW, state->CurLenA, stb_state->cursor,
       stb_state->select_start, stb_state->select_end);
  Text("has_preferred_x: %d (%.2f)", stb_state->has_preferred_x,
       stb_state->preferred_x);
  Text("undo_point: %d, redo_point: %d, undo_char_point: %d, redo_char_point: "
       "%d",
       undo_state->undo_point, undo_state->redo_point,
       undo_state->undo_char_point, undo_state->redo_char_point);
  if (BeginChild("undopoints", Vec2(0.0f, GetTextLineHeight() * 15),
                 ChildFlags_Border)) // Visualize undo state
  {
    PushStyleVar(StyleVar_ItemSpacing, Vec2(0, 0));
    for (int n = 0; n < IMSTB_TEXTEDIT_UNDOSTATECOUNT; n++) {
      StbUndoRecord *undo_rec = &undo_state->undo_rec[n];
      const char undo_rec_type = (n < undo_state->undo_point)    ? 'u'
                                 : (n >= undo_state->redo_point) ? 'r'
                                                                 : ' ';
      if (undo_rec_type == ' ')
        BeginDisabled();
      char buf[64] = "";
      if (undo_rec_type != ' ' && undo_rec->char_storage != -1)
        TextStrToUtf8(buf, GUI_ARRAYSIZE(buf),
                      (Wchar *)undo_state->undo_char + undo_rec->char_storage,
                      (Wchar *)undo_state->undo_char + undo_rec->char_storage +
                          undo_rec->insert_length);
      Text("%c [%02d] where %03d, insert %03d, delete %03d, char_storage %03d "
           "\"%s\"",
           undo_rec_type, n, undo_rec->where, undo_rec->insert_length,
           undo_rec->delete_length, undo_rec->char_storage, buf);
      if (undo_rec_type == ' ')
        EndDisabled();
    }
    PopStyleVar();
  }
  EndChild();
#else
  GUI_UNUSED(state);
#endif
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
//-------------------------------------------------------------------------
// - ColorEdit3()
// - ColorEdit4()
// - ColorPicker3()
// - RenderColorRectWithAlphaCheckerboard() [Internal]
// - ColorPicker4()
// - ColorButton()
// - SetColorEditOptions()
// - ColorTooltip() [Internal]
// - ColorEditOptionsPopup() [Internal]
// - ColorPickerOptionsPopup() [Internal]
//-------------------------------------------------------------------------

inline bool Gui::ColorEdit3(const char *label, float col[3],
                            ColorEditFlags flags) {
  return ColorEdit4(label, col, flags | ColorEditFlags_NoAlpha);
}

static void ColorEditRestoreH(const float *col, float *H) {
  Context &g = *GGui;
  GUI_ASSERT(g.ColorEditCurrentID != 0);
  if (g.ColorEditSavedID != g.ColorEditCurrentID ||
      g.ColorEditSavedColor !=
          Gui::ColorConvertFloat4ToU32(Vec4(col[0], col[1], col[2], 0)))
    return;
  *H = g.ColorEditSavedHue;
}

// ColorEdit supports RGB and HSV inputs. In case of RGB input resulting color
// may have undefined hue and/or saturation. Since widget displays both RGB and
// HSV values we must preserve hue and saturation to prevent these values
// resetting.
static void ColorEditRestoreHS(const float *col, float *H, float *S, float *V) {
  Context &g = *GGui;
  GUI_ASSERT(g.ColorEditCurrentID != 0);
  if (g.ColorEditSavedID != g.ColorEditCurrentID ||
      g.ColorEditSavedColor !=
          Gui::ColorConvertFloat4ToU32(Vec4(col[0], col[1], col[2], 0)))
    return;

  // When S == 0, H is undefined.
  // When H == 1 it wraps around to 0.
  if (*S == 0.0f || (*H == 0.0f && g.ColorEditSavedHue == 1))
    *H = g.ColorEditSavedHue;

  // When V == 0, S is undefined.
  if (*V == 0.0f)
    *S = g.ColorEditSavedSat;
}

// Edit colors components (each component in 0.0f..1.0f range).
// See enum ColorEditFlags_ for available options. e.g. Only access 3
// floats if ColorEditFlags_NoAlpha flag is set. With typical options:
// Left-click on color square to open color picker. Right-click to open option
// menu. CTRL-Click over input fields to edit them and TAB to go to next item.
inline bool Gui::ColorEdit4(const char *label, float col[4],
                            ColorEditFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  const Style &style = g.Style;
  const float square_sz = GetFrameHeight();
  const char *label_display_end = FindRenderedTextEnd(label);
  float w_full = CalcItemWidth();
  g.NextItemData.ClearFlags();

  BeginGroup();
  PushID(label);
  const bool set_current_color_edit_id = (g.ColorEditCurrentID == 0);
  if (set_current_color_edit_id)
    g.ColorEditCurrentID = window->IDStack.back();

  // If we're not showing any slider there's no point in doing any HSV
  // conversions
  const ColorEditFlags flags_untouched = flags;
  if (flags & ColorEditFlags_NoInputs)
    flags = (flags & (~ColorEditFlags_DisplayMask_)) |
            ColorEditFlags_DisplayRGB | ColorEditFlags_NoOptions;

  // Context menu: display and modify options (before defaults are applied)
  if (!(flags & ColorEditFlags_NoOptions))
    ColorEditOptionsPopup(col, flags);

  // Read stored options
  if (!(flags & ColorEditFlags_DisplayMask_))
    flags |= (g.ColorEditOptions & ColorEditFlags_DisplayMask_);
  if (!(flags & ColorEditFlags_DataTypeMask_))
    flags |= (g.ColorEditOptions & ColorEditFlags_DataTypeMask_);
  if (!(flags & ColorEditFlags_PickerMask_))
    flags |= (g.ColorEditOptions & ColorEditFlags_PickerMask_);
  if (!(flags & ColorEditFlags_InputMask_))
    flags |= (g.ColorEditOptions & ColorEditFlags_InputMask_);
  flags |= (g.ColorEditOptions &
            ~(ColorEditFlags_DisplayMask_ | ColorEditFlags_DataTypeMask_ |
              ColorEditFlags_PickerMask_ | ColorEditFlags_InputMask_));
  GUI_ASSERT(IsPowerOfTwo(
      flags & ColorEditFlags_DisplayMask_)); // Check that only 1 is selected
  GUI_ASSERT(IsPowerOfTwo(
      flags & ColorEditFlags_InputMask_)); // Check that only 1 is selected

  const bool alpha = (flags & ColorEditFlags_NoAlpha) == 0;
  const bool hdr = (flags & ColorEditFlags_HDR) != 0;
  const int components = alpha ? 4 : 3;
  const float w_button = (flags & ColorEditFlags_NoSmallPreview)
                             ? 0.0f
                             : (square_sz + style.ItemInnerSpacing.x);
  const float w_inputs = Max(w_full - w_button, 1.0f);
  w_full = w_inputs + w_button;

  // Convert to the formats we need
  float f[4] = {col[0], col[1], col[2], alpha ? col[3] : 1.0f};
  if ((flags & ColorEditFlags_InputHSV) && (flags & ColorEditFlags_DisplayRGB))
    ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
  else if ((flags & ColorEditFlags_InputRGB) &&
           (flags & ColorEditFlags_DisplayHSV)) {
    // Hue is lost when converting from grayscale rgb (saturation=0). Restore
    // it.
    ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);
    ColorEditRestoreHS(col, &f[0], &f[1], &f[2]);
  }
  int i[4] = {GUI_F32_TO_INT8_UNBOUND(f[0]), GUI_F32_TO_INT8_UNBOUND(f[1]),
              GUI_F32_TO_INT8_UNBOUND(f[2]), GUI_F32_TO_INT8_UNBOUND(f[3])};

  bool value_changed = false;
  bool value_changed_as_float = false;

  const Vec2 pos = window->DC.CursorPos;
  const float inputs_offset_x =
      (style.ColorButtonPosition == Dir_Left) ? w_button : 0.0f;
  window->DC.CursorPos.x = pos.x + inputs_offset_x;

  if ((flags & (ColorEditFlags_DisplayRGB | ColorEditFlags_DisplayHSV)) != 0 &&
      (flags & ColorEditFlags_NoInputs) == 0) {
    // RGB/HSV 0..255 Sliders
    const float w_items =
        w_inputs - style.ItemInnerSpacing.x * (components - 1);

    const bool hide_prefix =
        (GUI_TRUNC(w_items / components) <=
         CalcTextSize((flags & ColorEditFlags_Float) ? "M:0.000" : "M:000").x);
    static const char *ids[4] = {"##X", "##Y", "##Z", "##W"};
    static const char *fmt_table_int[3][4] = {
        {"%3d", "%3d", "%3d", "%3d"},         // Short display
        {"R:%3d", "G:%3d", "B:%3d", "A:%3d"}, // Long display for RGBA
        {"H:%3d", "S:%3d", "V:%3d", "A:%3d"}  // Long display for HSVA
    };
    static const char *fmt_table_float[3][4] = {
        {"%0.3f", "%0.3f", "%0.3f", "%0.3f"},         // Short display
        {"R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f"}, // Long display for RGBA
        {"H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f"}  // Long display for HSVA
    };
    const int fmt_idx = hide_prefix                           ? 0
                        : (flags & ColorEditFlags_DisplayHSV) ? 2
                                                              : 1;

    float prev_split = 0.0f;
    for (int n = 0; n < components; n++) {
      if (n > 0)
        SameLine(0, style.ItemInnerSpacing.x);
      float next_split = GUI_TRUNC(w_items * (n + 1) / components);
      SetNextItemWidth(Max(next_split - prev_split, 1.0f));
      prev_split = next_split;

      // FIXME: When ColorEditFlags_HDR flag is passed HS values snap in
      // weird ways when SV values go below 0.
      if (flags & ColorEditFlags_Float) {
        value_changed |=
            DragFloat(ids[n], &f[n], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f,
                      fmt_table_float[fmt_idx][n]);
        value_changed_as_float |= value_changed;
      } else {
        value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255,
                                 fmt_table_int[fmt_idx][n]);
      }
      if (!(flags & ColorEditFlags_NoOptions))
        OpenPopupOnItemClick("context", PopupFlags_MouseButtonRight);
    }
  } else if ((flags & ColorEditFlags_DisplayHex) != 0 &&
             (flags & ColorEditFlags_NoInputs) == 0) {
    // RGB Hexadecimal Input
    char buf[64];
    if (alpha)
      FormatString(buf, GUI_ARRAYSIZE(buf), "#%02X%02X%02X%02X",
                   Clamp(i[0], 0, 255), Clamp(i[1], 0, 255),
                   Clamp(i[2], 0, 255), Clamp(i[3], 0, 255));
    else
      FormatString(buf, GUI_ARRAYSIZE(buf), "#%02X%02X%02X",
                   Clamp(i[0], 0, 255), Clamp(i[1], 0, 255),
                   Clamp(i[2], 0, 255));
    SetNextItemWidth(w_inputs);
    if (InputText("##Text", buf, GUI_ARRAYSIZE(buf),
                  InputTextFlags_CharsUppercase)) {
      value_changed = true;
      char *p = buf;
      while (*p == '#' || CharIsBlankA(*p))
        p++;
      i[0] = i[1] = i[2] = 0;
      i[3] = 0xFF; // alpha default to 255 is not parsed by scanf (e.g.
                   // inputting #FFFFFF omitting alpha)
      int r;
      if (alpha)
        r = sscanf(p, "%02X%02X%02X%02X", (unsigned int *)&i[0],
                   (unsigned int *)&i[1], (unsigned int *)&i[2],
                   (unsigned int *)&i[3]); // Treat at unsigned (%X is unsigned)
      else
        r = sscanf(p, "%02X%02X%02X", (unsigned int *)&i[0],
                   (unsigned int *)&i[1], (unsigned int *)&i[2]);
      GUI_UNUSED(r); // Fixes C6031: Return value ignored: 'sscanf'.
    }
    if (!(flags & ColorEditFlags_NoOptions))
      OpenPopupOnItemClick("context", PopupFlags_MouseButtonRight);
  }

  Window *picker_active_window = NULL;
  if (!(flags & ColorEditFlags_NoSmallPreview)) {
    const float button_offset_x = ((flags & ColorEditFlags_NoInputs) ||
                                   (style.ColorButtonPosition == Dir_Left))
                                      ? 0.0f
                                      : w_inputs + style.ItemInnerSpacing.x;
    window->DC.CursorPos = Vec2(pos.x + button_offset_x, pos.y);

    const Vec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);
    if (ColorButton("##ColorButton", col_v4, flags)) {
      if (!(flags & ColorEditFlags_NoPicker)) {
        // Store current color and open a picker
        g.ColorPickerRef = col_v4;
        OpenPopup("picker");
        SetNextWindowPos(
            Add(g.LastItemData.Rect.GetBL(), Vec2(0.0f, style.ItemSpacing.y)));
      }
    }
    if (!(flags & ColorEditFlags_NoOptions))
      OpenPopupOnItemClick("context", PopupFlags_MouseButtonRight);

    if (BeginPopup("picker")) {
      if (g.CurrentWindow->BeginCount == 1) {
        picker_active_window = g.CurrentWindow;
        if (label != label_display_end) {
          TextEx(label, label_display_end);
          Spacing();
        }
        ColorEditFlags picker_flags_to_forward =
            ColorEditFlags_DataTypeMask_ | ColorEditFlags_PickerMask_ |
            ColorEditFlags_InputMask_ | ColorEditFlags_HDR |
            ColorEditFlags_NoAlpha | ColorEditFlags_AlphaBar;
        ColorEditFlags picker_flags =
            (flags_untouched & picker_flags_to_forward) |
            ColorEditFlags_DisplayMask_ | ColorEditFlags_NoLabel |
            ColorEditFlags_AlphaPreviewHalf;
        SetNextItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?
        value_changed |=
            ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef.x);
      }
      EndPopup();
    }
  }

  if (label != label_display_end && !(flags & ColorEditFlags_NoLabel)) {
    // Position not necessarily next to last submitted button (e.g. if
    // style.ColorButtonPosition == Dir_Left), but we need to use
    // SameLine() to setup baseline correctly. Might want to refactor SameLine()
    // to simplify this.
    SameLine(0.0f, style.ItemInnerSpacing.x);
    window->DC.CursorPos.x = pos.x + ((flags & ColorEditFlags_NoInputs)
                                          ? w_button
                                          : w_full + style.ItemInnerSpacing.x);
    TextEx(label, label_display_end);
  }

  // Convert back
  if (value_changed && picker_active_window == NULL) {
    if (!value_changed_as_float)
      for (int n = 0; n < 4; n++)
        f[n] = i[n] / 255.0f;
    if ((flags & ColorEditFlags_DisplayHSV) &&
        (flags & ColorEditFlags_InputRGB)) {
      g.ColorEditSavedHue = f[0];
      g.ColorEditSavedSat = f[1];
      ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
      g.ColorEditSavedID = g.ColorEditCurrentID;
      g.ColorEditSavedColor =
          ColorConvertFloat4ToU32(Vec4(f[0], f[1], f[2], 0));
    }
    if ((flags & ColorEditFlags_DisplayRGB) &&
        (flags & ColorEditFlags_InputHSV))
      ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);

    col[0] = f[0];
    col[1] = f[1];
    col[2] = f[2];
    if (alpha)
      col[3] = f[3];
  }

  if (set_current_color_edit_id)
    g.ColorEditCurrentID = 0;
  PopID();
  EndGroup();

  // Drag and Drop Target
  // NB: The flag test is merely an optional micro-optimization,
  // BeginDragDropTarget() does the same test.
  if ((g.LastItemData.StatusFlags & ItemStatusFlags_HoveredRect) &&
      !(g.LastItemData.InFlags & ItemFlags_ReadOnly) &&
      !(flags & ColorEditFlags_NoDragDrop) && BeginDragDropTarget()) {
    bool accepted_drag_drop = false;
    if (const Payload *payload =
            AcceptDragDropPayload(GUI_PAYLOAD_TYPE_COLOR_3F)) {
      memcpy((float *)col, payload->Data,
             sizeof(float) * 3); // Preserve alpha if any //-V512 //-V1086
      value_changed = accepted_drag_drop = true;
    }
    if (const Payload *payload =
            AcceptDragDropPayload(GUI_PAYLOAD_TYPE_COLOR_4F)) {
      memcpy((float *)col, payload->Data, sizeof(float) * components);
      value_changed = accepted_drag_drop = true;
    }

    // Drag-drop payloads are always RGB
    if (accepted_drag_drop && (flags & ColorEditFlags_InputHSV))
      ColorConvertRGBtoHSV(col[0], col[1], col[2], col[0], col[1], col[2]);
    EndDragDropTarget();
  }

  // When picker is being actively used, use its active id so IsItemActive()
  // will function on ColorEdit4().
  if (picker_active_window && g.ActiveId != 0 &&
      g.ActiveIdWindow == picker_active_window)
    g.LastItemData.ID = g.ActiveId;

  if (value_changed &&
      g.LastItemData.ID != 0) // In case of ID collision, the second EndGroup()
                              // won't catch g.ActiveId
    MarkItemEdited(g.LastItemData.ID);

  return value_changed;
}

inline bool Gui::ColorPicker3(const char *label, float col[3],
                              ColorEditFlags flags) {
  float col4[4] = {col[0], col[1], col[2], 1.0f};
  if (!ColorPicker4(label, col4, flags | ColorEditFlags_NoAlpha))
    return false;
  col[0] = col4[0];
  col[1] = col4[1];
  col[2] = col4[2];
  return true;
}

// Helper for ColorPicker4()
static void RenderArrowsForVerticalBar(DrawList *draw_list, Vec2 pos,
                                       Vec2 half_sz, float bar_w, float alpha) {
  U32 alpha8 = GUI_F32_TO_INT8_SAT(alpha);
  Gui::RenderArrowPointingAt(draw_list, Vec2(pos.x + half_sz.x + 1, pos.y),
                             Vec2(half_sz.x + 2, half_sz.y + 1), Dir_Right,
                             GUI_COL32(0, 0, 0, alpha8));
  Gui::RenderArrowPointingAt(draw_list, Vec2(pos.x + half_sz.x, pos.y), half_sz,
                             Dir_Right, GUI_COL32(255, 255, 255, alpha8));
  Gui::RenderArrowPointingAt(
      draw_list, Vec2(pos.x + bar_w - half_sz.x - 1, pos.y),
      Vec2(half_sz.x + 2, half_sz.y + 1), Dir_Left, GUI_COL32(0, 0, 0, alpha8));
  Gui::RenderArrowPointingAt(draw_list, Vec2(pos.x + bar_w - half_sz.x, pos.y),
                             half_sz, Dir_Left,
                             GUI_COL32(255, 255, 255, alpha8));
}

// Note: ColorPicker4() only accesses 3 floats if ColorEditFlags_NoAlpha
// flag is set. (In C++ the 'float col[4]' notation for a function argument is
// equivalent to 'float* col', we only specify a size to facilitate
// understanding of the code.)
// FIXME: we adjust the big color square height based on item width, which may
// cause a flickering feedback loop (if automatic height makes a vertical
// scrollbar appears, affecting automatic width..)
// FIXME: this is trying to be aware of style.Alpha but not fully correct. Also,
// the color wheel will have overlapping glitches with (style.Alpha < 1.0)
inline bool Gui::ColorPicker4(const char *label, float col[4],
                              ColorEditFlags flags, const float *ref_col) {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  DrawList *draw_list = window->DrawList;
  Style &style = g.Style;
  IO &io = g.IO;

  const float width = CalcItemWidth();
  const bool is_readonly = ((g.NextItemData.ItemFlags | g.CurrentItemFlags) &
                            ItemFlags_ReadOnly) != 0;
  g.NextItemData.ClearFlags();

  PushID(label);
  const bool set_current_color_edit_id = (g.ColorEditCurrentID == 0);
  if (set_current_color_edit_id)
    g.ColorEditCurrentID = window->IDStack.back();
  BeginGroup();

  if (!(flags & ColorEditFlags_NoSidePreview))
    flags |= ColorEditFlags_NoSmallPreview;

  // Context menu: display and store options.
  if (!(flags & ColorEditFlags_NoOptions))
    ColorPickerOptionsPopup(col, flags);

  // Read stored options
  if (!(flags & ColorEditFlags_PickerMask_))
    flags |= ((g.ColorEditOptions & ColorEditFlags_PickerMask_)
                  ? g.ColorEditOptions
                  : ColorEditFlags_DefaultOptions_) &
             ColorEditFlags_PickerMask_;
  if (!(flags & ColorEditFlags_InputMask_))
    flags |= ((g.ColorEditOptions & ColorEditFlags_InputMask_)
                  ? g.ColorEditOptions
                  : ColorEditFlags_DefaultOptions_) &
             ColorEditFlags_InputMask_;
  GUI_ASSERT(IsPowerOfTwo(
      flags & ColorEditFlags_PickerMask_)); // Check that only 1 is selected
  GUI_ASSERT(IsPowerOfTwo(
      flags & ColorEditFlags_InputMask_)); // Check that only 1 is selected
  if (!(flags & ColorEditFlags_NoOptions))
    flags |= (g.ColorEditOptions & ColorEditFlags_AlphaBar);

  // Setup
  int components = (flags & ColorEditFlags_NoAlpha) ? 3 : 4;
  bool alpha_bar =
      (flags & ColorEditFlags_AlphaBar) && !(flags & ColorEditFlags_NoAlpha);
  Vec2 picker_pos = window->DC.CursorPos;
  float square_sz = GetFrameHeight();
  float bars_width =
      square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
  float sv_picker_size = Max(
      bars_width * 1,
      width - (alpha_bar ? 2 : 1) *
                  (bars_width +
                   style.ItemInnerSpacing.x)); // Saturation/Value picking box
  float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;
  float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;
  float bars_triangles_half_sz = GUI_TRUNC(bars_width * 0.20f);

  float backup_initial_col[4];
  memcpy(backup_initial_col, col, components * sizeof(float));

  float wheel_thickness = sv_picker_size * 0.08f;
  float wheel_r_outer = sv_picker_size * 0.50f;
  float wheel_r_inner = wheel_r_outer - wheel_thickness;
  Vec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width) * 0.5f,
                    picker_pos.y + sv_picker_size * 0.5f);

  // Note: the triangle is displayed rotated with triangle_pa pointing to Hue,
  // but most coordinates stays unrotated for logic.
  float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);
  Vec2 triangle_pa = Vec2(triangle_r, 0.0f); // Hue point.
  Vec2 triangle_pb =
      Vec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.
  Vec2 triangle_pc =
      Vec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.

  float H = col[0], S = col[1], V = col[2];
  float R = col[0], G = col[1], B = col[2];
  if (flags & ColorEditFlags_InputRGB) {
    // Hue is lost when converting from grayscale rgb (saturation=0). Restore
    // it.
    ColorConvertRGBtoHSV(R, G, B, H, S, V);
    ColorEditRestoreHS(col, &H, &S, &V);
  } else if (flags & ColorEditFlags_InputHSV) {
    ColorConvertHSVtoRGB(H, S, V, R, G, B);
  }

  bool value_changed = false, value_changed_h = false, value_changed_sv = false;

  PushItemFlag(ItemFlags_NoNav, true);
  if (flags & ColorEditFlags_PickerHueWheel) {
    // Hue wheel + SV triangle logic
    InvisibleButton("hsv",
                    Vec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width,
                         sv_picker_size));
    if (IsItemActive() && !is_readonly) {
      Vec2 initial_off = Subtract(g.IO.MouseClickedPos[0], wheel_center);
      Vec2 current_off = Subtract(g.IO.MousePos, wheel_center);
      float initial_dist2 = LengthSqr(initial_off);
      if (initial_dist2 >= (wheel_r_inner - 1) * (wheel_r_inner - 1) &&
          initial_dist2 <= (wheel_r_outer + 1) * (wheel_r_outer + 1)) {
        // Interactive with Hue wheel
        H = Atan2(current_off.y, current_off.x) / GUI_PI * 0.5f;
        if (H < 0.0f)
          H += 1.0f;
        value_changed = value_changed_h = true;
      }
      float cos_hue_angle = Cos(-H * 2.0f * GUI_PI);
      float sin_hue_angle = Sin(-H * 2.0f * GUI_PI);
      if (TriangleContainsPoint(
              triangle_pa, triangle_pb, triangle_pc,
              Rotate(initial_off, cos_hue_angle, sin_hue_angle))) {
        // Interacting with SV triangle
        Vec2 current_off_unrotated =
            Rotate(current_off, cos_hue_angle, sin_hue_angle);
        if (!TriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc,
                                   current_off_unrotated))
          current_off_unrotated = TriangleClosestPoint(
              triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);
        float uu, vv, ww;
        TriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc,
                                  current_off_unrotated, uu, vv, ww);
        V = Clamp(1.0f - vv, 0.0001f, 1.0f);
        S = Clamp(uu / V, 0.0001f, 1.0f);
        value_changed = value_changed_sv = true;
      }
    }
    if (!(flags & ColorEditFlags_NoOptions))
      OpenPopupOnItemClick("context", PopupFlags_MouseButtonRight);
  } else if (flags & ColorEditFlags_PickerHueBar) {
    // SV rectangle logic
    InvisibleButton("sv", Vec2(sv_picker_size, sv_picker_size));
    if (IsItemActive() && !is_readonly) {
      S = Saturate((io.MousePos.x - picker_pos.x) / (sv_picker_size - 1));
      V = 1.0f -
          Saturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
      ColorEditRestoreH(
          col, &H); // Greatly reduces hue jitter and reset to 0 when hue == 255
                    // and color is rapidly modified using SV square.
      value_changed = value_changed_sv = true;
    }
    if (!(flags & ColorEditFlags_NoOptions))
      OpenPopupOnItemClick("context", PopupFlags_MouseButtonRight);

    // Hue bar logic
    SetCursorScreenPos(Vec2(bar0_pos_x, picker_pos.y));
    InvisibleButton("hue", Vec2(bars_width, sv_picker_size));
    if (IsItemActive() && !is_readonly) {
      H = Saturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
      value_changed = value_changed_h = true;
    }
  }

  // Alpha bar logic
  if (alpha_bar) {
    SetCursorScreenPos(Vec2(bar1_pos_x, picker_pos.y));
    InvisibleButton("alpha", Vec2(bars_width, sv_picker_size));
    if (IsItemActive()) {
      col[3] = 1.0f -
               Saturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
      value_changed = true;
    }
  }
  PopItemFlag(); // ItemFlags_NoNav

  if (!(flags & ColorEditFlags_NoSidePreview)) {
    SameLine(0, style.ItemInnerSpacing.x);
    BeginGroup();
  }

  if (!(flags & ColorEditFlags_NoLabel)) {
    const char *label_display_end = FindRenderedTextEnd(label);
    if (label != label_display_end) {
      if ((flags & ColorEditFlags_NoSidePreview))
        SameLine(0, style.ItemInnerSpacing.x);
      TextEx(label, label_display_end);
    }
  }

  if (!(flags & ColorEditFlags_NoSidePreview)) {
    PushItemFlag(ItemFlags_NoNavDefaultFocus, true);
    Vec4 col_v4(col[0], col[1], col[2],
                (flags & ColorEditFlags_NoAlpha) ? 1.0f : col[3]);
    if ((flags & ColorEditFlags_NoLabel))
      Text("Current");

    ColorEditFlags sub_flags_to_forward =
        ColorEditFlags_InputMask_ | ColorEditFlags_HDR |
        ColorEditFlags_AlphaPreview | ColorEditFlags_AlphaPreviewHalf |
        ColorEditFlags_NoTooltip;
    ColorButton("##current", col_v4, (flags & sub_flags_to_forward),
                Vec2(square_sz * 3, square_sz * 2));
    if (ref_col != NULL) {
      Text("Original");
      Vec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2],
                      (flags & ColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);
      if (ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward),
                      Vec2(square_sz * 3, square_sz * 2))) {
        memcpy(col, ref_col, components * sizeof(float));
        value_changed = true;
      }
    }
    PopItemFlag();
    EndGroup();
  }

  // Convert back color to RGB
  if (value_changed_h || value_changed_sv) {
    if (flags & ColorEditFlags_InputRGB) {
      ColorConvertHSVtoRGB(H, S, V, col[0], col[1], col[2]);
      g.ColorEditSavedHue = H;
      g.ColorEditSavedSat = S;
      g.ColorEditSavedID = g.ColorEditCurrentID;
      g.ColorEditSavedColor =
          ColorConvertFloat4ToU32(Vec4(col[0], col[1], col[2], 0));
    } else if (flags & ColorEditFlags_InputHSV) {
      col[0] = H;
      col[1] = S;
      col[2] = V;
    }
  }

  // R,G,B and H,S,V slider color editor
  bool value_changed_fix_hue_wrap = false;
  if ((flags & ColorEditFlags_NoInputs) == 0) {
    PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width -
                  picker_pos.x);
    ColorEditFlags sub_flags_to_forward =
        ColorEditFlags_DataTypeMask_ | ColorEditFlags_InputMask_ |
        ColorEditFlags_HDR | ColorEditFlags_NoAlpha | ColorEditFlags_NoOptions |
        ColorEditFlags_NoTooltip | ColorEditFlags_NoSmallPreview |
        ColorEditFlags_AlphaPreview | ColorEditFlags_AlphaPreviewHalf;
    ColorEditFlags sub_flags =
        (flags & sub_flags_to_forward) | ColorEditFlags_NoPicker;
    if (flags & ColorEditFlags_DisplayRGB ||
        (flags & ColorEditFlags_DisplayMask_) == 0)
      if (ColorEdit4("##rgb", col, sub_flags | ColorEditFlags_DisplayRGB)) {
        // FIXME: Hackily differentiating using the DragInt (ActiveId != 0 &&
        // !ActiveIdAllowOverlap) vs. using the InputText or DropTarget. For the
        // later we don't want to run the hue-wrap canceling code. If you are
        // well versed in HSV picker please provide your input! (See #2050)
        value_changed_fix_hue_wrap =
            (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);
        value_changed = true;
      }
    if (flags & ColorEditFlags_DisplayHSV ||
        (flags & ColorEditFlags_DisplayMask_) == 0)
      value_changed |=
          ColorEdit4("##hsv", col, sub_flags | ColorEditFlags_DisplayHSV);
    if (flags & ColorEditFlags_DisplayHex ||
        (flags & ColorEditFlags_DisplayMask_) == 0)
      value_changed |=
          ColorEdit4("##hex", col, sub_flags | ColorEditFlags_DisplayHex);
    PopItemWidth();
  }

  // Try to cancel hue wrap (after ColorEdit4 call), if any
  if (value_changed_fix_hue_wrap && (flags & ColorEditFlags_InputRGB)) {
    float new_H, new_S, new_V;
    ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);
    if (new_H <= 0 && H > 0) {
      if (new_V <= 0 && V != new_V)
        ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0],
                             col[1], col[2]);
      else if (new_S <= 0)
        ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0],
                             col[1], col[2]);
    }
  }

  if (value_changed) {
    if (flags & ColorEditFlags_InputRGB) {
      R = col[0];
      G = col[1];
      B = col[2];
      ColorConvertRGBtoHSV(R, G, B, H, S, V);
      ColorEditRestoreHS(
          col, &H, &S,
          &V); // Fix local Hue as display below will use it immediately.
    } else if (flags & ColorEditFlags_InputHSV) {
      H = col[0];
      S = col[1];
      V = col[2];
      ColorConvertHSVtoRGB(H, S, V, R, G, B);
    }
  }

  const int style_alpha8 = GUI_F32_TO_INT8_SAT(style.Alpha);
  const U32 col_black = GUI_COL32(0, 0, 0, style_alpha8);
  const U32 col_white = GUI_COL32(255, 255, 255, style_alpha8);
  const U32 col_midgrey = GUI_COL32(128, 128, 128, style_alpha8);
  const U32 col_hues[6 + 1] = {
      GUI_COL32(255, 0, 0, style_alpha8), GUI_COL32(255, 255, 0, style_alpha8),
      GUI_COL32(0, 255, 0, style_alpha8), GUI_COL32(0, 255, 255, style_alpha8),
      GUI_COL32(0, 0, 255, style_alpha8), GUI_COL32(255, 0, 255, style_alpha8),
      GUI_COL32(255, 0, 0, style_alpha8)};

  Vec4 hue_color_f(1, 1, 1, style.Alpha);
  ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);
  U32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);
  U32 user_col32_striped_of_alpha = ColorConvertFloat4ToU32(
      Vec4(R, G, B, style.Alpha)); // Important: this is still including the
                                   // main rendering/style alpha!!

  Vec2 sv_cursor_pos;

  if (flags & ColorEditFlags_PickerHueWheel) {
    // Render Hue Wheel
    const float aeps =
        0.5f /
        wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).
    const int segment_per_arc = Max(4, (int)wheel_r_outer / 12);
    for (int n = 0; n < 6; n++) {
      const float a0 = (n) / 6.0f * 2.0f * GUI_PI - aeps;
      const float a1 = (n + 1.0f) / 6.0f * 2.0f * GUI_PI + aeps;
      const int vert_start_idx = draw_list->VtxBuffer.Size;
      draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer) * 0.5f,
                           a0, a1, segment_per_arc);
      draw_list->PathStroke(col_white, 0, wheel_thickness);
      const int vert_end_idx = draw_list->VtxBuffer.Size;

      // Paint colors over existing vertices
      Vec2 gradient_p0(wheel_center.x + Cos(a0) * wheel_r_inner,
                       wheel_center.y + Sin(a0) * wheel_r_inner);
      Vec2 gradient_p1(wheel_center.x + Cos(a1) * wheel_r_inner,
                       wheel_center.y + Sin(a1) * wheel_r_inner);
      ShadeVertsLinearColorGradientKeepAlpha(
          draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1,
          col_hues[n], col_hues[n + 1]);
    }

    // Render Cursor + preview on Hue Wheel
    float cos_hue_angle = Cos(H * 2.0f * GUI_PI);
    float sin_hue_angle = Sin(H * 2.0f * GUI_PI);
    Vec2 hue_cursor_pos(
        wheel_center.x + cos_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f,
        wheel_center.y +
            sin_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f);
    float hue_cursor_rad =
        value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;
    int hue_cursor_segments = draw_list->_CalcCircleAutoSegmentCount(
        hue_cursor_rad); // Lock segment count so the +1 one matches others.
    draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32,
                               hue_cursor_segments);
    draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad + 1, col_midgrey,
                         hue_cursor_segments);
    draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, col_white,
                         hue_cursor_segments);

    // Render SV triangle (rotated according to hue)
    Vec2 tra =
        Add(wheel_center, Rotate(triangle_pa, cos_hue_angle, sin_hue_angle));
    Vec2 trb =
        Add(wheel_center, Rotate(triangle_pb, cos_hue_angle, sin_hue_angle));
    Vec2 trc =
        Add(wheel_center, Rotate(triangle_pc, cos_hue_angle, sin_hue_angle));
    Vec2 uv_white = GetFontTexUvWhitePixel();
    draw_list->PrimReserve(3, 3);
    draw_list->PrimVtx(tra, uv_white, hue_color32);
    draw_list->PrimVtx(trb, uv_white, col_black);
    draw_list->PrimVtx(trc, uv_white, col_white);
    draw_list->AddTriangle(tra, trb, trc, col_midgrey, 1.5f);
    sv_cursor_pos = Lerp(Lerp(trc, tra, Saturate(S)), trb, Saturate(1 - V));
  } else if (flags & ColorEditFlags_PickerHueBar) {
    // Render SV Square
    draw_list->AddRectFilledMultiColor(
        picker_pos, Add(picker_pos, Vec2(sv_picker_size, sv_picker_size)),
        col_white, hue_color32, hue_color32, col_white);
    draw_list->AddRectFilledMultiColor(
        picker_pos, Add(picker_pos, Vec2(sv_picker_size, sv_picker_size)), 0, 0,
        col_black, col_black);
    RenderFrameBorder(picker_pos,
                      Add(picker_pos, Vec2(sv_picker_size, sv_picker_size)),
                      0.0f);
    sv_cursor_pos.x =
        Clamp(GUI_ROUND(picker_pos.x + Saturate(S) * sv_picker_size),
              picker_pos.x + 2,
              picker_pos.x + sv_picker_size -
                  2); // Sneakily prevent the circle to stick out too much
    sv_cursor_pos.y =
        Clamp(GUI_ROUND(picker_pos.y + Saturate(1 - V) * sv_picker_size),
              picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

    // Render Hue Bar
    for (int i = 0; i < 6; ++i)
      draw_list->AddRectFilledMultiColor(
          Vec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)),
          Vec2(bar0_pos_x + bars_width,
               picker_pos.y + (i + 1) * (sv_picker_size / 6)),
          col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);
    float bar0_line_y = GUI_ROUND(picker_pos.y + H * sv_picker_size);
    RenderFrameBorder(
        Vec2(bar0_pos_x, picker_pos.y),
        Vec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);
    RenderArrowsForVerticalBar(
        draw_list, Vec2(bar0_pos_x - 1, bar0_line_y),
        Vec2(bars_triangles_half_sz + 1, bars_triangles_half_sz),
        bars_width + 2.0f, style.Alpha);
  }

  // Render cursor/preview circle (clamp S/V within 0..1 range because floating
  // points colors may lead HSV values to be out of range)
  float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;
  int sv_cursor_segments = draw_list->_CalcCircleAutoSegmentCount(
      sv_cursor_rad); // Lock segment count so the +1 one matches others.
  draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad,
                             user_col32_striped_of_alpha, sv_cursor_segments);
  draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad + 1, col_midgrey,
                       sv_cursor_segments);
  draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, col_white,
                       sv_cursor_segments);

  // Render alpha bar
  if (alpha_bar) {
    float alpha = Saturate(col[3]);
    Rect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width,
                 picker_pos.y + sv_picker_size);
    RenderColorRectWithAlphaCheckerboard(draw_list, bar1_bb.Min, bar1_bb.Max, 0,
                                         bar1_bb.GetWidth() / 2.0f,
                                         Vec2(0.0f, 0.0f));
    draw_list->AddRectFilledMultiColor(
        bar1_bb.Min, bar1_bb.Max, user_col32_striped_of_alpha,
        user_col32_striped_of_alpha,
        user_col32_striped_of_alpha & ~GUI_COL32_A_MASK,
        user_col32_striped_of_alpha & ~GUI_COL32_A_MASK);
    float bar1_line_y =
        GUI_ROUND(picker_pos.y + (1.0f - alpha) * sv_picker_size);
    RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);
    RenderArrowsForVerticalBar(
        draw_list, Vec2(bar1_pos_x - 1, bar1_line_y),
        Vec2(bars_triangles_half_sz + 1, bars_triangles_half_sz),
        bars_width + 2.0f, style.Alpha);
  }

  EndGroup();

  if (value_changed &&
      memcmp(backup_initial_col, col, components * sizeof(float)) == 0)
    value_changed = false;
  if (value_changed &&
      g.LastItemData.ID != 0) // In case of ID collision, the second EndGroup()
                              // won't catch g.ActiveId
    MarkItemEdited(g.LastItemData.ID);

  if (set_current_color_edit_id)
    g.ColorEditCurrentID = 0;
  PopID();

  return value_changed;
}

// A little color square. Return true when clicked.
// FIXME: May want to display/ignore the alpha component in the color display?
// Yet show it in the tooltip. 'desc_id' is not called 'label' because we don't
// display it next to the button, but only in the tooltip. Note that 'col' may
// be encoded in HSV if ColorEditFlags_InputHSV is set.
inline bool Gui::ColorButton(const char *desc_id, const Vec4 &col,
                             ColorEditFlags flags, const Vec2 &size_arg) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  const ID id = window->GetID(desc_id);
  const float default_size = GetFrameHeight();
  const Vec2 size(size_arg.x == 0.0f ? default_size : size_arg.x,
                  size_arg.y == 0.0f ? default_size : size_arg.y);
  const Rect bb(window->DC.CursorPos, Add(window->DC.CursorPos, size));
  ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
  if (!ItemAdd(bb, id))
    return false;

  bool hovered, held;
  bool pressed = ButtonBehavior(bb, id, &hovered, &held);

  if (flags & ColorEditFlags_NoAlpha)
    flags &= ~(ColorEditFlags_AlphaPreview | ColorEditFlags_AlphaPreviewHalf);

  Vec4 col_rgb = col;
  if (flags & ColorEditFlags_InputHSV)
    ColorConvertHSVtoRGB(col_rgb.x, col_rgb.y, col_rgb.z, col_rgb.x, col_rgb.y,
                         col_rgb.z);

  Vec4 col_rgb_without_alpha(col_rgb.x, col_rgb.y, col_rgb.z, 1.0f);
  float grid_step = Min(size.x, size.y) / 2.99f;
  float rounding = Min(g.Style.FrameRounding, grid_step * 0.5f);
  Rect bb_inner = bb;
  float off = 0.0f;
  if ((flags & ColorEditFlags_NoBorder) == 0) {
    off = -0.75f; // The border (using Col_FrameBg) tends to look off when color
                  // is near-opaque and rounding is enabled. This offset seemed
                  // like a good middle ground to reduce those artifacts.
    bb_inner.Expand(off);
  }
  if ((flags & ColorEditFlags_AlphaPreviewHalf) && col_rgb.w < 1.0f) {
    float mid_x = GUI_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5f);
    RenderColorRectWithAlphaCheckerboard(
        window->DrawList, Vec2(bb_inner.Min.x + grid_step, bb_inner.Min.y),
        bb_inner.Max, GetColorU32(col_rgb), grid_step,
        Vec2(-grid_step + off, off), rounding, DrawFlags_RoundCornersRight);
    window->DrawList->AddRectFilled(bb_inner.Min, Vec2(mid_x, bb_inner.Max.y),
                                    GetColorU32(col_rgb_without_alpha),
                                    rounding, DrawFlags_RoundCornersLeft);
  } else {
    // Because GetColorU32() multiplies by the global style Alpha and we don't
    // want to display a checkerboard if the source code had no alpha
    Vec4 col_source =
        (flags & ColorEditFlags_AlphaPreview) ? col_rgb : col_rgb_without_alpha;
    if (col_source.w < 1.0f)
      RenderColorRectWithAlphaCheckerboard(
          window->DrawList, bb_inner.Min, bb_inner.Max, GetColorU32(col_source),
          grid_step, Vec2(off, off), rounding);
    else
      window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max,
                                      GetColorU32(col_source), rounding);
  }
  RenderNavHighlight(bb, id);
  if ((flags & ColorEditFlags_NoBorder) == 0) {
    if (g.Style.FrameBorderSize > 0.0f)
      RenderFrameBorder(bb.Min, bb.Max, rounding);
    else
      window->DrawList->AddRect(
          bb.Min, bb.Max, GetColorU32(Col_FrameBg),
          rounding); // Color button are often in need of some sort of border
  }

  // Drag and Drop Source
  // NB: The ActiveId test is merely an optional micro-optimization,
  // BeginDragDropSource() does the same test.
  if (g.ActiveId == id && !(flags & ColorEditFlags_NoDragDrop) &&
      BeginDragDropSource()) {
    if (flags & ColorEditFlags_NoAlpha)
      SetDragDropPayload(GUI_PAYLOAD_TYPE_COLOR_3F, &col_rgb, sizeof(float) * 3,
                         Cond_Once);
    else
      SetDragDropPayload(GUI_PAYLOAD_TYPE_COLOR_4F, &col_rgb, sizeof(float) * 4,
                         Cond_Once);
    ColorButton(desc_id, col, flags);
    SameLine();
    TextEx("Color");
    EndDragDropSource();
  }

  // Tooltip
  if (!(flags & ColorEditFlags_NoTooltip) && hovered &&
      IsItemHovered(HoveredFlags_ForTooltip))
    ColorTooltip(desc_id, &col.x,
                 flags & (ColorEditFlags_InputMask_ | ColorEditFlags_NoAlpha |
                          ColorEditFlags_AlphaPreview |
                          ColorEditFlags_AlphaPreviewHalf));

  return pressed;
}

// Initialize/override default color options
inline void Gui::SetColorEditOptions(ColorEditFlags flags) {
  Context &g = *GGui;
  if ((flags & ColorEditFlags_DisplayMask_) == 0)
    flags |= ColorEditFlags_DefaultOptions_ & ColorEditFlags_DisplayMask_;
  if ((flags & ColorEditFlags_DataTypeMask_) == 0)
    flags |= ColorEditFlags_DefaultOptions_ & ColorEditFlags_DataTypeMask_;
  if ((flags & ColorEditFlags_PickerMask_) == 0)
    flags |= ColorEditFlags_DefaultOptions_ & ColorEditFlags_PickerMask_;
  if ((flags & ColorEditFlags_InputMask_) == 0)
    flags |= ColorEditFlags_DefaultOptions_ & ColorEditFlags_InputMask_;
  GUI_ASSERT(IsPowerOfTwo(
      flags & ColorEditFlags_DisplayMask_)); // Check only 1 option is selected
  GUI_ASSERT(IsPowerOfTwo(
      flags & ColorEditFlags_DataTypeMask_)); // Check only 1 option is selected
  GUI_ASSERT(IsPowerOfTwo(
      flags & ColorEditFlags_PickerMask_)); // Check only 1 option is selected
  GUI_ASSERT(IsPowerOfTwo(
      flags & ColorEditFlags_InputMask_)); // Check only 1 option is selected
  g.ColorEditOptions = flags;
}

// Note: only access 3 floats if ColorEditFlags_NoAlpha flag is set.

inline void Gui::ColorPickerOptionsPopup(const float *ref_col,
                                         ColorEditFlags flags) {
  bool allow_opt_picker = !(flags & ColorEditFlags_PickerMask_);
  bool allow_opt_alpha_bar =
      !(flags & ColorEditFlags_NoAlpha) && !(flags & ColorEditFlags_AlphaBar);
  if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup("context"))
    return;
  Context &g = *GGui;
  g.LockMarkEdited++;
  if (allow_opt_picker) {
    Vec2 picker_size(
        g.FontSize * 8,
        Max(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x),
            1.0f)); // FIXME: Picker size copied from main picker function
    PushItemWidth(picker_size.x);
    for (int picker_type = 0; picker_type < 2; picker_type++) {
      // Draw small/thumbnail version of each picker type (over an invisible
      // button for selection)
      if (picker_type > 0)
        Separator();
      PushID(picker_type);
      ColorEditFlags picker_flags =
          ColorEditFlags_NoInputs | ColorEditFlags_NoOptions |
          ColorEditFlags_NoLabel | ColorEditFlags_NoSidePreview |
          (flags & ColorEditFlags_NoAlpha);
      if (picker_type == 0)
        picker_flags |= ColorEditFlags_PickerHueBar;
      if (picker_type == 1)
        picker_flags |= ColorEditFlags_PickerHueWheel;
      Vec2 backup_pos = GetCursorScreenPos();
      if (Selectable("##selectable", false, 0,
                     picker_size)) // By default, Selectable() is closing popup
        g.ColorEditOptions =
            (g.ColorEditOptions & ~ColorEditFlags_PickerMask_) |
            (picker_flags & ColorEditFlags_PickerMask_);
      SetCursorScreenPos(backup_pos);
      Vec4 previewing_ref_col;
      memcpy(&previewing_ref_col, ref_col,
             sizeof(float) * ((picker_flags & ColorEditFlags_NoAlpha) ? 3 : 4));
      ColorPicker4("##previewing_picker", &previewing_ref_col.x, picker_flags);
      PopID();
    }
    PopItemWidth();
  }
  if (allow_opt_alpha_bar) {
    if (allow_opt_picker)
      Separator();
    CheckboxFlags("Alpha Bar", &g.ColorEditOptions, ColorEditFlags_AlphaBar);
  }
  EndPopup();
  g.LockMarkEdited--;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
//-------------------------------------------------------------------------
// - TreeNode()
// - TreeNodeV()
// - TreeNodeEx()
// - TreeNodeExV()
// - TreeNodeBehavior() [Internal]
// - TreePush()
// - TreePop()
// - GetTreeNodeToLabelSpacing()
// - SetNextItemOpen()
// - CollapsingHeader()
//-------------------------------------------------------------------------

inline bool Gui::TreeNode(const char *str_id, const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  bool is_open = TreeNodeExV(str_id, 0, fmt, args);
  va_end(args);
  return is_open;
}

inline bool Gui::TreeNode(const void *ptr_id, const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);
  va_end(args);
  return is_open;
}

inline bool Gui::TreeNode(const char *label) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;
  return TreeNodeBehavior(window->GetID(label), 0, label, NULL);
}

inline bool Gui::TreeNodeV(const char *str_id, const char *fmt, va_list args) {
  return TreeNodeExV(str_id, 0, fmt, args);
}

inline bool Gui::TreeNodeV(const void *ptr_id, const char *fmt, va_list args) {
  return TreeNodeExV(ptr_id, 0, fmt, args);
}

inline bool Gui::TreeNodeEx(const char *label, TreeNodeFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  return TreeNodeBehavior(window->GetID(label), flags, label, NULL);
}

inline bool Gui::TreeNodeEx(const char *str_id, TreeNodeFlags flags,
                            const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  bool is_open = TreeNodeExV(str_id, flags, fmt, args);
  va_end(args);
  return is_open;
}

inline bool Gui::TreeNodeEx(const void *ptr_id, TreeNodeFlags flags,
                            const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);
  va_end(args);
  return is_open;
}

inline bool Gui::TreeNodeExV(const char *str_id, TreeNodeFlags flags,
                             const char *fmt, va_list args) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  const char *label, *label_end;
  FormatStringToTempBufferV(&label, &label_end, fmt, args);
  return TreeNodeBehavior(window->GetID(str_id), flags, label, label_end);
}

inline bool Gui::TreeNodeExV(const void *ptr_id, TreeNodeFlags flags,
                             const char *fmt, va_list args) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  const char *label, *label_end;
  FormatStringToTempBufferV(&label, &label_end, fmt, args);
  return TreeNodeBehavior(window->GetID(ptr_id), flags, label, label_end);
}

inline bool Gui::TreeNodeBehavior(ID id, TreeNodeFlags flags, const char *label,
                                  const char *label_end) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  const Style &style = g.Style;
  const bool display_frame = (flags & TreeNodeFlags_Framed) != 0;
  const Vec2 padding =
      (display_frame || (flags & TreeNodeFlags_FramePadding))
          ? style.FramePadding
          : Vec2(style.FramePadding.x,
                 Min(window->DC.CurrLineTextBaseOffset, style.FramePadding.y));

  if (!label_end)
    label_end = FindRenderedTextEnd(label);
  const Vec2 label_size = CalcTextSize(label, label_end, false);

  // We vertically grow up to current line height up the typical widget height.
  const float frame_height =
      Max(Min(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2),
          label_size.y + padding.y * 2);
  const bool span_all_columns =
      (flags & TreeNodeFlags_SpanAllColumns) != 0 && (g.CurrentTable != NULL);
  Rect frame_bb;
  frame_bb.Min.x = span_all_columns ? window->ParentWorkRect.Min.x
                   : (flags & TreeNodeFlags_SpanFullWidth)
                       ? window->WorkRect.Min.x
                       : window->DC.CursorPos.x;
  frame_bb.Min.y = window->DC.CursorPos.y;
  frame_bb.Max.x =
      span_all_columns ? window->ParentWorkRect.Max.x : window->WorkRect.Max.x;
  frame_bb.Max.y = window->DC.CursorPos.y + frame_height;
  if (display_frame) {
    // Framed header expand a little outside the default padding, to the edge of
    // InnerClipRect (FIXME: May remove this at some point and make
    // InnerClipRect align with WindowPadding.x instead of WindowPadding.x*0.5f)
    frame_bb.Min.x -= GUI_TRUNC(window->WindowPadding.x * 0.5f - 1.0f);
    frame_bb.Max.x += GUI_TRUNC(window->WindowPadding.x * 0.5f);
  }

  const float text_offset_x =
      g.FontSize + (display_frame
                        ? padding.x * 3
                        : padding.x * 2); // Collapsing arrow width + Spacing
  const float text_offset_y = Max(
      padding.y,
      window->DC.CurrLineTextBaseOffset); // Latch before ItemSize changes it
  const float text_width =
      g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x * 2
                                        : 0.0f); // Include collapsing
  Vec2 text_pos(window->DC.CursorPos.x + text_offset_x,
                window->DC.CursorPos.y + text_offset_y);
  ItemSize(Vec2(text_width, frame_height), padding.y);

  // For regular tree nodes, we arbitrary allow to click past 2 worth of
  // ItemSpacing
  Rect interact_bb = frame_bb;
  if (!display_frame &&
      (flags & (TreeNodeFlags_SpanAvailWidth | TreeNodeFlags_SpanFullWidth |
                TreeNodeFlags_SpanAllColumns)) == 0)
    interact_bb.Max.x =
        frame_bb.Min.x + text_width + style.ItemSpacing.x * 2.0f;

  // Modify ClipRect for the ItemAdd(), faster than doing a
  // PushColumnsBackground/PushTableBackgroundChannel for every Selectable..
  const float backup_clip_rect_min_x = window->ClipRect.Min.x;
  const float backup_clip_rect_max_x = window->ClipRect.Max.x;
  if (span_all_columns) {
    window->ClipRect.Min.x = window->ParentWorkRect.Min.x;
    window->ClipRect.Max.x = window->ParentWorkRect.Max.x;
  }

  // Compute open and multi-select states before ItemAdd() as it clear NextItem
  // data.
  bool is_open = TreeNodeUpdateNextOpen(id, flags);
  bool item_add = ItemAdd(interact_bb, id);
  g.LastItemData.StatusFlags |= ItemStatusFlags_HasDisplayRect;
  g.LastItemData.DisplayRect = frame_bb;

  if (span_all_columns) {
    window->ClipRect.Min.x = backup_clip_rect_min_x;
    window->ClipRect.Max.x = backup_clip_rect_max_x;
  }

  // If a NavLeft request is happening and
  // TreeNodeFlags_NavLeftJumpsBackHere enabled: Store data for the current
  // depth to allow returning to this node from any child item. For this purpose
  // we essentially compare if g.NavIdIsAlive went from 0 to 1 between
  // TreeNode() and TreePop(). It will become tempting to enable
  // TreeNodeFlags_NavLeftJumpsBackHere by default or move it to
  // Style. Currently only supports 32 level deep and we are fine with (1
  // << Depth) overflowing into a zero, easy to increase.
  if (is_open && !g.NavIdIsAlive &&
      (flags & TreeNodeFlags_NavLeftJumpsBackHere) &&
      !(flags & TreeNodeFlags_NoTreePushOnOpen))
    if (g.NavMoveDir == Dir_Left && g.NavWindow == window &&
        NavMoveRequestButNoResultYet()) {
      g.NavTreeNodeStack.resize(g.NavTreeNodeStack.Size + 1);
      NavTreeNodeData *nav_tree_node_data = &g.NavTreeNodeStack.back();
      nav_tree_node_data->ID = id;
      nav_tree_node_data->InFlags = g.LastItemData.InFlags;
      nav_tree_node_data->NavRect = g.LastItemData.NavRect;
      window->DC.TreeJumpToParentOnPopMask |= (1 << window->DC.TreeDepth);
    }

  const bool is_leaf = (flags & TreeNodeFlags_Leaf) != 0;
  if (!item_add) {
    if (is_open && !(flags & TreeNodeFlags_NoTreePushOnOpen))
      TreePushOverrideID(id);
    GUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label,
                              g.LastItemData.StatusFlags |
                                  (is_leaf ? 0 : ItemStatusFlags_Openable) |
                                  (is_open ? ItemStatusFlags_Opened : 0));
    return is_open;
  }

  if (span_all_columns) {
    TablePushBackgroundChannel();
    g.LastItemData.StatusFlags |= ItemStatusFlags_HasClipRect;
    g.LastItemData.ClipRect = window->ClipRect;
  }

  ButtonFlags button_flags = TreeNodeFlags_None;
  if ((flags & TreeNodeFlags_AllowOverlap) ||
      (g.LastItemData.InFlags & ItemFlags_AllowOverlap))
    button_flags |= ButtonFlags_AllowOverlap;
  if (!is_leaf)
    button_flags |= ButtonFlags_PressedOnDragDropHold;

  // We allow clicking on the arrow section with keyboard modifiers held, in
  // order to easily allow browsing a tree while preserving selection with code
  // implementing multi-selection patterns. When clicking on the rest of the
  // tree node we always disallow keyboard modifiers.
  const float arrow_hit_x1 =
      (text_pos.x - text_offset_x) - style.TouchExtraPadding.x;
  const float arrow_hit_x2 = (text_pos.x - text_offset_x) +
                             (g.FontSize + padding.x * 2.0f) +
                             style.TouchExtraPadding.x;
  const bool is_mouse_x_over_arrow =
      (g.IO.MousePos.x >= arrow_hit_x1 && g.IO.MousePos.x < arrow_hit_x2);
  if (window != g.HoveredWindow || !is_mouse_x_over_arrow)
    button_flags |= ButtonFlags_NoKeyModifiers;

  // Open behaviors can be altered with the _OpenOnArrow and _OnOnDoubleClick
  // flags. Some alteration have subtle effects (e.g. toggle on MouseUp vs
  // MouseDown events) due to requirements for multi-selection and drag and drop
  // support.
  // - Single-click on label = Toggle on MouseUp (default, when _OpenOnArrow=0)
  // - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=0)
  // - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=1)
  // - Double-click on label = Toggle on MouseDoubleClick (when
  // _OpenOnDoubleClick=1)
  // - Double-click on arrow = Toggle on MouseDoubleClick (when
  // _OpenOnDoubleClick=1 and _OpenOnArrow=0) It is rather standard that arrow
  // click react on Down rather than Up. We set
  // ButtonFlags_PressedOnClickRelease on OpenOnDoubleClick because we want
  // the item to be active on the initial MouseDown in order for drag and drop
  // to work.
  if (is_mouse_x_over_arrow)
    button_flags |= ButtonFlags_PressedOnClick;
  else if (flags & TreeNodeFlags_OpenOnDoubleClick)
    button_flags |=
        ButtonFlags_PressedOnClickRelease | ButtonFlags_PressedOnDoubleClick;
  else
    button_flags |= ButtonFlags_PressedOnClickRelease;

  bool selected = (flags & TreeNodeFlags_Selected) != 0;
  const bool was_selected = selected;

  bool hovered, held;
  bool pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);
  bool toggled = false;
  if (!is_leaf) {
    if (pressed && g.DragDropHoldJustPressedId != id) {
      if ((flags & (TreeNodeFlags_OpenOnArrow |
                    TreeNodeFlags_OpenOnDoubleClick)) == 0 ||
          (g.NavActivateId == id))
        toggled = true;
      if (flags & TreeNodeFlags_OpenOnArrow)
        toggled |=
            is_mouse_x_over_arrow &&
            !g.NavDisableMouseHover; // Lightweight equivalent of
                                     // IsMouseHoveringRect() since
                                     // ButtonBehavior() already did the job
      if ((flags & TreeNodeFlags_OpenOnDoubleClick) &&
          g.IO.MouseClickedCount[0] == 2)
        toggled = true;
    } else if (pressed && g.DragDropHoldJustPressedId == id) {
      GUI_ASSERT(button_flags & ButtonFlags_PressedOnDragDropHold);
      if (!is_open) // When using Drag and Drop "hold to open" we keep the node
                    // highlighted after opening, but never close it again.
        toggled = true;
    }

    if (g.NavId == id && g.NavMoveDir == Dir_Left && is_open) {
      toggled = true;
      NavClearPreferredPosForAxis(Axis_X);
      NavMoveRequestCancel();
    }
    if (g.NavId == id && g.NavMoveDir == Dir_Right &&
        !is_open) // If there's something upcoming on the line we may want to
                  // give it the priority?
    {
      toggled = true;
      NavClearPreferredPosForAxis(Axis_X);
      NavMoveRequestCancel();
    }

    if (toggled) {
      is_open = !is_open;
      window->DC.StateStorage->SetInt(id, is_open);
      g.LastItemData.StatusFlags |= ItemStatusFlags_ToggledOpen;
    }
  }

  // In this branch, TreeNodeBehavior() cannot toggle the selection so this will
  // never trigger.
  if (selected != was_selected) //-V547
    g.LastItemData.StatusFlags |= ItemStatusFlags_ToggledSelection;

  // Render
  const U32 text_col = GetColorU32(Col_Text);
  NavHighlightFlags nav_highlight_flags = NavHighlightFlags_TypeThin;
  if (display_frame) {
    // Framed type
    const U32 bg_col = GetColorU32((held && hovered) ? Col_HeaderActive
                                   : hovered         ? Col_HeaderHovered
                                                     : Col_Header);
    RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, true, style.FrameRounding);
    RenderNavHighlight(frame_bb, id, nav_highlight_flags);
    if (flags & TreeNodeFlags_Bullet)
      RenderBullet(window->DrawList,
                   Vec2(text_pos.x - text_offset_x * 0.60f,
                        text_pos.y + g.FontSize * 0.5f),
                   text_col);
    else if (!is_leaf)
      RenderArrow(
          window->DrawList,
          Vec2(text_pos.x - text_offset_x + padding.x, text_pos.y), text_col,
          is_open
              ? ((flags & TreeNodeFlags_UpsideDownArrow) ? Dir_Up : Dir_Down)
              : Dir_Right,
          1.0f);
    else // Leaf without bullet, left-adjusted text
      text_pos.x -= text_offset_x - padding.x;
    if (flags & TreeNodeFlags_ClipLabelForTrailingButton)
      frame_bb.Max.x -= g.FontSize + style.FramePadding.x;

    if (g.LogEnabled)
      LogSetNextTextDecoration("###", "###");
  } else {
    // Unframed typed for tree nodes
    if (hovered || selected) {
      const U32 bg_col = GetColorU32((held && hovered) ? Col_HeaderActive
                                     : hovered         ? Col_HeaderHovered
                                                       : Col_Header);
      RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, false);
    }
    RenderNavHighlight(frame_bb, id, nav_highlight_flags);
    if (flags & TreeNodeFlags_Bullet)
      RenderBullet(window->DrawList,
                   Vec2(text_pos.x - text_offset_x * 0.5f,
                        text_pos.y + g.FontSize * 0.5f),
                   text_col);
    else if (!is_leaf)
      RenderArrow(window->DrawList,
                  Vec2(text_pos.x - text_offset_x + padding.x,
                       text_pos.y + g.FontSize * 0.15f),
                  text_col,
                  is_open ? ((flags & TreeNodeFlags_UpsideDownArrow) ? Dir_Up
                                                                     : Dir_Down)
                          : Dir_Right,
                  0.70f);
    if (g.LogEnabled)
      LogSetNextTextDecoration(">", NULL);
  }

  if (span_all_columns)
    TablePopBackgroundChannel();

  // Label
  if (display_frame)
    RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
  else
    RenderText(text_pos, label, label_end, false);

  if (is_open && !(flags & TreeNodeFlags_NoTreePushOnOpen))
    TreePushOverrideID(id);
  GUI_TEST_ENGINE_ITEM_INFO(id, label,
                            g.LastItemData.StatusFlags |
                                (is_leaf ? 0 : ItemStatusFlags_Openable) |
                                (is_open ? ItemStatusFlags_Opened : 0));
  return is_open;
}

inline void Gui::TreePush(const char *str_id) {
  Window *window = GetCurrentWindow();
  Indent();
  window->DC.TreeDepth++;
  PushID(str_id);
}

inline void Gui::TreePush(const void *ptr_id) {
  Window *window = GetCurrentWindow();
  Indent();
  window->DC.TreeDepth++;
  PushID(ptr_id);
}

inline void Gui::TreePop() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  Unindent();

  window->DC.TreeDepth--;
  U32 tree_depth_mask = (1 << window->DC.TreeDepth);

  // Handle Left arrow to move to parent tree node (when
  // TreeNodeFlags_NavLeftJumpsBackHere is enabled)
  if (window->DC.TreeJumpToParentOnPopMask &
      tree_depth_mask) // Only set during request
  {
    NavTreeNodeData *nav_tree_node_data = &g.NavTreeNodeStack.back();
    GUI_ASSERT(nav_tree_node_data->ID == window->IDStack.back());
    if (g.NavIdIsAlive && g.NavMoveDir == Dir_Left && g.NavWindow == window &&
        NavMoveRequestButNoResultYet())
      NavMoveRequestResolveWithPastTreeNode(&g.NavMoveResultLocal,
                                            nav_tree_node_data);
    g.NavTreeNodeStack.pop_back();
  }
  window->DC.TreeJumpToParentOnPopMask &= tree_depth_mask - 1;

  GUI_ASSERT(window->IDStack.Size >
             1); // There should always be 1 element in the IDStack (pushed
                 // during window creation). If this triggers you called
                 // TreePop/PopID too much.
  PopID();
}

// Horizontal distance preceding label when using TreeNode() or Bullet()
inline float Gui::GetTreeNodeToLabelSpacing() {
  Context &g = *GGui;
  return g.FontSize + (g.Style.FramePadding.x * 2.0f);
}

// Set next TreeNode/CollapsingHeader open state.
inline void Gui::SetNextItemOpen(bool is_open, Cond cond) {
  Context &g = *GGui;
  if (g.CurrentWindow->SkipItems)
    return;
  g.NextItemData.Flags |= NextItemDataFlags_HasOpen;
  g.NextItemData.OpenVal = is_open;
  g.NextItemData.OpenCond = cond ? cond : Cond_Always;
}

// CollapsingHeader returns true when opened but do not indent nor push into the
// ID stack (because of the TreeNodeFlags_NoTreePushOnOpen flag). This is
// basically the same as calling TreeNodeEx(label,
// TreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen
// flag if you want behavior closer to normal TreeNode().
inline bool Gui::CollapsingHeader(const char *label, TreeNodeFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  return TreeNodeBehavior(window->GetID(label),
                          flags | TreeNodeFlags_CollapsingHeader, label);
}

// p_visible == NULL                        : regular collapsing header
// p_visible != NULL && *p_visible == true  : show a small close button on the
// corner of the header, clicking the button will set *p_visible = false
// p_visible != NULL && *p_visible == false : do not show the header at all
// Do not mistake this with the Open state of the header itself, which you can
// adjust with SetNextItemOpen() or TreeNodeFlags_DefaultOpen.
inline bool Gui::CollapsingHeader(const char *label, bool *p_visible,
                                  TreeNodeFlags flags) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  if (p_visible && !*p_visible)
    return false;

  ID id = window->GetID(label);
  flags |= TreeNodeFlags_CollapsingHeader;
  if (p_visible)
    flags |= TreeNodeFlags_AllowOverlap |
             (TreeNodeFlags)TreeNodeFlags_ClipLabelForTrailingButton;
  bool is_open = TreeNodeBehavior(id, flags, label);
  if (p_visible != NULL) {
    // Create a small overlapping close button
    // FIXME: We can evolve this into user accessible helpers to add extra
    // buttons on title bars, headers, etc.
    // FIXME: CloseButton can overlap into text, need find a way to clip the
    // text somehow.
    Context &g = *GGui;
    LastItemData last_item_backup = g.LastItemData;
    float button_size = g.FontSize;
    float button_x =
        Max(g.LastItemData.Rect.Min.x,
            g.LastItemData.Rect.Max.x - g.Style.FramePadding.x - button_size);
    float button_y = g.LastItemData.Rect.Min.y + g.Style.FramePadding.y;
    ID close_button_id = GetIDWithSeed("#CLOSE", NULL, id);
    if (CloseButton(close_button_id, Vec2(button_x, button_y)))
      *p_visible = false;
    g.LastItemData = last_item_backup;
  }

  return is_open;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Selectable
//-------------------------------------------------------------------------
// - Selectable()
//-------------------------------------------------------------------------

// Tip: pass a non-visible label (e.g. "##hello") then you can use the space to
// draw other text or image. But you need to make sure the ID is unique, e.g.
// enclose calls in PushID/PopID or use ##unique_id. With this scheme,
// SelectableFlags_SpanAllColumns and SelectableFlags_AllowOverlap are
// also frequently used flags.
// FIXME: Selectable() with (size.x == 0.0f) and (SelectableTextAlign.x > 0.0f)
// followed by SameLine() is currently not supported.
inline bool Gui::Selectable(const char *label, bool selected,
                            SelectableFlags flags, const Vec2 &size_arg) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  const Style &style = g.Style;

  // Submit label or explicit size to ItemSize(), whereas ItemAdd() will submit
  // a larger/spanning rectangle.
  ID id = window->GetID(label);
  Vec2 label_size = CalcTextSize(label, NULL, true);
  Vec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x,
            size_arg.y != 0.0f ? size_arg.y : label_size.y);
  Vec2 pos = window->DC.CursorPos;
  pos.y += window->DC.CurrLineTextBaseOffset;
  ItemSize(size, 0.0f);

  // Fill horizontal space
  // We don't support (size < 0.0f) in Selectable() because the ItemSpacing
  // extension would make explicitly right-aligned sizes not visibly match other
  // widgets.
  const bool span_all_columns = (flags & SelectableFlags_SpanAllColumns) != 0;
  const float min_x = span_all_columns ? window->ParentWorkRect.Min.x : pos.x;
  const float max_x =
      span_all_columns ? window->ParentWorkRect.Max.x : window->WorkRect.Max.x;
  if (size_arg.x == 0.0f || (flags & SelectableFlags_SpanAvailWidth))
    size.x = Max(label_size.x, max_x - min_x);

  // Text stays at the submission position, but bounding box may be extended on
  // both sides
  const Vec2 text_min = pos;
  const Vec2 text_max(min_x + size.x, pos.y + size.y);

  // Selectables are meant to be tightly packed together with no click-gap, so
  // we extend their box to cover spacing between selectable.
  Rect bb(min_x, pos.y, text_max.x, text_max.y);
  if ((flags & SelectableFlags_NoPadWithHalfSpacing) == 0) {
    const float spacing_x = span_all_columns ? 0.0f : style.ItemSpacing.x;
    const float spacing_y = style.ItemSpacing.y;
    const float spacing_L = GUI_TRUNC(spacing_x * 0.50f);
    const float spacing_U = GUI_TRUNC(spacing_y * 0.50f);
    bb.Min.x -= spacing_L;
    bb.Min.y -= spacing_U;
    bb.Max.x += (spacing_x - spacing_L);
    bb.Max.y += (spacing_y - spacing_U);
  }
  // if (g.IO.KeyCtrl) { GetForegroundDrawList()->AddRect(bb.Min, bb.Max,
  // GUI_COL32(0, 255, 0, 255)); }

  // Modify ClipRect for the ItemAdd(), faster than doing a
  // PushColumnsBackground/PushTableBackgroundChannel for every Selectable..
  const float backup_clip_rect_min_x = window->ClipRect.Min.x;
  const float backup_clip_rect_max_x = window->ClipRect.Max.x;
  if (span_all_columns) {
    window->ClipRect.Min.x = window->ParentWorkRect.Min.x;
    window->ClipRect.Max.x = window->ParentWorkRect.Max.x;
  }

  const bool disabled_item = (flags & SelectableFlags_Disabled) != 0;
  const bool item_add = ItemAdd(
      bb, id, NULL, disabled_item ? ItemFlags_Disabled : ItemFlags_None);
  if (span_all_columns) {
    window->ClipRect.Min.x = backup_clip_rect_min_x;
    window->ClipRect.Max.x = backup_clip_rect_max_x;
  }

  if (!item_add)
    return false;

  const bool disabled_global = (g.CurrentItemFlags & ItemFlags_Disabled) != 0;
  if (disabled_item && !disabled_global) // Only testing this as an optimization
    BeginDisabled();

  // FIXME: We can standardize the behavior of those two, we could also keep the
  // fast path of override ClipRect + full push on render only, which would be
  // advantageous since most selectable are not selected.
  if (span_all_columns) {
    if (g.CurrentTable)
      TablePushBackgroundChannel();
    else if (window->DC.CurrentColumns)
      PushColumnsBackground();
    g.LastItemData.StatusFlags |= ItemStatusFlags_HasClipRect;
    g.LastItemData.ClipRect = window->ClipRect;
  }

  // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu
  // then drag to browse child entries
  ButtonFlags button_flags = 0;
  if (flags & SelectableFlags_NoHoldingActiveID) {
    button_flags |= ButtonFlags_NoHoldingActiveId;
  }
  if (flags & SelectableFlags_NoSetKeyOwner) {
    button_flags |= ButtonFlags_NoSetKeyOwner;
  }
  if (flags & SelectableFlags_SelectOnClick) {
    button_flags |= ButtonFlags_PressedOnClick;
  }
  if (flags & SelectableFlags_SelectOnRelease) {
    button_flags |= ButtonFlags_PressedOnRelease;
  }
  if (flags & SelectableFlags_AllowDoubleClick) {
    button_flags |=
        ButtonFlags_PressedOnClickRelease | ButtonFlags_PressedOnDoubleClick;
  }
  if ((flags & SelectableFlags_AllowOverlap) ||
      (g.LastItemData.InFlags & ItemFlags_AllowOverlap)) {
    button_flags |= ButtonFlags_AllowOverlap;
  }

  const bool was_selected = selected;
  bool hovered, held;
  bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);

  // Auto-select when moved into
  // - This will be more fully fleshed in the range-select branch
  // - This is not exposed as it won't nicely work with some user side handling
  // of shift/control
  // - We cannot do 'if (g.NavJustMovedToId != id) { selected = false; pressed =
  // was_selected; }' for two reasons
  //   - (1) it would require focus scope to be set, need exposing
  //   PushFocusScope() or equivalent (e.g. BeginSelection() calling
  //   PushFocusScope())
  //   - (2) usage will fail with clipped items
  //   The multi-select API aim to fix those issues, e.g. may be replaced with a
  //   BeginSelection() API.
  if ((flags & SelectableFlags_SelectOnNav) && g.NavJustMovedToId != 0 &&
      g.NavJustMovedToFocusScopeId == g.CurrentFocusScopeId)
    if (g.NavJustMovedToId == id)
      selected = pressed = true;

  // Update NavId when clicking or when Hovering (this doesn't happen on most
  // widgets), so navigation can be resumed with gamepad/keyboard
  if (pressed || (hovered && (flags & SelectableFlags_SetNavIdOnHover))) {
    if (!g.NavDisableMouseHover && g.NavWindow == window &&
        g.NavLayer == window->DC.NavLayerCurrent) {
      SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId,
               WindowRectAbsToRel(window, bb)); // (bb == NavRect)
      g.NavDisableHighlight = true;
    }
  }
  if (pressed)
    MarkItemEdited(id);

  // In this branch, Selectable() cannot toggle the selection so this will never
  // trigger.
  if (selected != was_selected) //-V547
    g.LastItemData.StatusFlags |= ItemStatusFlags_ToggledSelection;

  // Render
  if (hovered || selected) {
    const U32 col = GetColorU32((held && hovered) ? Col_HeaderActive
                                : hovered         ? Col_HeaderHovered
                                                  : Col_Header);
    RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
  }
  if (g.NavId == id)
    RenderNavHighlight(
        bb, id, NavHighlightFlags_TypeThin | NavHighlightFlags_NoRounding);

  if (span_all_columns) {
    if (g.CurrentTable)
      TablePopBackgroundChannel();
    else if (window->DC.CurrentColumns)
      PopColumnsBackground();
  }

  RenderTextClipped(text_min, text_max, label, NULL, &label_size,
                    style.SelectableTextAlign, &bb);

  // Automatically close popups
  if (pressed && (window->Flags & WindowFlags_Popup) &&
      !(flags & SelectableFlags_DontClosePopups) &&
      !(g.LastItemData.InFlags & ItemFlags_SelectableDontClosePopup))
    CloseCurrentPopup();

  if (disabled_item && !disabled_global)
    EndDisabled();

  GUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
  return pressed; //-V1020
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Typing-Select support
//-------------------------------------------------------------------------

// [Experimental] Currently not exposed in public API.
// Consume character inputs and return search request, if any.
// This would typically only be called on the focused window or location you
// want to grab inputs for, e.g.
//   if (Gui::IsWindowFocused(...))
//       if (TypingSelectRequest* req = Gui::GetTypingSelectRequest())
//           focus_idx = Gui::TypingSelectFindMatch(req, my_items.size(),
//           [](void*, int n) { return my_items[n]->Name; }, &my_items, -1);
// However the code is written in a way where calling it from multiple locations
// is safe (e.g. to obtain buffer).
inline TypingSelectRequest *
Gui::GetTypingSelectRequest(TypingSelectFlags flags) {
  Context &g = *GGui;
  TypingSelectState *data = &g.TypingSelectState;
  TypingSelectRequest *out_request = &data->Request;

  // Clear buffer
  const float TYPING_SELECT_RESET_TIMER =
      1.80f; // FIXME: Potentially move to IO config.
  const int TYPING_SELECT_SINGLE_CHAR_COUNT_FOR_LOCK =
      4; // Lock single char matching when repeating same char 4 times
  if (data->SearchBuffer[0] != 0) {
    bool clear_buffer = false;
    clear_buffer |= (g.NavFocusScopeId != data->FocusScope);
    clear_buffer |=
        (data->LastRequestTime + TYPING_SELECT_RESET_TIMER < g.Time);
    clear_buffer |= g.NavAnyRequest;
    clear_buffer |= g.ActiveId != 0 &&
                    g.NavActivateId ==
                        0; // Allow temporary SPACE activation to not interfere
    clear_buffer |= IsKeyPressed(Key_Escape) || IsKeyPressed(Key_Enter);
    clear_buffer |= IsKeyPressed(Key_Backspace) &&
                    (flags & TypingSelectFlags_AllowBackspace) == 0;
    // if (clear_buffer) { GUI_DEBUG_LOG("GetTypingSelectRequest(): Clear
    // SearchBuffer.\n"); }
    if (clear_buffer)
      data->Clear();
  }

  // Append to buffer
  const int buffer_max_len = GUI_ARRAYSIZE(data->SearchBuffer) - 1;
  int buffer_len = (int)strlen(data->SearchBuffer);
  bool select_request = false;
  for (Wchar w : g.IO.InputQueueCharacters) {
    const int w_len = TextCountUtf8BytesFromStr(&w, &w + 1);
    if (w < 32 || (buffer_len == 0 && CharIsBlankW(w)) ||
        (buffer_len + w_len > buffer_max_len)) // Ignore leading blanks
      continue;
    char w_buf[5];
    TextCharToUtf8(w_buf, (unsigned int)w);
    if (data->SingleCharModeLock && w_len == out_request->SingleCharSize &&
        memcmp(w_buf, data->SearchBuffer, w_len) == 0) {
      select_request = true; // Same character: don't need to append to buffer.
      continue;
    }
    if (data->SingleCharModeLock) {
      data->Clear(); // Different character: clear
      buffer_len = 0;
    }
    memcpy(data->SearchBuffer + buffer_len, w_buf, w_len + 1); // Append
    buffer_len += w_len;
    select_request = true;
  }
  g.IO.InputQueueCharacters.resize(0);

  // Handle backspace
  if ((flags & TypingSelectFlags_AllowBackspace) &&
      IsKeyPressed(Key_Backspace, 0, InputFlags_Repeat)) {
    char *p = (char *)(void *)TextFindPreviousUtf8Codepoint(
        data->SearchBuffer, data->SearchBuffer + buffer_len);
    *p = 0;
    buffer_len = (int)(p - data->SearchBuffer);
  }

  // Return request if any
  if (buffer_len == 0)
    return NULL;
  if (select_request) {
    data->FocusScope = g.NavFocusScopeId;
    data->LastRequestFrame = g.FrameCount;
    data->LastRequestTime = (float)g.Time;
  }
  out_request->Flags = flags;
  out_request->SearchBufferLen = buffer_len;
  out_request->SearchBuffer = data->SearchBuffer;
  out_request->SelectRequest = (data->LastRequestFrame == g.FrameCount);
  out_request->SingleCharMode = false;
  out_request->SingleCharSize = 0;

  // Calculate if buffer contains the same character repeated.
  // - This can be used to implement a special search mode on first character.
  // - Performed on UTF-8 codepoint for correctness.
  // - SingleCharMode is always set for first input character, because it
  // usually leads to a "next".
  if (flags & TypingSelectFlags_AllowSingleCharMode) {
    const char *buf_begin = out_request->SearchBuffer;
    const char *buf_end =
        out_request->SearchBuffer + out_request->SearchBufferLen;
    const int c0_len = TextCountUtf8BytesFromChar(buf_begin, buf_end);
    const char *p = buf_begin + c0_len;
    for (; p < buf_end; p += c0_len)
      if (memcmp(buf_begin, p, (size_t)c0_len) != 0)
        break;
    const int single_char_count =
        (p == buf_end) ? (out_request->SearchBufferLen / c0_len) : 0;
    out_request->SingleCharMode =
        (single_char_count > 0 || data->SingleCharModeLock);
    out_request->SingleCharSize = (S8)c0_len;
    data->SingleCharModeLock |=
        (single_char_count >=
         TYPING_SELECT_SINGLE_CHAR_COUNT_FOR_LOCK); // From now on we stop
                                                    // search matching to lock
                                                    // to single char mode.
  }

  return out_request;
}

static int Strimatchlen(const char *s1, const char *s1_end, const char *s2) {
  int match_len = 0;
  while (s1 < s1_end && ToUpper(*s1++) == ToUpper(*s2++))
    match_len++;
  return match_len;
}

// Default handler for finding a result for typing-select. You may implement
// your own. You might want to display a tooltip to visualize the current
// request SearchBuffer When SingleCharMode is set:
// - it is better to NOT display a tooltip of other on-screen display indicator.
// - the index of the currently focused item is required.
//   if your SetNextItemSelectionData() values are indices, you can obtain it
//   from MultiSelectIO::NavIdItem, otherwise from
//   g.NavLastValidSelectionUserData.
inline int Gui::TypingSelectFindMatch(TypingSelectRequest *req, int items_count,
                                      const char *(*get_item_name_func)(void *,
                                                                        int),
                                      void *user_data, int nav_item_idx) {
  if (req == NULL ||
      req->SelectRequest == false) // Support NULL parameter so both calls can
                                   // be done from same spot.
    return -1;
  int idx = -1;
  if (req->SingleCharMode &&
      (req->Flags & TypingSelectFlags_AllowSingleCharMode))
    idx = TypingSelectFindNextSingleCharMatch(
        req, items_count, get_item_name_func, user_data, nav_item_idx);
  else
    idx = TypingSelectFindBestLeadingMatch(req, items_count, get_item_name_func,
                                           user_data);
  if (idx != -1)
    NavRestoreHighlightAfterMove();
  return idx;
}

// Special handling when a single character is repeated: perform search on a
// single letter and goes to next.
inline int Gui::TypingSelectFindNextSingleCharMatch(
    TypingSelectRequest *req, int items_count,
    const char *(*get_item_name_func)(void *, int), void *user_data,
    int nav_item_idx) {
  // FIXME: Assume selection user data is index. Would be extremely practical.
  // if (nav_item_idx == -1)
  //    nav_item_idx = (int)g.NavLastValidSelectionUserData;

  int first_match_idx = -1;
  bool return_next_match = false;
  for (int idx = 0; idx < items_count; idx++) {
    const char *item_name = get_item_name_func(user_data, idx);
    if (Strimatchlen(req->SearchBuffer, req->SearchBuffer + req->SingleCharSize,
                     item_name) < req->SingleCharSize)
      continue;
    if (return_next_match) // Return next matching item after current item.
      return idx;
    if (first_match_idx == -1 &&
        nav_item_idx == -1) // Return first match immediately if we don't have a
                            // nav_item_idx value.
      return idx;
    if (first_match_idx == -1) // Record first match for wrapping.
      first_match_idx = idx;
    if (nav_item_idx == idx) // Record that we encountering nav_item so we can
                             // return next match.
      return_next_match = true;
  }
  return first_match_idx; // First result
}

inline int Gui::TypingSelectFindBestLeadingMatch(
    TypingSelectRequest *req, int items_count,
    const char *(*get_item_name_func)(void *, int), void *user_data) {
  int longest_match_idx = -1;
  int longest_match_len = 0;
  for (int idx = 0; idx < items_count; idx++) {
    const char *item_name = get_item_name_func(user_data, idx);
    const int match_len = Strimatchlen(
        req->SearchBuffer, req->SearchBuffer + req->SearchBufferLen, item_name);
    if (match_len <= longest_match_len)
      continue;
    longest_match_idx = idx;
    longest_match_len = match_len;
    if (match_len == req->SearchBufferLen)
      break;
  }
  return longest_match_idx;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Multi-Select support
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
// [SECTION] Widgets: ListBox
//-------------------------------------------------------------------------
// - BeginListBox()
// - EndListBox()
// - ListBox()
//-------------------------------------------------------------------------

// This is essentially a thin wrapper to using BeginChild/EndChild with the
// ChildFlags_FrameStyle flag for stylistic changes + displaying a label.
// Tip: To have a list filling the entire window width, use size.x = -FLT_MIN
// and pass an non-visible label e.g. "##empty" Tip: If your vertical size is
// calculated from an item count (e.g. 10 * item_height) consider adding a
// fractional part to facilitate seeing scrolling boundaries (e.g. 10.25 *
// item_height).
inline bool Gui::BeginListBox(const char *label, const Vec2 &size_arg) {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  const Style &style = g.Style;
  const ID id = GetID(label);
  const Vec2 label_size = CalcTextSize(label, NULL, true);

  // Size default to hold ~7.25 items.
  // Fractional number of items helps seeing that we can scroll down/up without
  // looking at scrollbar.
  Vec2 size = Trunc(CalcItemSize(size_arg, CalcItemWidth(),
                                 GetTextLineHeightWithSpacing() * 7.25f +
                                     style.FramePadding.y * 2.0f));
  Vec2 frame_size = Vec2(size.x, Max(size.y, label_size.y));
  Rect frame_bb(window->DC.CursorPos, Add(window->DC.CursorPos, frame_size));
  Rect bb(frame_bb.Min,
          Add(frame_bb.Max,
              Vec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x
                                       : 0.0f,
                   0.0f)));
  g.NextItemData.ClearFlags();

  if (!IsRectVisible(bb.Min, bb.Max)) {
    ItemSize(bb.GetSize(), style.FramePadding.y);
    ItemAdd(bb, 0, &frame_bb);
    g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume
                                   // those values
    return false;
  }

  // FIXME-OPT: We could omit the BeginGroup() if label_size.x == 0.0f but would
  // need to omit the EndGroup() as well.
  BeginGroup();
  if (label_size.x > 0.0f) {
    Vec2 label_pos = Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x,
                          frame_bb.Min.y + style.FramePadding.y);
    RenderText(label_pos, label);
    window->DC.CursorMaxPos =
        Max(window->DC.CursorMaxPos, Add(label_pos, label_size));
  }

  BeginChild(id, frame_bb.GetSize(), ChildFlags_FrameStyle);
  return true;
}

inline void Gui::EndListBox() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_ASSERT(
      (window->Flags & WindowFlags_ChildWindow) &&
      "Mismatched BeginListBox/EndListBox calls. Did you test the return "
      "value of BeginListBox?");
  GUI_UNUSED(window);

  EndChild();
  EndGroup(); // This is only required to be able to do IsItemXXX query on the
              // whole ListBox including label
}

inline bool Gui::ListBox(const char *label, int *current_item,
                         const char *const items[], int items_count,
                         int height_items) {
  const bool value_changed = ListBox(label, current_item, Items_ArrayGetter,
                                     (void *)items, items_count, height_items);
  return value_changed;
}

// This is merely a helper around BeginListBox(), EndListBox().
// Considering using those directly to submit custom data or store selection
// differently.
inline bool Gui::ListBox(const char *label, int *current_item,
                         const char *(*getter)(void *user_data, int idx),
                         void *user_data, int items_count,
                         int height_in_items) {
  Context &g = *GGui;

  // Calculate size from "height_in_items"
  if (height_in_items < 0)
    height_in_items = Min(items_count, 7);
  float height_in_items_f = height_in_items + 0.25f;
  Vec2 size(0.0f, Trunc(GetTextLineHeightWithSpacing() * height_in_items_f +
                        g.Style.FramePadding.y * 2.0f));

  if (!BeginListBox(label, size))
    return false;

  // Assume all items have even height (= 1 line of text). If you need items of
  // different height, you can create a custom version of ListBox() in your code
  // without using the clipper.
  bool value_changed = false;
  ListClipper clipper;
  clipper.Begin(
      items_count,
      GetTextLineHeightWithSpacing()); // We know exactly our line height here
                                       // so we pass it as a minor optimization,
                                       // but generally you don't need to.
  while (clipper.Step())
    for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++) {
      const char *item_text = getter(user_data, i);
      if (item_text == NULL)
        item_text = "*Unknown item*";

      PushID(i);
      const bool item_selected = (i == *current_item);
      if (Selectable(item_text, item_selected)) {
        *current_item = i;
        value_changed = true;
      }
      if (item_selected)
        SetItemDefaultFocus();
      PopID();
    }
  EndListBox();

  if (value_changed)
    MarkItemEdited(g.LastItemData.ID);

  return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: PlotLines, PlotHistogram
//-------------------------------------------------------------------------
// - PlotEx() [Internal]
// - PlotLines()
// - PlotHistogram()
//-------------------------------------------------------------------------
// Plot/Graph widgets are not very good.
// Consider writing your own, or using a third-party one, see:
// - Plot https://github.com/epezent/implot
// - others https://github.com/ocornut/imgui/wiki/Useful-Extensions
//-------------------------------------------------------------------------

inline int Gui::PlotEx(PlotType plot_type, const char *label,
                       float (*values_getter)(void *data, int idx), void *data,
                       int values_count, int values_offset,
                       const char *overlay_text, float scale_min,
                       float scale_max, const Vec2 &size_arg) {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return -1;

  const Style &style = g.Style;
  const ID id = window->GetID(label);

  const Vec2 label_size = CalcTextSize(label, NULL, true);
  const Vec2 frame_size = CalcItemSize(
      size_arg, CalcItemWidth(), label_size.y + style.FramePadding.y * 2.0f);

  const Rect frame_bb(window->DC.CursorPos,
                      Add(window->DC.CursorPos, frame_size));
  const Rect inner_bb(Add(frame_bb.Min, style.FramePadding),
                      Subtract(frame_bb.Max, style.FramePadding));
  const Rect total_bb(
      frame_bb.Min,
      Add(frame_bb.Max,
          Vec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x
                                   : 0.0f,
               0)));
  ItemSize(total_bb, style.FramePadding.y);
  if (!ItemAdd(total_bb, 0, &frame_bb))
    return -1;
  const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);

  // Determine scale from values if not specified
  if (scale_min == FLT_MAX || scale_max == FLT_MAX) {
    float v_min = FLT_MAX;
    float v_max = -FLT_MAX;
    for (int i = 0; i < values_count; i++) {
      const float v = values_getter(data, i);
      if (v != v) // Ignore NaN values
        continue;
      v_min = Min(v_min, v);
      v_max = Max(v_max, v);
    }
    if (scale_min == FLT_MAX)
      scale_min = v_min;
    if (scale_max == FLT_MAX)
      scale_max = v_max;
  }

  RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(Col_FrameBg), true,
              style.FrameRounding);

  const int values_count_min = (plot_type == PlotType_Lines) ? 2 : 1;
  int idx_hovered = -1;
  if (values_count >= values_count_min) {
    int res_w = Min((int)frame_size.x, values_count) +
                ((plot_type == PlotType_Lines) ? -1 : 0);
    int item_count = values_count + ((plot_type == PlotType_Lines) ? -1 : 0);

    // Tooltip on hover
    if (hovered && inner_bb.Contains(g.IO.MousePos)) {
      const float t = Clamp((g.IO.MousePos.x - inner_bb.Min.x) /
                                (inner_bb.Max.x - inner_bb.Min.x),
                            0.0f, 0.9999f);
      const int v_idx = (int)(t * item_count);
      GUI_ASSERT(v_idx >= 0 && v_idx < values_count);

      const float v0 =
          values_getter(data, (v_idx + values_offset) % values_count);
      const float v1 =
          values_getter(data, (v_idx + 1 + values_offset) % values_count);
      if (plot_type == PlotType_Lines)
        SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx + 1, v1);
      else if (plot_type == PlotType_Histogram)
        SetTooltip("%d: %8.4g", v_idx, v0);
      idx_hovered = v_idx;
    }

    const float t_step = 1.0f / (float)res_w;
    const float inv_scale =
        (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));

    float v0 = values_getter(data, (0 + values_offset) % values_count);
    float t0 = 0.0f;
    Vec2 tp0 =
        Vec2(t0, 1.0f - Saturate((v0 - scale_min) *
                                 inv_scale)); // Point in the normalized space
                                              // of our target rectangle
    float histogram_zero_line_t =
        (scale_min * scale_max < 0.0f)
            ? (1 + scale_min * inv_scale)
            : (scale_min < 0.0f ? 0.0f
                                : 1.0f); // Where does the zero line stands

    const U32 col_base = GetColorU32(
        (plot_type == PlotType_Lines) ? Col_PlotLines : Col_PlotHistogram);
    const U32 col_hovered =
        GetColorU32((plot_type == PlotType_Lines) ? Col_PlotLinesHovered
                                                  : Col_PlotHistogramHovered);

    for (int n = 0; n < res_w; n++) {
      const float t1 = t0 + t_step;
      const int v1_idx = (int)(t0 * item_count + 0.5f);
      GUI_ASSERT(v1_idx >= 0 && v1_idx < values_count);
      const float v1 =
          values_getter(data, (v1_idx + values_offset + 1) % values_count);
      const Vec2 tp1 = Vec2(t1, 1.0f - Saturate((v1 - scale_min) * inv_scale));

      // NB: Draw calls are merged together by the DrawList system. Still, we
      // should render our batch are lower level to save a bit of CPU.
      Vec2 pos0 = Lerp(inner_bb.Min, inner_bb.Max, tp0);
      Vec2 pos1 = Lerp(inner_bb.Min, inner_bb.Max,
                       (plot_type == PlotType_Lines)
                           ? tp1
                           : Vec2(tp1.x, histogram_zero_line_t));
      if (plot_type == PlotType_Lines) {
        window->DrawList->AddLine(
            pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base);
      } else if (plot_type == PlotType_Histogram) {
        if (pos1.x >= pos0.x + 2.0f)
          pos1.x -= 1.0f;
        window->DrawList->AddRectFilled(
            pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base);
      }

      t0 = t1;
      tp0 = tp1;
    }
  }

  // Text overlay
  if (overlay_text)
    RenderTextClipped(
        Vec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y),
        frame_bb.Max, overlay_text, NULL, NULL, Vec2(0.5f, 0.0f));

  if (label_size.x > 0.0f)
    RenderText(Vec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y),
               label);

  // Return hovered index or -1 if none are hovered.
  // This is currently not exposed in the public API because we need a larger
  // redesign of the whole thing, but in the short-term we are making it
  // available in PlotEx().
  return idx_hovered;
}

struct PlotArrayGetterData {
  const float *Values;
  int Stride;

  PlotArrayGetterData(const float *values, int stride) {
    Values = values;
    Stride = stride;
  }
};

static float Plot_ArrayGetter(void *data, int idx) {
  PlotArrayGetterData *plot_data = (PlotArrayGetterData *)data;
  const float v =
      *(const float *)(const void *)((const unsigned char *)plot_data->Values +
                                     (size_t)idx * plot_data->Stride);
  return v;
}

inline void Gui::PlotLines(const char *label, const float *values,
                           int values_count, int values_offset,
                           const char *overlay_text, float scale_min,
                           float scale_max, Vec2 graph_size, int stride) {
  PlotArrayGetterData data(values, stride);
  PlotEx(PlotType_Lines, label, &Plot_ArrayGetter, (void *)&data, values_count,
         values_offset, overlay_text, scale_min, scale_max, graph_size);
}

inline void Gui::PlotLines(const char *label,
                           float (*values_getter)(void *data, int idx),
                           void *data, int values_count, int values_offset,
                           const char *overlay_text, float scale_min,
                           float scale_max, Vec2 graph_size) {
  PlotEx(PlotType_Lines, label, values_getter, data, values_count,
         values_offset, overlay_text, scale_min, scale_max, graph_size);
}

inline void Gui::PlotHistogram(const char *label, const float *values,
                               int values_count, int values_offset,
                               const char *overlay_text, float scale_min,
                               float scale_max, Vec2 graph_size, int stride) {
  PlotArrayGetterData data(values, stride);
  PlotEx(PlotType_Histogram, label, &Plot_ArrayGetter, (void *)&data,
         values_count, values_offset, overlay_text, scale_min, scale_max,
         graph_size);
}

inline void Gui::PlotHistogram(const char *label,
                               float (*values_getter)(void *data, int idx),
                               void *data, int values_count, int values_offset,
                               const char *overlay_text, float scale_min,
                               float scale_max, Vec2 graph_size) {
  PlotEx(PlotType_Histogram, label, values_getter, data, values_count,
         values_offset, overlay_text, scale_min, scale_max, graph_size);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Value helpers
// Those is not very useful, legacy API.
//-------------------------------------------------------------------------
// - Value()
//-------------------------------------------------------------------------

inline void Gui::Value(const char *prefix, float v, const char *float_format) {
  if (float_format) {
    char fmt[64];
    FormatString(fmt, GUI_ARRAYSIZE(fmt), "%%s: %s", float_format);
    Text(fmt, prefix, v);
  } else {
    Text("%s: %.3f", prefix, v);
  }
}

//-------------------------------------------------------------------------
// [SECTION] MenuItem, BeginMenu, EndMenu, etc.
//-------------------------------------------------------------------------
// - MenuColumns [Internal]
// - BeginMenuBar()
// - EndMenuBar()
// - BeginMainMenuBar()
// - EndMainMenuBar()
// - BeginMenu()
// - EndMenu()
// - MenuItemEx() [Internal]
// - MenuItem()
//-------------------------------------------------------------------------

// Helpers for internal use
inline void MenuColumns::Update(float spacing, bool window_reappearing) {
  if (window_reappearing)
    memset(Widths, 0, sizeof(Widths));
  Spacing = (U16)spacing;
  CalcNextTotalWidth(true);
  memset(Widths, 0, sizeof(Widths));
  TotalWidth = NextTotalWidth;
  NextTotalWidth = 0;
}

// FIXME: Provided a rectangle perhaps e.g. a BeginMenuBarEx() could be used
// anywhere.. Currently the main responsibility of this function being to setup
// clip-rect + horizontal layout + menu navigation layer. Ideally we also want
// this to be responsible for claiming space out of the main window scrolling
// rectangle, in which case WindowFlags_MenuBar will become unnecessary.
// Then later the same system could be used for multiple menu-bars, scrollbars,
// side-bars.
inline bool Gui::BeginMenuBar() {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;
  if (!(window->Flags & WindowFlags_MenuBar))
    return false;

  GUI_ASSERT(!window->DC.MenuBarAppending);
  BeginGroup(); // Backup position on layer 0 // FIXME: Misleading to use a
                // group for that backup/restore
  PushID("##menubar");

  // We don't clip with current window clipping rectangle as it is already set
  // to the area below. However we clip with window full rect. We remove 1 worth
  // of rounding to Max.x to that text in long menus and small windows don't
  // tend to display over the lower-right rounded area, which looks particularly
  // glitchy.
  Rect bar_rect = window->MenuBarRect();
  Rect clip_rect(GUI_ROUND(bar_rect.Min.x + window->WindowBorderSize),
                 GUI_ROUND(bar_rect.Min.y + window->WindowBorderSize),
                 GUI_ROUND(Max(bar_rect.Min.x,
                               bar_rect.Max.x - Max(window->WindowRounding,
                                                    window->WindowBorderSize))),
                 GUI_ROUND(bar_rect.Max.y));
  clip_rect.ClipWith(window->OuterRectClipped);
  PushClipRect(clip_rect.Min, clip_rect.Max, false);

  // We overwrite CursorMaxPos because BeginGroup sets it to CursorPos
  // (essentially the .EmitItem hack in EndMenuBar() would need something
  // analogous here, maybe a BeginGroupEx() with flags).
  window->DC.CursorPos = window->DC.CursorMaxPos =
      Vec2(bar_rect.Min.x + window->DC.MenuBarOffset.x,
           bar_rect.Min.y + window->DC.MenuBarOffset.y);
  window->DC.LayoutType = LayoutType_Horizontal;
  window->DC.IsSameLine = false;
  window->DC.NavLayerCurrent = NavLayer_Menu;
  window->DC.MenuBarAppending = true;
  AlignTextToFramePadding();
  return true;
}

inline void Gui::EndMenuBar() {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return;
  Context &g = *GGui;

  // Nav: When a move request within one of our child menu failed, capture the
  // request to navigate among our siblings.
  if (NavMoveRequestButNoResultYet() &&
      (g.NavMoveDir == Dir_Left || g.NavMoveDir == Dir_Right) &&
      (g.NavWindow->Flags & WindowFlags_ChildMenu)) {
    // Try to find out if the request is for one of our child menu
    Window *nav_earliest_child = g.NavWindow;
    while (nav_earliest_child->ParentWindow &&
           (nav_earliest_child->ParentWindow->Flags & WindowFlags_ChildMenu))
      nav_earliest_child = nav_earliest_child->ParentWindow;
    if (nav_earliest_child->ParentWindow == window &&
        nav_earliest_child->DC.ParentLayoutType == LayoutType_Horizontal &&
        (g.NavMoveFlags & NavMoveFlags_Forwarded) == 0) {
      // To do so we claim focus back, restore NavId and then process the
      // movement request for yet another frame. This involve a one-frame delay
      // which isn't very problematic in this situation. We could remove it by
      // scoring in advance for multiple window (probably not worth bothering)
      const NavLayer layer = NavLayer_Menu;
      GUI_ASSERT(window->DC.NavLayersActiveMaskNext &
                 (1 << layer)); // Sanity check (FIXME: Seems unnecessary)
      FocusWindow(window);
      SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);
      g.NavDisableHighlight = true; // Hide highlight for the current frame so
                                    // we don't see the intermediary selection.
      g.NavDisableMouseHover = g.NavMousePosDirty = true;
      NavMoveRequestForward(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags,
                            g.NavMoveScrollFlags); // Repeat
    }
  }

  GUI_MSVC_WARNING_SUPPRESS(
      6011); // Static Analysis false positive "warning
             // C6011: Dereferencing NULL pointer 'window'"
  GUI_ASSERT(window->Flags & WindowFlags_MenuBar);
  GUI_ASSERT(window->DC.MenuBarAppending);
  PopClipRect();
  PopID();
  window->DC.MenuBarOffset.x =
      window->DC.CursorPos.x -
      window->Pos.x; // Save horizontal position so next append can reuse it.
                     // This is kinda equivalent to a per-layer CursorPos.

  // FIXME: Extremely confusing, cleanup by (a) working on WorkRect stack system
  // (b) not using a Group confusingly here.
  GroupData &group_data = g.GroupStack.back();
  group_data.EmitItem = false;
  Vec2 restore_cursor_max_pos = group_data.BackupCursorMaxPos;
  window->DC.IdealMaxPos.x =
      Max(window->DC.IdealMaxPos.x,
          window->DC.CursorMaxPos.x -
              window->Scroll
                  .x); // Convert ideal extents for scrolling layer equivalent.
  EndGroup(); // Restore position on layer 0 // FIXME: Misleading to use a group
              // for that backup/restore
  window->DC.LayoutType = LayoutType_Vertical;
  window->DC.IsSameLine = false;
  window->DC.NavLayerCurrent = NavLayer_Main;
  window->DC.MenuBarAppending = false;
  window->DC.CursorMaxPos = restore_cursor_max_pos;
}

// Important: calling order matters!
// FIXME: Somehow overlapping with docking tech.
// FIXME: The "rect-cut" aspect of this could be formalized into a lower-level
// helper (rect-cut: https://halt.software/dead-simple-layouts)
inline bool Gui::BeginViewportSideBar(const char *name, Viewport *viewport_p,
                                      Dir dir, float axis_size,
                                      WindowFlags window_flags) {
  GUI_ASSERT(dir != Dir_None);

  Window *bar_window = FindWindowByName(name);
  if (bar_window == NULL || bar_window->BeginCount == 0) {
    // Calculate and set window size/position
    ViewportP *viewport =
        (ViewportP *)(void *)(viewport_p ? viewport_p : GetMainViewport());
    Rect avail_rect = viewport->GetBuildWorkRect();
    Axis axis = (dir == Dir_Up || dir == Dir_Down) ? Axis_Y : Axis_X;
    Vec2 pos = avail_rect.Min;
    if (dir == Dir_Right || dir == Dir_Down)
      pos[axis] = avail_rect.Max[axis] - axis_size;
    Vec2 size = avail_rect.GetSize();
    size[axis] = axis_size;
    SetNextWindowPos(pos);
    SetNextWindowSize(size);

    // Report our size into work area (for next frame) using actual window size
    if (dir == Dir_Up || dir == Dir_Left)
      viewport->BuildWorkOffsetMin[axis] += axis_size;
    else if (dir == Dir_Down || dir == Dir_Right)
      viewport->BuildWorkOffsetMax[axis] -= axis_size;
  }

  window_flags |=
      WindowFlags_NoTitleBar | WindowFlags_NoResize | WindowFlags_NoMove;
  PushStyleVar(StyleVar_WindowRounding, 0.0f);
  PushStyleVar(StyleVar_WindowMinSize,
               Vec2(0, 0)); // Lift normal size constraint
  bool is_open = Begin(name, NULL, window_flags);
  PopStyleVar(2);

  return is_open;
}

inline bool Gui::BeginMainMenuBar() {
  Context &g = *GGui;
  ViewportP *viewport = (ViewportP *)(void *)GetMainViewport();

  // For the main menu bar, which cannot be moved, we honor
  // g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.
  // FIXME: This could be generalized as an opt-in way to clamp
  // window->DC.CursorStartPos to avoid SafeArea?
  // FIXME: Consider removing support for safe area down the line... it's messy.
  // Nowadays consoles have support for TV calibration in OS settings.
  g.NextWindowData.MenuBarOffsetMinVal = Vec2(
      g.Style.DisplaySafeAreaPadding.x,
      Max(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));
  WindowFlags window_flags = WindowFlags_NoScrollbar |
                             WindowFlags_NoSavedSettings | WindowFlags_MenuBar;
  float height = GetFrameHeight();
  bool is_open = BeginViewportSideBar("##MainMenuBar", viewport, Dir_Up, height,
                                      window_flags);
  g.NextWindowData.MenuBarOffsetMinVal = Vec2(0.0f, 0.0f);

  if (is_open)
    BeginMenuBar();
  else
    End();
  return is_open;
}

inline void Gui::EndMainMenuBar() {
  EndMenuBar();

  // When the user has left the menu layer (typically: closed menus through
  // activation of an item), we restore focus to the previous window
  // FIXME: With this strategy we won't be able to restore a NULL focus.
  Context &g = *GGui;
  if (g.CurrentWindow == g.NavWindow && g.NavLayer == NavLayer_Main &&
      !g.NavAnyRequest)
    FocusTopMostWindowUnderOne(g.NavWindow, NULL, NULL,
                               FocusRequestFlags_UnlessBelowModal |
                                   FocusRequestFlags_RestoreFocusedChild);

  End();
}

static bool IsRootOfOpenMenuSet() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if ((g.OpenPopupStack.Size <= g.BeginPopupStack.Size) ||
      (window->Flags & WindowFlags_ChildMenu))
    return false;

  // Initially we used 'upper_popup->OpenParentId == window->IDStack.back()' to
  // differentiate multiple menu sets from each others (e.g. inside menu bar vs
  // loose menu items) based on parent ID. This would however prevent the use of
  // e.g. PushID() user code submitting menus. Previously this worked between
  // popup and a first child menu because the first child menu always had the
  // _ChildWindow flag, making hovering on parent popup possible while first
  // child menu was focused - but this was generally a bug with other side
  // effects. Instead we don't treat Popup specifically (in order to
  // consistently support menu features in them), maybe the first child menu of
  // a Popup doesn't have the _ChildWindow flag, and we rely on this
  // IsRootOfOpenMenuSet() check to allow hovering between root window/popup and
  // first child menu. In the end, lack of ID check made it so we could no
  // longer differentiate between separate menu sets. To compensate for that, we
  // at least check parent window nav layer. This fixes the most common case of
  // menu opening on hover when moving between window content and menu bar.
  // Multiple different menu sets in same nav layer would still open on hover,
  // but that should be a lesser problem, because if such menus are close in
  // proximity in window content then it won't feel weird and if they are far
  // apart it likely won't be a problem anyone runs into.
  const PopupData *upper_popup = &g.OpenPopupStack[g.BeginPopupStack.Size];
  if (window->DC.NavLayerCurrent != upper_popup->ParentNavLayer)
    return false;
  return upper_popup->Window &&
         (upper_popup->Window->Flags & WindowFlags_ChildMenu) &&
         Gui::IsWindowChildOf(upper_popup->Window, window, true);
}

inline bool Gui::BeginMenuEx(const char *label, const char *icon,
                             bool enabled) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  const Style &style = g.Style;
  const ID id = window->GetID(label);
  bool menu_is_open = IsPopupOpen(id, PopupFlags_None);

  // Sub-menus are ChildWindow so that mouse can be hovering across them
  // (otherwise top-most popup menu would steal focus and not allow hovering on
  // parent menu) The first menu in a hierarchy isn't so hovering doesn't get
  // across (otherwise e.g. resizing borders with
  // ButtonFlags_FlattenChildren would react), but top-most BeginMenu()
  // will bypass that limitation.
  WindowFlags window_flags =
      WindowFlags_ChildMenu | WindowFlags_AlwaysAutoResize |
      WindowFlags_NoMove | WindowFlags_NoTitleBar |
      WindowFlags_NoSavedSettings | WindowFlags_NoNavFocus;
  if (window->Flags & WindowFlags_ChildMenu)
    window_flags |= WindowFlags_ChildWindow;

  // If a menu with same the ID was already submitted, we will append to it,
  // matching the behavior of Begin(). We are relying on a O(N) search - so O(N
  // log N) over the frame - which seems like the most efficient for the
  // expected small amount of BeginMenu() calls per frame. If somehow this is
  // ever becoming a problem we can switch to use e.g. Storage mapping key
  // to last frame used.
  if (g.MenusIdSubmittedThisFrame.contains(id)) {
    if (menu_is_open)
      menu_is_open = BeginPopupEx(
          id, window_flags); // menu_is_open can be 'false' when the popup is
                             // completely clipped (e.g. zero size display)
    else
      g.NextWindowData.ClearFlags(); // we behave like Begin() and need to
                                     // consume those values
    return menu_is_open;
  }

  // Tag menu as used. Next time BeginMenu() with same ID is called it will
  // append to existing menu
  g.MenusIdSubmittedThisFrame.push_back(id);

  Vec2 label_size = CalcTextSize(label, NULL, true);

  // Odd hack to allow hovering across menus of a same menu-set (otherwise we
  // wouldn't be able to hover parent without always being a Child window) This
  // is only done for items for the menu set and not the full parent window.
  const bool menuset_is_open = IsRootOfOpenMenuSet();
  if (menuset_is_open)
    PushItemFlag(ItemFlags_NoWindowHoverableCheck, true);

  // The reference position stored in popup_pos will be used by Begin() to find
  // a suitable position for the child menu, However the final position is going
  // to be different! It is chosen by FindBestWindowPosForPopup(). e.g. Menus
  // tend to overlap each other horizontally to amplify relative Z-ordering.
  Vec2 popup_pos, pos = window->DC.CursorPos;
  PushID(label);
  if (!enabled)
    BeginDisabled();
  const MenuColumns *offsets = &window->DC.MenuColumns;
  bool pressed;

  // We use SelectableFlags_NoSetKeyOwner to allow down on one menu item,
  // move, up on another.
  const SelectableFlags selectable_flags =
      SelectableFlags_NoHoldingActiveID | SelectableFlags_NoSetKeyOwner |
      SelectableFlags_SelectOnClick | SelectableFlags_DontClosePopups;
  if (window->DC.LayoutType == LayoutType_Horizontal) {
    // Menu inside an horizontal menu bar
    // Selectable extend their highlight by half ItemSpacing in each direction.
    // For ChildMenu, the popup position will be overwritten by the call to
    // FindBestWindowPosForPopup() in Begin()
    popup_pos = Vec2(pos.x - 1.0f - GUI_TRUNC(style.ItemSpacing.x * 0.5f),
                     pos.y - style.FramePadding.y + window->MenuBarHeight());
    window->DC.CursorPos.x += GUI_TRUNC(style.ItemSpacing.x * 0.5f);
    PushStyleVar(StyleVar_ItemSpacing,
                 Vec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));
    float w = label_size.x;
    Vec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel,
                  window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
    pressed =
        Selectable("", menu_is_open, selectable_flags, Vec2(w, label_size.y));
    RenderText(text_pos, label);
    PopStyleVar();
    window->DC.CursorPos.x += GUI_TRUNC(
        style.ItemSpacing.x *
        (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when
                         // Selectable() did a SameLine(). It would also work to
                         // call SameLine() ourselves after the PopStyleVar().
  } else {
    // Menu inside a regular/vertical menu
    // (In a typical menu window where all items are BeginMenu() or MenuItem()
    // calls, extra_w will always be 0.0f.
    //  Only when they are other items sticking out we're going to add spacing,
    //  yet only register minimum width into the layout system.
    popup_pos = Vec2(pos.x, pos.y - style.WindowPadding.y);
    float icon_w = (icon && icon[0]) ? CalcTextSize(icon, NULL).x : 0.0f;
    float checkmark_w = GUI_TRUNC(g.FontSize * 1.20f);
    float min_w = window->DC.MenuColumns.DeclColumns(
        icon_w, label_size.x, 0.0f, checkmark_w); // Feedback to next frame
    float extra_w = Max(0.0f, GetContentRegionAvail().x - min_w);
    Vec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel,
                  window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
    pressed = Selectable("", menu_is_open,
                         selectable_flags | SelectableFlags_SpanAvailWidth,
                         Vec2(min_w, label_size.y));
    RenderText(text_pos, label);
    if (icon_w > 0.0f)
      RenderText(Add(pos, Vec2(offsets->OffsetIcon, 0.0f)), icon);
    RenderArrow(
        window->DrawList,
        Add(pos,
            Vec2(offsets->OffsetMark + extra_w + g.FontSize * 0.30f, 0.0f)),
        GetColorU32(Col_Text), Dir_Right);
  }
  if (!enabled)
    EndDisabled();

  const bool hovered =
      (g.HoveredId == id) && enabled && !g.NavDisableMouseHover;
  if (menuset_is_open)
    PopItemFlag();

  bool want_open = false;
  bool want_close = false;
  if (window->DC.LayoutType ==
      LayoutType_Vertical) // (window->Flags &
                           // (WindowFlags_Popup|WindowFlags_ChildMenu))
  {
    // Close menu when not hovering it anymore unless we are moving roughly in
    // the direction of the menu Implement
    // http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to
    // avoid using timers, so menus feels more reactive.
    bool moving_toward_child_menu = false;
    PopupData *child_popup = (g.BeginPopupStack.Size < g.OpenPopupStack.Size)
                                 ? &g.OpenPopupStack[g.BeginPopupStack.Size]
                                 : NULL; // Popup candidate (testing below)
    Window *child_menu_window = (child_popup && child_popup->Window &&
                                 child_popup->Window->ParentWindow == window)
                                    ? child_popup->Window
                                    : NULL;
    if (g.HoveredWindow == window && child_menu_window != NULL) {
      const float ref_unit = g.FontSize; // FIXME-DPI
      const float child_dir =
          (window->Pos.x < child_menu_window->Pos.x) ? 1.0f : -1.0f;
      const Rect next_window_rect = child_menu_window->Rect();
      Vec2 ta = (Subtract(g.IO.MousePos, g.IO.MouseDelta));
      Vec2 tb = (child_dir > 0.0f) ? next_window_rect.GetTL()
                                   : next_window_rect.GetTR();
      Vec2 tc = (child_dir > 0.0f) ? next_window_rect.GetBL()
                                   : next_window_rect.GetBR();
      const float pad_farmost_h =
          Clamp(Fabs(ta.x - tb.x) * 0.30f, ref_unit * 0.5f,
                ref_unit * 2.5f); // Add a bit of extra slack.
      ta.x += child_dir * -0.5f;
      tb.x += child_dir * ref_unit;
      tc.x += child_dir * ref_unit;
      tb.y = ta.y +
             Max((tb.y - pad_farmost_h) - ta.y,
                 -ref_unit * 8.0f); // Triangle has maximum height to limit the
                                    // slope and the bias toward large sub-menus
      tc.y = ta.y + Min((tc.y + pad_farmost_h) - ta.y, +ref_unit * 8.0f);
      moving_toward_child_menu =
          TriangleContainsPoint(ta, tb, tc, g.IO.MousePos);
      // GetForegroundDrawList()->AddTriangleFilled(ta, tb, tc,
      // moving_toward_child_menu ? GUI_COL32(0,128,0,128) :
      // GUI_COL32(128,0,0,128)); // [DEBUG]
    }

    // The 'HovereWindow == window' check creates an inconsistency (e.g. moving
    // away from menu slowly tends to hit same window, whereas moving away fast
    // does not) But we also need to not close the top-menu menu when moving
    // over void. Perhaps we should extend the triangle check to a larger
    // polygon. (Remember to test this on BeginPopup("A")->BeginMenu("B")
    // sequence which behaves slightly differently as B isn't a Child of A and
    // hovering isn't shared.)
    if (menu_is_open && !hovered && g.HoveredWindow == window &&
        !moving_toward_child_menu && !g.NavDisableMouseHover && g.ActiveId == 0)
      want_close = true;

    // Open
    // (note: at this point 'hovered' actually includes the NavDisableMouseHover
    // == false test)
    if (!menu_is_open && pressed) // Click/activate to open
      want_open = true;
    else if (!menu_is_open && hovered &&
             !moving_toward_child_menu) // Hover to open
      want_open = true;
    else if (!menu_is_open && hovered && g.HoveredIdTimer >= 0.30f &&
             g.MouseStationaryTimer >= 0.30f) // Hover to open (timer fallback)
      want_open = true;
    if (g.NavId == id && g.NavMoveDir == Dir_Right) // Nav-Right to open
    {
      want_open = true;
      NavMoveRequestCancel();
    }
  } else {
    // Menu bar
    if (menu_is_open && pressed &&
        menuset_is_open) // Click an open menu again to close it
    {
      want_close = true;
      want_open = menu_is_open = false;
    } else if (pressed || (hovered && menuset_is_open &&
                           !menu_is_open)) // First click to open, then hover to
                                           // open others
    {
      want_open = true;
    } else if (g.NavId == id && g.NavMoveDir == Dir_Down) // Nav-Down to open
    {
      want_open = true;
      NavMoveRequestCancel();
    }
  }

  if (!enabled) // explicitly close if an open menu becomes disabled, facilitate
                // users code a lot in pattern such as 'if (BeginMenu("options",
                // has_object)) { ..use object.. }'
    want_close = true;
  if (want_close && IsPopupOpen(id, PopupFlags_None))
    ClosePopupToLevel(g.BeginPopupStack.Size, true);

  GUI_TEST_ENGINE_ITEM_INFO(id, label,
                            g.LastItemData.StatusFlags |
                                ItemStatusFlags_Openable |
                                (menu_is_open ? ItemStatusFlags_Opened : 0));
  PopID();

  if (want_open && !menu_is_open &&
      g.OpenPopupStack.Size > g.BeginPopupStack.Size) {
    // Don't reopen/recycle same menu level in the same frame, first close the
    // other menu and yield for a frame.
    OpenPopup(label);
  } else if (want_open) {
    menu_is_open = true;
    OpenPopup(label);
  }

  if (menu_is_open) {
    LastItemData last_item_in_parent = g.LastItemData;
    SetNextWindowPos(popup_pos,
                     Cond_Always); // Note: misleading: the value will serve as
                                   // reference for FindBestWindowPosForPopup(),
                                   // not actual pos.
    PushStyleVar(StyleVar_ChildRounding,
                 style.PopupRounding); // First level will use _PopupRounding,
                                       // subsequent will use _ChildRounding
    menu_is_open = BeginPopupEx(
        id, window_flags); // menu_is_open can be 'false' when the popup is
                           // completely clipped (e.g. zero size display)
    PopStyleVar();
    if (menu_is_open) {
      // Restore LastItemData so IsItemXXXX functions can work after
      // BeginMenu()/EndMenu() (This fixes using IsItemClicked() and
      // IsItemHovered(), but IsItemHovered() also relies on its support for
      // ItemFlags_NoWindowHoverableCheck)
      g.LastItemData = last_item_in_parent;
      if (g.HoveredWindow == window)
        g.LastItemData.StatusFlags |= ItemStatusFlags_HoveredWindow;
    }
  } else {
    g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume
                                   // those values
  }

  return menu_is_open;
}

inline bool Gui::BeginMenu(const char *label, bool enabled) {
  return BeginMenuEx(label, NULL, enabled);
}

inline void Gui::EndMenu() {
  // Nav: When a left move request our menu failed, close ourselves.
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_ASSERT(window->Flags &
             WindowFlags_Popup); // Mismatched BeginMenu()/EndMenu() calls
  Window *parent_window =
      window->ParentWindow; // Should always be != NULL is we passed assert.
  if (window->BeginCount == window->BeginCountPreviousFrame)
    if (g.NavMoveDir == Dir_Left && NavMoveRequestButNoResultYet())
      if (g.NavWindow && (g.NavWindow->RootWindowForNav == window) &&
          parent_window->DC.LayoutType == LayoutType_Vertical) {
        ClosePopupToLevel(g.BeginPopupStack.Size - 1, true);
        NavMoveRequestCancel();
      }

  EndPopup();
}

inline bool Gui::MenuItemEx(const char *label, const char *icon,
                            const char *shortcut, bool selected, bool enabled) {
  Window *window = GetCurrentWindow();
  if (window->SkipItems)
    return false;

  Context &g = *GGui;
  Style &style = g.Style;
  Vec2 pos = window->DC.CursorPos;
  Vec2 label_size = CalcTextSize(label, NULL, true);

  // See BeginMenuEx() for comments about this.
  const bool menuset_is_open = IsRootOfOpenMenuSet();
  if (menuset_is_open)
    PushItemFlag(ItemFlags_NoWindowHoverableCheck, true);

  // We've been using the equivalent of SelectableFlags_SetNavIdOnHover on
  // all Selectable() since early Nav system days (commit 43ee5d73), but I am
  // unsure whether this should be kept at all. For now moved it to be an opt-in
  // feature used by menus only.
  bool pressed;
  PushID(label);
  if (!enabled)
    BeginDisabled();

  // We use SelectableFlags_NoSetKeyOwner to allow down on one menu item,
  // move, up on another.
  const SelectableFlags selectable_flags = SelectableFlags_SelectOnRelease |
                                           SelectableFlags_NoSetKeyOwner |
                                           SelectableFlags_SetNavIdOnHover;
  const MenuColumns *offsets = &window->DC.MenuColumns;
  if (window->DC.LayoutType == LayoutType_Horizontal) {
    // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside
    // a menu bar, which is a little misleading but may be useful Note that in
    // this situation: we don't render the shortcut, we render a highlight
    // instead of the selected tick mark.
    float w = label_size.x;
    window->DC.CursorPos.x += GUI_TRUNC(style.ItemSpacing.x * 0.5f);
    Vec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel,
                  window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
    PushStyleVar(StyleVar_ItemSpacing,
                 Vec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));
    pressed = Selectable("", selected, selectable_flags, Vec2(w, 0.0f));
    PopStyleVar();
    if (g.LastItemData.StatusFlags & ItemStatusFlags_Visible)
      RenderText(text_pos, label);
    window->DC.CursorPos.x += GUI_TRUNC(
        style.ItemSpacing.x *
        (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when
                         // Selectable() did a SameLine(). It would also work to
                         // call SameLine() ourselves after the PopStyleVar().
  } else {
    // Menu item inside a vertical menu
    // (In a typical menu window where all items are BeginMenu() or MenuItem()
    // calls, extra_w will always be 0.0f.
    //  Only when they are other items sticking out we're going to add spacing,
    //  yet only register minimum width into the layout system.
    float icon_w = (icon && icon[0]) ? CalcTextSize(icon, NULL).x : 0.0f;
    float shortcut_w =
        (shortcut && shortcut[0]) ? CalcTextSize(shortcut, NULL).x : 0.0f;
    float checkmark_w = GUI_TRUNC(g.FontSize * 1.20f);
    float min_w = window->DC.MenuColumns.DeclColumns(
        icon_w, label_size.x, shortcut_w,
        checkmark_w); // Feedback for next frame
    float stretch_w = Max(0.0f, GetContentRegionAvail().x - min_w);
    pressed =
        Selectable("", false, selectable_flags | SelectableFlags_SpanAvailWidth,
                   Vec2(min_w, label_size.y));
    if (g.LastItemData.StatusFlags & ItemStatusFlags_Visible) {
      RenderText(Add(pos, Vec2(offsets->OffsetLabel, 0.0f)), label);
      if (icon_w > 0.0f)
        RenderText(Add(pos, Vec2(offsets->OffsetIcon, 0.0f)), icon);
      if (shortcut_w > 0.0f) {
        PushStyleColor(Col_Text, style.Colors[Col_TextDisabled]);
        RenderText(Add(pos, Vec2(offsets->OffsetShortcut + stretch_w, 0.0f)),
                   shortcut, NULL, false);
        PopStyleColor();
      }
      if (selected)
        RenderCheckMark(
            window->DrawList,
            Add(pos, Vec2(offsets->OffsetMark + stretch_w + g.FontSize * 0.40f,
                          g.FontSize * 0.134f * 0.5f)),
            GetColorU32(Col_Text), g.FontSize * 0.866f);
    }
  }
  GUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label,
                            g.LastItemData.StatusFlags |
                                ItemStatusFlags_Checkable |
                                (selected ? ItemStatusFlags_Checked : 0));
  if (!enabled)
    EndDisabled();
  PopID();
  if (menuset_is_open)
    PopItemFlag();

  return pressed;
}

inline bool Gui::MenuItem(const char *label, const char *shortcut,
                          bool selected, bool enabled) {
  return MenuItemEx(label, NULL, shortcut, selected, enabled);
}

inline bool Gui::MenuItem(const char *label, const char *shortcut,
                          bool *p_selected, bool enabled) {
  if (MenuItemEx(label, NULL, shortcut, p_selected ? *p_selected : false,
                 enabled)) {
    if (p_selected)
      *p_selected = !*p_selected;
    return true;
  }
  return false;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
//-------------------------------------------------------------------------
// - BeginTabBar()
// - BeginTabBarEx() [Internal]
// - EndTabBar()
// - TabBarLayout() [Internal]
// - TabBarCalcTabID() [Internal]
// - TabBarCalcMaxTabWidth() [Internal]
// - TabBarFindTabById() [Internal]
// - TabBarFindTabByOrder() [Internal]
// - TabBarGetCurrentTab() [Internal]
// - TabBarGetTabName() [Internal]
// - TabBarRemoveTab() [Internal]
// - TabBarCloseTab() [Internal]
// - TabBarScrollClamp() [Internal]
// - TabBarScrollToTab() [Internal]
// - TabBarQueueFocus() [Internal]
// - TabBarQueueReorder() [Internal]
// - TabBarProcessReorderFromMousePos() [Internal]
// - TabBarProcessReorder() [Internal]
// - TabBarScrollingButtons() [Internal]
// - TabBarTabListPopupButton() [Internal]
//-------------------------------------------------------------------------

struct TabBarSection {
  int TabCount;  // Number of tabs in this section.
  float Width;   // Sum of width of tabs in this section (after shrinking down)
  float Spacing; // Horizontal spacing at the end of the section.

  TabBarSection() { memset(this, 0, sizeof(*this)); }
};

namespace Gui {
static void TabBarLayout(TabBar *tab_bar);
static U32 TabBarCalcTabID(TabBar *tab_bar, const char *label,
                           Window *docked_window);
static float TabBarCalcMaxTabWidth();
static float TabBarScrollClamp(TabBar *tab_bar, float scrolling);
static void TabBarScrollToTab(TabBar *tab_bar, ID tab_id,
                              TabBarSection *sections);
static TabItem *TabBarScrollingButtons(TabBar *tab_bar);
static TabItem *TabBarTabListPopupButton(TabBar *tab_bar);
} // namespace Gui

inline TabBar::TabBar() {
  memset(this, 0, sizeof(*this));
  CurrFrameVisible = PrevFrameVisible = -1;
  LastTabItemIdx = -1;
}

static inline int TabItemGetSectionIdx(const TabItem *tab) {
  return (tab->Flags & TabItemFlags_Leading)    ? 0
         : (tab->Flags & TabItemFlags_Trailing) ? 2
                                                : 1;
}

static int GUI_CDECL TabItemComparerBySection(const void *lhs,
                                              const void *rhs) {
  const TabItem *a = (const TabItem *)lhs;
  const TabItem *b = (const TabItem *)rhs;
  const int a_section = TabItemGetSectionIdx(a);
  const int b_section = TabItemGetSectionIdx(b);
  if (a_section != b_section)
    return a_section - b_section;
  return (int)(a->IndexDuringLayout - b->IndexDuringLayout);
}

static int GUI_CDECL TabItemComparerByBeginOrder(const void *lhs,
                                                 const void *rhs) {
  const TabItem *a = (const TabItem *)lhs;
  const TabItem *b = (const TabItem *)rhs;
  return (int)(a->BeginOrder - b->BeginOrder);
}

static TabBar *GetTabBarFromTabBarRef(const PtrOrIndex &ref) {
  Context &g = *GGui;
  return ref.Ptr ? (TabBar *)ref.Ptr : g.TabBars.GetByIndex(ref.Index);
}

static PtrOrIndex GetTabBarRefFromTabBar(TabBar *tab_bar) {
  Context &g = *GGui;
  if (g.TabBars.Contains(tab_bar))
    return PtrOrIndex(g.TabBars.GetIndex(tab_bar));
  return PtrOrIndex(tab_bar);
}

inline bool Gui::BeginTabBar(const char *str_id, TabBarFlags flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return false;

  ID id = window->GetID(str_id);
  TabBar *tab_bar = g.TabBars.GetOrAddByKey(id);
  Rect tab_bar_bb = Rect(
      window->DC.CursorPos.x, window->DC.CursorPos.y, window->WorkRect.Max.x,
      window->DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2);
  tab_bar->ID = id;
  tab_bar->SeparatorMinX =
      tab_bar->BarRect.Min.x - GUI_TRUNC(window->WindowPadding.x * 0.5f);
  tab_bar->SeparatorMaxX =
      tab_bar->BarRect.Max.x + GUI_TRUNC(window->WindowPadding.x * 0.5f);
  return BeginTabBarEx(tab_bar, tab_bar_bb, flags | TabBarFlags_IsFocused);
}

inline bool Gui::BeginTabBarEx(TabBar *tab_bar, const Rect &tab_bar_bb,
                               TabBarFlags flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return false;

  GUI_ASSERT(tab_bar->ID != 0);
  if ((flags & TabBarFlags_DockNode) == 0)
    PushOverrideID(tab_bar->ID);

  // Add to stack
  g.CurrentTabBarStack.push_back(GetTabBarRefFromTabBar(tab_bar));
  g.CurrentTabBar = tab_bar;

  // Append with multiple BeginTabBar()/EndTabBar() pairs.
  tab_bar->BackupCursorPos = window->DC.CursorPos;
  if (tab_bar->CurrFrameVisible == g.FrameCount) {
    window->DC.CursorPos = Vec2(tab_bar->BarRect.Min.x,
                                tab_bar->BarRect.Max.y + tab_bar->ItemSpacingY);
    tab_bar->BeginCount++;
    return true;
  }

  // Ensure correct ordering when toggling TabBarFlags_Reorderable flag, or
  // when a new tab was added while being not reorderable
  if ((flags & TabBarFlags_Reorderable) !=
          (tab_bar->Flags & TabBarFlags_Reorderable) ||
      (tab_bar->TabsAddedNew && !(flags & TabBarFlags_Reorderable)))
    Qsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(TabItem),
          TabItemComparerByBeginOrder);
  tab_bar->TabsAddedNew = false;

  // Flags
  if ((flags & TabBarFlags_FittingPolicyMask_) == 0)
    flags |= TabBarFlags_FittingPolicyDefault_;

  tab_bar->Flags = flags;
  tab_bar->BarRect = tab_bar_bb;
  tab_bar->WantLayout =
      true; // Layout will be done on the first call to ItemTab()
  tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;
  tab_bar->CurrFrameVisible = g.FrameCount;
  tab_bar->PrevTabsContentsHeight = tab_bar->CurrTabsContentsHeight;
  tab_bar->CurrTabsContentsHeight = 0.0f;
  tab_bar->ItemSpacingY = g.Style.ItemSpacing.y;
  tab_bar->FramePadding = g.Style.FramePadding;
  tab_bar->TabsActiveCount = 0;
  tab_bar->LastTabItemIdx = -1;
  tab_bar->BeginCount = 1;

  // Set cursor pos in a way which only be used in the off-chance the user
  // erroneously submits item before BeginTabItem(): items will overlap
  window->DC.CursorPos = Vec2(tab_bar->BarRect.Min.x,
                              tab_bar->BarRect.Max.y + tab_bar->ItemSpacingY);

  // Draw separator
  // (it would be misleading to draw this in EndTabBar() suggesting that it may
  // be drawn over tabs, as tab bar are appendable)
  const U32 col = GetColorU32(
      (flags & TabBarFlags_IsFocused) ? Col_TabActive : Col_TabUnfocusedActive);
  if (g.Style.TabBarBorderSize > 0.0f) {
    const float y = tab_bar->BarRect.Max.y;
    window->DrawList->AddRectFilled(
        Vec2(tab_bar->SeparatorMinX, y - g.Style.TabBarBorderSize),
        Vec2(tab_bar->SeparatorMaxX, y), col);
  }
  return true;
}

inline void Gui::EndTabBar() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return;

  TabBar *tab_bar = g.CurrentTabBar;
  if (tab_bar == NULL) {
    GUI_ASSERT_USER_ERROR(tab_bar != NULL,
                          "Mismatched BeginTabBar()/EndTabBar()!");
    return;
  }

  // Fallback in case no TabItem have been submitted
  if (tab_bar->WantLayout)
    TabBarLayout(tab_bar);

  // Restore the last visible height if no tab is visible, this reduce vertical
  // flicker/movement when a tabs gets removed without calling
  // SetTabItemClosed().
  const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
  if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 ||
      tab_bar_appearing) {
    tab_bar->CurrTabsContentsHeight =
        Max(window->DC.CursorPos.y - tab_bar->BarRect.Max.y,
            tab_bar->CurrTabsContentsHeight);
    window->DC.CursorPos.y =
        tab_bar->BarRect.Max.y + tab_bar->CurrTabsContentsHeight;
  } else {
    window->DC.CursorPos.y =
        tab_bar->BarRect.Max.y + tab_bar->PrevTabsContentsHeight;
  }
  if (tab_bar->BeginCount > 1)
    window->DC.CursorPos = tab_bar->BackupCursorPos;

  tab_bar->LastTabItemIdx = -1;
  if ((tab_bar->Flags & TabBarFlags_DockNode) == 0)
    PopID();

  g.CurrentTabBarStack.pop_back();
  g.CurrentTabBar = g.CurrentTabBarStack.empty()
                        ? NULL
                        : GetTabBarFromTabBarRef(g.CurrentTabBarStack.back());
}

// Scrolling happens only in the central section (leading/trailing sections are
// not scrolling)
static float TabBarCalcScrollableWidth(TabBar *tab_bar,
                                       TabBarSection *sections) {
  return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width -
         sections[1].Spacing;
}

// This is called only once a frame before by the first call to ItemTab()
// The reason we're not calling it in BeginTabBar() is to leave a chance to the
// user to call the SetTabItemClosed() functions.
static void Gui::TabBarLayout(TabBar *tab_bar) {
  Context &g = *GGui;
  tab_bar->WantLayout = false;

  // Garbage collect by compacting list
  // Detect if we need to sort out tab list (e.g. in rare case where a tab
  // changed section)
  int tab_dst_n = 0;
  bool need_sort_by_section = false;
  TabBarSection sections[3]; // Layout sections: Leading, Central, Trailing
  for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++) {
    TabItem *tab = &tab_bar->Tabs[tab_src_n];
    if (tab->LastFrameVisible < tab_bar->PrevFrameVisible || tab->WantClose) {
      // Remove tab
      if (tab_bar->VisibleTabId == tab->ID) {
        tab_bar->VisibleTabId = 0;
      }
      if (tab_bar->SelectedTabId == tab->ID) {
        tab_bar->SelectedTabId = 0;
      }
      if (tab_bar->NextSelectedTabId == tab->ID) {
        tab_bar->NextSelectedTabId = 0;
      }
      continue;
    }
    if (tab_dst_n != tab_src_n)
      tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];

    tab = &tab_bar->Tabs[tab_dst_n];
    tab->IndexDuringLayout = (S16)tab_dst_n;

    // We will need sorting if tabs have changed section (e.g. moved from one of
    // Leading/Central/Trailing to another)
    int curr_tab_section_n = TabItemGetSectionIdx(tab);
    if (tab_dst_n > 0) {
      TabItem *prev_tab = &tab_bar->Tabs[tab_dst_n - 1];
      int prev_tab_section_n = TabItemGetSectionIdx(prev_tab);
      if (curr_tab_section_n == 0 && prev_tab_section_n != 0)
        need_sort_by_section = true;
      if (prev_tab_section_n == 2 && curr_tab_section_n != 2)
        need_sort_by_section = true;
    }

    sections[curr_tab_section_n].TabCount++;
    tab_dst_n++;
  }
  if (tab_bar->Tabs.Size != tab_dst_n)
    tab_bar->Tabs.resize(tab_dst_n);

  if (need_sort_by_section)
    Qsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(TabItem),
          TabItemComparerBySection);

  // Calculate spacing between sections
  sections[0].Spacing = sections[0].TabCount > 0 && (sections[1].TabCount +
                                                     sections[2].TabCount) > 0
                            ? g.Style.ItemInnerSpacing.x
                            : 0.0f;
  sections[1].Spacing = sections[1].TabCount > 0 && sections[2].TabCount > 0
                            ? g.Style.ItemInnerSpacing.x
                            : 0.0f;

  // Setup next selected tab
  ID scroll_to_tab_id = 0;
  if (tab_bar->NextSelectedTabId) {
    tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;
    tab_bar->NextSelectedTabId = 0;
    scroll_to_tab_id = tab_bar->SelectedTabId;
  }

  // Process order change request (we could probably process it when requested
  // but it's just saner to do it in a single spot).
  if (tab_bar->ReorderRequestTabId != 0) {
    if (TabBarProcessReorder(tab_bar))
      if (tab_bar->ReorderRequestTabId == tab_bar->SelectedTabId)
        scroll_to_tab_id = tab_bar->ReorderRequestTabId;
    tab_bar->ReorderRequestTabId = 0;
  }

  // Tab List Popup (will alter tab_bar->BarRect and therefore the available
  // width!)
  const bool tab_list_popup_button =
      (tab_bar->Flags & TabBarFlags_TabListPopupButton) != 0;
  if (tab_list_popup_button)
    if (TabItem *tab_to_select =
            TabBarTabListPopupButton(tab_bar)) // NB: Will alter BarRect.Min.x!
      scroll_to_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

  // Leading/Trailing tabs will be shrink only if central one aren't visible
  // anymore, so layout the shrink data as: leading, trailing, central (whereas
  // our tabs are stored as: leading, central, trailing)
  int shrink_buffer_indexes[3] = {
      0, sections[0].TabCount + sections[2].TabCount, sections[0].TabCount};
  g.ShrinkWidthBuffer.resize(tab_bar->Tabs.Size);

  // Compute ideal tabs widths + store them into shrink buffer
  TabItem *most_recently_selected_tab = NULL;
  int curr_section_n = -1;
  bool found_selected_tab_id = false;
  for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++) {
    TabItem *tab = &tab_bar->Tabs[tab_n];
    GUI_ASSERT(tab->LastFrameVisible >= tab_bar->PrevFrameVisible);

    if ((most_recently_selected_tab == NULL ||
         most_recently_selected_tab->LastFrameSelected <
             tab->LastFrameSelected) &&
        !(tab->Flags & TabItemFlags_Button))
      most_recently_selected_tab = tab;
    if (tab->ID == tab_bar->SelectedTabId)
      found_selected_tab_id = true;
    if (scroll_to_tab_id == 0 && g.NavJustMovedToId == tab->ID)
      scroll_to_tab_id = tab->ID;

    // Refresh tab width immediately, otherwise changes of style e.g.
    // style.FramePadding.x would noticeably lag in the tab bar. Additionally,
    // when using TabBarAddTab() to manipulate tab bar order we occasionally
    // insert new tabs that don't have a width yet, and we cannot wait for the
    // next BeginTabItem() call. We cannot compute this width within
    // TabBarAddTab() because font size depends on the active window.
    const char *tab_name = TabBarGetTabName(tab_bar, tab);
    const bool has_close_button_or_unsaved_marker =
        (tab->Flags & TabItemFlags_NoCloseButton) == 0 ||
        (tab->Flags & TabItemFlags_UnsavedDocument);
    tab->ContentWidth =
        (tab->RequestedWidth >= 0.0f)
            ? tab->RequestedWidth
            : TabItemCalcSize(tab_name, has_close_button_or_unsaved_marker).x;

    int section_n = TabItemGetSectionIdx(tab);
    TabBarSection *section = &sections[section_n];
    section->Width +=
        tab->ContentWidth +
        (section_n == curr_section_n ? g.Style.ItemInnerSpacing.x : 0.0f);
    curr_section_n = section_n;

    // Store data so we can build an array sorted by width if we need to shrink
    // tabs down
    GUI_MSVC_WARNING_SUPPRESS(6385);
    ShrinkWidthItem *shrink_width_item =
        &g.ShrinkWidthBuffer[shrink_buffer_indexes[section_n]++];
    shrink_width_item->Index = tab_n;
    shrink_width_item->Width = shrink_width_item->InitialWidth =
        tab->ContentWidth;
    tab->Width = Max(tab->ContentWidth, 1.0f);
  }

  // Compute total ideal width (used for e.g. auto-resizing a window)
  tab_bar->WidthAllTabsIdeal = 0.0f;
  for (int section_n = 0; section_n < 3; section_n++)
    tab_bar->WidthAllTabsIdeal +=
        sections[section_n].Width + sections[section_n].Spacing;

  // Horizontal scrolling buttons
  // (note that TabBarScrollButtons() will alter BarRect.Max.x)
  if ((tab_bar->WidthAllTabsIdeal > tab_bar->BarRect.GetWidth() &&
       tab_bar->Tabs.Size > 1) &&
      !(tab_bar->Flags & TabBarFlags_NoTabListScrollingButtons) &&
      (tab_bar->Flags & TabBarFlags_FittingPolicyScroll))
    if (TabItem *scroll_and_select_tab = TabBarScrollingButtons(tab_bar)) {
      scroll_to_tab_id = scroll_and_select_tab->ID;
      if ((scroll_and_select_tab->Flags & TabItemFlags_Button) == 0)
        tab_bar->SelectedTabId = scroll_to_tab_id;
    }

  // Shrink widths if full tabs don't fit in their allocated space
  float section_0_w = sections[0].Width + sections[0].Spacing;
  float section_1_w = sections[1].Width + sections[1].Spacing;
  float section_2_w = sections[2].Width + sections[2].Spacing;
  bool central_section_is_visible =
      (section_0_w + section_2_w) < tab_bar->BarRect.GetWidth();
  float width_excess;
  if (central_section_is_visible)
    width_excess = Max(
        section_1_w - (tab_bar->BarRect.GetWidth() - section_0_w - section_2_w),
        0.0f); // Excess used to shrink central section
  else
    width_excess =
        (section_0_w + section_2_w) -
        tab_bar->BarRect
            .GetWidth(); // Excess used to shrink leading/trailing section

  // With TabBarFlags_FittingPolicyScroll policy, we will only shrink
  // leading/trailing if the central section is not visible anymore
  if (width_excess >= 1.0f &&
      ((tab_bar->Flags & TabBarFlags_FittingPolicyResizeDown) ||
       !central_section_is_visible)) {
    int shrink_data_count = (central_section_is_visible
                                 ? sections[1].TabCount
                                 : sections[0].TabCount + sections[2].TabCount);
    int shrink_data_offset = (central_section_is_visible
                                  ? sections[0].TabCount + sections[2].TabCount
                                  : 0);
    ShrinkWidths(g.ShrinkWidthBuffer.Data + shrink_data_offset,
                 shrink_data_count, width_excess);

    // Apply shrunk values into tabs and sections
    for (int tab_n = shrink_data_offset;
         tab_n < shrink_data_offset + shrink_data_count; tab_n++) {
      TabItem *tab = &tab_bar->Tabs[g.ShrinkWidthBuffer[tab_n].Index];
      float shrinked_width = GUI_TRUNC(g.ShrinkWidthBuffer[tab_n].Width);
      if (shrinked_width < 0.0f)
        continue;

      shrinked_width = Max(1.0f, shrinked_width);
      int section_n = TabItemGetSectionIdx(tab);
      sections[section_n].Width -= (tab->Width - shrinked_width);
      tab->Width = shrinked_width;
    }
  }

  // Layout all active tabs
  int section_tab_index = 0;
  float tab_offset = 0.0f;
  tab_bar->WidthAllTabs = 0.0f;
  for (int section_n = 0; section_n < 3; section_n++) {
    TabBarSection *section = &sections[section_n];
    if (section_n == 2)
      tab_offset = Min(Max(0.0f, tab_bar->BarRect.GetWidth() - section->Width),
                       tab_offset);

    for (int tab_n = 0; tab_n < section->TabCount; tab_n++) {
      TabItem *tab = &tab_bar->Tabs[section_tab_index + tab_n];
      tab->Offset = tab_offset;
      tab->NameOffset = -1;
      tab_offset +=
          tab->Width +
          (tab_n < section->TabCount - 1 ? g.Style.ItemInnerSpacing.x : 0.0f);
    }
    tab_bar->WidthAllTabs += Max(section->Width + section->Spacing, 0.0f);
    tab_offset += section->Spacing;
    section_tab_index += section->TabCount;
  }

  // Clear name buffers
  tab_bar->TabsNames.Buf.resize(0);

  // If we have lost the selected tab, select the next most recently active one
  if (found_selected_tab_id == false)
    tab_bar->SelectedTabId = 0;
  if (tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 &&
      most_recently_selected_tab != NULL)
    scroll_to_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;

  // Lock in visible tab
  tab_bar->VisibleTabId = tab_bar->SelectedTabId;
  tab_bar->VisibleTabWasSubmitted = false;

  // Apply request requests
  if (scroll_to_tab_id != 0)
    TabBarScrollToTab(tab_bar, scroll_to_tab_id, sections);
  else if ((tab_bar->Flags & TabBarFlags_FittingPolicyScroll) &&
           IsMouseHoveringRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max,
                               true) &&
           IsWindowContentHoverable(g.CurrentWindow)) {
    const float wheel =
        g.IO.MouseWheelRequestAxisSwap ? g.IO.MouseWheel : g.IO.MouseWheelH;
    const Key wheel_key =
        g.IO.MouseWheelRequestAxisSwap ? Key_MouseWheelY : Key_MouseWheelX;
    if (TestKeyOwner(wheel_key, tab_bar->ID) && wheel != 0.0f) {
      const float scroll_step =
          wheel * TabBarCalcScrollableWidth(tab_bar, sections) / 3.0f;
      tab_bar->ScrollingTargetDistToVisibility = 0.0f;
      tab_bar->ScrollingTarget =
          TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget - scroll_step);
    }
    SetKeyOwner(wheel_key, tab_bar->ID);
  }

  // Update scrolling
  tab_bar->ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar->ScrollingAnim);
  tab_bar->ScrollingTarget =
      TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);
  if (tab_bar->ScrollingAnim != tab_bar->ScrollingTarget) {
    // Scrolling speed adjust itself so we can always reach our target in 1/3
    // seconds. Teleport if we are aiming far off the visible line
    tab_bar->ScrollingSpeed = Max(tab_bar->ScrollingSpeed, 70.0f * g.FontSize);
    tab_bar->ScrollingSpeed =
        Max(tab_bar->ScrollingSpeed,
            Fabs(tab_bar->ScrollingTarget - tab_bar->ScrollingAnim) / 0.3f);
    const bool teleport =
        (tab_bar->PrevFrameVisible + 1 < g.FrameCount) ||
        (tab_bar->ScrollingTargetDistToVisibility > 10.0f * g.FontSize);
    tab_bar->ScrollingAnim =
        teleport ? tab_bar->ScrollingTarget
                 : LinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget,
                               g.IO.DeltaTime * tab_bar->ScrollingSpeed);
  } else {
    tab_bar->ScrollingSpeed = 0.0f;
  }
  tab_bar->ScrollingRectMinX =
      tab_bar->BarRect.Min.x + sections[0].Width + sections[0].Spacing;
  tab_bar->ScrollingRectMaxX =
      tab_bar->BarRect.Max.x - sections[2].Width - sections[1].Spacing;

  // Actual layout in host window (we don't do it in BeginTabBar() so as not to
  // waste an extra frame)
  Window *window = g.CurrentWindow;
  window->DC.CursorPos = tab_bar->BarRect.Min;
  ItemSize(Vec2(tab_bar->WidthAllTabs, tab_bar->BarRect.GetHeight()),
           tab_bar->FramePadding.y);
  window->DC.IdealMaxPos.x =
      Max(window->DC.IdealMaxPos.x,
          tab_bar->BarRect.Min.x + tab_bar->WidthAllTabsIdeal);
}

// Dockable windows uses Name/ID in the global namespace. Non-dockable items use
// the ID stack.
static U32 Gui::TabBarCalcTabID(TabBar *tab_bar, const char *label,
                                Window *docked_window) {
  GUI_ASSERT(docked_window == NULL); // master branch only
  GUI_UNUSED(docked_window);
  if (tab_bar->Flags & TabBarFlags_DockNode) {
    ID id = HashStr(label);
    KeepAliveID(id);
    return id;
  } else {
    Window *window = GGui->CurrentWindow;
    return window->GetID(label);
  }
}

static float Gui::TabBarCalcMaxTabWidth() {
  Context &g = *GGui;
  return g.FontSize * 20.0f;
}

// Order = visible order, not submission order! (which is tab->BeginOrder)

inline const char *Gui::TabBarGetTabName(TabBar *tab_bar, TabItem *tab) {
  if (tab->NameOffset == -1)
    return "N/A";
  GUI_ASSERT(tab->NameOffset < tab_bar->TabsNames.Buf.Size);
  return tab_bar->TabsNames.Buf.Data + tab->NameOffset;
}

// The *TabId fields are already set by the docking system _before_ the actual
// TabItem was created, so we clear them regardless.

// Called on manual closure attempt
inline void Gui::TabBarCloseTab(TabBar *tab_bar, TabItem *tab) {
  if (tab->Flags & TabItemFlags_Button)
    return; // A button appended with TabItemButton().

  if ((tab->Flags &
       (TabItemFlags_UnsavedDocument | TabItemFlags_NoAssumedClosure)) == 0) {
    // This will remove a frame of lag for selecting another tab on closure.
    // However we don't run it in the case where the 'Unsaved' flag is set, so
    // user gets a chance to fully undo the closure
    tab->WantClose = true;
    if (tab_bar->VisibleTabId == tab->ID) {
      tab->LastFrameVisible = -1;
      tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;
    }
  } else {
    // Actually select before expecting closure attempt (on an UnsavedDocument
    // tab user is expect to e.g. show a popup)
    if (tab_bar->VisibleTabId != tab->ID)
      TabBarQueueFocus(tab_bar, tab);
  }
}

static float Gui::TabBarScrollClamp(TabBar *tab_bar, float scrolling) {
  scrolling =
      Min(scrolling, tab_bar->WidthAllTabs - tab_bar->BarRect.GetWidth());
  return Max(scrolling, 0.0f);
}

// Note: we may scroll to tab that are not selected! e.g. using keyboard arrow
// keys
static void Gui::TabBarScrollToTab(TabBar *tab_bar, ID tab_id,
                                   TabBarSection *sections) {
  TabItem *tab = TabBarFindTabByID(tab_bar, tab_id);
  if (tab == NULL)
    return;
  if (tab->Flags & TabItemFlags_SectionMask_)
    return;

  Context &g = *GGui;
  float margin =
      g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a
                         // bit of N visible to suggest more scrolling area
                         // (since we don't have a scrollbar)
  int order = TabBarGetTabOrder(tab_bar, tab);

  // Scrolling happens only in the central section (leading/trailing sections
  // are not scrolling)
  float scrollable_width = TabBarCalcScrollableWidth(tab_bar, sections);

  // We make all tabs positions all relative Sections[0].Width to make code
  // simpler
  float tab_x1 = tab->Offset - sections[0].Width +
                 (order > sections[0].TabCount - 1 ? -margin : 0.0f);
  float tab_x2 =
      tab->Offset - sections[0].Width + tab->Width +
      (order + 1 < tab_bar->Tabs.Size - sections[2].TabCount ? margin : 1.0f);
  tab_bar->ScrollingTargetDistToVisibility = 0.0f;
  if (tab_bar->ScrollingTarget > tab_x1 ||
      (tab_x2 - tab_x1 >= scrollable_width)) {
    // Scroll to the left
    tab_bar->ScrollingTargetDistToVisibility =
        Max(tab_bar->ScrollingAnim - tab_x2, 0.0f);
    tab_bar->ScrollingTarget = tab_x1;
  } else if (tab_bar->ScrollingTarget < tab_x2 - scrollable_width) {
    // Scroll to the right
    tab_bar->ScrollingTargetDistToVisibility =
        Max((tab_x1 - scrollable_width) - tab_bar->ScrollingAnim, 0.0f);
    tab_bar->ScrollingTarget = tab_x2 - scrollable_width;
  }
}

inline void Gui::TabBarQueueReorder(TabBar *tab_bar, TabItem *tab, int offset) {
  GUI_ASSERT(offset != 0);
  GUI_ASSERT(tab_bar->ReorderRequestTabId == 0);
  tab_bar->ReorderRequestTabId = tab->ID;
  tab_bar->ReorderRequestOffset = (S16)offset;
}

inline void Gui::TabBarQueueReorderFromMousePos(TabBar *tab_bar,
                                                TabItem *src_tab,
                                                Vec2 mouse_pos) {
  Context &g = *GGui;
  GUI_ASSERT(tab_bar->ReorderRequestTabId == 0);
  if ((tab_bar->Flags & TabBarFlags_Reorderable) == 0)
    return;

  const bool is_central_section =
      (src_tab->Flags & TabItemFlags_SectionMask_) == 0;
  const float bar_offset = tab_bar->BarRect.Min.x -
                           (is_central_section ? tab_bar->ScrollingTarget : 0);

  // Count number of contiguous tabs we are crossing over
  const int dir = (bar_offset + src_tab->Offset) > mouse_pos.x ? -1 : +1;
  const int src_idx = tab_bar->Tabs.index_from_ptr(src_tab);
  int dst_idx = src_idx;
  for (int i = src_idx; i >= 0 && i < tab_bar->Tabs.Size; i += dir) {
    // Reordered tabs must share the same section
    const TabItem *dst_tab = &tab_bar->Tabs[i];
    if (dst_tab->Flags & TabItemFlags_NoReorder)
      break;
    if ((dst_tab->Flags & TabItemFlags_SectionMask_) !=
        (src_tab->Flags & TabItemFlags_SectionMask_))
      break;
    dst_idx = i;

    // Include spacing after tab, so when mouse cursor is between tabs we would
    // not continue checking further tabs that are not hovered.
    const float x1 = bar_offset + dst_tab->Offset - g.Style.ItemInnerSpacing.x;
    const float x2 = bar_offset + dst_tab->Offset + dst_tab->Width +
                     g.Style.ItemInnerSpacing.x;
    // GetForegroundDrawList()->AddRect(Vec2(x1, tab_bar->BarRect.Min.y),
    // Vec2(x2, tab_bar->BarRect.Max.y), GUI_COL32(255, 0, 0, 255));
    if ((dir < 0 && mouse_pos.x > x1) || (dir > 0 && mouse_pos.x < x2))
      break;
  }

  if (dst_idx != src_idx)
    TabBarQueueReorder(tab_bar, src_tab, dst_idx - src_idx);
}

inline bool Gui::TabBarProcessReorder(TabBar *tab_bar) {
  TabItem *tab1 = TabBarFindTabByID(tab_bar, tab_bar->ReorderRequestTabId);
  if (tab1 == NULL || (tab1->Flags & TabItemFlags_NoReorder))
    return false;

  // GUI_ASSERT(tab_bar->Flags & TabBarFlags_Reorderable); // <- this may
  // happen when using debug tools
  int tab2_order =
      TabBarGetTabOrder(tab_bar, tab1) + tab_bar->ReorderRequestOffset;
  if (tab2_order < 0 || tab2_order >= tab_bar->Tabs.Size)
    return false;

  // Reordered tabs must share the same section
  // (Note: TabBarQueueReorderFromMousePos() also has a similar test but since
  // we allow direct calls to TabBarQueueReorder() we do it here too)
  TabItem *tab2 = &tab_bar->Tabs[tab2_order];
  if (tab2->Flags & TabItemFlags_NoReorder)
    return false;
  if ((tab1->Flags & TabItemFlags_SectionMask_) !=
      (tab2->Flags & TabItemFlags_SectionMask_))
    return false;

  TabItem item_tmp = *tab1;
  TabItem *src_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 + 1 : tab2;
  TabItem *dst_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 : tab2 + 1;
  const int move_count = (tab_bar->ReorderRequestOffset > 0)
                             ? tab_bar->ReorderRequestOffset
                             : -tab_bar->ReorderRequestOffset;
  memmove(dst_tab, src_tab, move_count * sizeof(TabItem));
  *tab2 = item_tmp;

  if (tab_bar->Flags & TabBarFlags_SaveSettings)
    MarkIniSettingsDirty();
  return true;
}

static TabItem *Gui::TabBarScrollingButtons(TabBar *tab_bar) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  const Vec2 arrow_button_size(g.FontSize - 2.0f,
                               g.FontSize + g.Style.FramePadding.y * 2.0f);
  const float scrolling_buttons_width = arrow_button_size.x * 2.0f;

  const Vec2 backup_cursor_pos = window->DC.CursorPos;
  // window->DrawList->AddRect(Vec2(tab_bar->BarRect.Max.x -
  // scrolling_buttons_width, tab_bar->BarRect.Min.y),
  // Vec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y),
  // GUI_COL32(255,0,0,255));

  int select_dir = 0;
  Vec4 arrow_col = g.Style.Colors[Col_Text];
  arrow_col.w *= 0.5f;

  PushStyleColor(Col_Text, arrow_col);
  PushStyleColor(Col_Button, Vec4(0, 0, 0, 0));
  const float backup_repeat_delay = g.IO.KeyRepeatDelay;
  const float backup_repeat_rate = g.IO.KeyRepeatRate;
  g.IO.KeyRepeatDelay = 0.250f;
  g.IO.KeyRepeatRate = 0.200f;
  float x = Max(tab_bar->BarRect.Min.x,
                tab_bar->BarRect.Max.x - scrolling_buttons_width);
  window->DC.CursorPos = Vec2(x, tab_bar->BarRect.Min.y);
  if (ArrowButtonEx("##<", Dir_Left, arrow_button_size,
                    ButtonFlags_PressedOnClick | ButtonFlags_Repeat))
    select_dir = -1;
  window->DC.CursorPos = Vec2(x + arrow_button_size.x, tab_bar->BarRect.Min.y);
  if (ArrowButtonEx("##>", Dir_Right, arrow_button_size,
                    ButtonFlags_PressedOnClick | ButtonFlags_Repeat))
    select_dir = +1;
  PopStyleColor(2);
  g.IO.KeyRepeatRate = backup_repeat_rate;
  g.IO.KeyRepeatDelay = backup_repeat_delay;

  TabItem *tab_to_scroll_to = NULL;
  if (select_dir != 0)
    if (TabItem *tab_item =
            TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId)) {
      int selected_order = TabBarGetTabOrder(tab_bar, tab_item);
      int target_order = selected_order + select_dir;

      // Skip tab item buttons until another tab item is found or end is reached
      while (tab_to_scroll_to == NULL) {
        // If we are at the end of the list, still scroll to make our tab
        // visible
        tab_to_scroll_to =
            &tab_bar
                 ->Tabs[(target_order >= 0 && target_order < tab_bar->Tabs.Size)
                            ? target_order
                            : selected_order];

        // Cross through buttons
        // (even if first/last item is a button, return it so we can update the
        // scroll)
        if (tab_to_scroll_to->Flags & TabItemFlags_Button) {
          target_order += select_dir;
          selected_order += select_dir;
          tab_to_scroll_to =
              (target_order < 0 || target_order >= tab_bar->Tabs.Size)
                  ? tab_to_scroll_to
                  : NULL;
        }
      }
    }
  window->DC.CursorPos = backup_cursor_pos;
  tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;

  return tab_to_scroll_to;
}

static TabItem *Gui::TabBarTabListPopupButton(TabBar *tab_bar) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;

  // We use g.Style.FramePadding.y to match the square ArrowButton size
  const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;
  const Vec2 backup_cursor_pos = window->DC.CursorPos;
  window->DC.CursorPos = Vec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y,
                              tab_bar->BarRect.Min.y);
  tab_bar->BarRect.Min.x += tab_list_popup_button_width;

  Vec4 arrow_col = g.Style.Colors[Col_Text];
  arrow_col.w *= 0.5f;
  PushStyleColor(Col_Text, arrow_col);
  PushStyleColor(Col_Button, Vec4(0, 0, 0, 0));
  bool open =
      BeginCombo("##v", NULL, ComboFlags_NoPreview | ComboFlags_HeightLargest);
  PopStyleColor(2);

  TabItem *tab_to_select = NULL;
  if (open) {
    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++) {
      TabItem *tab = &tab_bar->Tabs[tab_n];
      if (tab->Flags & TabItemFlags_Button)
        continue;

      const char *tab_name = TabBarGetTabName(tab_bar, tab);
      if (Selectable(tab_name, tab_bar->SelectedTabId == tab->ID))
        tab_to_select = tab;
    }
    EndCombo();
  }

  window->DC.CursorPos = backup_cursor_pos;
  return tab_to_select;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
//-------------------------------------------------------------------------
// - BeginTabItem()
// - EndTabItem()
// - TabItemButton()
// - TabItemEx() [Internal]
// - SetTabItemClosed()
// - TabItemCalcSize() [Internal]
// - TabItemBackground() [Internal]
// - TabItemLabelAndCloseButton() [Internal]
//-------------------------------------------------------------------------

inline bool Gui::BeginTabItem(const char *label, bool *p_open,
                              TabItemFlags flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return false;

  TabBar *tab_bar = g.CurrentTabBar;
  if (tab_bar == NULL) {
    GUI_ASSERT_USER_ERROR(
        tab_bar, "Needs to be called between BeginTabBar() and EndTabBar()!");
    return false;
  }
  GUI_ASSERT(!(
      flags & TabItemFlags_Button)); // BeginTabItem() Can't be used with button
                                     // flags, use TabItemButton() instead!

  bool ret = TabItemEx(tab_bar, label, p_open, flags, NULL);
  if (ret && !(flags & TabItemFlags_NoPushId)) {
    TabItem *tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
    PushOverrideID(tab->ID); // We already hashed 'label' so push into the ID
                             // stack directly instead of doing another hash
                             // through PushID(label)
  }
  return ret;
}

inline void Gui::EndTabItem() {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return;

  TabBar *tab_bar = g.CurrentTabBar;
  if (tab_bar == NULL) {
    GUI_ASSERT_USER_ERROR(
        tab_bar != NULL,
        "Needs to be called between BeginTabBar() and EndTabBar()!");
    return;
  }
  GUI_ASSERT(tab_bar->LastTabItemIdx >= 0);
  TabItem *tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
  if (!(tab->Flags & TabItemFlags_NoPushId))
    PopID();
}

inline bool Gui::TabItemButton(const char *label, TabItemFlags flags) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return false;

  TabBar *tab_bar = g.CurrentTabBar;
  if (tab_bar == NULL) {
    GUI_ASSERT_USER_ERROR(
        tab_bar != NULL,
        "Needs to be called between BeginTabBar() and EndTabBar()!");
    return false;
  }
  return TabItemEx(tab_bar, label, NULL,
                   flags | TabItemFlags_Button | TabItemFlags_NoReorder, NULL);
}

inline bool Gui::TabItemEx(TabBar *tab_bar, const char *label, bool *p_open,
                           TabItemFlags flags, Window *docked_window) {
  // Layout whole tab bar if not already done
  Context &g = *GGui;
  if (tab_bar->WantLayout) {
    NextItemData backup_next_item_data = g.NextItemData;
    TabBarLayout(tab_bar);
    g.NextItemData = backup_next_item_data;
  }
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return false;

  const Style &style = g.Style;
  const ID id = TabBarCalcTabID(tab_bar, label, docked_window);

  // If the user called us with *p_open == false, we early out and don't render.
  // We make a call to ItemAdd() so that attempts to use a contextual popup menu
  // with an implicit ID won't use an older ID.
  GUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
  if (p_open && !*p_open) {
    ItemAdd(Rect(), id, NULL, ItemFlags_NoNav);
    return false;
  }

  GUI_ASSERT(!p_open || !(flags & TabItemFlags_Button));
  GUI_ASSERT((flags & (TabItemFlags_Leading | TabItemFlags_Trailing)) !=
             (TabItemFlags_Leading |
              TabItemFlags_Trailing)); // Can't use both Leading and Trailing

  // Store into TabItemFlags_NoCloseButton, also honor
  // TabItemFlags_NoCloseButton passed by user (although not documented)
  if (flags & TabItemFlags_NoCloseButton)
    p_open = NULL;
  else if (p_open == NULL)
    flags |= TabItemFlags_NoCloseButton;

  // Acquire tab data
  TabItem *tab = TabBarFindTabByID(tab_bar, id);
  bool tab_is_new = false;
  if (tab == NULL) {
    tab_bar->Tabs.push_back(TabItem());
    tab = &tab_bar->Tabs.back();
    tab->ID = id;
    tab_bar->TabsAddedNew = tab_is_new = true;
  }
  tab_bar->LastTabItemIdx = (S16)tab_bar->Tabs.index_from_ptr(tab);

  // Calculate tab contents size
  Vec2 size = TabItemCalcSize(
      label, (p_open != NULL) || (flags & TabItemFlags_UnsavedDocument));
  tab->RequestedWidth = -1.0f;
  if (g.NextItemData.Flags & NextItemDataFlags_HasWidth)
    size.x = tab->RequestedWidth = g.NextItemData.Width;
  if (tab_is_new)
    tab->Width = Max(1.0f, size.x);
  tab->ContentWidth = size.x;
  tab->BeginOrder = tab_bar->TabsActiveCount++;

  const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
  const bool tab_bar_focused = (tab_bar->Flags & TabBarFlags_IsFocused) != 0;
  const bool tab_appearing = (tab->LastFrameVisible + 1 < g.FrameCount);
  const bool tab_just_unsaved = (flags & TabItemFlags_UnsavedDocument) &&
                                !(tab->Flags & TabItemFlags_UnsavedDocument);
  const bool is_tab_button = (flags & TabItemFlags_Button) != 0;
  tab->LastFrameVisible = g.FrameCount;
  tab->Flags = flags;

  // Append name _WITH_ the zero-terminator
  if (docked_window != NULL) {
    GUI_ASSERT(docked_window == NULL); // master branch only
  } else {
    tab->NameOffset = (S32)tab_bar->TabsNames.size();
    tab_bar->TabsNames.append(label, label + strlen(label) + 1);
  }

  // Update selected tab
  if (!is_tab_button) {
    if (tab_appearing && (tab_bar->Flags & TabBarFlags_AutoSelectNewTabs) &&
        tab_bar->NextSelectedTabId == 0)
      if (!tab_bar_appearing || tab_bar->SelectedTabId == 0)
        TabBarQueueFocus(tab_bar, tab); // New tabs gets activated
    if ((flags & TabItemFlags_SetSelected) &&
        (tab_bar->SelectedTabId !=
         id)) // _SetSelected can only be passed on explicit tab bar
      TabBarQueueFocus(tab_bar, tab);
  }

  // Lock visibility
  // (Note: tab_contents_visible != tab_selected... because CTRL+TAB operations
  // may preview some tabs without selecting them!)
  bool tab_contents_visible = (tab_bar->VisibleTabId == id);
  if (tab_contents_visible)
    tab_bar->VisibleTabWasSubmitted = true;

  // On the very first frame of a tab bar we let first tab contents be visible
  // to minimize appearing glitches
  if (!tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing)
    if (tab_bar->Tabs.Size == 1 &&
        !(tab_bar->Flags & TabBarFlags_AutoSelectNewTabs))
      tab_contents_visible = true;

  // Note that tab_is_new is not necessarily the same as tab_appearing! When a
  // tab bar stops being submitted and then gets submitted again, the tabs will
  // have 'tab_appearing=true' but 'tab_is_new=false'.
  if (tab_appearing && (!tab_bar_appearing || tab_is_new)) {
    ItemAdd(Rect(), id, NULL, ItemFlags_NoNav);
    if (is_tab_button)
      return false;
    return tab_contents_visible;
  }

  if (tab_bar->SelectedTabId == id)
    tab->LastFrameSelected = g.FrameCount;

  // Backup current layout position
  const Vec2 backup_main_cursor_pos = window->DC.CursorPos;

  // Layout
  const bool is_central_section = (tab->Flags & TabItemFlags_SectionMask_) == 0;
  size.x = tab->Width;
  if (is_central_section)
    window->DC.CursorPos =
        Add(tab_bar->BarRect.Min,
            Vec2(GUI_TRUNC(tab->Offset - tab_bar->ScrollingAnim), 0.0f));
  else
    window->DC.CursorPos = Add(tab_bar->BarRect.Min, Vec2(tab->Offset, 0.0f));
  Vec2 pos = window->DC.CursorPos;
  Rect bb(pos, Add(pos, size));

  // We don't have CPU clipping primitives to clip the CloseButton (until it
  // becomes a texture), so need to add an extra draw call (temporary in the
  // case of vertical animation)
  const bool want_clip_rect =
      is_central_section && (bb.Min.x < tab_bar->ScrollingRectMinX ||
                             bb.Max.x > tab_bar->ScrollingRectMaxX);
  if (want_clip_rect)
    PushClipRect(Vec2(Max(bb.Min.x, tab_bar->ScrollingRectMinX), bb.Min.y - 1),
                 Vec2(tab_bar->ScrollingRectMaxX, bb.Max.y), true);

  Vec2 backup_cursor_max_pos = window->DC.CursorMaxPos;
  ItemSize(bb.GetSize(), style.FramePadding.y);
  window->DC.CursorMaxPos = backup_cursor_max_pos;

  if (!ItemAdd(bb, id)) {
    if (want_clip_rect)
      PopClipRect();
    window->DC.CursorPos = backup_main_cursor_pos;
    return tab_contents_visible;
  }

  // Click to Select a tab
  // Allow the close button to overlap
  ButtonFlags button_flags = ((is_tab_button ? ButtonFlags_PressedOnClickRelease
                                             : ButtonFlags_PressedOnClick) |
                              ButtonFlags_AllowOverlap);
  if (g.DragDropActive)
    button_flags |= ButtonFlags_PressedOnDragDropHold;
  bool hovered, held;
  bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
  if (pressed && !is_tab_button)
    TabBarQueueFocus(tab_bar, tab);

  // Drag and drop: re-order tabs
  if (held && !tab_appearing && IsMouseDragging(0)) {
    if (!g.DragDropActive && (tab_bar->Flags & TabBarFlags_Reorderable)) {
      // While moving a tab it will jump on the other side of the mouse, so we
      // also test for MouseDelta.x
      if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x) {
        TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);
      } else if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x) {
        TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);
      }
    }
  }

#if 0
    if (hovered && g.HoveredIdNotActiveTimer > TOOLTIP_DELAY && bb.GetWidth() < tab->ContentWidth)
    {
        // Enlarge tab display when hovering
        bb.Max.x = bb.Min.x + GUI_TRUNC(Lerp(bb.GetWidth(), tab->ContentWidth,Saturate((g.HoveredIdNotActiveTimer - 0.40f) * 6.0f)));
        display_draw_list = GetForegroundDrawList(window);
        TabItemBackground(display_draw_list, bb, flags, GetColorU32(Col_TitleBgActive));
    }
#endif

  // Render tab shape
  DrawList *display_draw_list = window->DrawList;
  const U32 tab_col = GetColorU32(
      (held || hovered) ? Col_TabHovered
      : tab_contents_visible
          ? (tab_bar_focused ? Col_TabActive : Col_TabUnfocusedActive)
          : (tab_bar_focused ? Col_Tab : Col_TabUnfocused));
  TabItemBackground(display_draw_list, bb, flags, tab_col);
  RenderNavHighlight(bb, id);

  // Select with right mouse button. This is so the common idiom for context
  // menu automatically highlight the current widget.
  const bool hovered_unblocked =
      IsItemHovered(HoveredFlags_AllowWhenBlockedByPopup);
  if (hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)) &&
      !is_tab_button)
    TabBarQueueFocus(tab_bar, tab);

  if (tab_bar->Flags & TabBarFlags_NoCloseWithMiddleMouseButton)
    flags |= TabItemFlags_NoCloseWithMiddleMouseButton;

  // Render tab label, process close button
  const ID close_button_id = p_open ? GetIDWithSeed("#CLOSE", NULL, id) : 0;
  bool just_closed;
  bool text_clipped;
  TabItemLabelAndCloseButton(
      display_draw_list, bb,
      tab_just_unsaved ? (flags & ~TabItemFlags_UnsavedDocument) : flags,
      tab_bar->FramePadding, label, id, close_button_id, tab_contents_visible,
      &just_closed, &text_clipped);
  if (just_closed && p_open != NULL) {
    *p_open = false;
    TabBarCloseTab(tab_bar, tab);
  }

  // Restore main window position so user can draw there
  if (want_clip_rect)
    PopClipRect();
  window->DC.CursorPos = backup_main_cursor_pos;

  // Tooltip
  // (Won't work over the close button because ItemOverlap systems messes up
  // with HoveredIdTimer-> seems ok) (We test IsItemHovered() to discard e.g.
  // when another item is active or drag and drop over the tab bar, which
  // g.HoveredId ignores)
  // FIXME: This is a mess.
  // FIXME: We may want disabled tab to still display the tooltip?
  if (text_clipped && g.HoveredId == id && !held)
    if (!(tab_bar->Flags & TabBarFlags_NoTooltip) &&
        !(tab->Flags & TabItemFlags_NoTooltip))
      SetItemTooltip("%.*s", (int)(FindRenderedTextEnd(label) - label), label);

  GUI_ASSERT(!is_tab_button ||
             !(tab_bar->SelectedTabId == tab->ID &&
               is_tab_button)); // TabItemButton should not be selected
  if (is_tab_button)
    return pressed;
  return tab_contents_visible;
}

// [Public] This is call is 100% optional but it allows to remove some one-frame
// glitches when a tab has been unexpectedly removed. To use it to need to call
// the function SetTabItemClosed() between BeginTabBar() and EndTabBar(). Tabs
// closed by the close button will automatically be flagged to avoid this issue.
inline void Gui::SetTabItemClosed(const char *label) {
  Context &g = *GGui;
  bool is_within_manual_tab_bar =
      g.CurrentTabBar && !(g.CurrentTabBar->Flags & TabBarFlags_DockNode);
  if (is_within_manual_tab_bar) {
    TabBar *tab_bar = g.CurrentTabBar;
    ID tab_id = TabBarCalcTabID(tab_bar, label, NULL);
    if (TabItem *tab = TabBarFindTabByID(tab_bar, tab_id))
      tab->WantClose = true; // Will be processed by next call to TabBarLayout()
  }
}

inline Vec2 Gui::TabItemCalcSize(const char *label,
                                 bool has_close_button_or_unsaved_marker) {
  Context &g = *GGui;
  Vec2 label_size = CalcTextSize(label, NULL, true);
  Vec2 size = Vec2(label_size.x + g.Style.FramePadding.x,
                   label_size.y + g.Style.FramePadding.y * 2.0f);
  if (has_close_button_or_unsaved_marker)
    size.x +=
        g.Style.FramePadding.x +
        (g.Style.ItemInnerSpacing.x +
         g.FontSize); // We use Y intentionally to fit the close button circle.
  else
    size.x += g.Style.FramePadding.x + 1.0f;
  return Vec2(Min(size.x, TabBarCalcMaxTabWidth()), size.y);
}

inline Vec2 Gui::TabItemCalcSize(Window *) {
  GUI_ASSERT(
      0); // This function exists to facilitate merge with 'docking' branch.
  return Vec2(0.0f, 0.0f);
}

inline void Gui::TabItemBackground(DrawList *draw_list, const Rect &bb,
                                   TabItemFlags flags, U32 col) {
  // While rendering tabs, we trim 1 pixel off the top of our bounding box so
  // they can fit within a regular frame height while looking "detached" from
  // it.
  Context &g = *GGui;
  const float width = bb.GetWidth();
  GUI_UNUSED(flags);
  GUI_ASSERT(width > 0.0f);
  const float rounding =
      Max(0.0f, Min((flags & TabItemFlags_Button) ? g.Style.FrameRounding
                                                  : g.Style.TabRounding,
                    width * 0.5f - 1.0f));
  const float y1 = bb.Min.y + 1.0f;
  const float y2 = bb.Max.y - g.Style.TabBarBorderSize;
  draw_list->PathLineTo(Vec2(bb.Min.x, y2));
  draw_list->PathArcToFast(Vec2(bb.Min.x + rounding, y1 + rounding), rounding,
                           6, 9);
  draw_list->PathArcToFast(Vec2(bb.Max.x - rounding, y1 + rounding), rounding,
                           9, 12);
  draw_list->PathLineTo(Vec2(bb.Max.x, y2));
  draw_list->PathFillConvex(col);
  if (g.Style.TabBorderSize > 0.0f) {
    draw_list->PathLineTo(Vec2(bb.Min.x + 0.5f, y2));
    draw_list->PathArcToFast(
        Vec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);
    draw_list->PathArcToFast(
        Vec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9,
        12);
    draw_list->PathLineTo(Vec2(bb.Max.x - 0.5f, y2));
    draw_list->PathStroke(GetColorU32(Col_Border), 0, g.Style.TabBorderSize);
  }
}

// Render text label (with custom clipping) + Unsaved Document marker + Close
// Button logic We tend to lock style.FramePadding for a given tab-bar, hence
// the 'frame_padding' parameter.
inline void Gui::TabItemLabelAndCloseButton(
    DrawList *draw_list, const Rect &bb, TabItemFlags flags, Vec2 frame_padding,
    const char *label, ID tab_id, ID close_button_id, bool is_contents_visible,
    bool *out_just_closed, bool *out_text_clipped) {
  Context &g = *GGui;
  Vec2 label_size = CalcTextSize(label, NULL, true);

  if (out_just_closed)
    *out_just_closed = false;
  if (out_text_clipped)
    *out_text_clipped = false;

  if (bb.GetWidth() <= 1.0f)
    return;

    // In Style V2 we'll have full override of all colors per state (e.g.
    // focused, selected) But right now if you want to alter text color of tabs
    // this is what you need to do.
#if 0
    const float backup_alpha = g.Style.Alpha;
    if (!is_contents_visible)
        g.Style.Alpha *= 0.7f;
#endif

  // Render text label (with clipping + alpha gradient) + unsaved marker
  Rect text_pixel_clip_bb(bb.Min.x + frame_padding.x,
                          bb.Min.y + frame_padding.y,
                          bb.Max.x - frame_padding.x, bb.Max.y);
  Rect text_ellipsis_clip_bb = text_pixel_clip_bb;

  // Return clipped state ignoring the close button
  if (out_text_clipped) {
    *out_text_clipped =
        (text_ellipsis_clip_bb.Min.x + label_size.x) > text_pixel_clip_bb.Max.x;
    // draw_list->AddCircle(text_ellipsis_clip_bb.Min, 3.0f, *out_text_clipped ?
    // GUI_COL32(255, 0, 0, 255) : GUI_COL32(0, 255, 0, 255));
  }

  const float button_sz = g.FontSize;
  const Vec2 button_pos(Max(bb.Min.x, bb.Max.x - frame_padding.x - button_sz),
                        bb.Min.y + frame_padding.y);

  // Close Button & Unsaved Marker
  // We are relying on a subtle and confusing distinction between 'hovered' and
  // 'g.HoveredId' which happens because we are using
  // ButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
  //  'hovered' will be true when hovering the Tab but NOT when hovering the
  //  close button 'g.HoveredId==id' will be true when hovering the Tab
  //  including when hovering the close button 'g.ActiveId==close_button_id'
  //  will be true when we are holding on the close button, in which case both
  //  hovered booleans are false
  bool close_button_pressed = false;
  bool close_button_visible = false;
  if (close_button_id != 0)
    if (is_contents_visible ||
        bb.GetWidth() >= Max(button_sz, g.Style.TabMinWidthForCloseButton))
      if (g.HoveredId == tab_id || g.HoveredId == close_button_id ||
          g.ActiveId == tab_id || g.ActiveId == close_button_id)
        close_button_visible = true;
  bool unsaved_marker_visible = (flags & TabItemFlags_UnsavedDocument) != 0 &&
                                (button_pos.x + button_sz <= bb.Max.x);

  if (close_button_visible) {
    LastItemData last_item_backup = g.LastItemData;
    if (CloseButton(close_button_id, button_pos))
      close_button_pressed = true;
    g.LastItemData = last_item_backup;

    // Close with middle mouse button
    if (!(flags & TabItemFlags_NoCloseWithMiddleMouseButton) &&
        IsMouseClicked(2))
      close_button_pressed = true;
  } else if (unsaved_marker_visible) {
    const Rect bullet_bb(button_pos,
                         Add(button_pos, Vec2(button_sz, button_sz)));
    RenderBullet(draw_list, bullet_bb.GetCenter(), GetColorU32(Col_Text));
  }

  // This is all rather complicated
  // (the main idea is that because the close button only appears on hover, we
  // don't want it to alter the ellipsis position)
  // FIXME: if FramePadding is noticeably large, ellipsis_max_x will be wrong
  // here (e.g. #3497), maybe for consistency that parameter of
  // RenderTextEllipsis() shouldn't exist..
  float ellipsis_max_x =
      close_button_visible ? text_pixel_clip_bb.Max.x : bb.Max.x - 1.0f;
  if (close_button_visible || unsaved_marker_visible) {
    text_pixel_clip_bb.Max.x -=
        close_button_visible ? (button_sz) : (button_sz * 0.80f);
    text_ellipsis_clip_bb.Max.x -=
        unsaved_marker_visible ? (button_sz * 0.80f) : 0.0f;
    ellipsis_max_x = text_pixel_clip_bb.Max.x;
  }
  RenderTextEllipsis(draw_list, text_ellipsis_clip_bb.Min,
                     text_ellipsis_clip_bb.Max, text_pixel_clip_bb.Max.x,
                     ellipsis_max_x, label, NULL, &label_size);

#if 0
    if (!is_contents_visible)
        g.Style.Alpha = backup_alpha;
#endif

  if (out_just_closed)
    *out_just_closed = close_button_pressed;
}
// dear gui, v1.90.1 WIP
// (tables and columns code)

/*

Index of this file:

// [SECTION] Commentary
// [SECTION] Header mess
// [SECTION] Tables: Main code
// [SECTION] Tables: Simple accessors
// [SECTION] Tables: Row changes
// [SECTION] Tables: Columns changes
// [SECTION] Tables: Columns width management
// [SECTION] Tables: Drawing
// [SECTION] Tables: Sorting
// [SECTION] Tables: Headers
// [SECTION] Tables: Context Menu
// [SECTION] Tables: Settings (.ini data)
// [SECTION] Tables: Garbage Collection
// [SECTION] Tables: Debugging
// [SECTION] Columns, BeginColumns, EndColumns, etc.

*/

// Navigating this file:
// - In Visual Studio IDE: CTRL+comma ("Edit.GoToAll") can follow symbols in
// comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
// - With Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can
// also follow symbols in comments.

//-----------------------------------------------------------------------------
// [SECTION] Commentary
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typical tables call flow: (root level is generally public API):
//-----------------------------------------------------------------------------
// - BeginTable()                               user begin into a table
//    | BeginChild()                            - (if ScrollX/ScrollY is set)
//    | TableBeginInitMemory()                  - first time table is used
//    | TableResetSettings()                    - on settings reset
//    | TableLoadSettings()                     - on settings load
//    | TableBeginApplyRequests()               - apply queued
//    resizing/reordering/hiding requests | - TableSetColumnWidth() - apply
//    resizing width (for mouse resize, often requested by previous frame) | -
//    TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch
//    columns) from their respective width
// - TableSetupColumn()                         user submit columns details
// (optional)
// - TableSetupScrollFreeze()                   user submit scroll freeze
// information (optional)
//-----------------------------------------------------------------------------
// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup
// everything: widths, columns positions, clipping rectangles. Automatically
// called by the FIRST call to TableNextRow() or TableHeadersRow().
//    | TableSetupDrawChannels()                - setup DrawList channels
//    | TableUpdateBorders()                    - detect hovering columns for
//    resize, ahead of contents submission | TableBeginContextMenuPopup() | -
//    TableDrawDefaultContextMenu()         - draw right-click context menu
//    contents
//-----------------------------------------------------------------------------
// - TableHeadersRow() or TableHeader()         user submit a headers row
// (optional)
//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort
//    order and sort direction | TableOpenContextMenu()                  - when
//    right-clicked: trigger opening of the default context menu
// - TableGetSortSpecs()                        user queries updated sort specs
// (optional, generally after submitting headers)
// - TableNextRow()                             user begin into a new row (also
// automatically called by TableHeadersRow())
//    | TableEndRow()                           - finish existing row
//    | TableBeginRow()                         - add a new row
// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell
//    | TableEndCell()                          - close existing column/cell
//    | TableBeginCell()                        - enter into current column/cell
// - [...]                                      user emit contents
//-----------------------------------------------------------------------------
// - EndTable()                                 user ends the table
//    | TableDrawBorders()                      - draw outer borders, inner
//    vertical borders | TableMergeDrawChannels()                - merge draw
//    channels if clipping isn't required | EndChild() - (if ScrollX/ScrollY is
//    set)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// TABLE SIZING
//-----------------------------------------------------------------------------
// (Read carefully because this is subtle but it does make sense!)
//-----------------------------------------------------------------------------
// About 'outer_size':
// Its meaning needs to differ slightly depending on if we are using
// ScrollX/ScrollY flags. Default value is Vec2(0.0f, 0.0f).
//   X
//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most
//   edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.
//   - outer_size.x  > 0.0f  ->  Set Fixed width.
//   Y with ScrollX/ScrollY disabled: we output table directly in current window
//   - outer_size.y  < 0.0f  ->  Bottom-align (but will auto extend, unless
//   _NoHostExtendY is set). Not meaningful if parent window can vertically
//   scroll.
//   - outer_size.y  = 0.0f  ->  No minimum height (but will auto extend, unless
//   _NoHostExtendY is set)
//   - outer_size.y  > 0.0f  ->  Set Minimum height (but will auto extend,
//   unless _NoHostExtendY is set) Y with ScrollX/ScrollY enabled: using a child
//   window for scrolling
//   - outer_size.y  < 0.0f  ->  Bottom-align. Not meaningful if parent window
//   can vertically scroll.
//   - outer_size.y  = 0.0f  ->  Bottom-align, consistent with BeginChild(). Not
//   recommended unless table is last item in parent window.
//   - outer_size.y  > 0.0f  ->  Set Exact height. Recommended when using
//   Scrolling on any axis.
//-----------------------------------------------------------------------------
// Outer size is also affected by the NoHostExtendX/NoHostExtendY flags.
// Important to note how the two flags have slightly different behaviors!
//   - TableFlags_NoHostExtendX -> Make outer width auto-fit to columns
//   (overriding outer_size.x value). Only available when ScrollX/ScrollY are
//   disabled and Stretch columns are not used.
//   - TableFlags_NoHostExtendY -> Make outer height stop exactly at
//   outer_size.y (prevent auto-extending table past the limit). Only available
//   when ScrollX/ScrollY is disabled. Data below the limit will be clipped and
//   not visible.
// In theory TableFlags_NoHostExtendY could be the default and any
// non-scrolling tables with outer_size.y != 0.0f would use exact height. This
// would be consistent but perhaps less useful and more confusing (as vertically
// clipped items are not useful and not easily noticeable).
//-----------------------------------------------------------------------------
// About 'inner_width':
//   With ScrollX disabled:
//   - inner_width          ->  *ignored*
//   With ScrollX enabled:
//   - inner_width  < 0.0f  ->  *illegal* fit in known width (right align from
//   outer_size.x) <-- weird
//   - inner_width  = 0.0f  ->  fit in outer_width: Fixed size columns will take
//   space they need (if avail, otherwise shrink down), Stretch columns becomes
//   Fixed columns.
//   - inner_width  > 0.0f  ->  override scrolling width, generally to be larger
//   than outer_size.x. Fixed column take space they need (if avail, otherwise
//   shrink down), Stretch columns share remaining space!
//-----------------------------------------------------------------------------
// Details:
// - If you want to use Stretch columns with ScrollX, you generally need to
// specify 'inner_width' otherwise the concept
//   of "available space" doesn't make sense.
// - Even if not really useful, we allow 'inner_width < outer_size.x' for
// consistency and to facilitate understanding
//   of what the value does.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// COLUMNS SIZING POLICIES
// (Reference: TableFlags_SizingXXX flags and
// TableColumnFlags_WidthXXX flags)
//-----------------------------------------------------------------------------
// About overriding column sizing policy and width/weight with
// TableSetupColumn(): We use a default parameter of -1 for
// 'init_width'/'init_weight'.
//   - with TableColumnFlags_WidthFixed,    init_width  <= 0 (default)  -->
//   width is automatic
//   - with TableColumnFlags_WidthFixed,    init_width  >  0 (explicit) -->
//   width is custom
//   - with TableColumnFlags_WidthStretch,  init_weight <= 0 (default)  -->
//   weight is 1.0f
//   - with TableColumnFlags_WidthStretch,  init_weight >  0 (explicit) -->
//   weight is custom
// Widths are specified _without_ CellPadding. If you specify a width of 100.0f,
// the column will be cover (100.0f + Padding * 2.0f) and you can fit a 100.0f
// wide item in it without clipping and with padding honored.
//-----------------------------------------------------------------------------
// About default sizing policy (if you don't specify a
// TableColumnFlags_WidthXXXX flag)
//   - with Table policy TableFlags_SizingFixedFit      --> default Column
//   policy is TableColumnFlags_WidthFixed, default Width is equal to
//   contents width
//   - with Table policy TableFlags_SizingFixedSame     --> default Column
//   policy is TableColumnFlags_WidthFixed, default Width is max of all
//   contents width
//   - with Table policy TableFlags_SizingStretchSame   --> default Column
//   policy is TableColumnFlags_WidthStretch, default Weight is 1.0f
//   - with Table policy TableFlags_SizingStretchWeight --> default Column
//   policy is TableColumnFlags_WidthStretch, default Weight is
//   proportional to contents
// Default Width and default Weight can be overridden when calling
// TableSetupColumn().
//-----------------------------------------------------------------------------
// About mixing Fixed/Auto and Stretch columns together:
//   - the typical use of mixing sizing policies is: any number of LEADING Fixed
//   columns, followed by one or two TRAILING Stretch columns.
//   - using mixed policies with ScrollX does not make much sense, as using
//   Stretch columns with ScrollX does not make much sense in the first place!
//     that is, unless 'inner_width' is passed to BeginTable() to explicitly
//     provide a total width to layout columns in.
//   - when using TableFlags_SizingFixedSame with mixed columns, only the
//   Fixed/Auto columns will match their widths to the width of the maximum
//   contents.
//   - when using TableFlags_SizingStretchSame with mixed columns, only the
//   Stretch columns will match their weights/widths.
//-----------------------------------------------------------------------------
// About using column width:
// If a column is manually resizable or has a width specified with
// TableSetupColumn():
//   - you may use GetContentRegionAvail().x to query the width available in a
//   given column.
//   - right-side alignment features such as SetNextItemWidth(-x) or
//   PushItemWidth(-x) will rely on this width.
// If the column is not resizable and has no width specified with
// TableSetupColumn():
//   - its width will be automatic and be set to the max of items submitted.
//   - therefore you generally cannot have ALL items of the columns use e.g.
//   SetNextItemWidth(-FLT_MIN).
//   - but if the column has one or more items of known/fixed size, this will
//   become the reference width used by SetNextItemWidth(-FLT_MIN).
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// TABLES CLIPPING/CULLING
//-----------------------------------------------------------------------------
// About clipping/culling of Rows in Tables:
// - For large numbers of rows, it is recommended you use ListClipper to
// submit only visible rows.
//   ListClipper is reliant on the fact that rows are of equal height.
//   See 'Demo->Tables->Vertical Scrolling' or 'Demo->Tables->Advanced' for a
//   demo of using the clipper.
// - Note that auto-resizing columns don't play well with using the clipper.
//   By default a table with _ScrollX but without _Resizable will have column
//   auto-resize. So, if you want to use the clipper, make sure to either enable
//   _Resizable, either setup columns width explicitly with _WidthFixed.
//-----------------------------------------------------------------------------
// About clipping/culling of Columns in Tables:
// - Both TableSetColumnIndex() and TableNextColumn() return true when the
// column is visible or performing
//   width measurements. Otherwise, you may skip submitting the contents of a
//   cell/column, BUT ONLY if you know it is not going to contribute to row
//   height. In many situations, you may skip submitting contents for every
//   column but one (e.g. the first one).
// - Case A: column is not hidden by user, and at least partially in sight (most
// common case).
// - Case B: column is clipped / out of sight (because of scrolling or parent
// ClipRect): TableNextColumn() return false as a hint but we still allow layout
// output.
// - Case C: column is hidden explicitly by the user (e.g. via the context menu,
// or _DefaultHide column flag, etc.).
//
//                        [A]         [B]          [C]
//  TableNextColumn():    true        false        false       -> [userland]
//  when TableNextColumn() / TableSetColumnIndex() returns false, user can skip
//  submitting items but only if the column doesn't contribute to row height.
//          SkipItems:    false       false        true        -> [internal]
//          when SkipItems is true, most widgets will early out if submitted,
//          resulting is no layout output.
//           ClipRect:    normal      zero-width   zero-width  -> [internal]
//           when ClipRect is zero, ItemAdd() will return false and most widgets
//           will early out mid-way.
//  DrawList output:    normal      dummy        dummy       -> [internal]
//  when using the dummy channel, DrawList submissions (if any) will be wasted
//  (because cliprect is zero-width anyway).
//
// - We need to distinguish those cases because non-hidden columns that are
// clipped outside of scrolling bounds should still contribute their height to
// the row.
//   However, in the majority of cases, the contribution to row height is the
//   same for all columns, or the tallest cells are known by the programmer.
//-----------------------------------------------------------------------------
// About clipping/culling of whole Tables:
// - Scrolling tables with a known outer size can be clipped earlier as
// BeginTable() will return false.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef GUI_DEFINE_MATH_OPERATORS
#define GUI_DEFINE_MATH_OPERATORS
#endif

#ifndef GUI_DISABLE

// System includes
#include <stdint.h> // intptr_t

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning(disable : 4127) // condition expression is constant
#pragma warning(                                                               \
    disable : 4996) // 'This function or variable may be unsafe': strcpy,
                    // strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning(disable : 5054) // operator '|': deprecated between enumerations
                                // of different types
#endif
#pragma warning(                                                               \
    disable : 26451) // [Static Analyzer] Arithmetic overflow : Using operator
                     // 'xxx' on a 4 byte value and then casting the result to a
                     // 8 byte value. Cast the value to the wider type before
                     // calling operator 'xxx' to avoid overflow(io.2).
#pragma warning(                                                               \
    disable : 26812) // [Static Analyzer] The enum type 'xxx' is unscoped.
                     // Prefer 'enum class' over 'enum' (Enum.3).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored                                               \
    "-Wunknown-warning-option" // warning: unknown warning group 'xxx' // not
                               // all warnings are known by all Clang versions
                               // and they tend to be rename-happy.. so ignoring
                               // warnings triggers new warnings on some
                               // configuration. Great!
#endif
#pragma clang diagnostic ignored                                               \
    "-Wunknown-pragmas" // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored                                               \
    "-Wold-style-cast" // warning: use of old-style cast // yes, they are more
                       // terse.
#pragma clang diagnostic ignored                                               \
    "-Wfloat-equal" // warning: comparing floating point with == or != is unsafe
                    // // storing and comparing against same constants
                    // (typically 0.0f) is ok.
#pragma clang diagnostic ignored                                               \
    "-Wformat-nonliteral" // warning: format string is not a string literal //
                          // passing non-literal to vsnformat(). yes, user
                          // passing incorrect format strings can crash the
                          // code.
#pragma clang diagnostic ignored                                               \
    "-Wsign-conversion" // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored                                               \
    "-Wzero-as-null-pointer-constant" // warning: zero as null pointer constant
                                      // // some standard header variations use
                                      // #define NULL 0
#pragma clang diagnostic ignored                                               \
    "-Wdouble-promotion" // warning: implicit conversion from 'float' to
                         // 'double' when passing argument to function  // using
                         // printf() is a misery with this as C++ va_arg
                         // ellipsis changes float to double.
#pragma clang diagnostic ignored                                               \
    "-Wenum-enum-conversion" // warning: bitwise operation between different
                             // enumeration types ('XXXFlags_' and
                             // 'XXXFlagsPrivate_')
#pragma clang diagnostic ignored                                               \
    "-Wdeprecated-enum-enum-conversion" // warning: bitwise operation between
                                        // different enumeration types
                                        // ('XXXFlags_' and 'XXXFlagsPrivate_')
                                        // is deprecated
#pragma clang diagnostic ignored                                               \
    "-Wimplicit-int-float-conversion" // warning: implicit conversion from 'xxx'
                                      // to 'float' may lose precision
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored                                                 \
    "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored                                                 \
    "-Wformat-nonliteral" // warning: format not a string literal, format string
                          // not checked
#pragma GCC diagnostic ignored                                                 \
    "-Wclass-memaccess" // [__GNUC__ >= 8] warning: 'memset/memcpy'
                        // clearing/writing an object of type 'xxxx' with no
                        // trivial copy-assignment; use assignment or
                        // value-initialization instead
#endif

//-----------------------------------------------------------------------------
// [SECTION] Tables: Main code
//-----------------------------------------------------------------------------
// - TableFixFlags() [Internal]
// - TableFindByID() [Internal]
// - BeginTable()
// - BeginTableEx() [Internal]
// - TableBeginInitMemory() [Internal]
// - TableBeginApplyRequests() [Internal]
// - TableSetupColumnFlags() [Internal]
// - TableUpdateLayout() [Internal]
// - TableUpdateBorders() [Internal]
// - EndTable()
// - TableSetupColumn()
// - TableSetupScrollFreeze()
//-----------------------------------------------------------------------------

// Configuration
static const int TABLE_DRAW_CHANNEL_BG0 = 0;
static const int TABLE_DRAW_CHANNEL_BG2_FROZEN = 1;
static const int TABLE_DRAW_CHANNEL_NOCLIP =
    2; // When using TableFlags_NoClip (this becomes the last visible
       // channel)
static const float TABLE_BORDER_SIZE =
    1.0f; // FIXME-TABLE: Currently hard-coded because of clipping assumptions
          // with outer borders rendering.
static const float TABLE_RESIZE_SEPARATOR_HALF_THICKNESS =
    4.0f; // Extend outside inner borders.
static const float TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER =
    0.06f; // Delay/timer before making the hover feedback (color+cursor)
           // visible because tables/columns tends to be more cramped.

// Helper
inline TableFlags TableFixFlags(TableFlags flags, Window *outer_window) {
  // Adjust flags: set default sizing policy
  if ((flags & TableFlags_SizingMask_) == 0)
    flags |= ((flags & TableFlags_ScrollX) ||
              (outer_window->Flags & WindowFlags_AlwaysAutoResize))
                 ? TableFlags_SizingFixedFit
                 : TableFlags_SizingStretchSame;

  // Adjust flags: enable NoKeepColumnsVisible when using
  // TableFlags_SizingFixedSame
  if ((flags & TableFlags_SizingMask_) == TableFlags_SizingFixedSame)
    flags |= TableFlags_NoKeepColumnsVisible;

  // Adjust flags: enforce borders when resizable
  if (flags & TableFlags_Resizable)
    flags |= TableFlags_BordersInnerV;

  // Adjust flags: disable NoHostExtendX/NoHostExtendY if we have any scrolling
  // going on
  if (flags & (TableFlags_ScrollX | TableFlags_ScrollY))
    flags &= ~(TableFlags_NoHostExtendX | TableFlags_NoHostExtendY);

  // Adjust flags: NoBordersInBodyUntilResize takes priority over
  // NoBordersInBody
  if (flags & TableFlags_NoBordersInBodyUntilResize)
    flags &= ~TableFlags_NoBordersInBody;

  // Adjust flags: disable saved settings if there's nothing to save
  if ((flags & (TableFlags_Resizable | TableFlags_Hideable |
                TableFlags_Reorderable | TableFlags_Sortable)) == 0)
    flags |= TableFlags_NoSavedSettings;

  // Inherit _NoSavedSettings from top-level window (child windows always have
  // _NoSavedSettings set)
  if (outer_window->RootWindow->Flags & WindowFlags_NoSavedSettings)
    flags |= TableFlags_NoSavedSettings;

  return flags;
}

// Read about "TABLE SIZING" at the top of this file.
inline bool Gui::BeginTable(const char *str_id, int columns_count,
                            TableFlags flags, const Vec2 &outer_size,
                            float inner_width) {
  ID id = GetID(str_id);
  return BeginTableEx(str_id, id, columns_count, flags, outer_size,
                      inner_width);
}

inline bool Gui::BeginTableEx(const char *name, ID id, int columns_count,
                              TableFlags flags, const Vec2 &outer_size,
                              float inner_width) {
  Context &g = *GGui;
  Window *outer_window = GetCurrentWindow();
  if (outer_window->SkipItems) // Consistent with other tables + beneficial side
                               // effect that assert on miscalling EndTable()
                               // will be more visible.
    return false;

  // Sanity checks
  GUI_ASSERT(columns_count > 0 && columns_count < GUI_TABLE_MAX_COLUMNS);
  if (flags & TableFlags_ScrollX)
    GUI_ASSERT(inner_width >= 0.0f);

  // If an outer size is specified ahead we will be able to early out when not
  // visible. Exact clipping criteria may evolve.
  const bool use_child_window =
      (flags & (TableFlags_ScrollX | TableFlags_ScrollY)) != 0;
  const Vec2 avail_size = GetContentRegionAvail();
  const Vec2 actual_outer_size =
      CalcItemSize(outer_size, Max(avail_size.x, 1.0f),
                   use_child_window ? Max(avail_size.y, 1.0f) : 0.0f);
  const Rect outer_rect(outer_window->DC.CursorPos,
                        Add(outer_window->DC.CursorPos, actual_outer_size));
  const bool outer_window_is_measuring_size =
      (outer_window->AutoFitFramesX > 0) ||
      (outer_window->AutoFitFramesY >
       0); // Doesn't apply to AlwaysAutoResize windows!
  if (use_child_window && IsClippedEx(outer_rect, 0) &&
      !outer_window_is_measuring_size) {
    ItemSize(outer_rect);
    return false;
  }

  // Acquire storage for the table
  Table *table = g.Tables.GetOrAddByKey(id);
  const TableFlags table_last_flags = table->Flags;

  // Acquire temporary buffers
  const int table_idx = g.Tables.GetIndex(table);
  if (++g.TablesTempDataStacked > g.TablesTempData.Size)
    g.TablesTempData.resize(g.TablesTempDataStacked, TableTempData());
  TableTempData *temp_data = table->TempData =
      &g.TablesTempData[g.TablesTempDataStacked - 1];
  temp_data->TableIndex = table_idx;
  table->DrawSplitter = &table->TempData->DrawSplitter;
  table->DrawSplitter->Clear();

  // Fix flags
  table->IsDefaultSizingPolicy = (flags & TableFlags_SizingMask_) == 0;
  flags = TableFixFlags(flags, outer_window);

  // Initialize
  const int previous_frame_active = table->LastFrameActive;
  const int instance_no =
      (previous_frame_active != g.FrameCount) ? 0 : table->InstanceCurrent + 1;
  table->ID = id;
  table->Flags = flags;
  table->LastFrameActive = g.FrameCount;
  table->OuterWindow = table->InnerWindow = outer_window;
  table->ColumnsCount = columns_count;
  table->IsLayoutLocked = false;
  table->InnerWidth = inner_width;
  temp_data->UserOuterSize = outer_size;

  // Instance data (for instance 0, TableID == TableInstanceID)
  ID instance_id;
  table->InstanceCurrent = (S16)instance_no;
  if (instance_no > 0) {
    GUI_ASSERT(table->ColumnsCount == columns_count &&
               "BeginTable(): Cannot change columns count mid-frame while "
               "preserving same ID");
    if (table->InstanceDataExtra.Size < instance_no)
      table->InstanceDataExtra.push_back(TableInstanceData());
    instance_id = GetIDWithSeed(
        instance_no, GetIDWithSeed("##Instances", NULL,
                                   id)); // Push "##Instances" followed by
                                         // (int)instance_no in ID stack.
  } else {
    instance_id = id;
  }
  TableInstanceData *table_instance =
      TableGetInstanceData(table, table->InstanceCurrent);
  table_instance->TableInstanceID = instance_id;

  // When not using a child window, WorkRect.Max will grow as we append
  // contents.
  if (use_child_window) {
    // Ensure no vertical scrollbar appears if we only want horizontal one, to
    // make flag consistent (we have no other way to disable vertical scrollbar
    // of a window while keeping the horizontal one showing)
    Vec2 override_content_size(FLT_MAX, FLT_MAX);
    if ((flags & TableFlags_ScrollX) && !(flags & TableFlags_ScrollY))
      override_content_size.y = FLT_MIN;

    // Ensure specified width (when not specified, Stretched columns will act as
    // if the width == OuterWidth and never lead to any scrolling). We don't
    // handle inner_width < 0.0f, we could potentially use it to right-align
    // based on the right side of the child window work rect, which would
    // require knowing ahead if we are going to have decoration taking
    // horizontal spaces (typically a vertical scrollbar).
    if ((flags & TableFlags_ScrollX) && inner_width > 0.0f)
      override_content_size.x = inner_width;

    if (override_content_size.x != FLT_MAX ||
        override_content_size.y != FLT_MAX)
      SetNextWindowContentSize(Vec2(
          override_content_size.x != FLT_MAX ? override_content_size.x : 0.0f,
          override_content_size.y != FLT_MAX ? override_content_size.y : 0.0f));

    // Reset scroll if we are reactivating it
    if ((table_last_flags & (TableFlags_ScrollX | TableFlags_ScrollY)) == 0)
      SetNextWindowScroll(Vec2(0.0f, 0.0f));

    // Create scrolling region (without border and zero window padding)
    WindowFlags child_flags = (flags & TableFlags_ScrollX)
                                  ? WindowFlags_HorizontalScrollbar
                                  : WindowFlags_None;
    BeginChildEx(name, instance_id, outer_rect.GetSize(), false, child_flags);
    table->InnerWindow = g.CurrentWindow;
    table->WorkRect = table->InnerWindow->WorkRect;
    table->OuterRect = table->InnerWindow->Rect();
    table->InnerRect = table->InnerWindow->InnerRect;
    GUI_ASSERT(table->InnerWindow->WindowPadding.x == 0.0f &&
               table->InnerWindow->WindowPadding.y == 0.0f &&
               table->InnerWindow->WindowBorderSize == 0.0f);

    // Allow submitting when host is measuring
    if (table->InnerWindow->SkipItems && outer_window_is_measuring_size)
      table->InnerWindow->SkipItems = false;

    // When using multiple instances, ensure they have the same amount of
    // horizontal decorations (aka vertical scrollbar) so stretched columns can
    // be aligned)
    if (instance_no == 0) {
      table->HasScrollbarYPrev = table->HasScrollbarYCurr;
      table->HasScrollbarYCurr = false;
    }
    table->HasScrollbarYCurr |= table->InnerWindow->ScrollbarY;
  } else {
    // For non-scrolling tables, WorkRect == OuterRect == InnerRect.
    // But at this point we do NOT have a correct value for .Max.y (unless a
    // height has been explicitly passed in). It will only be updated in
    // EndTable().
    table->WorkRect = table->OuterRect = table->InnerRect = outer_rect;
  }

  // Push a standardized ID for both child-using and not-child-using tables
  PushOverrideID(id);
  if (instance_no > 0)
    PushOverrideID(
        instance_id); // FIXME: Somehow this is not resolved by stack-tool, even
                      // tho GetIDWithSeed() submitted the symbol.

  // Backup a copy of host window members we will modify
  Window *inner_window = table->InnerWindow;
  table->HostIndentX = inner_window->DC.Indent.x;
  table->HostClipRect = inner_window->ClipRect;
  table->HostSkipItems = inner_window->SkipItems;
  temp_data->HostBackupWorkRect = inner_window->WorkRect;
  temp_data->HostBackupParentWorkRect = inner_window->ParentWorkRect;
  temp_data->HostBackupColumnsOffset = outer_window->DC.ColumnsOffset;
  temp_data->HostBackupPrevLineSize = inner_window->DC.PrevLineSize;
  temp_data->HostBackupCurrLineSize = inner_window->DC.CurrLineSize;
  temp_data->HostBackupCursorMaxPos = inner_window->DC.CursorMaxPos;
  temp_data->HostBackupItemWidth = outer_window->DC.ItemWidth;
  temp_data->HostBackupItemWidthStackSize =
      outer_window->DC.ItemWidthStack.Size;
  inner_window->DC.PrevLineSize = inner_window->DC.CurrLineSize =
      Vec2(0.0f, 0.0f);

  // Make left and top borders not overlap our contents by offsetting
  // HostClipRect (#6765) (we normally shouldn't alter HostClipRect as we rely
  // on TableMergeDrawChannels() expanding non-clipped column toward the limits
  // of that rectangle, in order for DrawListSplitter::Merge() to merge the
  // draw commands. However since the overlap problem only affect scrolling
  // tables in this case we can get away with doing it without extra cost).
  if (inner_window != outer_window) {
    if (flags & TableFlags_BordersOuterV)
      table->HostClipRect.Min.x =
          Min(table->HostClipRect.Min.x + TABLE_BORDER_SIZE,
              table->HostClipRect.Max.x);
    if (flags & TableFlags_BordersOuterH)
      table->HostClipRect.Min.y =
          Min(table->HostClipRect.Min.y + TABLE_BORDER_SIZE,
              table->HostClipRect.Max.y);
  }

  // Padding and Spacing
  // - None               ........Content..... Pad .....Content........
  // - PadOuter           | Pad ..Content..... Pad .....Content.. Pad |
  // - PadInner           ........Content.. Pad | Pad ..Content........
  // - PadOuter+PadInner  | Pad ..Content.. Pad | Pad ..Content.. Pad |
  const bool pad_outer_x = (flags & TableFlags_NoPadOuterX) ? false
                           : (flags & TableFlags_PadOuterX)
                               ? true
                               : (flags & TableFlags_BordersOuterV) != 0;
  const bool pad_inner_x = (flags & TableFlags_NoPadInnerX) ? false : true;
  const float inner_spacing_for_border =
      (flags & TableFlags_BordersInnerV) ? TABLE_BORDER_SIZE : 0.0f;
  const float inner_spacing_explicit =
      (pad_inner_x && (flags & TableFlags_BordersInnerV) == 0)
          ? g.Style.CellPadding.x
          : 0.0f;
  const float inner_padding_explicit =
      (pad_inner_x && (flags & TableFlags_BordersInnerV) != 0)
          ? g.Style.CellPadding.x
          : 0.0f;
  table->CellSpacingX1 = inner_spacing_explicit + inner_spacing_for_border;
  table->CellSpacingX2 = inner_spacing_explicit;
  table->CellPaddingX = inner_padding_explicit;

  const float outer_padding_for_border =
      (flags & TableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
  const float outer_padding_explicit =
      pad_outer_x ? g.Style.CellPadding.x : 0.0f;
  table->OuterPaddingX =
      (outer_padding_for_border + outer_padding_explicit) - table->CellPaddingX;

  table->CurrentColumn = -1;
  table->CurrentRow = -1;
  table->RowBgColorCounter = 0;
  table->LastRowFlags = TableRowFlags_None;
  table->InnerClipRect =
      (inner_window == outer_window) ? table->WorkRect : inner_window->ClipRect;
  table->InnerClipRect.ClipWith(
      table->WorkRect); // We need this to honor inner_width
  table->InnerClipRect.ClipWithFull(table->HostClipRect);
  table->InnerClipRect.Max.y =
      (flags & TableFlags_NoHostExtendY)
          ? Min(table->InnerClipRect.Max.y, inner_window->WorkRect.Max.y)
          : inner_window->ClipRect.Max.y;

  table->RowPosY1 = table->RowPosY2 =
      table->WorkRect.Min.y; // This is needed somehow
  table->RowTextBaseline =
      0.0f; // This will be cleared again by TableBeginRow()
  table->RowCellPaddingY = 0.0f;
  table->FreezeRowsRequest = table->FreezeRowsCount =
      0; // This will be setup by TableSetupScrollFreeze(), if any
  table->FreezeColumnsRequest = table->FreezeColumnsCount = 0;
  table->IsUnfrozenRows = true;
  table->DeclColumnsCount = table->AngledHeadersCount = 0;
  if (previous_frame_active + 1 < g.FrameCount)
    table->IsActiveIdInTable = false;
  temp_data->AngledheadersExtraWidth = 0.0f;

  // Using opaque colors facilitate overlapping lines of the grid, otherwise
  // we'd need to improve TableDrawBorders()
  table->BorderColorStrong = GetColorU32(Col_TableBorderStrong);
  table->BorderColorLight = GetColorU32(Col_TableBorderLight);

  // Make table current
  g.CurrentTable = table;
  outer_window->DC.NavIsScrollPushableX =
      false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();
  outer_window->DC.CurrentTableIdx = table_idx;
  if (inner_window != outer_window) // So EndChild() within the inner window can
                                    // restore the table properly.
    inner_window->DC.CurrentTableIdx = table_idx;

  if ((table_last_flags & TableFlags_Reorderable) &&
      (flags & TableFlags_Reorderable) == 0)
    table->IsResetDisplayOrderRequest = true;

  // Mark as used to avoid GC
  if (table_idx >= g.TablesLastTimeActive.Size)
    g.TablesLastTimeActive.resize(table_idx + 1, -1.0f);
  g.TablesLastTimeActive[table_idx] = (float)g.Time;
  temp_data->LastTimeActive = (float)g.Time;
  table->MemoryCompacted = false;

  // Setup memory buffer (clear data if columns count changed)
  TableColumn *old_columns_to_preserve = NULL;
  void *old_columns_raw_data = NULL;
  const int old_columns_count = table->Columns.size();
  if (old_columns_count != 0 && old_columns_count != columns_count) {
    // Attempt to preserve width on column count change (#4046)
    old_columns_to_preserve = table->Columns.Data;
    old_columns_raw_data = table->RawData;
    table->RawData = NULL;
  }
  if (table->RawData == NULL) {
    TableBeginInitMemory(table, columns_count);
    table->IsInitializing = table->IsSettingsRequestLoad = true;
  }
  if (table->IsResetAllRequest)
    TableResetSettings(table);
  if (table->IsInitializing) {
    // Initialize
    table->SettingsOffset = -1;
    table->IsSortSpecsDirty = true;
    table->InstanceInteracted = -1;
    table->ContextPopupColumn = -1;
    table->ReorderColumn = table->ResizedColumn = table->LastResizedColumn = -1;
    table->AutoFitSingleColumn = -1;
    table->HoveredColumnBody = table->HoveredColumnBorder = -1;
    for (int n = 0; n < columns_count; n++) {
      TableColumn *column = &table->Columns[n];
      if (old_columns_to_preserve && n < old_columns_count) {
        // FIXME: We don't attempt to preserve column order in this path.
        *column = old_columns_to_preserve[n];
      } else {
        float width_auto = column->WidthAuto;
        *column = TableColumn();
        column->WidthAuto = width_auto;
        column->IsPreserveWidthAuto =
            true; // Preserve WidthAuto when reinitializing a live table: not
                  // technically necessary but remove a visible flicker
        column->IsEnabled = column->IsUserEnabled =
            column->IsUserEnabledNextFrame = true;
      }
      column->DisplayOrder = table->DisplayOrderToIndex[n] = (TableColumnIdx)n;
    }
  }
  if (old_columns_raw_data)
    GUI_FREE(old_columns_raw_data);

  // Load settings
  if (table->IsSettingsRequestLoad)
    TableLoadSettings(table);

  // Handle DPI/font resize
  // This is designed to facilitate DPI changes with the assumption that e.g.
  // style.CellPadding has been scaled as well. It will also react to changing
  // fonts with mixed results. It doesn't need to be perfect but merely provide
  // a decent transition.
  // FIXME-DPI: Provide consistent standards for reference size. Perhaps using
  // g.CurrentDpiScale would be more self explanatory. This is will lead us to
  // non-rounded WidthRequest in columns, which should work but is a poorly
  // tested path.
  const float new_ref_scale_unit = g.FontSize; // g.Font->GetCharAdvance('A') ?
  if (table->RefScale != 0.0f && table->RefScale != new_ref_scale_unit) {
    const float scale_factor = new_ref_scale_unit / table->RefScale;
    // GUI_DEBUG_PRINT("[table] %08X RefScaleUnit %.3f -> %.3f, scaling width
    // by %.3f\n", table->ID, table->RefScaleUnit, new_ref_scale_unit,
    // scale_factor);
    for (int n = 0; n < columns_count; n++)
      table->Columns[n].WidthRequest =
          table->Columns[n].WidthRequest * scale_factor;
  }
  table->RefScale = new_ref_scale_unit;

  // Disable output until user calls TableNextRow() or TableNextColumn() leading
  // to the TableUpdateLayout() call.. This is not strictly necessary but will
  // reduce cases were "out of table" output will be misleading to the user.
  // Because we cannot safely assert in EndTable() when no rows have been
  // created, this seems like our best option.
  inner_window->SkipItems = true;

  // Clear names
  // At this point the ->NameOffset field of each column will be invalid until
  // TableUpdateLayout() or the first call to TableSetupColumn()
  if (table->ColumnsNames.Buf.Size > 0)
    table->ColumnsNames.Buf.resize(0);

  // Apply queued resizing/reordering/hiding requests
  TableBeginApplyRequests(table);

  return true;
}

// For reference, the average total _allocation count_ for a table is:
// + 0 (for Table instance, we are pooling allocations in g.Tables[])
// + 1 (for table->RawData allocated below)
// + 1 (for table->ColumnsNames, if names are used)
// Shared allocations for the maximum number of simultaneously nested tables
// (generally a very small number)
// + 1 (for table->Splitter._Channels)
// + 2 * active_channels_count (for DrawCmd and DrawIdx buffers inside
// channels) Where active_channels_count is variable but often == columns_count
// or == columns_count + 1, see TableSetupDrawChannels() for details. Unused
// channels don't perform their +2 allocations.
inline void Gui::TableBeginInitMemory(Table *table, int columns_count) {
  // Allocate single buffer for our arrays
  const int columns_bit_array_size =
      (int)BitArrayGetStorageSizeInBytes(columns_count);
  SpanAllocator<6> span_allocator;
  span_allocator.Reserve(0, columns_count * sizeof(TableColumn));
  span_allocator.Reserve(1, columns_count * sizeof(TableColumnIdx));
  span_allocator.Reserve(2, columns_count * sizeof(TableCellData), 4);
  for (int n = 3; n < 6; n++)
    span_allocator.Reserve(n, columns_bit_array_size);
  table->RawData = GUI_ALLOC(span_allocator.GetArenaSizeInBytes());
  memset(table->RawData, 0, span_allocator.GetArenaSizeInBytes());
  span_allocator.SetArenaBasePtr(table->RawData);
  span_allocator.GetSpan(0, &table->Columns);
  span_allocator.GetSpan(1, &table->DisplayOrderToIndex);
  span_allocator.GetSpan(2, &table->RowCellData);
  table->EnabledMaskByDisplayOrder = (U32 *)span_allocator.GetSpanPtrBegin(3);
  table->EnabledMaskByIndex = (U32 *)span_allocator.GetSpanPtrBegin(4);
  table->VisibleMaskByIndex = (U32 *)span_allocator.GetSpanPtrBegin(5);
}

// Apply queued resizing/reordering/hiding requests
inline void Gui::TableBeginApplyRequests(Table *table) {
  // Handle resizing request
  // (We process this in the TableBegin() of the first instance of each table)
  // FIXME-TABLE: Contains columns if our work area doesn't allow for scrolling?
  if (table->InstanceCurrent == 0) {
    if (table->ResizedColumn != -1 && table->ResizedColumnNextWidth != FLT_MAX)
      TableSetColumnWidth(table->ResizedColumn, table->ResizedColumnNextWidth);
    table->LastResizedColumn = table->ResizedColumn;
    table->ResizedColumnNextWidth = FLT_MAX;
    table->ResizedColumn = -1;

    // Process auto-fit for single column, which is a special case for stretch
    // columns and fixed columns with FixedSame policy.
    // FIXME-TABLE: Would be nice to redistribute available stretch space
    // accordingly to other weights, instead of giving it all to siblings.
    if (table->AutoFitSingleColumn != -1) {
      TableSetColumnWidth(table->AutoFitSingleColumn,
                          table->Columns[table->AutoFitSingleColumn].WidthAuto);
      table->AutoFitSingleColumn = -1;
    }
  }

  // Handle reordering request
  // Note: we don't clear ReorderColumn after handling the request.
  if (table->InstanceCurrent == 0) {
    if (table->HeldHeaderColumn == -1 && table->ReorderColumn != -1)
      table->ReorderColumn = -1;
    table->HeldHeaderColumn = -1;
    if (table->ReorderColumn != -1 && table->ReorderColumnDir != 0) {
      // We need to handle reordering across hidden columns.
      // In the configuration below, moving C to the right of E will lead to:
      //    ... C [D] E  --->  ... [D] E  C   (Column name/index)
      //    ... 2  3  4        ...  2  3  4   (Display order)
      const int reorder_dir = table->ReorderColumnDir;
      GUI_ASSERT(reorder_dir == -1 || reorder_dir == +1);
      GUI_ASSERT(table->Flags & TableFlags_Reorderable);
      TableColumn *src_column = &table->Columns[table->ReorderColumn];
      TableColumn *dst_column =
          &table->Columns[(reorder_dir == -1) ? src_column->PrevEnabledColumn
                                              : src_column->NextEnabledColumn];
      GUI_UNUSED(dst_column);
      const int src_order = src_column->DisplayOrder;
      const int dst_order = dst_column->DisplayOrder;
      src_column->DisplayOrder = (TableColumnIdx)dst_order;
      for (int order_n = src_order + reorder_dir;
           order_n != dst_order + reorder_dir; order_n += reorder_dir)
        table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder -=
            (TableColumnIdx)reorder_dir;
      GUI_ASSERT(dst_column->DisplayOrder == dst_order - reorder_dir);

      // Display order is stored in both columns->IndexDisplayOrder and
      // table->DisplayOrder[]. Rebuild later from the former.
      for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] =
            (TableColumnIdx)column_n;
      table->ReorderColumnDir = 0;
      table->IsSettingsDirty = true;
    }
  }

  // Handle display order reset request
  if (table->IsResetDisplayOrderRequest) {
    for (int n = 0; n < table->ColumnsCount; n++)
      table->DisplayOrderToIndex[n] = table->Columns[n].DisplayOrder =
          (TableColumnIdx)n;
    table->IsResetDisplayOrderRequest = false;
    table->IsSettingsDirty = true;
  }
}

// Adjust flags: default width mode + stretch columns are not allowed when auto
// extending
static void TableSetupColumnFlags(Table *table, TableColumn *column,
                                  TableColumnFlags flags_in) {
  TableColumnFlags flags = flags_in;

  // Sizing Policy
  if ((flags & TableColumnFlags_WidthMask_) == 0) {
    const TableFlags table_sizing_policy =
        (table->Flags & TableFlags_SizingMask_);
    if (table_sizing_policy == TableFlags_SizingFixedFit ||
        table_sizing_policy == TableFlags_SizingFixedSame)
      flags |= TableColumnFlags_WidthFixed;
    else
      flags |= TableColumnFlags_WidthStretch;
  } else {
    GUI_ASSERT(IsPowerOfTwo(
        flags & TableColumnFlags_WidthMask_)); // Check that only 1 of each
                                               // set is used.
  }

  // Resize
  if ((table->Flags & TableFlags_Resizable) == 0)
    flags |= TableColumnFlags_NoResize;

  // Sorting
  if ((flags & TableColumnFlags_NoSortAscending) &&
      (flags & TableColumnFlags_NoSortDescending))
    flags |= TableColumnFlags_NoSort;

  // Indentation
  if ((flags & TableColumnFlags_IndentMask_) == 0)
    flags |= (table->Columns.index_from_ptr(column) == 0)
                 ? TableColumnFlags_IndentEnable
                 : TableColumnFlags_IndentDisable;

  // Alignment
  // if ((flags & TableColumnFlags_AlignMask_) == 0)
  //    flags |= TableColumnFlags_AlignCenter;
  // GUI_ASSERT(IsPowerOfTwo(flags & TableColumnFlags_AlignMask_)); //
  // Check that only 1 of each set is used.

  // Preserve status flags
  column->Flags = flags | (column->Flags & TableColumnFlags_StatusMask_);

  // Build an ordered list of available sort directions
  column->SortDirectionsAvailCount = column->SortDirectionsAvailMask =
      column->SortDirectionsAvailList = 0;
  if (table->Flags & TableFlags_Sortable) {
    int count = 0, mask = 0, list = 0;
    if ((flags & TableColumnFlags_PreferSortAscending) != 0 &&
        (flags & TableColumnFlags_NoSortAscending) == 0) {
      mask |= 1 << SortDirection_Ascending;
      list |= SortDirection_Ascending << (count << 1);
      count++;
    }
    if ((flags & TableColumnFlags_PreferSortDescending) != 0 &&
        (flags & TableColumnFlags_NoSortDescending) == 0) {
      mask |= 1 << SortDirection_Descending;
      list |= SortDirection_Descending << (count << 1);
      count++;
    }
    if ((flags & TableColumnFlags_PreferSortAscending) == 0 &&
        (flags & TableColumnFlags_NoSortAscending) == 0) {
      mask |= 1 << SortDirection_Ascending;
      list |= SortDirection_Ascending << (count << 1);
      count++;
    }
    if ((flags & TableColumnFlags_PreferSortDescending) == 0 &&
        (flags & TableColumnFlags_NoSortDescending) == 0) {
      mask |= 1 << SortDirection_Descending;
      list |= SortDirection_Descending << (count << 1);
      count++;
    }
    if ((table->Flags & TableFlags_SortTristate) || count == 0) {
      mask |= 1 << SortDirection_None;
      count++;
    }
    column->SortDirectionsAvailList = (U8)list;
    column->SortDirectionsAvailMask = (U8)mask;
    column->SortDirectionsAvailCount = (U8)count;
    Gui::TableFixColumnSortDirection(table, column);
  }
}

// Layout columns for the frame. This is in essence the followup to BeginTable()
// and this is our largest function. Runs on the first call to TableNextRow(),
// to give a chance for TableSetupColumn() and other TableSetupXXXXX() functions
// to be called first.
// FIXME-TABLE: Our width (and therefore our WorkRect) will be minimal in the
// first frame for _WidthAuto columns. Increase feedback side-effect with
// widgets relying on WorkRect.Max.x... Maybe provide a default distribution for
// _WidthAuto columns?
inline void Gui::TableUpdateLayout(Table *table) {
  Context &g = *GGui;
  GUI_ASSERT(table->IsLayoutLocked == false);

  const TableFlags table_sizing_policy =
      (table->Flags & TableFlags_SizingMask_);
  table->IsDefaultDisplayOrder = true;
  table->ColumnsEnabledCount = 0;
  BitArrayClearAllBits(table->EnabledMaskByIndex, table->ColumnsCount);
  BitArrayClearAllBits(table->EnabledMaskByDisplayOrder, table->ColumnsCount);
  table->LeftMostEnabledColumn = -1;
  table->MinColumnWidth =
      Max(1.0f, g.Style.FramePadding.x *
                    1.0f); // g.Style.ColumnsMinSpacing; // FIXME-TABLE

  // [Part 1] Apply/lock Enabled and Order states. Calculate auto/ideal width
  // for columns. Count fixed/stretch columns. Process columns in their visible
  // orders as we are building the Prev/Next indices.
  int count_fixed = 0;   // Number of columns that have fixed sizing policies
  int count_stretch = 0; // Number of columns that have stretch sizing policies
  int prev_visible_column_idx = -1;
  bool has_auto_fit_request = false;
  bool has_resizable = false;
  float stretch_sum_width_auto = 0.0f;
  float fixed_max_width_auto = 0.0f;
  for (int order_n = 0; order_n < table->ColumnsCount; order_n++) {
    const int column_n = table->DisplayOrderToIndex[order_n];
    if (column_n != order_n)
      table->IsDefaultDisplayOrder = false;
    TableColumn *column = &table->Columns[column_n];

    // Clear column setup if not submitted by user. Currently we make it
    // mandatory to call TableSetupColumn() every frame. It would easily work
    // without but we're not ready to guarantee it since e.g. names need
    // resubmission anyway. We take a slight shortcut but in theory we could be
    // calling TableSetupColumn() here with dummy values, it should yield the
    // same effect.
    if (table->DeclColumnsCount <= column_n) {
      TableSetupColumnFlags(table, column, TableColumnFlags_None);
      column->NameOffset = -1;
      column->UserID = 0;
      column->InitStretchWeightOrWidth = -1.0f;
    }

    // Update Enabled state, mark settings and sort specs dirty
    if (!(table->Flags & TableFlags_Hideable) ||
        (column->Flags & TableColumnFlags_NoHide))
      column->IsUserEnabledNextFrame = true;
    if (column->IsUserEnabled != column->IsUserEnabledNextFrame) {
      column->IsUserEnabled = column->IsUserEnabledNextFrame;
      table->IsSettingsDirty = true;
    }
    column->IsEnabled = column->IsUserEnabled &&
                        (column->Flags & TableColumnFlags_Disabled) == 0;

    if (column->SortOrder != -1 && !column->IsEnabled)
      table->IsSortSpecsDirty = true;
    if (column->SortOrder > 0 && !(table->Flags & TableFlags_SortMulti))
      table->IsSortSpecsDirty = true;

    // Auto-fit unsized columns
    const bool start_auto_fit = (column->Flags & TableColumnFlags_WidthFixed)
                                    ? (column->WidthRequest < 0.0f)
                                    : (column->StretchWeight < 0.0f);
    if (start_auto_fit)
      column->AutoFitQueue = column->CannotSkipItemsQueue =
          (1 << 3) - 1; // Fit for three frames

    if (!column->IsEnabled) {
      column->IndexWithinEnabledSet = -1;
      continue;
    }

    // Mark as enabled and link to previous/next enabled column
    column->PrevEnabledColumn = (TableColumnIdx)prev_visible_column_idx;
    column->NextEnabledColumn = -1;
    if (prev_visible_column_idx != -1)
      table->Columns[prev_visible_column_idx].NextEnabledColumn =
          (TableColumnIdx)column_n;
    else
      table->LeftMostEnabledColumn = (TableColumnIdx)column_n;
    column->IndexWithinEnabledSet = table->ColumnsEnabledCount++;
    BitArraySetBit(table->EnabledMaskByIndex, column_n);
    BitArraySetBit(table->EnabledMaskByDisplayOrder, column->DisplayOrder);
    prev_visible_column_idx = column_n;
    GUI_ASSERT(column->IndexWithinEnabledSet <= column->DisplayOrder);

    // Calculate ideal/auto column width (that's the width required for all
    // contents to be visible without clipping) Combine width from regular rows
    // + width from headers unless requested not to.
    if (!column->IsPreserveWidthAuto)
      column->WidthAuto = TableGetColumnWidthAuto(table, column);

    // Non-resizable columns keep their requested width (apply user value
    // regardless of IsPreserveWidthAuto)
    const bool column_is_resizable =
        (column->Flags & TableColumnFlags_NoResize) == 0;
    if (column_is_resizable)
      has_resizable = true;
    if ((column->Flags & TableColumnFlags_WidthFixed) &&
        column->InitStretchWeightOrWidth > 0.0f && !column_is_resizable)
      column->WidthAuto = column->InitStretchWeightOrWidth;

    if (column->AutoFitQueue != 0x00)
      has_auto_fit_request = true;
    if (column->Flags & TableColumnFlags_WidthStretch) {
      stretch_sum_width_auto += column->WidthAuto;
      count_stretch++;
    } else {
      fixed_max_width_auto = Max(fixed_max_width_auto, column->WidthAuto);
      count_fixed++;
    }
  }
  if ((table->Flags & TableFlags_Sortable) && table->SortSpecsCount == 0 &&
      !(table->Flags & TableFlags_SortTristate))
    table->IsSortSpecsDirty = true;
  table->RightMostEnabledColumn = (TableColumnIdx)prev_visible_column_idx;
  GUI_ASSERT(table->LeftMostEnabledColumn >= 0 &&
             table->RightMostEnabledColumn >= 0);

  // [Part 2] Disable child window clipping while fitting columns. This is not
  // strictly necessary but makes it possible to avoid the column fitting having
  // to wait until the first visible frame of the child container (may or not be
  // a good thing). Also see #6510.
  // FIXME-TABLE: for always auto-resizing columns may not want to do that all
  // the time.
  if (has_auto_fit_request && table->OuterWindow != table->InnerWindow)
    table->InnerWindow->SkipItems = false;
  if (has_auto_fit_request)
    table->IsSettingsDirty = true;

  // [Part 3] Fix column flags and record a few extra information.
  float sum_width_requests =
      0.0f; // Sum of all width for fixed and auto-resize columns, excluding
            // width contributed by Stretch columns but including
            // spacing/padding.
  float stretch_sum_weights = 0.0f; // Sum of all weights for stretch columns.
  table->LeftMostStretchedColumn = table->RightMostStretchedColumn = -1;
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
    if (!GUI_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
      continue;
    TableColumn *column = &table->Columns[column_n];

    const bool column_is_resizable =
        (column->Flags & TableColumnFlags_NoResize) == 0;
    if (column->Flags & TableColumnFlags_WidthFixed) {
      // Apply same widths policy
      float width_auto = column->WidthAuto;
      if (table_sizing_policy == TableFlags_SizingFixedSame &&
          (column->AutoFitQueue != 0x00 || !column_is_resizable))
        width_auto = fixed_max_width_auto;

      // Apply automatic width
      // Latch initial size for fixed columns and update it constantly for
      // auto-resizing column (unless clipped!)
      if (column->AutoFitQueue != 0x00)
        column->WidthRequest = width_auto;
      else if ((column->Flags & TableColumnFlags_WidthFixed) &&
               !column_is_resizable && column->IsRequestOutput)
        column->WidthRequest = width_auto;

      // FIXME-TABLE: Increase minimum size during init frame to avoid biasing
      // auto-fitting widgets (e.g. TextWrapped) too much. Otherwise what tends
      // to happen is that TextWrapped would output a very large height (= first
      // frame scrollbar display very off + clipper would skip lots of items).
      // This is merely making the side-effect less extreme, but doesn't
      // properly fixes it.
      // FIXME: Move this to ->WidthGiven to avoid temporary lossyless?
      // FIXME: This break IsPreserveWidthAuto from not flickering if the stored
      // WidthAuto was smaller.
      if (column->AutoFitQueue > 0x01 && table->IsInitializing &&
          !column->IsPreserveWidthAuto)
        column->WidthRequest =
            Max(column->WidthRequest,
                table->MinColumnWidth *
                    4.0f); // FIXME-TABLE: Another constant/scale?
      sum_width_requests += column->WidthRequest;
    } else {
      // Initialize stretch weight
      if (column->AutoFitQueue != 0x00 || column->StretchWeight < 0.0f ||
          !column_is_resizable) {
        if (column->InitStretchWeightOrWidth > 0.0f)
          column->StretchWeight = column->InitStretchWeightOrWidth;
        else if (table_sizing_policy == TableFlags_SizingStretchProp)
          column->StretchWeight =
              (column->WidthAuto / stretch_sum_width_auto) * count_stretch;
        else
          column->StretchWeight = 1.0f;
      }

      stretch_sum_weights += column->StretchWeight;
      if (table->LeftMostStretchedColumn == -1 ||
          table->Columns[table->LeftMostStretchedColumn].DisplayOrder >
              column->DisplayOrder)
        table->LeftMostStretchedColumn = (TableColumnIdx)column_n;
      if (table->RightMostStretchedColumn == -1 ||
          table->Columns[table->RightMostStretchedColumn].DisplayOrder <
              column->DisplayOrder)
        table->RightMostStretchedColumn = (TableColumnIdx)column_n;
    }
    column->IsPreserveWidthAuto = false;
    sum_width_requests += table->CellPaddingX * 2.0f;
  }
  table->ColumnsEnabledFixedCount = (TableColumnIdx)count_fixed;
  table->ColumnsStretchSumWeights = stretch_sum_weights;

  // [Part 4] Apply final widths based on requested widths
  const Rect work_rect = table->WorkRect;
  const float width_spacings = (table->OuterPaddingX * 2.0f) +
                               (table->CellSpacingX1 + table->CellSpacingX2) *
                                   (table->ColumnsEnabledCount - 1);
  const float width_removed =
      (table->HasScrollbarYPrev && !table->InnerWindow->ScrollbarY)
          ? g.Style.ScrollbarSize
          : 0.0f; // To synchronize decoration width of synched tables with
                  // mismatching scrollbar state (#5920)
  const float width_avail = Max(
      1.0f, (((table->Flags & TableFlags_ScrollX) && table->InnerWidth == 0.0f)
                 ? table->InnerClipRect.GetWidth()
                 : work_rect.GetWidth()) -
                width_removed);
  const float width_avail_for_stretched_columns =
      width_avail - width_spacings - sum_width_requests;
  float width_remaining_for_stretched_columns =
      width_avail_for_stretched_columns;
  table->ColumnsGivenWidth = width_spacings + (table->CellPaddingX * 2.0f) *
                                                  table->ColumnsEnabledCount;
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
    if (!GUI_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
      continue;
    TableColumn *column = &table->Columns[column_n];

    // Allocate width for stretched/weighted columns (StretchWeight gets
    // converted into WidthRequest)
    if (column->Flags & TableColumnFlags_WidthStretch) {
      float weight_ratio = column->StretchWeight / stretch_sum_weights;
      column->WidthRequest =
          GUI_TRUNC(Max(width_avail_for_stretched_columns * weight_ratio,
                        table->MinColumnWidth) +
                    0.01f);
      width_remaining_for_stretched_columns -= column->WidthRequest;
    }

    // [Resize Rule 1] The right-most Visible column is not resizable if there
    // is at least one Stretch column See additional comments in
    // TableSetColumnWidth().
    if (column->NextEnabledColumn == -1 && table->LeftMostStretchedColumn != -1)
      column->Flags |= TableColumnFlags_NoDirectResize_;

    // Assign final width, record width in case we will need to shrink
    column->WidthGiven =
        Trunc(Max(column->WidthRequest, table->MinColumnWidth));
    table->ColumnsGivenWidth += column->WidthGiven;
  }

  // [Part 5] Redistribute stretch remainder width due to rounding (remainder
  // width is < 1.0f * number of Stretch column). Using right-to-left
  // distribution (more likely to match resizing cursor).
  if (width_remaining_for_stretched_columns >= 1.0f &&
      !(table->Flags & TableFlags_PreciseWidths))
    for (int order_n = table->ColumnsCount - 1;
         stretch_sum_weights > 0.0f &&
         width_remaining_for_stretched_columns >= 1.0f && order_n >= 0;
         order_n--) {
      if (!GUI_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
        continue;
      TableColumn *column =
          &table->Columns[table->DisplayOrderToIndex[order_n]];
      if (!(column->Flags & TableColumnFlags_WidthStretch))
        continue;
      column->WidthRequest += 1.0f;
      column->WidthGiven += 1.0f;
      width_remaining_for_stretched_columns -= 1.0f;
    }

  // Determine if table is hovered which will be used to flag columns as
  // hovered.
  // - In principle we'd like to use the equivalent of
  // IsItemHovered(HoveredFlags_AllowWhenBlockedByActiveItem),
  //   but because our item is partially submitted at this point we use
  //   ItemHoverable() and a workaround (temporarily clear ActiveId, which is
  //   equivalent to the change provided by _AllowWhenBLockedByActiveItem).
  // - This allows columns to be marked as hovered when e.g. clicking a button
  // inside the column, or using drag and drop.
  TableInstanceData *table_instance =
      TableGetInstanceData(table, table->InstanceCurrent);
  table_instance->HoveredRowLast = table_instance->HoveredRowNext;
  table_instance->HoveredRowNext = -1;
  table->HoveredColumnBody = table->HoveredColumnBorder = -1;
  const Rect mouse_hit_rect(
      table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.Max.x,
      Max(table->OuterRect.Max.y,
          table->OuterRect.Min.y + table_instance->LastOuterHeight));
  const ID backup_active_id = g.ActiveId;
  g.ActiveId = 0;
  const bool is_hovering_table =
      ItemHoverable(mouse_hit_rect, 0, ItemFlags_None);
  g.ActiveId = backup_active_id;

  // Determine skewed MousePos.x to support angled headers.
  float mouse_skewed_x = g.IO.MousePos.x;
  if (table->AngledHeadersHeight > 0.0f)
    if (g.IO.MousePos.y >= table->OuterRect.Min.y &&
        g.IO.MousePos.y <= table->OuterRect.Min.y + table->AngledHeadersHeight)
      mouse_skewed_x += Trunc((table->OuterRect.Min.y +
                               table->AngledHeadersHeight - g.IO.MousePos.y) *
                              table->AngledHeadersSlope);

  // [Part 6] Setup final position, offset, skip/clip states and clipping
  // rectangles, detect hovered column Process columns in their visible orders
  // as we are comparing the visible order and adjusting host_clip_rect while
  // looping.
  int visible_n = 0;
  bool has_at_least_one_column_requesting_output = false;
  bool offset_x_frozen = (table->FreezeColumnsCount > 0);
  float offset_x = ((table->FreezeColumnsCount > 0) ? table->OuterRect.Min.x
                                                    : work_rect.Min.x) +
                   table->OuterPaddingX - table->CellSpacingX1;
  Rect host_clip_rect = table->InnerClipRect;
  // host_clip_rect.Max.x += table->CellPaddingX + table->CellSpacingX2;
  BitArrayClearAllBits(table->VisibleMaskByIndex, table->ColumnsCount);
  for (int order_n = 0; order_n < table->ColumnsCount; order_n++) {
    const int column_n = table->DisplayOrderToIndex[order_n];
    TableColumn *column = &table->Columns[column_n];

    column->NavLayerCurrent =
        (S8)(table->FreezeRowsCount > 0
                 ? NavLayer_Menu
                 : NavLayer_Main); // Use Count NOT request so Header
                                   // line changes layer when frozen

    if (offset_x_frozen && table->FreezeColumnsCount == visible_n) {
      offset_x += work_rect.Min.x - table->OuterRect.Min.x;
      offset_x_frozen = false;
    }

    // Clear status flags
    column->Flags &= ~TableColumnFlags_StatusMask_;

    if (!GUI_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n)) {
      // Hidden column: clear a few fields and we are done with it for the
      // remainder of the function. We set a zero-width clip rect but set
      // Min.y/Max.y properly to not interfere with the clipper.
      column->MinX = column->MaxX = column->WorkMinX = column->ClipRect.Min.x =
          column->ClipRect.Max.x = offset_x;
      column->WidthGiven = 0.0f;
      column->ClipRect.Min.y = work_rect.Min.y;
      column->ClipRect.Max.y = FLT_MAX;
      column->ClipRect.ClipWithFull(host_clip_rect);
      column->IsVisibleX = column->IsVisibleY = column->IsRequestOutput = false;
      column->IsSkipItems = true;
      column->ItemWidth = 1.0f;
      continue;
    }

    // Detect hovered column
    if (is_hovering_table && mouse_skewed_x >= column->ClipRect.Min.x &&
        mouse_skewed_x < column->ClipRect.Max.x)
      table->HoveredColumnBody = (TableColumnIdx)column_n;

    // Lock start position
    column->MinX = offset_x;

    // Lock width based on start position and minimum/maximum width for this
    // position
    float max_width = TableGetMaxColumnWidth(table, column_n);
    column->WidthGiven = Min(column->WidthGiven, max_width);
    column->WidthGiven = Max(column->WidthGiven,
                             Min(column->WidthRequest, table->MinColumnWidth));
    column->MaxX = offset_x + column->WidthGiven + table->CellSpacingX1 +
                   table->CellSpacingX2 + table->CellPaddingX * 2.0f;

    // Lock other positions
    // - ClipRect.Min.x: Because merging draw commands doesn't compare min
    // boundaries, we make ClipRect.Min.x match left bounds to be consistent
    // regardless of merging.
    // - ClipRect.Max.x: using WorkMaxX instead of MaxX (aka including padding)
    // makes things more consistent when resizing down, tho slightly detrimental
    // to visibility in very-small column.
    // - ClipRect.Max.x: using MaxX makes it easier for header to receive hover
    // highlight with no discontinuity and display sorting arrow.
    // - FIXME-TABLE: We want equal width columns to have equal (ClipRect.Max.x
    // - WorkMinX) width, which means ClipRect.max.x cannot stray off
    // host_clip_rect.Max.x else right-most column may appear shorter.
    column->WorkMinX =
        column->MinX + table->CellPaddingX + table->CellSpacingX1;
    column->WorkMaxX = column->MaxX - table->CellPaddingX -
                       table->CellSpacingX2; // Expected max
    column->ItemWidth = Trunc(column->WidthGiven * 0.65f);
    column->ClipRect.Min.x = column->MinX;
    column->ClipRect.Min.y = work_rect.Min.y;
    column->ClipRect.Max.x = column->MaxX; // column->WorkMaxX;
    column->ClipRect.Max.y = FLT_MAX;
    column->ClipRect.ClipWithFull(host_clip_rect);

    // Mark column as Clipped (not in sight)
    // Note that scrolling tables (where inner_window != outer_window) handle Y
    // clipped earlier in BeginTable() so IsVisibleY really only applies to
    // non-scrolling tables.
    // FIXME-TABLE: Because InnerClipRect.Max.y is conservatively
    // ==outer_window->ClipRect.Max.y, we never can mark columns _Above_ the
    // scroll line as not IsVisibleY. Taking advantage of LastOuterHeight would
    // yield good results there...
    // FIXME-TABLE: Y clipping is disabled because it effectively means not
    // submitting will reduce contents width which is fed to
    // outer_window->DC.CursorMaxPos.x, and this may be used (e.g. typically by
    // outer_window using AlwaysAutoResize or outer_window's horizontal
    // scrollbar, but could be something else). Possible solution to preserve
    // last known content width for clipped column. Test 'table_reported_size'
    // fails when enabling Y clipping and window is resized small.
    column->IsVisibleX = (column->ClipRect.Max.x > column->ClipRect.Min.x);
    column->IsVisibleY =
        true; // (column->ClipRect.Max.y > column->ClipRect.Min.y);
    const bool is_visible = column->IsVisibleX; //&& column->IsVisibleY;
    if (is_visible)
      BitArraySetBit(table->VisibleMaskByIndex, column_n);

    // Mark column as requesting output from user. Note that fixed +
    // non-resizable sets are auto-fitting at all times and therefore always
    // request output.
    column->IsRequestOutput = is_visible || column->AutoFitQueue != 0 ||
                              column->CannotSkipItemsQueue != 0;

    // Mark column as SkipItems (ignoring all items/layout)
    // (table->HostSkipItems is a copy of inner_window->SkipItems before we
    // cleared it above in Part 2)
    column->IsSkipItems = !column->IsEnabled || table->HostSkipItems;
    if (column->IsSkipItems)
      GUI_ASSERT(!is_visible);
    if (column->IsRequestOutput && !column->IsSkipItems)
      has_at_least_one_column_requesting_output = true;

    // Update status flags
    column->Flags |= TableColumnFlags_IsEnabled;
    if (is_visible)
      column->Flags |= TableColumnFlags_IsVisible;
    if (column->SortOrder != -1)
      column->Flags |= TableColumnFlags_IsSorted;
    if (table->HoveredColumnBody == column_n)
      column->Flags |= TableColumnFlags_IsHovered;

    // Alignment
    // FIXME-TABLE: This align based on the whole column width, not per-cell,
    // and therefore isn't useful in many cases (to be able to honor this we
    // might be able to store a log of cells width, per row, for visible rows,
    // but nav/programmatic scroll would have visible artifacts.)
    // if (column->Flags & TableColumnFlags_AlignRight)
    //    column->WorkMinX = Max(column->WorkMinX, column->MaxX -
    //    column->ContentWidthRowsUnfrozen);
    // else if (column->Flags & TableColumnFlags_AlignCenter)
    //    column->WorkMinX = Lerp(column->WorkMinX, Max(column->StartX,
    //    column->MaxX - column->ContentWidthRowsUnfrozen), 0.5f);

    // Reset content width variables
    column->ContentMaxXFrozen = column->ContentMaxXUnfrozen = column->WorkMinX;
    column->ContentMaxXHeadersUsed = column->ContentMaxXHeadersIdeal =
        column->WorkMinX;

    // Don't decrement auto-fit counters until container window got a chance to
    // submit its items
    if (table->HostSkipItems == false) {
      column->AutoFitQueue >>= 1;
      column->CannotSkipItemsQueue >>= 1;
    }

    if (visible_n < table->FreezeColumnsCount)
      host_clip_rect.Min.x = Clamp(column->MaxX + TABLE_BORDER_SIZE,
                                   host_clip_rect.Min.x, host_clip_rect.Max.x);

    offset_x += column->WidthGiven + table->CellSpacingX1 +
                table->CellSpacingX2 + table->CellPaddingX * 2.0f;
    visible_n++;
  }

  // In case the table is visible (e.g. decorations) but all columns clipped, we
  // keep a column visible. Else if give no chance to a clipper-savy user to
  // submit rows and therefore total contents height used by scrollbar.
  if (has_at_least_one_column_requesting_output == false) {
    table->Columns[table->LeftMostEnabledColumn].IsRequestOutput = true;
    table->Columns[table->LeftMostEnabledColumn].IsSkipItems = false;
  }

  // [Part 7] Detect/store when we are hovering the unused space after the
  // right-most column (so e.g. context menus can react on it) Clear Resizable
  // flag if none of our column are actually resizable (either via an explicit
  // _NoResize flag, either because of using _WidthAuto/_WidthStretch). This
  // will hide the resizing option from the context menu.
  const float unused_x1 =
      Max(table->WorkRect.Min.x,
          table->Columns[table->RightMostEnabledColumn].ClipRect.Max.x);
  if (is_hovering_table && table->HoveredColumnBody == -1)
    if (mouse_skewed_x >= unused_x1)
      table->HoveredColumnBody = (TableColumnIdx)table->ColumnsCount;
  if (has_resizable == false && (table->Flags & TableFlags_Resizable))
    table->Flags &= ~TableFlags_Resizable;

  table->IsActiveIdAliveBeforeTable = (g.ActiveIdIsAlive != 0);

  // [Part 8] Lock actual OuterRect/WorkRect right-most position.
  // This is done late to handle the case of fixed-columns tables not claiming
  // more widths that they need. Because of this we are careful with uses of
  // WorkRect and InnerClipRect before this point.
  if (table->RightMostStretchedColumn != -1)
    table->Flags &= ~TableFlags_NoHostExtendX;
  if (table->Flags & TableFlags_NoHostExtendX) {
    table->OuterRect.Max.x = table->WorkRect.Max.x = unused_x1;
    table->InnerClipRect.Max.x = Min(table->InnerClipRect.Max.x, unused_x1);
  }
  table->InnerWindow->ParentWorkRect = table->WorkRect;
  table->BorderX1 = table->InnerClipRect.Min.x;
  table->BorderX2 = table->InnerClipRect.Max.x;

  // Setup window's WorkRect.Max.y for GetContentRegionAvail(). Other values
  // will be updated in each TableBeginCell() call.
  float window_content_max_y;
  if (table->Flags & TableFlags_NoHostExtendY)
    window_content_max_y = table->OuterRect.Max.y;
  else
    window_content_max_y = Max(
        table->InnerWindow->ContentRegionRect.Max.y,
        (table->Flags & TableFlags_ScrollY) ? 0.0f : table->OuterRect.Max.y);
  table->InnerWindow->WorkRect.Max.y = Clamp(
      window_content_max_y - g.Style.CellPadding.y,
      table->InnerWindow->WorkRect.Min.y, table->InnerWindow->WorkRect.Max.y);

  // [Part 9] Allocate draw channels and setup background cliprect
  TableSetupDrawChannels(table);

  // [Part 10] Hit testing on borders
  if (table->Flags & TableFlags_Resizable)
    TableUpdateBorders(table);
  table_instance->LastTopHeadersRowHeight = 0.0f;
  table->IsLayoutLocked = true;
  table->IsUsingHeaders = false;

  // Highlight header
  table->HighlightColumnHeader = -1;
  if (table->IsContextPopupOpen && table->ContextPopupColumn != -1 &&
      table->InstanceInteracted == table->InstanceCurrent)
    table->HighlightColumnHeader = table->ContextPopupColumn;
  else if ((table->Flags & TableFlags_HighlightHoveredColumn) &&
           table->HoveredColumnBody != -1 &&
           table->HoveredColumnBody != table->ColumnsCount &&
           table->HoveredColumnBorder == -1)
    if (g.ActiveId == 0 || (table->IsActiveIdInTable || g.DragDropActive))
      table->HighlightColumnHeader = table->HoveredColumnBody;

  // [Part 11] Default context menu
  // - To append to this menu: you can call
  // TableBeginContextMenuPopup()/.../EndPopup().
  // - To modify or replace this: set table->IsContextPopupNoDefaultContents =
  // true, then call TableBeginContextMenuPopup()/.../EndPopup().
  // - You may call TableDrawDefaultContextMenu() with selected flags to display
  // specific sections of the default menu,
  //   e.g. TableDrawDefaultContextMenu(table, table->Flags &
  //   ~TableFlags_Hideable) will display everything EXCEPT columns
  //   visibility options.
  if (table->DisableDefaultContextMenu == false &&
      TableBeginContextMenuPopup(table)) {
    TableDrawDefaultContextMenu(table, table->Flags);
    EndPopup();
  }

  // [Part 12] Sanitize and build sort specs before we have a chance to use them
  // for display. This path will only be exercised when sort specs are modified
  // before header rows (e.g. init or visibility change)
  if (table->IsSortSpecsDirty && (table->Flags & TableFlags_Sortable))
    TableSortSpecsBuild(table);

  // [Part 13] Setup inner window decoration size (for scrolling / nav tracking
  // to properly take account of frozen rows/columns)
  if (table->FreezeColumnsRequest > 0)
    table->InnerWindow->DecoInnerSizeX1 =
        table
            ->Columns[table->DisplayOrderToIndex[table->FreezeColumnsRequest -
                                                 1]]
            .MaxX -
        table->OuterRect.Min.x;
  if (table->FreezeRowsRequest > 0)
    table->InnerWindow->DecoInnerSizeY1 = table_instance->LastFrozenHeight;
  table_instance->LastFrozenHeight = 0.0f;

  // Initial state
  Window *inner_window = table->InnerWindow;
  if (table->Flags & TableFlags_NoClip)
    table->DrawSplitter->SetCurrentChannel(inner_window->DrawList,
                                           TABLE_DRAW_CHANNEL_NOCLIP);
  else
    inner_window->DrawList->PushClipRect(inner_window->ClipRect.Min,
                                         inner_window->ClipRect.Max, false);
}

// Process hit-testing on resizing borders. Actual size change will be applied
// in EndTable()
// - Set table->HoveredColumnBorder with a short delay/timer to reduce visual
// feedback noise.
inline void Gui::TableUpdateBorders(Table *table) {
  Context &g = *GGui;
  GUI_ASSERT(table->Flags & TableFlags_Resizable);

  // At this point OuterRect height may be zero or under actual final height, so
  // we rely on temporal coherency and use the final height from last frame.
  // Because this is only affecting _interaction_ with columns, it is not really
  // problematic (whereas the actual visual will be displayed in EndTable() and
  // using the current frame height). Actual columns highlight/render will be
  // performed in EndTable() and not be affected.
  TableInstanceData *table_instance =
      TableGetInstanceData(table, table->InstanceCurrent);
  const float hit_half_width = TABLE_RESIZE_SEPARATOR_HALF_THICKNESS;
  const float hit_y1 = (table->FreezeRowsCount >= 1 ? table->OuterRect.Min.y
                                                    : table->WorkRect.Min.y) +
                       table->AngledHeadersHeight;
  const float hit_y2_body =
      Max(table->OuterRect.Max.y, hit_y1 + table_instance->LastOuterHeight);
  const float hit_y2_head = hit_y1 + table_instance->LastTopHeadersRowHeight;

  for (int order_n = 0; order_n < table->ColumnsCount; order_n++) {
    if (!GUI_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
      continue;

    const int column_n = table->DisplayOrderToIndex[order_n];
    TableColumn *column = &table->Columns[column_n];
    if (column->Flags &
        (TableColumnFlags_NoResize | TableColumnFlags_NoDirectResize_))
      continue;

    // TableFlags_NoBordersInBodyUntilResize will be honored in
    // TableDrawBorders()
    const float border_y2_hit =
        (table->Flags & TableFlags_NoBordersInBody) ? hit_y2_head : hit_y2_body;
    if ((table->Flags & TableFlags_NoBordersInBody) &&
        table->IsUsingHeaders == false)
      continue;

    if (!column->IsVisibleX && table->LastResizedColumn != column_n)
      continue;

    ID column_id =
        TableGetColumnResizeID(table, column_n, table->InstanceCurrent);
    Rect hit_rect(column->MaxX - hit_half_width, hit_y1,
                  column->MaxX + hit_half_width, border_y2_hit);
    ItemAdd(hit_rect, column_id, NULL, ItemFlags_NoNav);
    // GetForegroundDrawList()->AddRect(hit_rect.Min, hit_rect.Max,
    // GUI_COL32(255, 0, 0, 100));

    bool hovered = false, held = false;
    bool pressed = ButtonBehavior(
        hit_rect, column_id, &hovered, &held,
        ButtonFlags_FlattenChildren | ButtonFlags_PressedOnClick |
            ButtonFlags_PressedOnDoubleClick | ButtonFlags_NoNavFocus);
    if (pressed && IsMouseDoubleClicked(0)) {
      TableSetColumnWidthAutoSingle(table, column_n);
      ClearActiveID();
      held = false;
    }
    if (held) {
      if (table->LastResizedColumn == -1)
        table->ResizeLockMinContentsX2 =
            table->RightMostEnabledColumn != -1
                ? table->Columns[table->RightMostEnabledColumn].MaxX
                : -FLT_MAX;
      table->ResizedColumn = (TableColumnIdx)column_n;
      table->InstanceInteracted = table->InstanceCurrent;
    }
    if ((hovered && g.HoveredIdTimer > TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER) ||
        held) {
      table->HoveredColumnBorder = (TableColumnIdx)column_n;
      SetMouseCursor(MouseCursor_ResizeEW);
    }
  }
}

inline void Gui::EndTable() {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  GUI_ASSERT(table != NULL &&
             "Only call EndTable() if BeginTable() returns true!");

  // This assert would be very useful to catch a common error... unfortunately
  // it would probably trigger in some cases, and for consistency user may
  // sometimes output empty tables (and still benefit from e.g. outer border)
  // GUI_ASSERT(table->IsLayoutLocked && "Table unused: never called
  // TableNextRow(), is that the intent?");

  // If the user never got to call TableNextRow() or TableNextColumn(), we call
  // layout ourselves to ensure all our code paths are consistent (instead of
  // just hoping that TableBegin/TableEnd will work), get borders drawn, etc.
  if (!table->IsLayoutLocked)
    TableUpdateLayout(table);

  const TableFlags flags = table->Flags;
  Window *inner_window = table->InnerWindow;
  Window *outer_window = table->OuterWindow;
  TableTempData *temp_data = table->TempData;
  GUI_ASSERT(inner_window == g.CurrentWindow);
  GUI_ASSERT(outer_window == inner_window ||
             outer_window == inner_window->ParentWindow);

  if (table->IsInsideRow)
    TableEndRow(table);

  // Context menu in columns body
  if (flags & TableFlags_ContextMenuInBody)
    if (table->HoveredColumnBody != -1 && !IsAnyItemHovered() &&
        IsMouseReleased(MouseButton_Right))
      TableOpenContextMenu((int)table->HoveredColumnBody);

  // Finalize table height
  TableInstanceData *table_instance =
      TableGetInstanceData(table, table->InstanceCurrent);
  inner_window->DC.PrevLineSize = temp_data->HostBackupPrevLineSize;
  inner_window->DC.CurrLineSize = temp_data->HostBackupCurrLineSize;
  inner_window->DC.CursorMaxPos = temp_data->HostBackupCursorMaxPos;
  const float inner_content_max_y = table->RowPosY2;
  GUI_ASSERT(table->RowPosY2 == inner_window->DC.CursorPos.y);
  if (inner_window != outer_window)
    inner_window->DC.CursorMaxPos.y = inner_content_max_y;
  else if (!(flags & TableFlags_NoHostExtendY))
    table->OuterRect.Max.y = table->InnerRect.Max.y =
        Max(table->OuterRect.Max.y,
            inner_content_max_y); // Patch OuterRect/InnerRect height
  table->WorkRect.Max.y = Max(table->WorkRect.Max.y, table->OuterRect.Max.y);
  table_instance->LastOuterHeight = table->OuterRect.GetHeight();

  // Setup inner scrolling range
  // FIXME: This ideally should be done earlier, in BeginTable()
  // SetNextWindowContentSize call, just like writing to
  // inner_window->DC.CursorMaxPos.y, but since the later is likely to be
  // impossible to do we'd rather update both axises together.
  if (table->Flags & TableFlags_ScrollX) {
    const float outer_padding_for_border =
        (table->Flags & TableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
    float max_pos_x = table->InnerWindow->DC.CursorMaxPos.x;
    if (table->RightMostEnabledColumn != -1)
      max_pos_x = Max(max_pos_x,
                      table->Columns[table->RightMostEnabledColumn].WorkMaxX +
                          table->CellPaddingX + table->OuterPaddingX -
                          outer_padding_for_border);
    if (table->ResizedColumn != -1)
      max_pos_x = Max(max_pos_x, table->ResizeLockMinContentsX2);
    table->InnerWindow->DC.CursorMaxPos.x =
        max_pos_x + table->TempData->AngledheadersExtraWidth;
  }

  // Pop clipping rect
  if (!(flags & TableFlags_NoClip))
    inner_window->DrawList->PopClipRect();
  inner_window->ClipRect = inner_window->DrawList->_ClipRectStack.back();

  // Draw borders
  if ((flags & TableFlags_Borders) != 0)
    TableDrawBorders(table);

#if 0
    // Strip out dummy channel draw calls
    // We have no way to prevent user submitting direct DrawList calls into a hidden column (but Gui:: calls will be clipped out)
    // Pros: remove draw calls which will have no effect. since they'll have zero-size cliprect they may be early out anyway.
    // Cons: making it harder for users watching metrics/debugger to spot the wasted vertices.
    if (table->DummyDrawChannel != (TableColumnIdx)-1)
    {
        DrawChannel* dummy_channel = &table->DrawSplitter._Channels[table->DummyDrawChannel];
        dummy_channel->_CmdBuffer.resize(0);
        dummy_channel->_IdxBuffer.resize(0);
    }
#endif

  // Flatten channels and merge draw calls
  DrawListSplitter *splitter = table->DrawSplitter;
  splitter->SetCurrentChannel(inner_window->DrawList, 0);
  if ((table->Flags & TableFlags_NoClip) == 0)
    TableMergeDrawChannels(table);
  splitter->Merge(inner_window->DrawList);

  // Update ColumnsAutoFitWidth to get us ahead for host using our size to
  // auto-resize without waiting for next BeginTable()
  float auto_fit_width_for_fixed = 0.0f;
  float auto_fit_width_for_stretched = 0.0f;
  float auto_fit_width_for_stretched_min = 0.0f;
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    if (GUI_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n)) {
      TableColumn *column = &table->Columns[column_n];
      float column_width_request =
          ((column->Flags & TableColumnFlags_WidthFixed) &&
           !(column->Flags & TableColumnFlags_NoResize))
              ? column->WidthRequest
              : TableGetColumnWidthAuto(table, column);
      if (column->Flags & TableColumnFlags_WidthFixed)
        auto_fit_width_for_fixed += column_width_request;
      else
        auto_fit_width_for_stretched += column_width_request;
      if ((column->Flags & TableColumnFlags_WidthStretch) &&
          (column->Flags & TableColumnFlags_NoResize) != 0)
        auto_fit_width_for_stretched_min =
            Max(auto_fit_width_for_stretched_min,
                column_width_request /
                    (column->StretchWeight / table->ColumnsStretchSumWeights));
    }
  const float width_spacings = (table->OuterPaddingX * 2.0f) +
                               (table->CellSpacingX1 + table->CellSpacingX2) *
                                   (table->ColumnsEnabledCount - 1);
  table->ColumnsAutoFitWidth =
      width_spacings +
      (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount +
      auto_fit_width_for_fixed +
      Max(auto_fit_width_for_stretched, auto_fit_width_for_stretched_min);

  // Update scroll
  if ((table->Flags & TableFlags_ScrollX) == 0 &&
      inner_window != outer_window) {
    inner_window->Scroll.x = 0.0f;
  } else if (table->LastResizedColumn != -1 && table->ResizedColumn == -1 &&
             inner_window->ScrollbarX &&
             table->InstanceInteracted == table->InstanceCurrent) {
    // When releasing a column being resized, scroll to keep the resulting
    // column in sight
    const float neighbor_width_to_keep_visible =
        table->MinColumnWidth + table->CellPaddingX * 2.0f;
    TableColumn *column = &table->Columns[table->LastResizedColumn];
    if (column->MaxX < table->InnerClipRect.Min.x)
      SetScrollFromPosX(inner_window,
                        column->MaxX - inner_window->Pos.x -
                            neighbor_width_to_keep_visible,
                        1.0f);
    else if (column->MaxX > table->InnerClipRect.Max.x)
      SetScrollFromPosX(inner_window,
                        column->MaxX - inner_window->Pos.x +
                            neighbor_width_to_keep_visible,
                        1.0f);
  }

  // Apply resizing/dragging at the end of the frame
  if (table->ResizedColumn != -1 &&
      table->InstanceCurrent == table->InstanceInteracted) {
    TableColumn *column = &table->Columns[table->ResizedColumn];
    const float new_x2 = (g.IO.MousePos.x - g.ActiveIdClickOffset.x +
                          TABLE_RESIZE_SEPARATOR_HALF_THICKNESS);
    const float new_width = Trunc(new_x2 - column->MinX - table->CellSpacingX1 -
                                  table->CellPaddingX * 2.0f);
    table->ResizedColumnNextWidth = new_width;
  }

  table->IsActiveIdInTable =
      (g.ActiveIdIsAlive != 0 && table->IsActiveIdAliveBeforeTable == false);

  // Pop from id stack
  GUI_ASSERT_USER_ERROR(inner_window->IDStack.back() ==
                            table_instance->TableInstanceID,
                        "Mismatching PushID/PopID!");
  GUI_ASSERT_USER_ERROR(outer_window->DC.ItemWidthStack.Size >=
                            temp_data->HostBackupItemWidthStackSize,
                        "Too many PopItemWidth!");
  if (table->InstanceCurrent > 0)
    PopID();
  PopID();

  // Restore window data that we modified
  const Vec2 backup_outer_max_pos = outer_window->DC.CursorMaxPos;
  inner_window->WorkRect = temp_data->HostBackupWorkRect;
  inner_window->ParentWorkRect = temp_data->HostBackupParentWorkRect;
  inner_window->SkipItems = table->HostSkipItems;
  outer_window->DC.CursorPos = table->OuterRect.Min;
  outer_window->DC.ItemWidth = temp_data->HostBackupItemWidth;
  outer_window->DC.ItemWidthStack.Size =
      temp_data->HostBackupItemWidthStackSize;
  outer_window->DC.ColumnsOffset = temp_data->HostBackupColumnsOffset;

  // Layout in outer window
  // (FIXME: To allow auto-fit and allow desirable effect of SameLine() we
  // dissociate 'used' vs 'ideal' size by overriding CursorPosPrevLine and
  // CursorMaxPos manually. That should be a more general layout feature, see
  // same problem e.g. #3414)
  if (inner_window != outer_window) {
    EndChild();
  } else {
    ItemSize(table->OuterRect.GetSize());
    ItemAdd(table->OuterRect, 0);
  }

  // Override declared contents width/height to enable auto-resize while not
  // needlessly adding a scrollbar
  if (table->Flags & TableFlags_NoHostExtendX) {
    // FIXME-TABLE: Could we remove this section?
    // ColumnsAutoFitWidth may be one frame ahead here since for Fixed+NoResize
    // is calculated from latest contents
    GUI_ASSERT((table->Flags & TableFlags_ScrollX) == 0);
    outer_window->DC.CursorMaxPos.x =
        Max(backup_outer_max_pos.x,
            table->OuterRect.Min.x + table->ColumnsAutoFitWidth);
  } else if (temp_data->UserOuterSize.x <= 0.0f) {
    const float decoration_size =
        table->TempData->AngledheadersExtraWidth +
        ((table->Flags & TableFlags_ScrollX) ? inner_window->ScrollbarSizes.x
                                             : 0.0f);
    outer_window->DC.IdealMaxPos.x =
        Max(outer_window->DC.IdealMaxPos.x,
            table->OuterRect.Min.x + table->ColumnsAutoFitWidth +
                decoration_size - temp_data->UserOuterSize.x);
    outer_window->DC.CursorMaxPos.x =
        Max(backup_outer_max_pos.x,
            Min(table->OuterRect.Max.x,
                table->OuterRect.Min.x + table->ColumnsAutoFitWidth));
  } else {
    outer_window->DC.CursorMaxPos.x =
        Max(backup_outer_max_pos.x, table->OuterRect.Max.x);
  }
  if (temp_data->UserOuterSize.y <= 0.0f) {
    const float decoration_size = (table->Flags & TableFlags_ScrollY)
                                      ? inner_window->ScrollbarSizes.y
                                      : 0.0f;
    outer_window->DC.IdealMaxPos.y =
        Max(outer_window->DC.IdealMaxPos.y,
            inner_content_max_y + decoration_size - temp_data->UserOuterSize.y);
    outer_window->DC.CursorMaxPos.y =
        Max(backup_outer_max_pos.y,
            Min(table->OuterRect.Max.y, inner_content_max_y));
  } else {
    // OuterRect.Max.y may already have been pushed downward from the initial
    // value (unless TableFlags_NoHostExtendY is set)
    outer_window->DC.CursorMaxPos.y =
        Max(backup_outer_max_pos.y, table->OuterRect.Max.y);
  }

  // Save settings
  if (table->IsSettingsDirty)
    TableSaveSettings(table);
  table->IsInitializing = false;

  // Clear or restore current table, if any
  GUI_ASSERT(g.CurrentWindow == outer_window && g.CurrentTable == table);
  GUI_ASSERT(g.TablesTempDataStacked > 0);
  temp_data = (--g.TablesTempDataStacked > 0)
                  ? &g.TablesTempData[g.TablesTempDataStacked - 1]
                  : NULL;
  g.CurrentTable =
      temp_data ? g.Tables.GetByIndex(temp_data->TableIndex) : NULL;
  if (g.CurrentTable) {
    g.CurrentTable->TempData = temp_data;
    g.CurrentTable->DrawSplitter = &temp_data->DrawSplitter;
  }
  outer_window->DC.CurrentTableIdx =
      g.CurrentTable ? g.Tables.GetIndex(g.CurrentTable) : -1;
  NavUpdateCurrentWindowIsScrollPushableX();
}

// See "COLUMNS SIZING POLICIES" comments at the top of this file
// If (init_width_or_weight <= 0.0f) it is ignored
inline void Gui::TableSetupColumn(const char *label, TableColumnFlags flags,
                                  float init_width_or_weight, ID user_id) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  GUI_ASSERT(table != NULL &&
             "Need to call TableSetupColumn() after BeginTable()!");
  GUI_ASSERT(table->IsLayoutLocked == false &&
             "Need to call call TableSetupColumn() before first row!");
  GUI_ASSERT((flags & TableColumnFlags_StatusMask_) == 0 &&
             "Illegal to pass StatusMask values to TableSetupColumn()");
  if (table->DeclColumnsCount >= table->ColumnsCount) {
    GUI_ASSERT_USER_ERROR(table->DeclColumnsCount < table->ColumnsCount,
                          "Called TableSetupColumn() too many times!");
    return;
  }

  TableColumn *column = &table->Columns[table->DeclColumnsCount];
  table->DeclColumnsCount++;

  // Assert when passing a width or weight if policy is entirely left to
  // default, to avoid storing width into weight and vice-versa. Give a grace to
  // users of TableFlags_ScrollX.
  if (table->IsDefaultSizingPolicy &&
      (flags & TableColumnFlags_WidthMask_) == 0 &&
      (flags & TableFlags_ScrollX) == 0)
    GUI_ASSERT(init_width_or_weight <= 0.0f &&
               "Can only specify width/weight if sizing policy is set "
               "explicitly in either Table or Column.");

  // When passing a width automatically enforce WidthFixed policy
  // (whereas TableSetupColumnFlags would default to WidthAuto if table is not
  // Resizable)
  if ((flags & TableColumnFlags_WidthMask_) == 0 && init_width_or_weight > 0.0f)
    if ((table->Flags & TableFlags_SizingMask_) == TableFlags_SizingFixedFit ||
        (table->Flags & TableFlags_SizingMask_) == TableFlags_SizingFixedSame)
      flags |= TableColumnFlags_WidthFixed;
  if (flags & TableColumnFlags_AngledHeader) {
    flags |= TableColumnFlags_NoHeaderLabel;
    table->AngledHeadersCount++;
  }

  TableSetupColumnFlags(table, column, flags);
  column->UserID = user_id;
  flags = column->Flags;

  // Initialize defaults
  column->InitStretchWeightOrWidth = init_width_or_weight;
  if (table->IsInitializing) {
    // Init width or weight
    if (column->WidthRequest < 0.0f && column->StretchWeight < 0.0f) {
      if ((flags & TableColumnFlags_WidthFixed) && init_width_or_weight > 0.0f)
        column->WidthRequest = init_width_or_weight;
      if (flags & TableColumnFlags_WidthStretch)
        column->StretchWeight =
            (init_width_or_weight > 0.0f) ? init_width_or_weight : -1.0f;

      // Disable auto-fit if an explicit width/weight has been specified
      if (init_width_or_weight > 0.0f)
        column->AutoFitQueue = 0x00;
    }

    // Init default visibility/sort state
    if ((flags & TableColumnFlags_DefaultHide) &&
        (table->SettingsLoadedFlags & TableFlags_Hideable) == 0)
      column->IsUserEnabled = column->IsUserEnabledNextFrame = false;
    if (flags & TableColumnFlags_DefaultSort &&
        (table->SettingsLoadedFlags & TableFlags_Sortable) == 0) {
      column->SortOrder =
          0; // Multiple columns using _DefaultSort will be reassigned unique
             // SortOrder values when building the sort specs.
      column->SortDirection =
          (column->Flags & TableColumnFlags_PreferSortDescending)
              ? (S8)SortDirection_Descending
              : (U8)(SortDirection_Ascending);
    }
  }

  // Store name (append with zero-terminator in contiguous buffer)
  column->NameOffset = -1;
  if (label != NULL && label[0] != 0) {
    column->NameOffset = (S16)table->ColumnsNames.size();
    table->ColumnsNames.append(label, label + strlen(label) + 1);
  }
}

// [Public]
inline void Gui::TableSetupScrollFreeze(int columns, int rows) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  GUI_ASSERT(table != NULL &&
             "Need to call TableSetupColumn() after BeginTable()!");
  GUI_ASSERT(table->IsLayoutLocked == false &&
             "Need to call TableSetupColumn() before first row!");
  GUI_ASSERT(columns >= 0 && columns < GUI_TABLE_MAX_COLUMNS);
  GUI_ASSERT(rows >= 0 && rows < 128); // Arbitrary limit

  table->FreezeColumnsRequest =
      (table->Flags & TableFlags_ScrollX)
          ? (TableColumnIdx)Min(columns, table->ColumnsCount)
          : 0;
  table->FreezeColumnsCount =
      (table->InnerWindow->Scroll.x != 0.0f) ? table->FreezeColumnsRequest : 0;
  table->FreezeRowsRequest =
      (table->Flags & TableFlags_ScrollY) ? (TableColumnIdx)rows : 0;
  table->FreezeRowsCount =
      (table->InnerWindow->Scroll.y != 0.0f) ? table->FreezeRowsRequest : 0;
  table->IsUnfrozenRows =
      (table->FreezeRowsCount ==
       0); // Make sure this is set before TableUpdateLayout() so
           // ListClipper can benefit from it.b

  // Ensure frozen columns are ordered in their section. We still allow multiple
  // frozen columns to be reordered.
  // FIXME-TABLE: This work for preserving 2143 into 21|43. How about 4321
  // turning into 21|43? (preserve relative order in each section)
  for (int column_n = 0; column_n < table->FreezeColumnsRequest; column_n++) {
    int order_n = table->DisplayOrderToIndex[column_n];
    if (order_n != column_n && order_n >= table->FreezeColumnsRequest) {
      Swap(table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder,
           table->Columns[table->DisplayOrderToIndex[column_n]].DisplayOrder);
      Swap(table->DisplayOrderToIndex[order_n],
           table->DisplayOrderToIndex[column_n]);
    }
  }
}

//-----------------------------------------------------------------------------
// [SECTION] Tables: Simple accessors
//-----------------------------------------------------------------------------
// - TableGetColumnCount()
// - TableGetColumnName()
// - TableGetColumnName() [Internal]
// - TableSetColumnEnabled()
// - TableGetColumnFlags()
// - TableGetCellBgRect() [Internal]
// - TableGetColumnResizeID() [Internal]
// - TableGetHoveredColumn() [Internal]
// - TableGetHoveredRow() [Internal]
// - TableSetBgColor()
//-----------------------------------------------------------------------------

inline int Gui::TableGetColumnCount() {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  return table ? table->ColumnsCount : 0;
}

inline const char *Gui::TableGetColumnName(int column_n) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  if (!table)
    return NULL;
  if (column_n < 0)
    column_n = table->CurrentColumn;
  return TableGetColumnName(table, column_n);
}

// Change user accessible enabled/disabled state of a column (often perceived as
// "showing/hiding" from users point of view) Note that end-user can use the
// context menu to change this themselves (right-click in headers, or
// right-click in columns body with TableFlags_ContextMenuInBody)
// - Require table to have the TableFlags_Hideable flag because we are
// manipulating user accessible state.
// - Request will be applied during next layout, which happens on the first call
// to TableNextRow() after BeginTable().
// - For the getter you can test (TableGetColumnFlags() &
// TableColumnFlags_IsEnabled) != 0.
// - Alternative: the TableColumnFlags_Disabled is an overriding/master
// disable flag which will also hide the column from context menu.
inline void Gui::TableSetColumnEnabled(int column_n, bool enabled) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  GUI_ASSERT(table != NULL);
  if (!table)
    return;
  GUI_ASSERT(table->Flags & TableFlags_Hideable); // See comments above
  if (column_n < 0)
    column_n = table->CurrentColumn;
  GUI_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
  TableColumn *column = &table->Columns[column_n];
  column->IsUserEnabledNextFrame = enabled;
}

// We allow querying for an extra column in order to poll the IsHovered state of
// the right-most section
inline TableColumnFlags Gui::TableGetColumnFlags(int column_n) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  if (!table)
    return TableColumnFlags_None;
  if (column_n < 0)
    column_n = table->CurrentColumn;
  if (column_n == table->ColumnsCount)
    return (table->HoveredColumnBody == column_n) ? TableColumnFlags_IsHovered
                                                  : TableColumnFlags_None;
  return table->Columns[column_n].Flags;
}

// Return the cell rectangle based on currently known height.
// - Important: we generally don't know our row height until the end of the row,
// so Max.y will be incorrect in many situations.
//   The only case where this is correct is if we provided a min_row_height to
//   TableNextRow() and don't go below it, or in TableEndRow() when we locked
//   that height.
// - Important: if TableFlags_PadOuterX is set but
// TableFlags_PadInnerX is not set, the outer-most left and right
//   columns report a small offset so their CellBgRect can extend up to the
//   outer border.
//   FIXME: But the rendering code in TableEndRow() nullifies that with clamping
//   required for scrolling.

// Return the resizing ID for the right-side of the given column.
inline ID Gui::TableGetColumnResizeID(Table *table, int column_n,
                                      int instance_no) {
  GUI_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
  ID instance_id = TableGetInstanceID(table, instance_no);
  return instance_id + 1 + column_n; // FIXME: #6140: still not ideal
}

// Return -1 when table is not hovered. return columns_count if hovering the
// unused space at the right of the right-most visible column.

// Return -1 when table is not hovered. Return maxrow+1 if in table but below
// last submitted row. *IMPORTANT* Unlike TableGetHoveredColumn(), this has a
// one frame latency in updating the value. This difference with is the reason
// why this is not public yet.
inline int Gui::TableGetHoveredRow() {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  if (!table)
    return -1;
  TableInstanceData *table_instance =
      TableGetInstanceData(table, table->InstanceCurrent);
  return (int)table_instance->HoveredRowLast;
}

inline void Gui::TableSetBgColor(TableBgTarget target, U32 color,
                                 int column_n) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  GUI_ASSERT(target != TableBgTarget_None);

  if (color == GUI_COL32_DISABLE)
    color = 0;

  // We cannot draw neither the cell or row background immediately as we don't
  // know the row height at this point in time.
  switch (target) {
  case TableBgTarget_CellBg: {
    if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
      return;
    if (column_n == -1)
      column_n = table->CurrentColumn;
    if (!GUI_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))
      return;
    if (table->RowCellDataCurrent < 0 ||
        table->RowCellData[table->RowCellDataCurrent].Column != column_n)
      table->RowCellDataCurrent++;
    TableCellData *cell_data = &table->RowCellData[table->RowCellDataCurrent];
    cell_data->BgColor = color;
    cell_data->Column = (TableColumnIdx)column_n;
    break;
  }
  case TableBgTarget_RowBg0:
  case TableBgTarget_RowBg1: {
    if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
      return;
    GUI_ASSERT(column_n == -1);
    int bg_idx = (target == TableBgTarget_RowBg1) ? 1 : 0;
    table->RowBgColor[bg_idx] = color;
    break;
  }
  default:
    GUI_ASSERT(0);
  }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Row changes
//-------------------------------------------------------------------------
// - TableGetRowIndex()
// - TableNextRow()
// - TableBeginRow() [Internal]
// - TableEndRow() [Internal]
//-------------------------------------------------------------------------

// [Public] Note: for row coloring we use ->RowBgColorCounter which is the same
// value without counting header rows
inline int Gui::TableGetRowIndex() {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  if (!table)
    return 0;
  return table->CurrentRow;
}

// [Public] Starts into the first cell of a new row
inline void Gui::TableNextRow(TableRowFlags row_flags, float row_min_height) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;

  if (!table->IsLayoutLocked)
    TableUpdateLayout(table);
  if (table->IsInsideRow)
    TableEndRow(table);

  table->LastRowFlags = table->RowFlags;
  table->RowFlags = row_flags;
  table->RowCellPaddingY = g.Style.CellPadding.y;
  table->RowMinHeight = row_min_height;
  TableBeginRow(table);

  // We honor min_row_height requested by user, but cannot guarantee per-row
  // maximum height, because that would essentially require a unique clipping
  // rectangle per-cell.
  table->RowPosY2 += table->RowCellPaddingY * 2.0f;
  table->RowPosY2 = Max(table->RowPosY2, table->RowPosY1 + row_min_height);

  // Disable output until user calls TableNextColumn()
  table->InnerWindow->SkipItems = true;
}

// [Internal] Only called by TableNextRow()
inline void Gui::TableBeginRow(Table *table) {
  Window *window = table->InnerWindow;
  GUI_ASSERT(!table->IsInsideRow);

  // New row
  table->CurrentRow++;
  table->CurrentColumn = -1;
  table->RowBgColor[0] = table->RowBgColor[1] = GUI_COL32_DISABLE;
  table->RowCellDataCurrent = -1;
  table->IsInsideRow = true;

  // Begin frozen rows
  float next_y1 = table->RowPosY2;
  if (table->CurrentRow == 0 && table->FreezeRowsCount > 0)
    next_y1 = window->DC.CursorPos.y = table->OuterRect.Min.y;

  table->RowPosY1 = table->RowPosY2 = next_y1;
  table->RowTextBaseline = 0.0f;
  table->RowIndentOffsetX =
      window->DC.Indent.x - table->HostIndentX; // Lock indent

  window->DC.PrevLineTextBaseOffset = 0.0f;
  window->DC.CursorPosPrevLine =
      Vec2(window->DC.CursorPos.x,
           window->DC.CursorPos.y +
               table->RowCellPaddingY); // This allows users to call SameLine()
                                        // to share LineSize between columns.
  window->DC.PrevLineSize = window->DC.CurrLineSize = Vec2(
      0.0f, 0.0f); // This allows users to call SameLine() to share LineSize
                   // between columns, and to call it from first column too.
  window->DC.IsSameLine = window->DC.IsSetPos = false;
  window->DC.CursorMaxPos.y = next_y1;

  // Making the header BG color non-transparent will allow us to overlay it
  // multiple times when handling smooth dragging.
  if (table->RowFlags & TableRowFlags_Headers) {
    TableSetBgColor(TableBgTarget_RowBg0, GetColorU32(Col_TableHeaderBg));
    if (table->CurrentRow == 0)
      table->IsUsingHeaders = true;
  }
}

// [Internal] Called by TableNextRow()
inline void Gui::TableEndRow(Table *table) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_ASSERT(window == table->InnerWindow);
  GUI_ASSERT(table->IsInsideRow);

  if (table->CurrentColumn != -1)
    TableEndCell(table);

  // Logging
  if (g.LogEnabled)
    LogRenderedText(NULL, "|");

  // Position cursor at the bottom of our row so it can be used for e.g.
  // clipping calculation. However it is likely that the next call to
  // TableBeginCell() will reposition the cursor to take account of vertical
  // padding.
  window->DC.CursorPos.y = table->RowPosY2;

  // Row background fill
  const float bg_y1 = table->RowPosY1;
  const float bg_y2 = table->RowPosY2;
  const bool unfreeze_rows_actual =
      (table->CurrentRow + 1 == table->FreezeRowsCount);
  const bool unfreeze_rows_request =
      (table->CurrentRow + 1 == table->FreezeRowsRequest);
  TableInstanceData *table_instance =
      TableGetInstanceData(table, table->InstanceCurrent);
  if ((table->RowFlags & TableRowFlags_Headers) &&
      (table->CurrentRow == 0 || (table->LastRowFlags & TableRowFlags_Headers)))
    table_instance->LastTopHeadersRowHeight += bg_y2 - bg_y1;

  const bool is_visible = (bg_y2 >= table->InnerClipRect.Min.y &&
                           bg_y1 <= table->InnerClipRect.Max.y);
  if (is_visible) {
    // Update data for TableGetHoveredRow()
    if (table->HoveredColumnBody != -1 && g.IO.MousePos.y >= bg_y1 &&
        g.IO.MousePos.y < bg_y2)
      table_instance->HoveredRowNext = table->CurrentRow;

    // Decide of background color for the row
    U32 bg_col0 = 0;
    U32 bg_col1 = 0;
    if (table->RowBgColor[0] != GUI_COL32_DISABLE)
      bg_col0 = table->RowBgColor[0];
    else if (table->Flags & TableFlags_RowBg)
      bg_col0 = GetColorU32((table->RowBgColorCounter & 1) ? Col_TableRowBgAlt
                                                           : Col_TableRowBg);
    if (table->RowBgColor[1] != GUI_COL32_DISABLE)
      bg_col1 = table->RowBgColor[1];

    // Decide of top border color
    U32 top_border_col = 0;
    const float border_size = TABLE_BORDER_SIZE;
    if (table->CurrentRow > 0 && (table->Flags & TableFlags_BordersInnerH))
      top_border_col = (table->LastRowFlags & TableRowFlags_Headers)
                           ? table->BorderColorStrong
                           : table->BorderColorLight;

    const bool draw_cell_bg_color = table->RowCellDataCurrent >= 0;
    const bool draw_strong_bottom_border = unfreeze_rows_actual;
    if ((bg_col0 | bg_col1 | top_border_col) != 0 ||
        draw_strong_bottom_border || draw_cell_bg_color) {
      // In theory we could call SetWindowClipRectBeforeSetChannel() but since
      // we know TableEndRow() is always followed by a change of clipping
      // rectangle we perform the smallest overwrite possible here.
      if ((table->Flags & TableFlags_NoClip) == 0)
        window->DrawList->_CmdHeader.ClipRect =
            table->Bg0ClipRectForDrawCmd.ToVec4();
      table->DrawSplitter->SetCurrentChannel(window->DrawList,
                                             TABLE_DRAW_CHANNEL_BG0);
    }

    // Draw row background
    // We soft/cpu clip this so all backgrounds and borders can share the same
    // clipping rectangle
    if (bg_col0 || bg_col1) {
      Rect row_rect(table->WorkRect.Min.x, bg_y1, table->WorkRect.Max.x, bg_y2);
      row_rect.ClipWith(table->BgClipRect);
      if (bg_col0 != 0 && row_rect.Min.y < row_rect.Max.y)
        window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col0);
      if (bg_col1 != 0 && row_rect.Min.y < row_rect.Max.y)
        window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col1);
    }

    // Draw cell background color
    if (draw_cell_bg_color) {
      TableCellData *cell_data_end =
          &table->RowCellData[table->RowCellDataCurrent];
      for (TableCellData *cell_data = &table->RowCellData[0];
           cell_data <= cell_data_end; cell_data++) {
        // As we render the BG here we need to clip things (for layout we would
        // not)
        // FIXME: This cancels the OuterPadding addition done by
        // TableGetCellBgRect(), need to keep it while rendering correctly while
        // scrolling.
        const TableColumn *column = &table->Columns[cell_data->Column];
        Rect cell_bg_rect = TableGetCellBgRect(table, cell_data->Column);
        cell_bg_rect.ClipWith(table->BgClipRect);
        cell_bg_rect.Min.x =
            Max(cell_bg_rect.Min.x,
                column->ClipRect.Min.x); // So that first column after frozen
                                         // one gets clipped when scrolling
        cell_bg_rect.Max.x = Min(cell_bg_rect.Max.x, column->MaxX);
        window->DrawList->AddRectFilled(cell_bg_rect.Min, cell_bg_rect.Max,
                                        cell_data->BgColor);
      }
    }

    // Draw top border
    if (top_border_col && bg_y1 >= table->BgClipRect.Min.y &&
        bg_y1 < table->BgClipRect.Max.y)
      window->DrawList->AddLine(Vec2(table->BorderX1, bg_y1),
                                Vec2(table->BorderX2, bg_y1), top_border_col,
                                border_size);

    // Draw bottom border at the row unfreezing mark (always strong)
    if (draw_strong_bottom_border && bg_y2 >= table->BgClipRect.Min.y &&
        bg_y2 < table->BgClipRect.Max.y)
      window->DrawList->AddLine(Vec2(table->BorderX1, bg_y2),
                                Vec2(table->BorderX2, bg_y2),
                                table->BorderColorStrong, border_size);
  }

  // End frozen rows (when we are past the last frozen row line, teleport cursor
  // and alter clipping rectangle) We need to do that in TableEndRow() instead
  // of TableBeginRow() so the list clipper can mark end of row and get the new
  // cursor position.
  if (unfreeze_rows_request)
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
      table->Columns[column_n].NavLayerCurrent = NavLayer_Main;
  if (unfreeze_rows_actual) {
    GUI_ASSERT(table->IsUnfrozenRows == false);
    const float y0 = Max(table->RowPosY2 + 1, window->InnerClipRect.Min.y);
    table->IsUnfrozenRows = true;
    table_instance->LastFrozenHeight = y0 - table->OuterRect.Min.y;

    // BgClipRect starts as table->InnerClipRect, reduce it now and make
    // BgClipRectForDrawCmd == BgClipRect
    table->BgClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y =
        Min(y0, window->InnerClipRect.Max.y);
    table->BgClipRect.Max.y = table->Bg2ClipRectForDrawCmd.Max.y =
        window->InnerClipRect.Max.y;
    table->Bg2DrawChannelCurrent = table->Bg2DrawChannelUnfrozen;
    GUI_ASSERT(table->Bg2ClipRectForDrawCmd.Min.y <=
               table->Bg2ClipRectForDrawCmd.Max.y);

    float row_height = table->RowPosY2 - table->RowPosY1;
    table->RowPosY2 = window->DC.CursorPos.y =
        table->WorkRect.Min.y + table->RowPosY2 - table->OuterRect.Min.y;
    table->RowPosY1 = table->RowPosY2 - row_height;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
      TableColumn *column = &table->Columns[column_n];
      column->DrawChannelCurrent = column->DrawChannelUnfrozen;
      column->ClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y;
    }

    // Update cliprect ahead of TableBeginCell() so clipper can access to new
    // ClipRect->Min.y
    SetWindowClipRectBeforeSetChannel(window, table->Columns[0].ClipRect);
    table->DrawSplitter->SetCurrentChannel(
        window->DrawList, table->Columns[0].DrawChannelCurrent);
  }

  if (!(table->RowFlags & TableRowFlags_Headers))
    table->RowBgColorCounter++;
  table->IsInsideRow = false;
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns changes
//-------------------------------------------------------------------------
// - TableGetColumnIndex()
// - TableSetColumnIndex()
// - TableNextColumn()
// - TableBeginCell() [Internal]
// - TableEndCell() [Internal]
//-------------------------------------------------------------------------

inline int Gui::TableGetColumnIndex() {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  if (!table)
    return 0;
  return table->CurrentColumn;
}

// [Public] Append into a specific column
inline bool Gui::TableSetColumnIndex(int column_n) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  if (!table)
    return false;

  if (table->CurrentColumn != column_n) {
    if (table->CurrentColumn != -1)
      TableEndCell(table);
    GUI_ASSERT(column_n >= 0 && table->ColumnsCount);
    TableBeginCell(table, column_n);
  }

  // Return whether the column is visible. User may choose to skip submitting
  // items based on this return value, however they shouldn't skip submitting
  // for columns that may have the tallest contribution to row height.
  return table->Columns[column_n].IsRequestOutput;
}

// [Public] Append into the next column, wrap and create a new row when already
// on last column
inline bool Gui::TableNextColumn() {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  if (!table)
    return false;

  if (table->IsInsideRow && table->CurrentColumn + 1 < table->ColumnsCount) {
    if (table->CurrentColumn != -1)
      TableEndCell(table);
    TableBeginCell(table, table->CurrentColumn + 1);
  } else {
    TableNextRow();
    TableBeginCell(table, 0);
  }

  // Return whether the column is visible. User may choose to skip submitting
  // items based on this return value, however they shouldn't skip submitting
  // for columns that may have the tallest contribution to row height.
  return table->Columns[table->CurrentColumn].IsRequestOutput;
}

// [Internal] Called by TableSetColumnIndex()/TableNextColumn()
// This is called very frequently, so we need to be mindful of unnecessary
// overhead.
// FIXME-TABLE FIXME-OPT: Could probably shortcut some things for non-active or
// clipped columns.
inline void Gui::TableBeginCell(Table *table, int column_n) {
  Context &g = *GGui;
  TableColumn *column = &table->Columns[column_n];
  Window *window = table->InnerWindow;
  table->CurrentColumn = column_n;

  // Start position is roughly ~~ CellRect.Min + CellPadding + Indent
  float start_x = column->WorkMinX;
  if (column->Flags & TableColumnFlags_IndentEnable)
    start_x += table->RowIndentOffsetX; // ~~ += window.DC.Indent.x -
                                        // table->HostIndentX, except we locked
                                        // it for the row.

  window->DC.CursorPos.x = start_x;
  window->DC.CursorPos.y = table->RowPosY1 + table->RowCellPaddingY;
  window->DC.CursorMaxPos.x = window->DC.CursorPos.x;
  window->DC.ColumnsOffset.x =
      start_x - window->Pos.x - window->DC.Indent.x; // FIXME-WORKRECT
  window->DC.CursorPosPrevLine.x =
      window->DC.CursorPos
          .x; // PrevLine.y is preserved. This allows users to call SameLine()
              // to share LineSize between columns.
  window->DC.CurrLineTextBaseOffset = table->RowTextBaseline;
  window->DC.NavLayerCurrent = (NavLayer)column->NavLayerCurrent;

  // Note how WorkRect.Max.y is only set once during layout
  window->WorkRect.Min.y = window->DC.CursorPos.y;
  window->WorkRect.Min.x = column->WorkMinX;
  window->WorkRect.Max.x = column->WorkMaxX;
  window->DC.ItemWidth = column->ItemWidth;

  window->SkipItems = column->IsSkipItems;
  if (column->IsSkipItems) {
    g.LastItemData.ID = 0;
    g.LastItemData.StatusFlags = 0;
  }

  if (table->Flags & TableFlags_NoClip) {
    // FIXME: if we end up drawing all borders/bg in EndTable, could remove this
    // and just assert that channel hasn't changed.
    table->DrawSplitter->SetCurrentChannel(window->DrawList,
                                           TABLE_DRAW_CHANNEL_NOCLIP);
    // GUI_ASSERT(table->DrawSplitter._Current == TABLE_DRAW_CHANNEL_NOCLIP);
  } else {
    // FIXME-TABLE: Could avoid this if draw channel is dummy channel?
    SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
    table->DrawSplitter->SetCurrentChannel(window->DrawList,
                                           column->DrawChannelCurrent);
  }

  // Logging
  if (g.LogEnabled && !column->IsSkipItems) {
    LogRenderedText(&window->DC.CursorPos, "|");
    g.LogLinePosY = FLT_MAX;
  }
}

// [Internal] Called by TableNextRow()/TableSetColumnIndex()/TableNextColumn()
inline void Gui::TableEndCell(Table *table) {
  TableColumn *column = &table->Columns[table->CurrentColumn];
  Window *window = table->InnerWindow;

  if (window->DC.IsSetPos)
    ErrorCheckUsingSetCursorPosToExtendParentBoundaries();

  // Report maximum position so we can infer content size per column.
  float *p_max_pos_x;
  if (table->RowFlags & TableRowFlags_Headers)
    p_max_pos_x =
        &column->ContentMaxXHeadersUsed; // Useful in case user submit contents
                                         // in header row that is not a
                                         // TableHeader() call
  else
    p_max_pos_x = table->IsUnfrozenRows ? &column->ContentMaxXUnfrozen
                                        : &column->ContentMaxXFrozen;
  *p_max_pos_x = Max(*p_max_pos_x, window->DC.CursorMaxPos.x);
  if (column->IsEnabled)
    table->RowPosY2 = Max(table->RowPosY2,
                          window->DC.CursorMaxPos.y + table->RowCellPaddingY);
  column->ItemWidth = window->DC.ItemWidth;

  // Propagate text baseline for the entire row
  // FIXME-TABLE: Here we propagate text baseline from the last line of the
  // cell.. instead of the first one.
  table->RowTextBaseline =
      Max(table->RowTextBaseline, window->DC.PrevLineTextBaseOffset);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns width management
//-------------------------------------------------------------------------
// - TableGetMaxColumnWidth() [Internal]
// - TableGetColumnWidthAuto() [Internal]
// - TableSetColumnWidth()
// - TableSetColumnWidthAutoSingle() [Internal]
// - TableSetColumnWidthAutoAll() [Internal]
// - TableUpdateColumnsWeightFromWidth() [Internal]
//-------------------------------------------------------------------------

// Maximum column content width given current layout. Use column->MinX so this
// value on a per-column basis.

// Note this is meant to be stored in column->WidthAuto, please generally use
// the WidthAuto field

// 'width' = inner column width, without padding
inline void Gui::TableSetColumnWidth(int column_n, float width) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  GUI_ASSERT(table != NULL && table->IsLayoutLocked == false);
  GUI_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
  TableColumn *column_0 = &table->Columns[column_n];
  float column_0_width = width;

  // Apply constraints early
  // Compare both requested and actual given width to avoid overwriting
  // requested width when column is stuck (minimum size, bounded)
  GUI_ASSERT(table->MinColumnWidth > 0.0f);
  const float min_width = table->MinColumnWidth;
  const float max_width =
      Max(min_width, TableGetMaxColumnWidth(table, column_n));
  column_0_width = Clamp(column_0_width, min_width, max_width);
  if (column_0->WidthGiven == column_0_width ||
      column_0->WidthRequest == column_0_width)
    return;

  // GUI_DEBUG_PRINT("TableSetColumnWidth(%d, %.1f->%.1f)\n", column_0_idx,
  // column_0->WidthGiven, column_0_width);
  TableColumn *column_1 = (column_0->NextEnabledColumn != -1)
                              ? &table->Columns[column_0->NextEnabledColumn]
                              : NULL;

  // In this surprisingly not simple because of how we support mixing Fixed and
  // multiple Stretch columns.
  // - All fixed: easy.
  // - All stretch: easy.
  // - One or more fixed + one stretch: easy.
  // - One or more fixed + more than one stretch: tricky.
  // Qt when manual resize is enabled only supports a single _trailing_ stretch
  // column, we support more cases here.

  // When forwarding resize from Wn| to Fn+1| we need to be considerate of the
  // _NoResize flag on Fn+1.
  // FIXME-TABLE: Find a way to rewrite all of this so interactions feel more
  // consistent for the user. Scenarios:
  // - F1 F2 F3  resize from F1| or F2|   --> ok: alter ->WidthRequested of
  // Fixed column. Subsequent columns will be offset.
  // - F1 F2 F3  resize from F3|          --> ok: alter ->WidthRequested of
  // Fixed column. If active, ScrollX extent can be altered.
  // - F1 F2 W3  resize from F1| or F2|   --> ok: alter ->WidthRequested of
  // Fixed column. If active, ScrollX extent can be altered, but it doesn't make
  // much sense as the Stretch column will always be minimal size.
  // - F1 F2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule
  // 1)
  // - W1 W2 W3  resize from W1| or W2|   --> ok
  // - W1 W2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule
  // 1)
  // - W1 F2 F3  resize from F3|          --> ok: no-op (disabled by Resize Rule
  // 1)
  // - W1 F2     resize from F2|          --> ok: no-op (disabled by Resize Rule
  // 1)
  // - W1 W2 F3  resize from W1| or W2|   --> ok
  // - W1 F2 W3  resize from W1| or F2|   --> ok
  // - F1 W2 F3  resize from W2|          --> ok
  // - F1 W3 F2  resize from W3|          --> ok
  // - W1 F2 F3  resize from W1|          --> ok: equivalent to resizing |F2. F3
  // will not move.
  // - W1 F2 F3  resize from F2|          --> ok
  // All resizes from a Wx columns are locking other columns.

  // Possible improvements:
  // - W1 W2 W3  resize W1|               --> to not be stuck, both W2 and W3
  // would stretch down. Seems possible to fix. Would be most beneficial to
  // simplify resize of all-weighted columns.
  // - W3 F1 F2  resize W3|               --> to not be stuck past F1|, both F1
  // and F2 would need to stretch down, which would be lossy or ambiguous. Seems
  // hard to fix.

  // [Resize Rule 1] Can't resize from right of right-most visible column if
  // there is any Stretch column. Implemented in TableUpdateLayout().

  // If we have all Fixed columns OR resizing a Fixed column that doesn't come
  // after a Stretch one, we can do an offsetting resize. This is the preferred
  // resize path
  if (column_0->Flags & TableColumnFlags_WidthFixed)
    if (!column_1 || table->LeftMostStretchedColumn == -1 ||
        table->Columns[table->LeftMostStretchedColumn].DisplayOrder >=
            column_0->DisplayOrder) {
      column_0->WidthRequest = column_0_width;
      table->IsSettingsDirty = true;
      return;
    }

  // We can also use previous column if there's no next one (this is used when
  // doing an auto-fit on the right-most stretch column)
  if (column_1 == NULL)
    column_1 = (column_0->PrevEnabledColumn != -1)
                   ? &table->Columns[column_0->PrevEnabledColumn]
                   : NULL;
  if (column_1 == NULL)
    return;

  // Resizing from right-side of a Stretch column before a Fixed column forward
  // sizing to left-side of fixed column. (old_a + old_b == new_a + new_b) -->
  // (new_a == old_a + old_b - new_b)
  float column_1_width =
      Max(column_1->WidthRequest - (column_0_width - column_0->WidthRequest),
          min_width);
  column_0_width =
      column_0->WidthRequest + column_1->WidthRequest - column_1_width;
  GUI_ASSERT(column_0_width > 0.0f && column_1_width > 0.0f);
  column_0->WidthRequest = column_0_width;
  column_1->WidthRequest = column_1_width;
  if ((column_0->Flags | column_1->Flags) & TableColumnFlags_WidthStretch)
    TableUpdateColumnsWeightFromWidth(table);
  table->IsSettingsDirty = true;
}

// Disable clipping then auto-fit, will take 2 frames
// (we don't take a shortcut for unclipped columns to reduce inconsistencies
// when e.g. resizing multiple columns)

inline void Gui::TableUpdateColumnsWeightFromWidth(Table *table) {
  GUI_ASSERT(table->LeftMostStretchedColumn != -1 &&
             table->RightMostStretchedColumn != -1);

  // Measure existing quantities
  float visible_weight = 0.0f;
  float visible_width = 0.0f;
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
    TableColumn *column = &table->Columns[column_n];
    if (!column->IsEnabled || !(column->Flags & TableColumnFlags_WidthStretch))
      continue;
    GUI_ASSERT(column->StretchWeight > 0.0f);
    visible_weight += column->StretchWeight;
    visible_width += column->WidthRequest;
  }
  GUI_ASSERT(visible_weight > 0.0f && visible_width > 0.0f);

  // Apply new weights
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
    TableColumn *column = &table->Columns[column_n];
    if (!column->IsEnabled || !(column->Flags & TableColumnFlags_WidthStretch))
      continue;
    column->StretchWeight =
        (column->WidthRequest / visible_width) * visible_weight;
    GUI_ASSERT(column->StretchWeight > 0.0f);
  }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Drawing
//-------------------------------------------------------------------------
// - TablePushBackgroundChannel() [Internal]
// - TablePopBackgroundChannel() [Internal]
// - TableSetupDrawChannels() [Internal]
// - TableMergeDrawChannels() [Internal]
// - TableGetColumnBorderCol() [Internal]
// - TableDrawBorders() [Internal]
//-------------------------------------------------------------------------

// Bg2 is used by Selectable (and possibly other widgets) to render to the
// background. Unlike our Bg0/1 channel which we uses for RowBg/CellBg/Borders
// and where we guarantee all shapes to be CPU-clipped, the Bg2 channel being
// widgets-facing will rely on regular ClipRect.

// Allocate draw channels. Called by TableUpdateLayout()
// - We allocate them following storage order instead of display order so
// reordering columns won't needlessly
//   increase overall dormant memory cost.
// - We isolate headers draw commands in their own channels instead of just
// altering clip rects.
//   This is in order to facilitate merging of draw commands.
// - After crossing FreezeRowsCount, all columns see their current draw channel
// changed to a second set of channels.
// - We only use the dummy draw channel so we can push a null clipping rectangle
// into it without affecting other
//   channels, while simplifying per-row/per-cell overhead. It will be empty and
//   discarded when merged.
// - We allocate 1 or 2 background draw channels. This is because we know
// TablePushBackgroundChannel() is only used for
//   horizontal spanning. If we allowed vertical spanning we'd need one
//   background draw channel per merge group (1-4).
// Draw channel allocation (before merging):
// - NoClip                       --> 2+D+1 channels: bg0/1 + bg2 + foreground
// (same clip rect == always 1 draw call)
// - Clip                         --> 2+D+N channels
// - FreezeRows                   --> 2+D+N*2 (unless scrolling value is zero)
// - FreezeRows || FreezeColunns  --> 3+D+N*2 (unless scrolling value is zero)
// Where D is 1 if any column is clipped or hidden (dummy channel) otherwise 0.
inline void Gui::TableSetupDrawChannels(Table *table) {
  const int freeze_row_multiplier = (table->FreezeRowsCount > 0) ? 2 : 1;
  const int channels_for_row =
      (table->Flags & TableFlags_NoClip) ? 1 : table->ColumnsEnabledCount;
  const int channels_for_bg = 1 + 1 * freeze_row_multiplier;
  const int channels_for_dummy =
      (table->ColumnsEnabledCount < table->ColumnsCount ||
       (memcmp(table->VisibleMaskByIndex, table->EnabledMaskByIndex,
               BitArrayGetStorageSizeInBytes(table->ColumnsCount)) != 0))
          ? +1
          : 0;
  const int channels_total = channels_for_bg +
                             (channels_for_row * freeze_row_multiplier) +
                             channels_for_dummy;
  table->DrawSplitter->Split(table->InnerWindow->DrawList, channels_total);
  table->DummyDrawChannel =
      (TableDrawChannelIdx)((channels_for_dummy > 0) ? channels_total - 1 : -1);
  table->Bg2DrawChannelCurrent = TABLE_DRAW_CHANNEL_BG2_FROZEN;
  table->Bg2DrawChannelUnfrozen =
      (TableDrawChannelIdx)((table->FreezeRowsCount > 0)
                                ? 2 + channels_for_row
                                : TABLE_DRAW_CHANNEL_BG2_FROZEN);

  int draw_channel_current = 2;
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
    TableColumn *column = &table->Columns[column_n];
    if (column->IsVisibleX && column->IsVisibleY) {
      column->DrawChannelFrozen = (TableDrawChannelIdx)(draw_channel_current);
      column->DrawChannelUnfrozen =
          (TableDrawChannelIdx)(draw_channel_current +
                                (table->FreezeRowsCount > 0
                                     ? channels_for_row + 1
                                     : 0));
      if (!(table->Flags & TableFlags_NoClip))
        draw_channel_current++;
    } else {
      column->DrawChannelFrozen = column->DrawChannelUnfrozen =
          table->DummyDrawChannel;
    }
    column->DrawChannelCurrent = column->DrawChannelFrozen;
  }

  // Initial draw cmd starts with a BgClipRect that matches the one of its host,
  // to facilitate merge draw commands by default. All our cell highlight are
  // manually clipped with BgClipRect. When unfreezing it will be made smaller
  // to fit scrolling rect. (This technically isn't part of setting up draw
  // channels, but is reasonably related to be done here)
  table->BgClipRect = table->InnerClipRect;
  table->Bg0ClipRectForDrawCmd = table->OuterWindow->ClipRect;
  table->Bg2ClipRectForDrawCmd = table->HostClipRect;
  GUI_ASSERT(table->BgClipRect.Min.y <= table->BgClipRect.Max.y);
}

// This function reorder draw channels based on matching clip rectangle, to
// facilitate merging them. Called by EndTable(). For simplicity we call it
// TableMergeDrawChannels() but in fact it only reorder channels + overwrite
// ClipRect, actual merging is done by table->DrawSplitter.Merge() which is
// called right after TableMergeDrawChannels().
//
// Columns where the contents didn't stray off their local clip rectangle can be
// merged. To achieve this we merge their clip rect and make them contiguous in
// the channel list, so they can be merged by the call to DrawSplitter.Merge()
// following to the call to this function. We reorder draw commands by arranging
// them into a maximum of 4 distinct groups:
//
//   1 group:               2 groups:              2 groups:              4
//   groups: [ 0. ] no freeze       [ 0. ] row freeze      [ 01 ] col freeze [
//   01 ] row+col freeze [ .. ]  or no scroll   [ 2. ]  and v-scroll   [ .. ]
//   and h-scroll   [ 23 ]  and v+h-scroll
//
// Each column itself can use 1 channel (row freeze disabled) or 2 channels (row
// freeze enabled). When the contents of a column didn't stray off its limit, we
// move its channels into the corresponding group based on its position (within
// frozen rows/columns groups or not). At the end of the operation our 1-4
// groups will each have a DrawCmd using the same ClipRect. This function
// assume that each column are pointing to a distinct draw channel, otherwise
// merge_group->ChannelsCount will not match set bit count of
// merge_group->ChannelsMask.
//
// Column channels will not be merged into one of the 1-4 groups in the
// following cases:
// - The contents stray off its clipping rectangle (we only compare the MaxX
// value, not the MinX value).
//   Direct DrawList calls won't be taken into account by default, if you use
//   them make sure the Gui:: bounds matches, by e.g. calling
//   SetCursorScreenPos().
// - The channel uses more than one draw command itself. We drop all our attempt
// at merging stuff here..
//   we could do better but it's going to be rare and probably not worth the
//   hassle.
// Columns for which the draw channel(s) haven't been merged with other will use
// their own DrawCmd.
//
// This function is particularly tricky to understand.. take a breath.
inline void Gui::TableMergeDrawChannels(Table *table) {
  Context &g = *GGui;
  DrawListSplitter *splitter = table->DrawSplitter;
  const bool has_freeze_v = (table->FreezeRowsCount > 0);
  const bool has_freeze_h = (table->FreezeColumnsCount > 0);
  GUI_ASSERT(splitter->_Current == 0);

  // Track which groups we are going to attempt to merge, and which channels
  // goes into each group.
  struct MergeGroup {
    Rect ClipRect;
    int ChannelsCount = 0;
    BitArrayPtr ChannelsMask = NULL;
  };
  int merge_group_mask = 0x00;
  MergeGroup merge_groups[4];

  // Use a reusable temp buffer for the merge masks as they are dynamically
  // sized.
  const int max_draw_channels = (4 + table->ColumnsCount * 2);
  const int size_for_masks_bitarrays_one =
      (int)BitArrayGetStorageSizeInBytes(max_draw_channels);
  g.TempBuffer.reserve(size_for_masks_bitarrays_one * 5);
  memset(g.TempBuffer.Data, 0, size_for_masks_bitarrays_one * 5);
  for (int n = 0; n < GUI_ARRAYSIZE(merge_groups); n++)
    merge_groups[n].ChannelsMask =
        (BitArrayPtr)(void *)(g.TempBuffer.Data +
                              (size_for_masks_bitarrays_one * n));
  BitArrayPtr remaining_mask =
      (BitArrayPtr)(void *)(g.TempBuffer.Data +
                            (size_for_masks_bitarrays_one * 4));

  // 1. Scan channels and take note of those which can be merged
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
    if (!GUI_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))
      continue;
    TableColumn *column = &table->Columns[column_n];

    const int merge_group_sub_count = has_freeze_v ? 2 : 1;
    for (int merge_group_sub_n = 0; merge_group_sub_n < merge_group_sub_count;
         merge_group_sub_n++) {
      const int channel_no = (merge_group_sub_n == 0)
                                 ? column->DrawChannelFrozen
                                 : column->DrawChannelUnfrozen;

      // Don't attempt to merge if there are multiple draw calls within the
      // column
      DrawChannel *src_channel = &splitter->_Channels[channel_no];
      if (src_channel->_CmdBuffer.Size > 0 &&
          src_channel->_CmdBuffer.back().ElemCount == 0 &&
          src_channel->_CmdBuffer.back().UserCallback ==
              NULL) // Equivalent of PopUnusedDrawCmd()
        src_channel->_CmdBuffer.pop_back();
      if (src_channel->_CmdBuffer.Size != 1)
        continue;

      // Find out the width of this merge group and check if it will fit in our
      // column (note that we assume that rendering didn't stray on the left
      // direction. we should need a CursorMinPos to detect it)
      if (!(column->Flags & TableColumnFlags_NoClip)) {
        float content_max_x;
        if (!has_freeze_v)
          content_max_x = Max(column->ContentMaxXUnfrozen,
                              column->ContentMaxXHeadersUsed); // No row freeze
        else if (merge_group_sub_n == 0)
          content_max_x =
              Max(column->ContentMaxXFrozen,
                  column->ContentMaxXHeadersUsed); // Row freeze: use width
                                                   // before freeze
        else
          content_max_x =
              column->ContentMaxXUnfrozen; // Row freeze: use width after freeze
        if (content_max_x > column->ClipRect.Max.x)
          continue;
      }

      const int merge_group_n =
          (has_freeze_h && column_n < table->FreezeColumnsCount ? 0 : 1) +
          (has_freeze_v && merge_group_sub_n == 0 ? 0 : 2);
      GUI_ASSERT(channel_no < max_draw_channels);
      MergeGroup *merge_group = &merge_groups[merge_group_n];
      if (merge_group->ChannelsCount == 0)
        merge_group->ClipRect = Rect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
      BitArraySetBit(merge_group->ChannelsMask, channel_no);
      merge_group->ChannelsCount++;
      merge_group->ClipRect.Add(src_channel->_CmdBuffer[0].ClipRect);
      merge_group_mask |= (1 << merge_group_n);
    }

    // Invalidate current draw channel
    // (we don't clear DrawChannelFrozen/DrawChannelUnfrozen solely to
    // facilitate debugging/later inspection of data)
    column->DrawChannelCurrent = (TableDrawChannelIdx)-1;
  }

  // [DEBUG] Display merge groups
#if 0
    if (g.IO.KeyShift)
        for (int merge_group_n = 0; merge_group_n < GUI_ARRAYSIZE(merge_groups); merge_group_n++)
        {
            MergeGroup* merge_group = &merge_groups[merge_group_n];
            if (merge_group->ChannelsCount == 0)
                continue;
            char buf[32];
            FormatString(buf, 32, "MG%d:%d", merge_group_n, merge_group->ChannelsCount);
            Vec2 text_pos = merge_group->ClipRect.Min + Vec2(4, 4);
            Vec2 text_size = CalcTextSize(buf, NULL);
            GetForegroundDrawList()->AddRectFilled(text_pos, text_pos + text_size, GUI_COL32(0, 0, 0, 255));
            GetForegroundDrawList()->AddText(text_pos, GUI_COL32(255, 255, 0, 255), buf, NULL);
            GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, GUI_COL32(255, 255, 0, 255));
        }
#endif

  // 2. Rewrite channel list in our preferred order
  if (merge_group_mask != 0) {
    // We skip channel 0 (Bg0/Bg1) and 1 (Bg2 frozen) from the shuffling since
    // they won't move - see channels allocation in TableSetupDrawChannels().
    const int LEADING_DRAW_CHANNELS = 2;
    g.DrawChannelsTempMergeBuffer.resize(
        splitter->_Count -
        LEADING_DRAW_CHANNELS); // Use shared temporary storage so the
                                // allocation gets amortized
    DrawChannel *dst_tmp = g.DrawChannelsTempMergeBuffer.Data;
    BitArraySetBitRange(remaining_mask, LEADING_DRAW_CHANNELS,
                        splitter->_Count);
    BitArrayClearBit(remaining_mask, table->Bg2DrawChannelUnfrozen);
    GUI_ASSERT(has_freeze_v == false ||
               table->Bg2DrawChannelUnfrozen != TABLE_DRAW_CHANNEL_BG2_FROZEN);
    int remaining_count =
        splitter->_Count -
        (has_freeze_v ? LEADING_DRAW_CHANNELS + 1 : LEADING_DRAW_CHANNELS);
    // Rect host_rect = (table->InnerWindow == table->OuterWindow) ?
    // table->InnerClipRect : table->HostClipRect;
    Rect host_rect = table->HostClipRect;
    for (int merge_group_n = 0; merge_group_n < GUI_ARRAYSIZE(merge_groups);
         merge_group_n++) {
      if (int merge_channels_count =
              merge_groups[merge_group_n].ChannelsCount) {
        MergeGroup *merge_group = &merge_groups[merge_group_n];
        Rect merge_clip_rect = merge_group->ClipRect;

        // Extend outer-most clip limits to match those of host, so draw calls
        // can be merged even if outer-most columns have some outer padding
        // offsetting them from their parent ClipRect. The principal cases this
        // is dealing with are:
        // - On a same-window table (not scrolling = single group), all fitting
        // columns ClipRect -> will extend and match host ClipRect -> will merge
        // - Columns can use padding and have left-most ClipRect.Min.x and
        // right-most ClipRect.Max.x != from host ClipRect -> will extend and
        // match host ClipRect -> will merge
        // FIXME-TABLE FIXME-WORKRECT: We are wasting a merge opportunity on
        // tables without scrolling if column doesn't fit within host clip rect,
        // solely because of the half-padding difference between
        // window->WorkRect and window->InnerClipRect.
        if ((merge_group_n & 1) == 0 || !has_freeze_h)
          merge_clip_rect.Min.x = Min(merge_clip_rect.Min.x, host_rect.Min.x);
        if ((merge_group_n & 2) == 0 || !has_freeze_v)
          merge_clip_rect.Min.y = Min(merge_clip_rect.Min.y, host_rect.Min.y);
        if ((merge_group_n & 1) != 0)
          merge_clip_rect.Max.x = Max(merge_clip_rect.Max.x, host_rect.Max.x);
        if ((merge_group_n & 2) != 0 &&
            (table->Flags & TableFlags_NoHostExtendY) == 0)
          merge_clip_rect.Max.y = Max(merge_clip_rect.Max.y, host_rect.Max.y);
        // GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min,
        // merge_group->ClipRect.Max, GUI_COL32(255, 0, 0, 200), 0.0f, 0, 1.0f);
        // // [DEBUG]
        // GetForegroundDrawList()->AddLine(merge_group->ClipRect.Min,
        // merge_clip_rect.Min, GUI_COL32(255, 100, 0, 200));
        // GetForegroundDrawList()->AddLine(merge_group->ClipRect.Max,
        // merge_clip_rect.Max, GUI_COL32(255, 100, 0, 200));
        remaining_count -= merge_group->ChannelsCount;
        for (int n = 0; n < (size_for_masks_bitarrays_one >> 2); n++)
          remaining_mask[n] &= ~merge_group->ChannelsMask[n];
        for (int n = 0; n < splitter->_Count && merge_channels_count != 0;
             n++) {
          // Copy + overwrite new clip rect
          if (!GUI_BITARRAY_TESTBIT(merge_group->ChannelsMask, n))
            continue;
          GUI_BITARRAY_CLEARBIT(merge_group->ChannelsMask, n);
          merge_channels_count--;

          DrawChannel *channel = &splitter->_Channels[n];
          GUI_ASSERT(
              channel->_CmdBuffer.Size == 1 &&
              merge_clip_rect.Contains(Rect(channel->_CmdBuffer[0].ClipRect)));
          channel->_CmdBuffer[0].ClipRect = merge_clip_rect.ToVec4();
          memcpy(dst_tmp++, channel, sizeof(DrawChannel));
        }
      }

      // Make sure Bg2DrawChannelUnfrozen appears in the middle of our groups
      // (whereas Bg0/Bg1 and Bg2 frozen are fixed to 0 and 1)
      if (merge_group_n == 1 && has_freeze_v)
        memcpy(dst_tmp++, &splitter->_Channels[table->Bg2DrawChannelUnfrozen],
               sizeof(DrawChannel));
    }

    // Append unmergeable channels that we didn't reorder at the end of the list
    for (int n = 0; n < splitter->_Count && remaining_count != 0; n++) {
      if (!GUI_BITARRAY_TESTBIT(remaining_mask, n))
        continue;
      DrawChannel *channel = &splitter->_Channels[n];
      memcpy(dst_tmp++, channel, sizeof(DrawChannel));
      remaining_count--;
    }
    GUI_ASSERT(dst_tmp == g.DrawChannelsTempMergeBuffer.Data +
                              g.DrawChannelsTempMergeBuffer.Size);
    memcpy(splitter->_Channels.Data + LEADING_DRAW_CHANNELS,
           g.DrawChannelsTempMergeBuffer.Data,
           (splitter->_Count - LEADING_DRAW_CHANNELS) * sizeof(DrawChannel));
  }
}

static U32 TableGetColumnBorderCol(Table *table, int order_n, int column_n) {
  const bool is_hovered = (table->HoveredColumnBorder == column_n);
  const bool is_resized = (table->ResizedColumn == column_n) &&
                          (table->InstanceInteracted == table->InstanceCurrent);
  const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);
  if (is_resized || is_hovered)
    return Gui::GetColorU32(is_resized ? Col_SeparatorActive
                                       : Col_SeparatorHovered);
  if (is_frozen_separator ||
      (table->Flags &
       (TableFlags_NoBordersInBody | TableFlags_NoBordersInBodyUntilResize)))
    return table->BorderColorStrong;
  return table->BorderColorLight;
}

// FIXME-TABLE: This is a mess, need to redesign how we render borders (as some
// are also done in TableEndRow)
inline void Gui::TableDrawBorders(Table *table) {
  Window *inner_window = table->InnerWindow;
  if (!table->OuterWindow->ClipRect.Overlaps(table->OuterRect))
    return;

  DrawList *inner_drawlist = inner_window->DrawList;
  table->DrawSplitter->SetCurrentChannel(inner_drawlist,
                                         TABLE_DRAW_CHANNEL_BG0);
  inner_drawlist->PushClipRect(table->Bg0ClipRectForDrawCmd.Min,
                               table->Bg0ClipRectForDrawCmd.Max, false);

  // Draw inner border and resizing feedback
  TableInstanceData *table_instance =
      TableGetInstanceData(table, table->InstanceCurrent);
  const float border_size = TABLE_BORDER_SIZE;
  const float draw_y1 =
      Max(table->InnerRect.Min.y,
          (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y
                                       : table->WorkRect.Min.y) +
              table->AngledHeadersHeight) +
      ((table->Flags & TableFlags_BordersOuterH) ? 1.0f : 0.0f);
  const float draw_y2_body = table->InnerRect.Max.y;
  const float draw_y2_head =
      table->IsUsingHeaders
          ? Min(table->InnerRect.Max.y,
                (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y
                                             : table->WorkRect.Min.y) +
                    table_instance->LastTopHeadersRowHeight)
          : draw_y1;
  if (table->Flags & TableFlags_BordersInnerV) {
    for (int order_n = 0; order_n < table->ColumnsCount; order_n++) {
      if (!GUI_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
        continue;

      const int column_n = table->DisplayOrderToIndex[order_n];
      TableColumn *column = &table->Columns[column_n];
      const bool is_hovered = (table->HoveredColumnBorder == column_n);
      const bool is_resized =
          (table->ResizedColumn == column_n) &&
          (table->InstanceInteracted == table->InstanceCurrent);
      const bool is_resizable =
          (column->Flags &
           (TableColumnFlags_NoResize | TableColumnFlags_NoDirectResize_)) == 0;
      const bool is_frozen_separator =
          (table->FreezeColumnsCount == order_n + 1);
      if (column->MaxX > table->InnerClipRect.Max.x && !is_resized)
        continue;

      // Decide whether right-most column is visible
      if (column->NextEnabledColumn == -1 && !is_resizable)
        if ((table->Flags & TableFlags_SizingMask_) !=
                TableFlags_SizingFixedSame ||
            (table->Flags & TableFlags_NoHostExtendX))
          continue;
      if (column->MaxX <=
          column->ClipRect.Min
              .x) // FIXME-TABLE FIXME-STYLE: Assume BorderSize==1, this is
                  // problematic if we want to increase the border size..
        continue;

      // Draw in outer window so right-most column won't be clipped
      // Always draw full height border when being resized/hovered, or on the
      // delimitation of frozen column scrolling.
      float draw_y2 =
          (is_hovered || is_resized || is_frozen_separator ||
           (table->Flags & (TableFlags_NoBordersInBody |
                            TableFlags_NoBordersInBodyUntilResize)) == 0)
              ? draw_y2_body
              : draw_y2_head;
      if (draw_y2 > draw_y1)
        inner_drawlist->AddLine(
            Vec2(column->MaxX, draw_y1), Vec2(column->MaxX, draw_y2),
            TableGetColumnBorderCol(table, order_n, column_n), border_size);
    }
  }

  // Draw outer border
  // FIXME: could use AddRect or explicit VLine/HLine helper?
  if (table->Flags & TableFlags_BordersOuter) {
    // Display outer border offset by 1 which is a simple way to display it
    // without adding an extra draw call (Without the offset, in outer_window it
    // would be rendered behind cells, because child windows are above their
    // parent. In inner_window, it won't reach out over scrollbars. Another
    // weird solution would be to display part of it in inner window, and the
    // part that's over scrollbars in the outer window..) Either solution
    // currently won't allow us to use a larger border size: the border would
    // clipped.
    const Rect outer_border = table->OuterRect;
    const U32 outer_col = table->BorderColorStrong;
    if ((table->Flags & TableFlags_BordersOuter) == TableFlags_BordersOuter) {
      inner_drawlist->AddRect(outer_border.Min,
                              Add(outer_border.Max, Vec2(1, 1)), outer_col,
                              0.0f, 0, border_size);
    } else if (table->Flags & TableFlags_BordersOuterV) {
      inner_drawlist->AddLine(outer_border.Min,
                              Vec2(outer_border.Min.x, outer_border.Max.y),
                              outer_col, border_size);
      inner_drawlist->AddLine(Vec2(outer_border.Max.x, outer_border.Min.y),
                              outer_border.Max, outer_col, border_size);
    } else if (table->Flags & TableFlags_BordersOuterH) {
      inner_drawlist->AddLine(outer_border.Min,
                              Vec2(outer_border.Max.x, outer_border.Min.y),
                              outer_col, border_size);
      inner_drawlist->AddLine(Vec2(outer_border.Min.x, outer_border.Max.y),
                              outer_border.Max, outer_col, border_size);
    }
  }
  if ((table->Flags & TableFlags_BordersInnerH) &&
      table->RowPosY2 < table->OuterRect.Max.y) {
    // Draw bottom-most row border between it is above outer border.
    const float border_y = table->RowPosY2;
    if (border_y >= table->BgClipRect.Min.y &&
        border_y < table->BgClipRect.Max.y)
      inner_drawlist->AddLine(Vec2(table->BorderX1, border_y),
                              Vec2(table->BorderX2, border_y),
                              table->BorderColorLight, border_size);
  }

  inner_drawlist->PopClipRect();
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Sorting
//-------------------------------------------------------------------------
// - TableGetSortSpecs()
// - TableFixColumnSortDirection() [Internal]
// - TableGetColumnNextSortDirection() [Internal]
// - TableSetColumnSortDirection() [Internal]
// - TableSortSpecsSanitize() [Internal]
// - TableSortSpecsBuild() [Internal]
//-------------------------------------------------------------------------

// Return NULL if no sort specs (most often when TableFlags_Sortable is not
// set) When 'sort_specs->SpecsDirty == true' you should sort your data. It will
// be true when sorting specs have changed since last call, or the first time.
// Make sure to set 'SpecsDirty = false' after sorting, else you may wastefully
// sort your data every frame! Lifetime: don't hold on this pointer over
// multiple frames or past any subsequent call to BeginTable()!
inline TableSortSpecs *Gui::TableGetSortSpecs() {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  GUI_ASSERT(table != NULL);

  if (!(table->Flags & TableFlags_Sortable))
    return NULL;

  // Require layout (in case TableHeadersRow() hasn't been called) as it may
  // alter IsSortSpecsDirty in some paths.
  if (!table->IsLayoutLocked)
    TableUpdateLayout(table);

  TableSortSpecsBuild(table);
  return &table->SortSpecs;
}

static inline SortDirection
TableGetColumnAvailSortDirection(TableColumn *column, int n) {
  GUI_ASSERT(n < column->SortDirectionsAvailCount);
  return (column->SortDirectionsAvailList >> (n << 1)) & 0x03;
}

// Fix sort direction if currently set on a value which is unavailable (e.g.
// activating NoSortAscending/NoSortDescending)
inline void Gui::TableFixColumnSortDirection(Table *table,
                                             TableColumn *column) {
  if (column->SortOrder == -1 ||
      (column->SortDirectionsAvailMask & (1 << column->SortDirection)) != 0)
    return;
  column->SortDirection = (U8)TableGetColumnAvailSortDirection(column, 0);
  table->IsSortSpecsDirty = true;
}

// Calculate next sort direction that would be set after clicking the column
// - If the PreferSortDescending flag is set, we will default to a Descending
// direction on the first click.
// - Note that the PreferSortAscending flag is never checked, it is essentially
// the default and therefore a no-op.
GUI_STATIC_ASSERT(SortDirection_None == 0 && SortDirection_Ascending == 1 &&
                  SortDirection_Descending == 2);
inline SortDirection Gui::TableGetColumnNextSortDirection(TableColumn *column) {
  GUI_ASSERT(column->SortDirectionsAvailCount > 0);
  if (column->SortOrder == -1)
    return TableGetColumnAvailSortDirection(column, 0);
  for (int n = 0; n < 3; n++)
    if (column->SortDirection == TableGetColumnAvailSortDirection(column, n))
      return TableGetColumnAvailSortDirection(
          column, (n + 1) % column->SortDirectionsAvailCount);
  GUI_ASSERT(0);
  return SortDirection_None;
}

// Note that the NoSortAscending/NoSortDescending flags are processed in
// TableSortSpecsSanitize(), and they may change/revert the value of
// SortDirection. We could technically also do it here but it would be
// unnecessary and duplicate code.
inline void Gui::TableSetColumnSortDirection(int column_n,
                                             SortDirection sort_direction,
                                             bool append_to_sort_specs) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;

  if (!(table->Flags & TableFlags_SortMulti))
    append_to_sort_specs = false;
  if (!(table->Flags & TableFlags_SortTristate))
    GUI_ASSERT(sort_direction != SortDirection_None);

  TableColumnIdx sort_order_max = 0;
  if (append_to_sort_specs)
    for (int other_column_n = 0; other_column_n < table->ColumnsCount;
         other_column_n++)
      sort_order_max =
          Max(sort_order_max, table->Columns[other_column_n].SortOrder);

  TableColumn *column = &table->Columns[column_n];
  column->SortDirection = (U8)sort_direction;
  if (column->SortDirection == SortDirection_None)
    column->SortOrder = -1;
  else if (column->SortOrder == -1 || !append_to_sort_specs)
    column->SortOrder = append_to_sort_specs ? sort_order_max + 1 : 0;

  for (int other_column_n = 0; other_column_n < table->ColumnsCount;
       other_column_n++) {
    TableColumn *other_column = &table->Columns[other_column_n];
    if (other_column != column && !append_to_sort_specs)
      other_column->SortOrder = -1;
    TableFixColumnSortDirection(table, other_column);
  }
  table->IsSettingsDirty = true;
  table->IsSortSpecsDirty = true;
}

inline void Gui::TableSortSpecsSanitize(Table *table) {
  GUI_ASSERT(table->Flags & TableFlags_Sortable);

  // Clear SortOrder from hidden column and verify that there's no gap or
  // duplicate.
  int sort_order_count = 0;
  U64 sort_order_mask = 0x00;
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
    TableColumn *column = &table->Columns[column_n];
    if (column->SortOrder != -1 && !column->IsEnabled)
      column->SortOrder = -1;
    if (column->SortOrder == -1)
      continue;
    sort_order_count++;
    sort_order_mask |= ((U64)1 << column->SortOrder);
    GUI_ASSERT(sort_order_count < (int)sizeof(sort_order_mask) * 8);
  }

  const bool need_fix_linearize =
      ((U64)1 << sort_order_count) != (sort_order_mask + 1);
  const bool need_fix_single_sort_order =
      (sort_order_count > 1) && !(table->Flags & TableFlags_SortMulti);
  if (need_fix_linearize || need_fix_single_sort_order) {
    U64 fixed_mask = 0x00;
    for (int sort_n = 0; sort_n < sort_order_count; sort_n++) {
      // Fix: Rewrite sort order fields if needed so they have no gap or
      // duplicate. (e.g. SortOrder 0 disappeared, SortOrder 1..2 exists -->
      // rewrite then as SortOrder 0..1)
      int column_with_smallest_sort_order = -1;
      for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        if ((fixed_mask & ((U64)1 << (U64)column_n)) == 0 &&
            table->Columns[column_n].SortOrder != -1)
          if (column_with_smallest_sort_order == -1 ||
              table->Columns[column_n].SortOrder <
                  table->Columns[column_with_smallest_sort_order].SortOrder)
            column_with_smallest_sort_order = column_n;
      GUI_ASSERT(column_with_smallest_sort_order != -1);
      fixed_mask |= ((U64)1 << column_with_smallest_sort_order);
      table->Columns[column_with_smallest_sort_order].SortOrder =
          (TableColumnIdx)sort_n;

      // Fix: Make sure only one column has a SortOrder if
      // TableFlags_MultiSortable is not set.
      if (need_fix_single_sort_order) {
        sort_order_count = 1;
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
          if (column_n != column_with_smallest_sort_order)
            table->Columns[column_n].SortOrder = -1;
        break;
      }
    }
  }

  // Fallback default sort order (if no column with the
  // TableColumnFlags_DefaultSort flag)
  if (sort_order_count == 0 && !(table->Flags & TableFlags_SortTristate))
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
      TableColumn *column = &table->Columns[column_n];
      if (column->IsEnabled && !(column->Flags & TableColumnFlags_NoSort)) {
        sort_order_count = 1;
        column->SortOrder = 0;
        column->SortDirection = (U8)TableGetColumnAvailSortDirection(column, 0);
        break;
      }
    }

  table->SortSpecsCount = (TableColumnIdx)sort_order_count;
}

inline void Gui::TableSortSpecsBuild(Table *table) {
  bool dirty = table->IsSortSpecsDirty;
  if (dirty) {
    TableSortSpecsSanitize(table);
    table->SortSpecsMulti.resize(
        table->SortSpecsCount <= 1 ? 0 : table->SortSpecsCount);
    table->SortSpecs.SpecsDirty = true; // Mark as dirty for user
    table->IsSortSpecsDirty = false;    // Mark as not dirty for us
  }

  // Write output
  TableColumnSortSpecs *sort_specs = (table->SortSpecsCount == 0) ? NULL
                                     : (table->SortSpecsCount == 1)
                                         ? &table->SortSpecsSingle
                                         : table->SortSpecsMulti.Data;
  if (dirty && sort_specs != NULL)
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
      TableColumn *column = &table->Columns[column_n];
      if (column->SortOrder == -1)
        continue;
      GUI_ASSERT(column->SortOrder < table->SortSpecsCount);
      TableColumnSortSpecs *sort_spec = &sort_specs[column->SortOrder];
      sort_spec->ColumnUserID = column->UserID;
      sort_spec->ColumnIndex = (TableColumnIdx)column_n;
      sort_spec->SortOrder = (TableColumnIdx)column->SortOrder;
      sort_spec->SortDirection = column->SortDirection;
    }

  table->SortSpecs.Specs = sort_specs;
  table->SortSpecs.SpecsCount = table->SortSpecsCount;
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Headers
//-------------------------------------------------------------------------
// - TableGetHeaderRowHeight() [Internal]
// - TableHeadersRow()
// - TableHeader()
// - TableAngledHeadersRow()
// - TableAngledHeadersRowEx() [Internal]
//-------------------------------------------------------------------------

inline float Gui::TableGetHeaderRowHeight() {
  // Caring for a minor edge case:
  // Calculate row height, for the unlikely case that some labels may be taller
  // than others. If we didn't do that, uneven header height would highlight but
  // smaller one before the tallest wouldn't catch input for all height. In your
  // custom header row you may omit this all together and just call
  // TableNextRow() without a height...
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  float row_height = g.FontSize;
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    if (GUI_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
      if ((table->Columns[column_n].Flags & TableColumnFlags_NoHeaderLabel) ==
          0)
        row_height = Max(row_height,
                         CalcTextSize(TableGetColumnName(table, column_n)).y);
  return row_height + g.Style.CellPadding.y * 2.0f;
}

inline float Gui::TableGetHeaderAngledMaxLabelWidth() {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  float width = 0.0f;
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    if (GUI_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
      if (table->Columns[column_n].Flags & TableColumnFlags_AngledHeader)
        width = Max(
            width,
            CalcTextSize(TableGetColumnName(table, column_n), NULL, true).x);
  return width + g.Style.CellPadding.x * 2.0f;
}

// [Public] This is a helper to output TableHeader() calls based on the column
// names declared in TableSetupColumn(). The intent is that advanced users
// willing to create customized headers would not need to use this helper and
// can create their own! For example: TableHeader() may be preceeded by
// Checkbox() or other custom widgets. See 'Demo->Tables->Custom headers' for a
// demonstration of implementing a custom version of this. This code is
// constructed to not make much use of internal functions, as it is intended to
// be a template to copy.
// FIXME-TABLE: TableOpenContextMenu() and TableGetHeaderRowHeight() are not
// public.
inline void Gui::TableHeadersRow() {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  GUI_ASSERT(table != NULL &&
             "Need to call TableHeadersRow() after BeginTable()!");

  // Layout if not already done (this is automatically done by TableNextRow, we
  // do it here solely to facilitate stepping in debugger as it is frequent to
  // step in TableUpdateLayout)
  if (!table->IsLayoutLocked)
    TableUpdateLayout(table);

  // Open row
  const float row_height = TableGetHeaderRowHeight();
  TableNextRow(TableRowFlags_Headers, row_height);
  const float row_y1 = GetCursorScreenPos().y;
  if (table->HostSkipItems) // Merely an optimization, you may skip in your own
                            // code.
    return;

  const int columns_count = TableGetColumnCount();
  for (int column_n = 0; column_n < columns_count; column_n++) {
    if (!TableSetColumnIndex(column_n))
      continue;

    // Push an id to allow unnamed labels (generally accidental, but let's
    // behave nicely with them) In your own code you may omit the PushID/PopID
    // all-together, provided you know they won't collide.
    const char *name =
        (TableGetColumnFlags(column_n) & TableColumnFlags_NoHeaderLabel)
            ? ""
            : TableGetColumnName(column_n);
    PushID(column_n);
    TableHeader(name);
    PopID();
  }

  // Allow opening popup from the right-most section after the last column.
  Vec2 mouse_pos = Gui::GetMousePos();
  if (IsMouseReleased(1) && TableGetHoveredColumn() == columns_count)
    if (mouse_pos.y >= row_y1 && mouse_pos.y < row_y1 + row_height)
      TableOpenContextMenu(
          columns_count); // Will open a non-column-specific popup.
}

// Emit a column header (text + optional sort order)
// We cpu-clip text here so that all columns headers can be merged into a same
// draw call. Note that because of how we cpu-clip and display sorting
// indicators, you _cannot_ use SameLine() after a TableHeader()
inline void Gui::TableHeader(const char *label) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return;

  Table *table = g.CurrentTable;
  GUI_ASSERT(table != NULL && "Need to call TableHeader() after BeginTable()!");
  GUI_ASSERT(table->CurrentColumn != -1);
  const int column_n = table->CurrentColumn;
  TableColumn *column = &table->Columns[column_n];

  // Label
  if (label == NULL)
    label = "";
  const char *label_end = FindRenderedTextEnd(label);
  Vec2 label_size = CalcTextSize(label, label_end, true);
  Vec2 label_pos = window->DC.CursorPos;

  // If we already got a row height, there's use that.
  // FIXME-TABLE: Padding problem if the correct outer-padding CellBgRect strays
  // off our ClipRect?
  Rect cell_r = TableGetCellBgRect(table, column_n);
  float label_height =
      Max(label_size.y, table->RowMinHeight - table->RowCellPaddingY * 2.0f);

  // Calculate ideal size for sort order arrow
  float w_arrow = 0.0f;
  float w_sort_text = 0.0f;
  bool sort_arrow = false;
  char sort_order_suf[4] = "";
  const float ARROW_SCALE = 0.65f;
  if ((table->Flags & TableFlags_Sortable) &&
      !(column->Flags & TableColumnFlags_NoSort)) {
    w_arrow = Trunc(g.FontSize * ARROW_SCALE + g.Style.FramePadding.x);
    if (column->SortOrder != -1)
      sort_arrow = true;
    if (column->SortOrder > 0) {
      FormatString(sort_order_suf, GUI_ARRAYSIZE(sort_order_suf), "%d",
                   column->SortOrder + 1);
      w_sort_text = g.Style.ItemInnerSpacing.x + CalcTextSize(sort_order_suf).x;
    }
  }

  // We feed our unclipped width to the column without writing on CursorMaxPos,
  // so that column is still considered for merging.
  float max_pos_x = label_pos.x + label_size.x + w_sort_text + w_arrow;
  column->ContentMaxXHeadersUsed =
      Max(column->ContentMaxXHeadersUsed,
          sort_arrow ? cell_r.Max.x : Min(max_pos_x, cell_r.Max.x));
  column->ContentMaxXHeadersIdeal =
      Max(column->ContentMaxXHeadersIdeal, max_pos_x);

  // Keep header highlighted when context menu is open.
  ID id = window->GetID(label);
  Rect bb(cell_r.Min.x, cell_r.Min.y, cell_r.Max.x,
          Max(cell_r.Max.y,
              cell_r.Min.y + label_height + g.Style.CellPadding.y * 2.0f));
  ItemSize(Vec2(0.0f, label_height)); // Don't declare unclipped width, it'll
                                      // be fed ContentMaxPosHeadersIdeal
  if (!ItemAdd(bb, id))
    return;

  // GetForegroundDrawList()->AddRect(cell_r.Min, cell_r.Max, GUI_COL32(255, 0,
  // 0, 255)); // [DEBUG] GetForegroundDrawList()->AddRect(bb.Min, bb.Max,
  // GUI_COL32(255, 0, 0, 255)); // [DEBUG]

  // Using AllowOverlap mode because we cover the whole cell, and we want user
  // to be able to submit subsequent items.
  const bool highlight = (table->HighlightColumnHeader == column_n);
  bool hovered, held;
  bool pressed =
      ButtonBehavior(bb, id, &hovered, &held, ButtonFlags_AllowOverlap);
  if (held || hovered || highlight) {
    const U32 col = GetColorU32(held      ? Col_HeaderActive
                                : hovered ? Col_HeaderHovered
                                          : Col_Header);
    // RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
    TableSetBgColor(TableBgTarget_CellBg, col, table->CurrentColumn);
  } else {
    // Submit single cell bg color in the case we didn't submit a full header
    // row
    if ((table->RowFlags & TableRowFlags_Headers) == 0)
      TableSetBgColor(TableBgTarget_CellBg, GetColorU32(Col_TableHeaderBg),
                      table->CurrentColumn);
  }
  RenderNavHighlight(bb, id,
                     NavHighlightFlags_TypeThin | NavHighlightFlags_NoRounding);
  if (held)
    table->HeldHeaderColumn = (TableColumnIdx)column_n;
  window->DC.CursorPos.y -= g.Style.ItemSpacing.y * 0.5f;

  // Drag and drop to re-order columns.
  // FIXME-TABLE: Scroll request while reordering a column and it lands out of
  // the scrolling zone.
  if (held && (table->Flags & TableFlags_Reorderable) && IsMouseDragging(0) &&
      !g.DragDropActive) {
    // While moving a column it will jump on the other side of the mouse, so we
    // also test for MouseDelta.x
    table->ReorderColumn = (TableColumnIdx)column_n;
    table->InstanceInteracted = table->InstanceCurrent;

    // We don't reorder: through the frozen<>unfrozen line, or through a column
    // that is marked with TableColumnFlags_NoReorder.
    if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < cell_r.Min.x)
      if (TableColumn *prev_column =
              (column->PrevEnabledColumn != -1)
                  ? &table->Columns[column->PrevEnabledColumn]
                  : NULL)
        if (!((column->Flags | prev_column->Flags) &
              TableColumnFlags_NoReorder))
          if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) ==
              (prev_column->IndexWithinEnabledSet <
               table->FreezeColumnsRequest))
            table->ReorderColumnDir = -1;
    if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > cell_r.Max.x)
      if (TableColumn *next_column =
              (column->NextEnabledColumn != -1)
                  ? &table->Columns[column->NextEnabledColumn]
                  : NULL)
        if (!((column->Flags | next_column->Flags) &
              TableColumnFlags_NoReorder))
          if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) ==
              (next_column->IndexWithinEnabledSet <
               table->FreezeColumnsRequest))
            table->ReorderColumnDir = +1;
  }

  // Sort order arrow
  const float ellipsis_max =
      Max(cell_r.Max.x - w_arrow - w_sort_text, label_pos.x);
  if ((table->Flags & TableFlags_Sortable) &&
      !(column->Flags & TableColumnFlags_NoSort)) {
    if (column->SortOrder != -1) {
      float x = Max(cell_r.Min.x, cell_r.Max.x - w_arrow - w_sort_text);
      float y = label_pos.y;
      if (column->SortOrder > 0) {
        PushStyleColor(Col_Text, GetColorU32(Col_Text, 0.70f));
        RenderText(Vec2(x + g.Style.ItemInnerSpacing.x, y), sort_order_suf);
        PopStyleColor();
        x += w_sort_text;
      }
      RenderArrow(window->DrawList, Vec2(x, y), GetColorU32(Col_Text),
                  column->SortDirection == SortDirection_Ascending ? Dir_Up
                                                                   : Dir_Down,
                  ARROW_SCALE);
    }

    // Handle clicking on column header to adjust Sort Order
    if (pressed && table->ReorderColumn != column_n) {
      SortDirection sort_direction = TableGetColumnNextSortDirection(column);
      TableSetColumnSortDirection(column_n, sort_direction, g.IO.KeyShift);
    }
  }

  // Render clipped label. Clipping here ensure that in the majority of
  // situations, all our header cells will be merged into a single draw call.
  // window->DrawList->AddCircleFilled(Vec2(ellipsis_max, label_pos.y), 40,
  // GUI_COL32_WHITE);
  RenderTextEllipsis(
      window->DrawList, label_pos,
      Vec2(ellipsis_max, label_pos.y + label_height + g.Style.FramePadding.y),
      ellipsis_max, ellipsis_max, label, label_end, &label_size);

  const bool text_clipped = label_size.x > (ellipsis_max - label_pos.x);
  if (text_clipped && hovered && g.ActiveId == 0)
    SetItemTooltip("%.*s", (int)(label_end - label), label);

  // We don't use BeginPopupContextItem() because we want the popup to stay up
  // even after the column is hidden
  if (IsMouseReleased(1) && IsItemHovered())
    TableOpenContextMenu(column_n);
}

// Unlike TableHeadersRow() it is not expected that you can reimplement or
// customize this with custom widgets.
// FIXME: highlight without TableFlags_HighlightHoveredColumn
// FIXME: No hit-testing/button on the angled header.
inline void Gui::TableAngledHeadersRow() {
  Context &g = *GGui;
  TableAngledHeadersRowEx(g.Style.TableAngledHeadersAngle, 0.0f);
}

inline void Gui::TableAngledHeadersRowEx(float angle, float max_label_width) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  Window *window = g.CurrentWindow;
  DrawList *draw_list = window->DrawList;
  GUI_ASSERT(table != NULL &&
             "Need to call TableHeadersRow() after BeginTable()!");
  GUI_ASSERT(table->CurrentRow == -1 && "Must be first row");

  if (max_label_width == 0.0f)
    max_label_width = TableGetHeaderAngledMaxLabelWidth();

  // Angle argument expressed in (-GUI_PI/2 .. +GUI_PI/2) as it is easier to
  // think about for user.
  const bool flip_label = (angle < 0.0f);
  angle -= GUI_PI * 0.5f;
  const float cos_a = Cos(angle);
  const float sin_a = Sin(angle);
  const float label_cos_a = flip_label ? Cos(angle + GUI_PI) : cos_a;
  const float label_sin_a = flip_label ? Sin(angle + GUI_PI) : sin_a;
  const Vec2 unit_right = Vec2(cos_a, sin_a);

  // Calculate our base metrics and set angled headers data _before_ the first
  // call to TableNextRow()
  // FIXME-STYLE: Would it be better for user to submit 'max_label_width' or
  // 'row_height' ? One can be derived from the other.
  const float header_height = table->RowCellPaddingY * 2.0f + g.FontSize;
  const float row_height =
      Fabs(Rotate(Vec2(max_label_width,
                       flip_label ? +header_height : -header_height),
                  cos_a, sin_a)
               .y);
  const Vec2 header_angled_vector = Multiply(unit_right, (row_height / -sin_a));
  table->AngledHeadersHeight = row_height;
  table->AngledHeadersSlope = (sin_a != 0.0f) ? (cos_a / sin_a) : 0.0f;

  // Declare row, override and draw our own background
  TableNextRow(TableRowFlags_Headers, row_height);
  TableNextColumn();
  table->DrawSplitter->SetCurrentChannel(draw_list, TABLE_DRAW_CHANNEL_BG0);
  float clip_rect_min_x = table->BgClipRect.Min.x;
  if (table->FreezeColumnsCount > 0)
    clip_rect_min_x = Max(clip_rect_min_x,
                          table->Columns[table->FreezeColumnsCount - 1].MaxX);
  TableSetBgColor(TableBgTarget_RowBg0, 0); // Cancel
  PushClipRect(table->BgClipRect.Min, table->BgClipRect.Max,
               false); // Span all columns
  draw_list->AddRectFilled(
      table->BgClipRect.Min, table->BgClipRect.Max,
      GetColorU32(Col_TableHeaderBg,
                  0.25f)); // FIXME-STYLE: Change row background with an
                           // arbitrary color.
  PushClipRect(Vec2(clip_rect_min_x, table->BgClipRect.Min.y),
               table->BgClipRect.Max, true); // Span all columns

  const Rect row_r(table->WorkRect.Min.x, table->BgClipRect.Min.y,
                   table->WorkRect.Max.x, window->DC.CursorPos.y + row_height);
  const ID row_id = GetID("##AngledHeaders");
  ButtonBehavior(row_r, row_id, NULL, NULL);
  KeepAliveID(row_id);

  TableInstanceData *table_instance =
      TableGetInstanceData(table, table->InstanceCurrent);
  int highlight_column_n = table->HighlightColumnHeader;
  if (highlight_column_n == -1 && table->HoveredColumnBody != -1)
    if (table_instance->HoveredRowLast == 0 &&
        table->HoveredColumnBorder == -1 &&
        (g.ActiveId == 0 || g.ActiveId == row_id ||
         (table->IsActiveIdInTable || g.DragDropActive)))
      highlight_column_n = table->HoveredColumnBody;

  float max_x = 0.0f;
  for (int pass = 0; pass < 2; pass++)
    for (int order_n = 0; order_n < table->ColumnsCount; order_n++) {
      if (!GUI_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
        continue;
      const int column_n = table->DisplayOrderToIndex[order_n];
      TableColumn *column = &table->Columns[column_n];
      if ((column->Flags & TableColumnFlags_AngledHeader) ==
          0) // Note: can't rely on TableColumnFlags_IsVisible test here.
        continue;

      Vec2 bg_shape[4];
      bg_shape[0] = Vec2(column->MaxX, row_r.Max.y);
      bg_shape[1] = Vec2(column->MinX, row_r.Max.y);
      bg_shape[2] = Add(bg_shape[1], header_angled_vector);
      bg_shape[3] = Add(bg_shape[0], header_angled_vector);
      if (pass == 0) {
        // Draw shape
        draw_list->AddQuadFilled(bg_shape[0], bg_shape[1], bg_shape[2],
                                 bg_shape[3], GetColorU32(Col_TableHeaderBg));
        if (column_n == highlight_column_n)
          draw_list->AddQuadFilled(
              bg_shape[0], bg_shape[1], bg_shape[2], bg_shape[3],
              GetColorU32(Col_Header)); // Highlight on hover
        // draw_list->AddQuad(bg_shape[0], bg_shape[1], bg_shape[2],
        // bg_shape[3], GetColorU32(Col_TableBorderLight), 1.0f);
        max_x = Max(max_x, bg_shape[3].x);

        // Draw label (first draw at an offset where RenderTextXXX() function
        // won't meddle with applying current ClipRect, then transform to final
        // offset)
        // FIXME: May be worth tidying up all those operations to make them
        // easier to understand.
        const char *label_name = TableGetColumnName(table, column_n);
        const float clip_width =
            max_label_width - (sin_a * table->RowCellPaddingY);
        Rect label_r(
            window->ClipRect.Min,
            Add(window->ClipRect.Min,
                Vec2(clip_width + (flip_label ? 0.0f : table->CellPaddingX),
                     header_height + table->RowCellPaddingY)));
        Vec2 label_size = CalcTextSize(label_name, NULL, true);
        Vec2 label_off =
            Vec2(flip_label ? Max(0.0f, max_label_width - label_size.x -
                                            table->CellPaddingX)
                            : table->CellPaddingX,
                 table->RowCellPaddingY);
        int vtx_idx_begin = draw_list->_VtxCurrentIdx;
        RenderTextEllipsis(draw_list, Add(label_r.Min, label_off), label_r.Max,
                           label_r.Max.x, label_r.Max.x, label_name, NULL,
                           &label_size);
        // if (g.IO.KeyShift) { draw_list->AddRect(label_r.Min, label_r.Max,
        // GUI_COL32(0, 255, 0, 255), 0.0f, 0, 2.0f); }
        int vtx_idx_end = draw_list->_VtxCurrentIdx;

        // Rotate and offset label
        Vec2 pivot_in = label_r.GetBL();
        Vec2 pivot_out = Add(Vec2(column->WorkMinX, row_r.Max.y),
                             (flip_label ? (Multiply(unit_right, clip_width))
                                         : Vec2(header_height, 0.0f)));
        ShadeVertsTransformPos(draw_list, vtx_idx_begin, vtx_idx_end, pivot_in,
                               label_cos_a, label_sin_a,
                               pivot_out); // Rotate and offset
      }
      if (pass == 1) {
        // Draw border
        draw_list->AddLine(bg_shape[0], bg_shape[3],
                           TableGetColumnBorderCol(table, order_n, column_n));
      }
    }
  PopClipRect();
  PopClipRect();
  table->TempData->AngledheadersExtraWidth =
      Max(0.0f, max_x - table->Columns[table->RightMostEnabledColumn].MaxX);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Context Menu
//-------------------------------------------------------------------------
// - TableOpenContextMenu() [Internal]
// - TableBeginContextMenuPopup() [Internal]
// - TableDrawDefaultContextMenu() [Internal]
//-------------------------------------------------------------------------

// Use -1 to open menu not specific to a given column.
inline void Gui::TableOpenContextMenu(int column_n) {
  Context &g = *GGui;
  Table *table = g.CurrentTable;
  if (column_n == -1 &&
      table->CurrentColumn != -1) // When called within a column automatically
                                  // use this one (for consistency)
    column_n = table->CurrentColumn;
  if (column_n ==
      table->ColumnsCount) // To facilitate using with TableGetHoveredColumn()
    column_n = -1;
  GUI_ASSERT(column_n >= -1 && column_n < table->ColumnsCount);
  if (table->Flags &
      (TableFlags_Resizable | TableFlags_Reorderable | TableFlags_Hideable)) {
    table->IsContextPopupOpen = true;
    table->ContextPopupColumn = (TableColumnIdx)column_n;
    table->InstanceInteracted = table->InstanceCurrent;
    const ID context_menu_id = HashStr("##ContextMenu", 0, table->ID);
    OpenPopupEx(context_menu_id, PopupFlags_None);
  }
}

// Output context menu into current window (generally a popup)
// FIXME-TABLE: Ideally this should be writable by the user. Full programmatic
// access to that data? Sections to display are pulled from
// 'flags_for_section_to_display', which is typically == table->Flags.
// - TableFlags_Resizable   -> display Sizing menu items
// - TableFlags_Reorderable -> display "Reset Order"
////- TableFlags_Sortable   -> display sorting options (disabled)
// - TableFlags_Hideable    -> display columns visibility menu items
// It means if you have a custom context menus you can call this section and
// omit some sections, and add your own.
inline void
Gui::TableDrawDefaultContextMenu(Table *table,
                                 TableFlags flags_for_section_to_display) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  if (window->SkipItems)
    return;

  bool want_separator = false;
  const int column_n = (table->ContextPopupColumn >= 0 &&
                        table->ContextPopupColumn < table->ColumnsCount)
                           ? table->ContextPopupColumn
                           : -1;
  TableColumn *column = (column_n != -1) ? &table->Columns[column_n] : NULL;

  // Sizing
  if (flags_for_section_to_display & TableFlags_Resizable) {
    if (column != NULL) {
      const bool can_resize =
          !(column->Flags & TableColumnFlags_NoResize) && column->IsEnabled;
      if (MenuItem(LocalizeGetMsg(LocKey_TableSizeOne), NULL, false,
                   can_resize)) // "###SizeOne"
        TableSetColumnWidthAutoSingle(table, column_n);
    }

    const char *size_all_desc;
    if (table->ColumnsEnabledFixedCount == table->ColumnsEnabledCount &&
        (table->Flags & TableFlags_SizingMask_) != TableFlags_SizingFixedSame)
      size_all_desc =
          LocalizeGetMsg(LocKey_TableSizeAllFit); // "###SizeAll" All fixed
    else
      size_all_desc = LocalizeGetMsg(
          LocKey_TableSizeAllDefault); // "###SizeAll" All stretch or mixed
    if (MenuItem(size_all_desc, NULL))
      TableSetColumnWidthAutoAll(table);
    want_separator = true;
  }

  // Ordering
  if (flags_for_section_to_display & TableFlags_Reorderable) {
    if (MenuItem(LocalizeGetMsg(LocKey_TableResetOrder), NULL, false,
                 !table->IsDefaultDisplayOrder))
      table->IsResetDisplayOrderRequest = true;
    want_separator = true;
  }

  // Reset all (should work but seems unnecessary/noisy to expose?)
  // if (MenuItem("Reset all"))
  //    table->IsResetAllRequest = true;

  // Sorting
  // (modify TableOpenContextMenu() to add _Sortable flag if enabling this)
#if 0
    if ((flags_for_section_to_display & TableFlags_Sortable) && column != NULL && (column->Flags & TableColumnFlags_NoSort) == 0)
    {
        if (want_separator)
            Separator();
        want_separator = true;

        bool append_to_sort_specs = g.IO.KeyShift;
        if (MenuItem("Sort in Ascending Order", NULL, column->SortOrder != -1 && column->SortDirection == SortDirection_Ascending, (column->Flags & TableColumnFlags_NoSortAscending) == 0))
            TableSetColumnSortDirection(table, column_n, SortDirection_Ascending, append_to_sort_specs);
        if (MenuItem("Sort in Descending Order", NULL, column->SortOrder != -1 && column->SortDirection == SortDirection_Descending, (column->Flags & TableColumnFlags_NoSortDescending) == 0))
            TableSetColumnSortDirection(table, column_n, SortDirection_Descending, append_to_sort_specs);
    }
#endif

  // Hiding / Visibility
  if (flags_for_section_to_display & TableFlags_Hideable) {
    if (want_separator)
      Separator();
    want_separator = true;

    PushItemFlag(ItemFlags_SelectableDontClosePopup, true);
    for (int other_column_n = 0; other_column_n < table->ColumnsCount;
         other_column_n++) {
      TableColumn *other_column = &table->Columns[other_column_n];
      if (other_column->Flags & TableColumnFlags_Disabled)
        continue;

      const char *name = TableGetColumnName(table, other_column_n);
      if (name == NULL || name[0] == 0)
        name = "<Unknown>";

      // Make sure we can't hide the last active column
      bool menu_item_active =
          (other_column->Flags & TableColumnFlags_NoHide) ? false : true;
      if (other_column->IsUserEnabled && table->ColumnsEnabledCount <= 1)
        menu_item_active = false;
      if (MenuItem(name, NULL, other_column->IsUserEnabled, menu_item_active))
        other_column->IsUserEnabledNextFrame = !other_column->IsUserEnabled;
    }
    PopItemFlag();
  }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Settings (.ini data)
//-------------------------------------------------------------------------
// FIXME: The binding/finding/creating flow are too confusing.
//-------------------------------------------------------------------------
// - TableSettingsInit() [Internal]
// - TableSettingsCalcChunkSize() [Internal]
// - TableSettingsCreate() [Internal]
// - TableSettingsFindByID() [Internal]
// - TableGetBoundSettings() [Internal]
// - TableResetSettings()
// - TableSaveSettings() [Internal]
// - TableLoadSettings() [Internal]
// - TableSettingsHandler_ClearAll() [Internal]
// - TableSettingsHandler_ApplyAll() [Internal]
// - TableSettingsHandler_ReadOpen() [Internal]
// - TableSettingsHandler_ReadLine() [Internal]
// - TableSettingsHandler_WriteAll() [Internal]
// - TableSettingsInstallHandler() [Internal]
//-------------------------------------------------------------------------
// [Init] 1: TableSettingsHandler_ReadXXXX()   Load and parse .ini file into
// TableSettings. [Main] 2: TableLoadSettings()               When table is
// created, bind Table to TableSettings, serialize TableSettings data into
// Table. [Main] 3: TableSaveSettings()               When table properties are
// modified, serialize Table data into bound or new TableSettings, mark .ini as
// dirty. [Main] 4: TableSettingsHandler_WriteAll()   When .ini file is dirty
// (which can come from other source), save TableSettings into .ini file.
//-------------------------------------------------------------------------

// Clear and initialize empty settings instance
static void TableSettingsInit(TableSettings *settings, ID id, int columns_count,
                              int columns_count_max) {
  GUI_PLACEMENT_NEW(settings) TableSettings();
  TableColumnSettings *settings_column = settings->GetColumnSettings();
  for (int n = 0; n < columns_count_max; n++, settings_column++)
    GUI_PLACEMENT_NEW(settings_column) TableColumnSettings();
  settings->ID = id;
  settings->ColumnsCount = (TableColumnIdx)columns_count;
  settings->ColumnsCountMax = (TableColumnIdx)columns_count_max;
  settings->WantApply = true;
}

static size_t TableSettingsCalcChunkSize(int columns_count) {
  return sizeof(TableSettings) +
         (size_t)columns_count * sizeof(TableColumnSettings);
}

inline TableSettings *Gui::TableSettingsCreate(ID id, int columns_count) {
  Context &g = *GGui;
  TableSettings *settings =
      g.SettingsTables.alloc_chunk(TableSettingsCalcChunkSize(columns_count));
  TableSettingsInit(settings, id, columns_count, columns_count);
  return settings;
}

// Find existing settings

// Get settings for a given table, NULL if none
inline TableSettings *Gui::TableGetBoundSettings(Table *table) {
  if (table->SettingsOffset != -1) {
    Context &g = *GGui;
    TableSettings *settings =
        g.SettingsTables.ptr_from_offset(table->SettingsOffset);
    GUI_ASSERT(settings->ID == table->ID);
    if (settings->ColumnsCountMax >= table->ColumnsCount)
      return settings; // OK
    settings->ID =
        0; // Invalidate storage, we won't fit because of a count change
  }
  return NULL;
}

// Restore initial state of table (with or without saved settings)

inline void Gui::TableSaveSettings(Table *table) {
  table->IsSettingsDirty = false;
  if (table->Flags & TableFlags_NoSavedSettings)
    return;

  // Bind or create settings data
  Context &g = *GGui;
  TableSettings *settings = TableGetBoundSettings(table);
  if (settings == NULL) {
    settings = TableSettingsCreate(table->ID, table->ColumnsCount);
    table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
  }
  settings->ColumnsCount = (TableColumnIdx)table->ColumnsCount;

  // Serialize Table/TableColumn into
  // TableSettings/TableColumnSettings
  GUI_ASSERT(settings->ID == table->ID);
  GUI_ASSERT(settings->ColumnsCount == table->ColumnsCount &&
             settings->ColumnsCountMax >= settings->ColumnsCount);
  TableColumn *column = table->Columns.Data;
  TableColumnSettings *column_settings = settings->GetColumnSettings();

  bool save_ref_scale = false;
  settings->SaveFlags = TableFlags_None;
  for (int n = 0; n < table->ColumnsCount; n++, column++, column_settings++) {
    const float width_or_weight =
        (column->Flags & TableColumnFlags_WidthStretch) ? column->StretchWeight
                                                        : column->WidthRequest;
    column_settings->WidthOrWeight = width_or_weight;
    column_settings->Index = (TableColumnIdx)n;
    column_settings->DisplayOrder = column->DisplayOrder;
    column_settings->SortOrder = column->SortOrder;
    column_settings->SortDirection = column->SortDirection;
    column_settings->IsEnabled = column->IsUserEnabled;
    column_settings->IsStretch =
        (column->Flags & TableColumnFlags_WidthStretch) ? 1 : 0;
    if ((column->Flags & TableColumnFlags_WidthStretch) == 0)
      save_ref_scale = true;

    // We skip saving some data in the .ini file when they are unnecessary to
    // restore our state. Note that fixed width where initial width was derived
    // from auto-fit will always be saved as InitStretchWeightOrWidth will be
    // 0.0f.
    // FIXME-TABLE: We don't have logic to easily compare SortOrder to
    // DefaultSortOrder yet so it's always saved when present.
    if (width_or_weight != column->InitStretchWeightOrWidth)
      settings->SaveFlags |= TableFlags_Resizable;
    if (column->DisplayOrder != n)
      settings->SaveFlags |= TableFlags_Reorderable;
    if (column->SortOrder != -1)
      settings->SaveFlags |= TableFlags_Sortable;
    if (column->IsUserEnabled !=
        ((column->Flags & TableColumnFlags_DefaultHide) == 0))
      settings->SaveFlags |= TableFlags_Hideable;
  }
  settings->SaveFlags &= table->Flags;
  settings->RefScale = save_ref_scale ? table->RefScale : 0.0f;

  MarkIniSettingsDirty();
}

inline void Gui::TableLoadSettings(Table *table) {
  Context &g = *GGui;
  table->IsSettingsRequestLoad = false;
  if (table->Flags & TableFlags_NoSavedSettings)
    return;

  // Bind settings
  TableSettings *settings;
  if (table->SettingsOffset == -1) {
    settings = TableSettingsFindByID(table->ID);
    if (settings == NULL)
      return;
    if (settings->ColumnsCount !=
        table->ColumnsCount) // Allow settings if columns count changed. We
                             // could otherwise decide to return...
      table->IsSettingsDirty = true;
    table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
  } else {
    settings = TableGetBoundSettings(table);
  }

  table->SettingsLoadedFlags = settings->SaveFlags;
  table->RefScale = settings->RefScale;

  // Serialize TableSettings/TableColumnSettings into
  // Table/TableColumn
  TableColumnSettings *column_settings = settings->GetColumnSettings();
  U64 display_order_mask = 0;
  for (int data_n = 0; data_n < settings->ColumnsCount;
       data_n++, column_settings++) {
    int column_n = column_settings->Index;
    if (column_n < 0 || column_n >= table->ColumnsCount)
      continue;

    TableColumn *column = &table->Columns[column_n];
    if (settings->SaveFlags & TableFlags_Resizable) {
      if (column_settings->IsStretch)
        column->StretchWeight = column_settings->WidthOrWeight;
      else
        column->WidthRequest = column_settings->WidthOrWeight;
      column->AutoFitQueue = 0x00;
    }
    if (settings->SaveFlags & TableFlags_Reorderable)
      column->DisplayOrder = column_settings->DisplayOrder;
    else
      column->DisplayOrder = (TableColumnIdx)column_n;
    display_order_mask |= (U64)1 << column->DisplayOrder;
    column->IsUserEnabled = column->IsUserEnabledNextFrame =
        column_settings->IsEnabled;
    column->SortOrder = column_settings->SortOrder;
    column->SortDirection = column_settings->SortDirection;
  }

  // Validate and fix invalid display order data
  const U64 expected_display_order_mask =
      (settings->ColumnsCount == 64) ? ~0
                                     : ((U64)1 << settings->ColumnsCount) - 1;
  if (display_order_mask != expected_display_order_mask)
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
      table->Columns[column_n].DisplayOrder = (TableColumnIdx)column_n;

  // Rebuild index
  for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] =
        (TableColumnIdx)column_n;
}

static void TableSettingsHandler_ClearAll(Context *ctx, SettingsHandler *) {
  Context &g = *ctx;
  for (int i = 0; i != g.Tables.GetMapSize(); i++)
    if (Table *table = g.Tables.TryGetMapData(i))
      table->SettingsOffset = -1;
  g.SettingsTables.clear();
}

// Apply to existing windows (if any)
static void TableSettingsHandler_ApplyAll(Context *ctx, SettingsHandler *) {
  Context &g = *ctx;
  for (int i = 0; i != g.Tables.GetMapSize(); i++)
    if (Table *table = g.Tables.TryGetMapData(i)) {
      table->IsSettingsRequestLoad = true;
      table->SettingsOffset = -1;
    }
}

static void *TableSettingsHandler_ReadOpen(Context *, SettingsHandler *,
                                           const char *name) {
  ID id = 0;
  int columns_count = 0;
  if (sscanf(name, "0x%08X,%d", &id, &columns_count) < 2)
    return NULL;

  if (TableSettings *settings = Gui::TableSettingsFindByID(id)) {
    if (settings->ColumnsCountMax >= columns_count) {
      TableSettingsInit(settings, id, columns_count,
                        settings->ColumnsCountMax); // Recycle
      return settings;
    }
    settings->ID =
        0; // Invalidate storage, we won't fit because of a count change
  }
  return Gui::TableSettingsCreate(id, columns_count);
}

static void TableSettingsHandler_ReadLine(Context *, SettingsHandler *,
                                          void *entry, const char *line) {
  // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
  TableSettings *settings = (TableSettings *)entry;
  float f = 0.0f;
  int column_n = 0, r = 0, n = 0;

  if (sscanf(line, "RefScale=%f", &f) == 1) {
    settings->RefScale = f;
    return;
  }

  if (sscanf(line, "Column %d%n", &column_n, &r) == 1) {
    if (column_n < 0 || column_n >= settings->ColumnsCount)
      return;
    line = StrSkipBlank(line + r);
    char c = 0;
    TableColumnSettings *column = settings->GetColumnSettings() + column_n;
    column->Index = (TableColumnIdx)column_n;
    if (sscanf(line, "UserID=0x%08X%n", (U32 *)&n, &r) == 1) {
      line = StrSkipBlank(line + r);
      column->UserID = (ID)n;
    }
    if (sscanf(line, "Width=%d%n", &n, &r) == 1) {
      line = StrSkipBlank(line + r);
      column->WidthOrWeight = (float)n;
      column->IsStretch = 0;
      settings->SaveFlags |= TableFlags_Resizable;
    }
    if (sscanf(line, "Weight=%f%n", &f, &r) == 1) {
      line = StrSkipBlank(line + r);
      column->WidthOrWeight = f;
      column->IsStretch = 1;
      settings->SaveFlags |= TableFlags_Resizable;
    }
    if (sscanf(line, "Visible=%d%n", &n, &r) == 1) {
      line = StrSkipBlank(line + r);
      column->IsEnabled = (U8)n;
      settings->SaveFlags |= TableFlags_Hideable;
    }
    if (sscanf(line, "Order=%d%n", &n, &r) == 1) {
      line = StrSkipBlank(line + r);
      column->DisplayOrder = (TableColumnIdx)n;
      settings->SaveFlags |= TableFlags_Reorderable;
    }
    if (sscanf(line, "Sort=%d%c%n", &n, &c, &r) == 2) {
      line = StrSkipBlank(line + r);
      column->SortOrder = (TableColumnIdx)n;
      column->SortDirection =
          (c == '^') ? SortDirection_Descending : SortDirection_Ascending;
      settings->SaveFlags |= TableFlags_Sortable;
    }
  }
}

static void TableSettingsHandler_WriteAll(Context *ctx,
                                          SettingsHandler *handler,
                                          TextBuffer *buf) {
  Context &g = *ctx;
  for (TableSettings *settings = g.SettingsTables.begin(); settings != NULL;
       settings = g.SettingsTables.next_chunk(settings)) {
    if (settings->ID == 0) // Skip ditched settings
      continue;

    // TableSaveSettings() may clear some of those flags when we establish that
    // the data can be stripped (e.g. Order was unchanged)
    const bool save_size = (settings->SaveFlags & TableFlags_Resizable) != 0;
    const bool save_visible = (settings->SaveFlags & TableFlags_Hideable) != 0;
    const bool save_order = (settings->SaveFlags & TableFlags_Reorderable) != 0;
    const bool save_sort = (settings->SaveFlags & TableFlags_Sortable) != 0;
    if (!save_size && !save_visible && !save_order && !save_sort)
      continue;

    buf->reserve(buf->size() + 30 +
                 settings->ColumnsCount * 50); // ballpark reserve
    buf->appendf("[%s][0x%08X,%d]\n", handler->TypeName, settings->ID,
                 settings->ColumnsCount);
    if (settings->RefScale != 0.0f)
      buf->appendf("RefScale=%g\n", settings->RefScale);
    TableColumnSettings *column = settings->GetColumnSettings();
    for (int column_n = 0; column_n < settings->ColumnsCount;
         column_n++, column++) {
      // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
      bool save_column = column->UserID != 0 || save_size || save_visible ||
                         save_order || (save_sort && column->SortOrder != -1);
      if (!save_column)
        continue;
      buf->appendf("Column %-2d", column_n);
      if (column->UserID != 0) {
        buf->appendf(" UserID=%08X", column->UserID);
      }
      if (save_size && column->IsStretch) {
        buf->appendf(" Weight=%.4f", column->WidthOrWeight);
      }
      if (save_size && !column->IsStretch) {
        buf->appendf(" Width=%d", (int)column->WidthOrWeight);
      }
      if (save_visible) {
        buf->appendf(" Visible=%d", column->IsEnabled);
      }
      if (save_order) {
        buf->appendf(" Order=%d", column->DisplayOrder);
      }
      if (save_sort && column->SortOrder != -1) {
        buf->appendf(" Sort=%d%c", column->SortOrder,
                     (column->SortDirection == SortDirection_Ascending) ? 'v'
                                                                        : '^');
      }
      buf->append("\n");
    }
    buf->append("\n");
  }
}

inline void Gui::TableSettingsAddSettingsHandler() {
  SettingsHandler ini_handler;
  ini_handler.TypeName = "Table";
  ini_handler.TypeHash = HashStr("Table");
  ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;
  ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;
  ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;
  ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;
  ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;
  AddSettingsHandler(&ini_handler);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Garbage Collection
//-------------------------------------------------------------------------
// - TableRemove() [Internal]
// - TableGcCompactTransientBuffers() [Internal]
// - TableGcCompactSettings() [Internal]
//-------------------------------------------------------------------------

// Remove Table (currently only used by TestEngine)

// Free up/compact internal Table buffers for when it gets unused
inline void Gui::TableGcCompactTransientBuffers(Table *table) {
  // GUI_DEBUG_PRINT("TableGcCompactTransientBuffers() id=0x%08X\n",
  // table->ID);
  Context &g = *GGui;
  GUI_ASSERT(table->MemoryCompacted == false);
  table->SortSpecs.Specs = NULL;
  table->SortSpecsMulti.clear();
  table->IsSortSpecsDirty = true; // FIXME: In theory shouldn't have to leak
                                  // into user performing a sort on resume.
  table->ColumnsNames.clear();
  table->MemoryCompacted = true;
  for (int n = 0; n < table->ColumnsCount; n++)
    table->Columns[n].NameOffset = -1;
  g.TablesLastTimeActive[g.Tables.GetIndex(table)] = -1.0f;
}

// Compact and remove unused settings data (currently only used by TestEngine)
inline void Gui::TableGcCompactSettings() {
  Context &g = *GGui;
  int required_memory = 0;
  for (TableSettings *settings = g.SettingsTables.begin(); settings != NULL;
       settings = g.SettingsTables.next_chunk(settings))
    if (settings->ID != 0)
      required_memory +=
          (int)TableSettingsCalcChunkSize(settings->ColumnsCount);
  if (required_memory == g.SettingsTables.Buf.Size)
    return;
  ChunkStream<TableSettings> new_chunk_stream;
  new_chunk_stream.Buf.reserve(required_memory);
  for (TableSettings *settings = g.SettingsTables.begin(); settings != NULL;
       settings = g.SettingsTables.next_chunk(settings))
    if (settings->ID != 0)
      memcpy(new_chunk_stream.alloc_chunk(
                 TableSettingsCalcChunkSize(settings->ColumnsCount)),
             settings, TableSettingsCalcChunkSize(settings->ColumnsCount));
  g.SettingsTables.swap(new_chunk_stream);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Debugging
//-------------------------------------------------------------------------
// - DebugNodeTable() [Internal]
//-------------------------------------------------------------------------

#ifndef GUI_DISABLE_DEBUG_TOOLS

static const char *DebugNodeTableGetSizingPolicyDesc(TableFlags sizing_policy) {
  sizing_policy &= TableFlags_SizingMask_;
  if (sizing_policy == TableFlags_SizingFixedFit) {
    return "FixedFit";
  }
  if (sizing_policy == TableFlags_SizingFixedSame) {
    return "FixedSame";
  }
  if (sizing_policy == TableFlags_SizingStretchProp) {
    return "StretchProp";
  }
  if (sizing_policy == TableFlags_SizingStretchSame) {
    return "StretchSame";
  }
  return "N/A";
}

inline void Gui::DebugNodeTable(Table *table) {
  const bool is_active =
      (table->LastFrameActive >=
       GetFrameCount() - 2); // Note that fully clipped early out scrolling
                             // tables will appear as inactive here.
  if (!is_active) {
    PushStyleColor(Col_Text, GetStyleColorVec4(Col_TextDisabled));
  }
  bool open = TreeNode(table, "Table 0x%08X (%d columns, in '%s')%s", table->ID,
                       table->ColumnsCount, table->OuterWindow->Name,
                       is_active ? "" : " *Inactive*");
  if (!is_active) {
    PopStyleColor();
  }
  if (IsItemHovered())
    GetForegroundDrawList()->AddRect(table->OuterRect.Min, table->OuterRect.Max,
                                     GUI_COL32(255, 255, 0, 255));
  if (IsItemVisible() && table->HoveredColumnBody != -1)
    GetForegroundDrawList()->AddRect(GetItemRectMin(), GetItemRectMax(),
                                     GUI_COL32(255, 255, 0, 255));
  if (!open)
    return;
  if (table->InstanceCurrent > 0)
    Text("** %d instances of same table! Some data below will refer to last "
         "instance.",
         table->InstanceCurrent + 1);
  bool clear_settings = SmallButton("Clear settings");
  BulletText("OuterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: '%s'",
             table->OuterRect.Min.x, table->OuterRect.Min.y,
             table->OuterRect.GetWidth(), table->OuterRect.GetHeight(),
             DebugNodeTableGetSizingPolicyDesc(table->Flags));
  BulletText(
      "ColumnsGivenWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%s",
      table->ColumnsGivenWidth, table->ColumnsAutoFitWidth, table->InnerWidth,
      table->InnerWidth == 0.0f ? " (auto)" : "");
  BulletText("CellPaddingX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f",
             table->CellPaddingX, table->CellSpacingX1, table->CellSpacingX2,
             table->OuterPaddingX);
  BulletText("HoveredColumnBody: %d, HoveredColumnBorder: %d",
             table->HoveredColumnBody, table->HoveredColumnBorder);
  BulletText("ResizedColumn: %d, ReorderColumn: %d, HeldHeaderColumn: %d",
             table->ResizedColumn, table->ReorderColumn,
             table->HeldHeaderColumn);
  for (int n = 0; n < table->InstanceCurrent + 1; n++) {
    TableInstanceData *table_instance = TableGetInstanceData(table, n);
    BulletText("Instance %d: HoveredRow: %d, LastOuterHeight: %.2f", n,
               table_instance->HoveredRowLast, table_instance->LastOuterHeight);
  }
  // BulletText("BgDrawChannels: %d/%d", 0, table->BgDrawChannelUnfrozen);
  float sum_weights = 0.0f;
  for (int n = 0; n < table->ColumnsCount; n++)
    if (table->Columns[n].Flags & TableColumnFlags_WidthStretch)
      sum_weights += table->Columns[n].StretchWeight;
  for (int n = 0; n < table->ColumnsCount; n++) {
    TableColumn *column = &table->Columns[n];
    const char *name = TableGetColumnName(table, n);
    char buf[512];
    FormatString(
        buf, GUI_ARRAYSIZE(buf),
        "Column %d order %d '%s': offset %+.2f to %+.2f%s\n"
        "Enabled: %d, VisibleX/Y: %d/%d, RequestOutput: %d, SkipItems: %d, "
        "DrawChannels: %d,%d\n"
        "WidthGiven: %.1f, Request/Auto: %.1f/%.1f, StretchWeight: %.3f "
        "(%.1f%%)\n"
        "MinX: %.1f, MaxX: %.1f (%+.1f), ClipRect: %.1f to %.1f (+%.1f)\n"
        "ContentWidth: %.1f,%.1f, HeadersUsed/Ideal %.1f/%.1f\n"
        "Sort: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..",
        n, column->DisplayOrder, name, column->MinX - table->WorkRect.Min.x,
        column->MaxX - table->WorkRect.Min.x,
        (n < table->FreezeColumnsRequest) ? " (Frozen)" : "", column->IsEnabled,
        column->IsVisibleX, column->IsVisibleY, column->IsRequestOutput,
        column->IsSkipItems, column->DrawChannelFrozen,
        column->DrawChannelUnfrozen, column->WidthGiven, column->WidthRequest,
        column->WidthAuto, column->StretchWeight,
        column->StretchWeight > 0.0f
            ? (column->StretchWeight / sum_weights) * 100.0f
            : 0.0f,
        column->MinX, column->MaxX, column->MaxX - column->MinX,
        column->ClipRect.Min.x, column->ClipRect.Max.x,
        column->ClipRect.Max.x - column->ClipRect.Min.x,
        column->ContentMaxXFrozen - column->WorkMinX,
        column->ContentMaxXUnfrozen - column->WorkMinX,
        column->ContentMaxXHeadersUsed - column->WorkMinX,
        column->ContentMaxXHeadersIdeal - column->WorkMinX, column->SortOrder,
        (column->SortDirection == SortDirection_Ascending)    ? " (Asc)"
        : (column->SortDirection == SortDirection_Descending) ? " (Des)"
                                                              : "",
        column->UserID, column->Flags,
        (column->Flags & TableColumnFlags_WidthStretch) ? "WidthStretch " : "",
        (column->Flags & TableColumnFlags_WidthFixed) ? "WidthFixed " : "",
        (column->Flags & TableColumnFlags_NoResize) ? "NoResize " : "");
    Bullet();
    Selectable(buf);
    if (IsItemHovered()) {
      Rect r(column->MinX, table->OuterRect.Min.y, column->MaxX,
             table->OuterRect.Max.y);
      GetForegroundDrawList()->AddRect(r.Min, r.Max,
                                       GUI_COL32(255, 255, 0, 255));
    }
  }
  if (TableSettings *settings = TableGetBoundSettings(table))
    DebugNodeTableSettings(settings);
  if (clear_settings)
    table->IsResetAllRequest = true;
  TreePop();
}

inline void Gui::DebugNodeTableSettings(TableSettings *settings) {
  if (!TreeNode((void *)(intptr_t)settings->ID, "Settings 0x%08X (%d columns)",
                settings->ID, settings->ColumnsCount))
    return;
  BulletText("SaveFlags: 0x%08X", settings->SaveFlags);
  BulletText("ColumnsCount: %d (max %d)", settings->ColumnsCount,
             settings->ColumnsCountMax);
  for (int n = 0; n < settings->ColumnsCount; n++) {
    TableColumnSettings *column_settings = &settings->GetColumnSettings()[n];
    SortDirection sort_dir = (column_settings->SortOrder != -1)
                                 ? (SortDirection)column_settings->SortDirection
                                 : SortDirection_None;
    BulletText(
        "Column %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%08X", n,
        column_settings->DisplayOrder, column_settings->SortOrder,
        (sort_dir == SortDirection_Ascending)    ? "Asc"
        : (sort_dir == SortDirection_Descending) ? "Des"
                                                 : "---",
        column_settings->IsEnabled,
        column_settings->IsStretch ? "Weight" : "Width ",
        column_settings->WidthOrWeight, column_settings->UserID);
  }
  TreePop();
}

#else // #ifndef GUI_DISABLE_DEBUG_TOOLS

void Gui::DebugNodeTable(Table *) {}
void Gui::DebugNodeTableSettings(TableSettings *) {}

#endif

//-------------------------------------------------------------------------
// [SECTION] Columns, BeginColumns, EndColumns, etc.
// (This is a legacy API, prefer using BeginTable/EndTable!)
//-------------------------------------------------------------------------
// FIXME: sizing is lossy when columns width is very small (default width may
// turn negative etc.)
//-------------------------------------------------------------------------
// - SetWindowClipRectBeforeSetChannel() [Internal]
// - GetColumnIndex()
// - GetColumnsCount()
// - GetColumnOffset()
// - GetColumnWidth()
// - SetColumnOffset()
// - SetColumnWidth()
// - PushColumnClipRect() [Internal]
// - PushColumnsBackground() [Internal]
// - PopColumnsBackground() [Internal]
// - FindOrCreateColumns() [Internal]
// - GetColumnsID() [Internal]
// - BeginColumns()
// - NextColumn()
// - EndColumns()
// - Columns()
//-------------------------------------------------------------------------

// [Internal] Small optimization to avoid calls to
// PopClipRect/SetCurrentChannel/PushClipRect in sequences, they would meddle
// many times with the underlying DrawCmd. Instead, we do a preemptive
// overwrite of clipping rectangle _without_ altering the command-buffer and let
// the subsequent single call to SetCurrentChannel() does it things once.

inline int Gui::GetColumnIndex() {
  Window *window = GetCurrentWindowRead();
  return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;
}

inline int Gui::GetColumnsCount() {
  Window *window = GetCurrentWindowRead();
  return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;
}

static const float COLUMNS_HIT_RECT_HALF_WIDTH = 4.0f;

static float GetDraggedColumnOffset(OldColumns *columns, int column_index) {
  // Active (dragged) column always follow mouse. The reason we need this is
  // that dragging a column to the right edge of an auto-resizing window creates
  // a feedback loop because we store normalized positions. So while dragging we
  // enforce absolute positioning.
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  GUI_ASSERT(column_index > 0); // We are not supposed to drag column 0.
  GUI_ASSERT(g.ActiveId == columns->ID + ID(column_index));

  float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x +
            COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;
  x = Max(x,
          Gui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
  if ((columns->Flags & OldColumnFlags_NoPreserveWidths))
    x = Min(x,
            Gui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

  return x;
}

inline float Gui::GetColumnOffset(int column_index) {
  Window *window = GetCurrentWindowRead();
  OldColumns *columns = window->DC.CurrentColumns;
  if (columns == NULL)
    return 0.0f;

  if (column_index < 0)
    column_index = columns->Current;
  GUI_ASSERT(column_index < columns->Columns.Size);

  const float t = columns->Columns[column_index].OffsetNorm;
  const float x_offset = Lerp(columns->OffMinX, columns->OffMaxX, t);
  return x_offset;
}

static float GetColumnWidthEx(OldColumns *columns, int column_index,
                              bool before_resize = false) {
  if (column_index < 0)
    column_index = columns->Current;

  float offset_norm;
  if (before_resize)
    offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize -
                  columns->Columns[column_index].OffsetNormBeforeResize;
  else
    offset_norm = columns->Columns[column_index + 1].OffsetNorm -
                  columns->Columns[column_index].OffsetNorm;
  return Gui::GetColumnOffsetFromNorm(columns, offset_norm);
}

inline float Gui::GetColumnWidth(int column_index) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  OldColumns *columns = window->DC.CurrentColumns;
  if (columns == NULL)
    return GetContentRegionAvail().x;

  if (column_index < 0)
    column_index = columns->Current;
  return GetColumnOffsetFromNorm(columns,
                                 columns->Columns[column_index + 1].OffsetNorm -
                                     columns->Columns[column_index].OffsetNorm);
}

inline void Gui::SetColumnOffset(int column_index, float offset) {
  Context &g = *GGui;
  Window *window = g.CurrentWindow;
  OldColumns *columns = window->DC.CurrentColumns;
  GUI_ASSERT(columns != NULL);

  if (column_index < 0)
    column_index = columns->Current;
  GUI_ASSERT(column_index < columns->Columns.Size);

  const bool preserve_width =
      !(columns->Flags & OldColumnFlags_NoPreserveWidths) &&
      (column_index < columns->Count - 1);
  const float width = preserve_width ? GetColumnWidthEx(columns, column_index,
                                                        columns->IsBeingResized)
                                     : 0.0f;

  if (!(columns->Flags & OldColumnFlags_NoForceWithinWindow))
    offset =
        Min(offset, columns->OffMaxX - g.Style.ColumnsMinSpacing *
                                           (columns->Count - column_index));
  columns->Columns[column_index].OffsetNorm =
      GetColumnNormFromOffset(columns, offset - columns->OffMinX);

  if (preserve_width)
    SetColumnOffset(column_index + 1,
                    offset + Max(g.Style.ColumnsMinSpacing, width));
}

inline void Gui::SetColumnWidth(int column_index, float width) {
  Window *window = GetCurrentWindowRead();
  OldColumns *columns = window->DC.CurrentColumns;
  GUI_ASSERT(columns != NULL);

  if (column_index < 0)
    column_index = columns->Current;
  SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
}

// Get into the columns background draw command (which is generally the same
// draw command as before we called BeginColumns)

inline void Gui::BeginColumns(const char *str_id, int columns_count,
                              OldColumnFlags flags) {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();

  GUI_ASSERT(columns_count >= 1);
  GUI_ASSERT(window->DC.CurrentColumns ==
             NULL); // Nested columns are currently not supported

  // Acquire storage for the columns set
  ID id = GetColumnsID(str_id, columns_count);
  OldColumns *columns = FindOrCreateColumns(window, id);
  GUI_ASSERT(columns->ID == id);
  columns->Current = 0;
  columns->Count = columns_count;
  columns->Flags = flags;
  window->DC.CurrentColumns = columns;
  window->DC.NavIsScrollPushableX =
      false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();

  columns->HostCursorPosY = window->DC.CursorPos.y;
  columns->HostCursorMaxPosX = window->DC.CursorMaxPos.x;
  columns->HostInitialClipRect = window->ClipRect;
  columns->HostBackupParentWorkRect = window->ParentWorkRect;
  window->ParentWorkRect = window->WorkRect;

  // Set state for first column
  // We aim so that the right-most column will have the same clipping width as
  // other after being clipped by parent ClipRect
  const float column_padding = g.Style.ItemSpacing.x;
  const float half_clip_extend_x =
      Trunc(Max(window->WindowPadding.x * 0.5f, window->WindowBorderSize));
  const float max_1 = window->WorkRect.Max.x + column_padding -
                      Max(column_padding - window->WindowPadding.x, 0.0f);
  const float max_2 = window->WorkRect.Max.x + half_clip_extend_x;
  columns->OffMinX = window->DC.Indent.x - column_padding +
                     Max(column_padding - window->WindowPadding.x, 0.0f);
  columns->OffMaxX =
      Max(Min(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);
  columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;

  // Clear data if columns count changed
  if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
    columns->Columns.resize(0);

  // Initialize default widths
  columns->IsFirstFrame = (columns->Columns.Size == 0);
  if (columns->Columns.Size == 0) {
    columns->Columns.reserve(columns_count + 1);
    for (int n = 0; n < columns_count + 1; n++) {
      OldColumnData column;
      column.OffsetNorm = n / (float)columns_count;
      columns->Columns.push_back(column);
    }
  }

  for (int n = 0; n < columns_count; n++) {
    // Compute clipping rectangle
    OldColumnData *column = &columns->Columns[n];
    float clip_x1 = GUI_ROUND(window->Pos.x + GetColumnOffset(n));
    float clip_x2 = GUI_ROUND(window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
    column->ClipRect = Rect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
    column->ClipRect.ClipWithFull(window->ClipRect);
  }

  if (columns->Count > 1) {
    columns->Splitter.Split(window->DrawList, 1 + columns->Count);
    columns->Splitter.SetCurrentChannel(window->DrawList, 1);
    PushColumnClipRect(0);
  }

  // We don't generally store Indent.x inside ColumnsOffset because it may be
  // manipulated by the user.
  float offset_0 = GetColumnOffset(columns->Current);
  float offset_1 = GetColumnOffset(columns->Current + 1);
  float width = offset_1 - offset_0;
  PushItemWidth(width * 0.65f);
  window->DC.ColumnsOffset.x =
      Max(column_padding - window->WindowPadding.x, 0.0f);
  window->DC.CursorPos.x = GUI_TRUNC(window->Pos.x + window->DC.Indent.x +
                                     window->DC.ColumnsOffset.x);
  window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
  window->WorkRect.Max.y = window->ContentRegionRect.Max.y;
}

inline void Gui::NextColumn() {
  Window *window = GetCurrentWindow();
  if (window->SkipItems || window->DC.CurrentColumns == NULL)
    return;

  Context &g = *GGui;
  OldColumns *columns = window->DC.CurrentColumns;

  if (columns->Count == 1) {
    window->DC.CursorPos.x = GUI_TRUNC(window->Pos.x + window->DC.Indent.x +
                                       window->DC.ColumnsOffset.x);
    GUI_ASSERT(columns->Current == 0);
    return;
  }

  // Next column
  if (++columns->Current == columns->Count)
    columns->Current = 0;

  PopItemWidth();

  // Optimization: avoid PopClipRect() + SetCurrentChannel() + PushClipRect()
  // (which would needlessly attempt to update commands in the wrong channel,
  // then pop or overwrite them),
  OldColumnData *column = &columns->Columns[columns->Current];
  SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
  columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);

  const float column_padding = g.Style.ItemSpacing.x;
  columns->LineMaxY = Max(columns->LineMaxY, window->DC.CursorPos.y);
  if (columns->Current > 0) {
    // Columns 1+ ignore IndentX (by canceling it out)
    // FIXME-COLUMNS: Unnecessary, could be locked?
    window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) -
                                 window->DC.Indent.x + column_padding;
  } else {
    // New row/line: column 0 honor IndentX.
    window->DC.ColumnsOffset.x =
        Max(column_padding - window->WindowPadding.x, 0.0f);
    window->DC.IsSameLine = false;
    columns->LineMinY = columns->LineMaxY;
  }
  window->DC.CursorPos.x = GUI_TRUNC(window->Pos.x + window->DC.Indent.x +
                                     window->DC.ColumnsOffset.x);
  window->DC.CursorPos.y = columns->LineMinY;
  window->DC.CurrLineSize = Vec2(0.0f, 0.0f);
  window->DC.CurrLineTextBaseOffset = 0.0f;

  // FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.
  float offset_0 = GetColumnOffset(columns->Current);
  float offset_1 = GetColumnOffset(columns->Current + 1);
  float width = offset_1 - offset_0;
  PushItemWidth(width * 0.65f);
  window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
}

inline void Gui::EndColumns() {
  Context &g = *GGui;
  Window *window = GetCurrentWindow();
  OldColumns *columns = window->DC.CurrentColumns;
  GUI_ASSERT(columns != NULL);

  PopItemWidth();
  if (columns->Count > 1) {
    PopClipRect();
    columns->Splitter.Merge(window->DrawList);
  }

  const OldColumnFlags flags = columns->Flags;
  columns->LineMaxY = Max(columns->LineMaxY, window->DC.CursorPos.y);
  window->DC.CursorPos.y = columns->LineMaxY;
  if (!(flags & OldColumnFlags_GrowParentContentsSize))
    window->DC.CursorMaxPos.x =
        columns->HostCursorMaxPosX; // Restore cursor max pos, as columns don't
                                    // grow parent

  // Draw columns borders and handle resize
  // The IsBeingResized flag ensure we preserve pre-resize columns width so
  // back-and-forth are not lossy
  bool is_being_resized = false;
  if (!(flags & OldColumnFlags_NoBorder) && !window->SkipItems) {
    // We clip Y boundaries CPU side because very long triangles are mishandled
    // by some GPU drivers.
    const float y1 = Max(columns->HostCursorPosY, window->ClipRect.Min.y);
    const float y2 = Min(window->DC.CursorPos.y, window->ClipRect.Max.y);
    int dragging_column = -1;
    for (int n = 1; n < columns->Count; n++) {
      OldColumnData *column = &columns->Columns[n];
      float x = window->Pos.x + GetColumnOffset(n);
      const ID column_id = columns->ID + ID(n);
      const float column_hit_hw = COLUMNS_HIT_RECT_HALF_WIDTH;
      const Rect column_hit_rect(Vec2(x - column_hit_hw, y1),
                                 Vec2(x + column_hit_hw, y2));
      if (!ItemAdd(column_hit_rect, column_id, NULL, ItemFlags_NoNav))
        continue;

      bool hovered = false, held = false;
      if (!(flags & OldColumnFlags_NoResize)) {
        ButtonBehavior(column_hit_rect, column_id, &hovered, &held);
        if (hovered || held)
          g.MouseCursor = MouseCursor_ResizeEW;
        if (held && !(column->Flags & OldColumnFlags_NoResize))
          dragging_column = n;
      }

      // Draw column
      const U32 col = GetColorU32(held      ? Col_SeparatorActive
                                  : hovered ? Col_SeparatorHovered
                                            : Col_Separator);
      const float xi = GUI_TRUNC(x);
      window->DrawList->AddLine(Vec2(xi, y1 + 1.0f), Vec2(xi, y2), col);
    }

    // Apply dragging after drawing the column lines, so our rendered lines are
    // in sync with how items were displayed during the frame.
    if (dragging_column != -1) {
      if (!columns->IsBeingResized)
        for (int n = 0; n < columns->Count + 1; n++)
          columns->Columns[n].OffsetNormBeforeResize =
              columns->Columns[n].OffsetNorm;
      columns->IsBeingResized = is_being_resized = true;
      float x = GetDraggedColumnOffset(columns, dragging_column);
      SetColumnOffset(dragging_column, x);
    }
  }
  columns->IsBeingResized = is_being_resized;

  window->WorkRect = window->ParentWorkRect;
  window->ParentWorkRect = columns->HostBackupParentWorkRect;
  window->DC.CurrentColumns = NULL;
  window->DC.ColumnsOffset.x = 0.0f;
  window->DC.CursorPos.x = GUI_TRUNC(window->Pos.x + window->DC.Indent.x +
                                     window->DC.ColumnsOffset.x);
  NavUpdateCurrentWindowIsScrollPushableX();
}

inline void Gui::Columns(int columns_count, const char *id, bool border) {
  Window *window = GetCurrentWindow();
  GUI_ASSERT(columns_count >= 1);

  OldColumnFlags flags = (border ? 0 : OldColumnFlags_NoBorder);
  // flags |= OldColumnFlags_NoPreserveWidths; // NB: Legacy behavior
  OldColumns *columns = window->DC.CurrentColumns;
  if (columns != NULL && columns->Count == columns_count &&
      columns->Flags == flags)
    return;

  if (columns != NULL)
    EndColumns();

  if (columns_count != 1)
    BeginColumns(id, columns_count, flags);
}

//-------------------------------------------------------------------------

#endif // #ifndef GUI_DISABLE
